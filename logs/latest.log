[12:25:50] [main/INFO]: ModLauncher running: args [--username, kaues, --version, Ender Tech, --gameDir, C:\Users\kaues\AppData\Roaming\.minecraft\versions\Ender Tech, --assetsDir, C:\Users\kaues\AppData\Roaming\.minecraft\assets, --assetIndex, 1.16, --uuid, cb2a9bf2973042ff957579d48c089416, --accessToken, ????????, --userType, mojang, --versionType, release, --width, 925, --height, 530, --launchTarget, fmlclient, --fml.forgeVersion, 36.2.33, --fml.mcVersion, 1.16.5, --fml.forgeGroup, net.minecraftforge, --fml.mcpVersion, 20210115.111550]
[12:25:50] [main/INFO]: ModLauncher 8.1.3+8.1.3+main-8.1.x.c94d18ec starting: java version 1.8.0_51 by Oracle Corporation
[12:25:51] [main/WARN]: LEGACY JDK DETECTED, SECURED JAR HANDLING DISABLED
[12:26:10] [main/INFO]: OptiFineTransformationService.onLoad
[12:26:10] [main/INFO]: OptiFine ZIP file: C:\Users\kaues\AppData\Roaming\.minecraft\versions\Ender Tech\mods\OptiFine-1.16.5_HD_U_G8_pre2.jar
[12:26:10] [main/INFO]: Target.PRE_CLASS is available
[12:26:11] [main/INFO]: Added Lets Encrypt root certificates as additional trust
[12:26:11] [main/INFO]: SpongePowered MIXIN Subsystem Version=0.8.4 Source=file:/C:/Users/kaues/AppData/Roaming/.minecraft/libraries/org/spongepowered/mixin/0.8.4/mixin-0.8.4.jar Service=ModLauncher Env=CLIENT
[12:26:11] [main/INFO]: OptiFineTransformationService.initialize
[12:26:18] [main/INFO]: OptiFineTransformationService.transformers
[12:26:18] [main/INFO]: Targets: 308
[12:26:21] [main/INFO]: additionalClassesLocator: [optifine., net.optifine.]
[12:26:22] [main/INFO]: Successfully loaded Mixin Connector [de.maxhenkel.miningdimension.mixin.MixinConnector]
[12:26:22] [main/INFO]: Launching target 'fmlclient' with arguments [--version, Ender Tech, --gameDir, C:\Users\kaues\AppData\Roaming\.minecraft\versions\Ender Tech, --assetsDir, C:\Users\kaues\AppData\Roaming\.minecraft\assets, --uuid, cb2a9bf2973042ff957579d48c089416, --username, kaues, --assetIndex, 1.16, --accessToken, ????????, --userType, mojang, --versionType, release, --width, 925, --height, 530]
[12:26:25] [main/INFO]: [FANCYMENU] APPLYING MIXIN: de.keksuccino.fancymenu.mixin.client.MixinWidget | TO TARGET: net.minecraft.client.gui.widget.Widget
[12:26:25] [main/INFO]: [FANCYMENU] APPLYING MIXIN: de.keksuccino.fancymenu.mixin.client.MixinImageButton | TO TARGET: net.minecraft.client.gui.widget.button.ImageButton
[12:26:25] [main/INFO]: [FANCYMENU] APPLYING MIXIN: de.keksuccino.fancymenu.mixin.client.MixinAbstractList | TO TARGET: net.minecraft.client.gui.widget.list.AbstractList
[12:26:25] [main/INFO]: [FANCYMENU] APPLYING MIXIN: de.keksuccino.fancymenu.mixin.client.MixinScreen | TO TARGET: net.minecraft.client.gui.screen.Screen
[12:26:25] [main/INFO]: [FANCYMENU] APPLYING MIXIN: de.keksuccino.fancymenu.mixin.client.MixinMinecraft | TO TARGET: net.minecraft.client.Minecraft
[12:26:25] [main/INFO]: [FANCYMENU] APPLYING MIXIN: de.keksuccino.fancymenu.mixin.client.MixinResourceLoadProgressGui | TO TARGET: net.minecraft.client.gui.ResourceLoadProgressGui
[12:26:25] [main/INFO]: [FANCYMENU] APPLYING MIXIN: de.keksuccino.fancymenu.mixin.client.MixinAbstractGui | TO TARGET: net.minecraft.client.gui.AbstractGui
[12:26:25] [main/INFO]: [FANCYMENU] APPLYING MIXIN: de.keksuccino.fancymenu.mixin.client.MixinOnlineServerEntry | TO TARGET: net.minecraft.client.gui.screen.ServerSelectionList$NormalEntry
[12:26:25] [main/INFO]: [FANCYMENU] APPLYING MIXIN: de.keksuccino.fancymenu.mixin.client.MixinWorldListEntry | TO TARGET: net.minecraft.client.gui.screen.WorldSelectionList$Entry
[12:26:54] [main/INFO]: Environment: authHost='https://authserver.mojang.com', accountsHost='https://api.mojang.com', sessionHost='https://sessionserver.mojang.com', servicesHost='https://api.minecraftservices.com', name='PROD'
[12:26:54] [main/INFO]: Setting user: kaues
[12:26:55] [main/INFO]: [OptiFine] (Reflector) Class not present: net.minecraft.launchwrapper.Launch
[12:26:55] [main/INFO]: Backend library: LWJGL version 3.2.2 build 10
[12:26:55] [main/INFO]: [OptiFine] 
[12:26:55] [main/INFO]: [OptiFine] OptiFine_1.16.5_HD_U_G8_pre2
[12:26:56] [main/INFO]: [OptiFine] Build: 20210305-002749
[12:26:56] [main/INFO]: [OptiFine] OS: Windows 10 (amd64) version 10.0
[12:26:56] [main/INFO]: [OptiFine] Java: 1.8.0_51, Oracle Corporation
[12:26:56] [main/INFO]: [OptiFine] VM: Java HotSpot(TM) 64-Bit Server VM (mixed mode), Oracle Corporation
[12:26:56] [main/INFO]: [OptiFine] LWJGL: 3.3.0 Win32 WGL EGL OSMesa VisualC DLL
[12:26:56] [main/INFO]: [OptiFine] OpenGL: Intel(R) HD Graphics, version 2.1.0 - Build 8.15.10.2900, Intel
[12:26:56] [main/INFO]: [OptiFine] OpenGL Version: 2.1.0
[12:26:56] [main/INFO]: [OptiFine] OpenGL Fancy fog: Not available (GL_NV_fog_distance)
[12:26:56] [main/INFO]: [OptiFine] Maximum texture size: 8192x8192
[12:26:56] [VersionCheck/INFO]: [OptiFine] Checking for new version
[12:26:56] [main/INFO]: [Shaders] OpenGL Version: 2.1.0 - Build 8.15.10.2900
[12:26:56] [main/INFO]: [Shaders] Vendor:  Intel
[12:26:56] [main/INFO]: [Shaders] Renderer: Intel(R) HD Graphics
[12:26:56] [main/INFO]: [Shaders] Capabilities:  2.0  2.1  -  -  - 
[12:26:56] [main/INFO]: [Shaders] GL_MAX_DRAW_BUFFERS: 8
[12:26:56] [main/INFO]: [Shaders] GL_MAX_COLOR_ATTACHMENTS_EXT: 8
[12:26:56] [main/INFO]: [Shaders] GL_MAX_TEXTURE_IMAGE_UNITS: 16
[12:26:56] [main/INFO]: [Shaders] Load shaders configuration.
[12:26:56] [main/INFO]: [Shaders] Save shaders configuration.
[12:26:56] [main/INFO]: [Shaders] No shaderpack loaded.
[12:26:56] [main/INFO]: [OptiFine] (Reflector) Class not present: net.minecraftforge.fml.common.Loader
[12:26:57] [VersionCheck/INFO]: [OptiFine] Version found: G7
[12:26:58] [main/INFO]: Scanning classes for titanium
[12:26:58] [main/INFO]: Found FeaturePluginInstance for class IndustrialForegoingResourcePlugin for plugin resources
[12:26:58] [main/INFO]: Found FeaturePluginInstance for class DefaultResourceRegistryPlugin for plugin resources
[12:26:59] [main/INFO]: Potentially Dangerous alternative prefix `mining_dimension` for name `teleporter`, expected `minecraft`. This could be a intended override, but in most cases indicates a broken mod.
[12:27:00] [modloading-worker-2/INFO]: Here we go! Launching Dungeon Crawl 2.3.5...
[12:27:02] [modloading-worker-2/INFO]: Forge mod loading, version 36.2.33, for MC 1.16.5 with MCP 20210115.111550
[12:27:02] [modloading-worker-2/INFO]: MinecraftForge v36.2.33 Initialized
[12:27:02] [modloading-worker-2/INFO]: [KONKRETE] Optifine detected! ###############################
[12:27:02] [modloading-worker-2/INFO]: [KONKRETE] Successfully initialized!
[12:27:02] [modloading-worker-2/INFO]: [KONKRETE] Server-side libs ready to use!
[12:27:03] [modloading-worker-2/INFO]: Scanning classes for industrialforegoing
[12:27:03] [modloading-worker-2/INFO]: Found FeaturePluginInstance for class FTBChunksPlugin for plugin ftbchunks
[12:27:03] [modloading-worker-2/INFO]: Found FeaturePluginInstance for class CuriosPlugin for plugin curios
[12:27:03] [modloading-worker-2/INFO]: Constructed class FTBChunksPlugin for plugin ftbchunks for mod industrialforegoing
[12:27:03] [modloading-worker-2/INFO]: Constructed class CuriosPlugin for plugin curios for mod industrialforegoing
[12:27:03] [modloading-worker-2/INFO]: Executing phase CONSTRUCTION for plugin class FTBChunksPlugin
[12:27:03] [modloading-worker-2/INFO]: Executing phase CONSTRUCTION for plugin class CuriosPlugin
[12:27:03] [modloading-worker-2/INFO]: Executing phase PRE_INIT for plugin class FTBChunksPlugin
[12:27:03] [modloading-worker-2/INFO]: Executing phase PRE_INIT for plugin class CuriosPlugin
[12:27:04] [modloading-worker-0/INFO]: Scanning classes for titanium
[12:27:04] [modloading-worker-0/INFO]: Constructed class IndustrialForegoingResourcePlugin for plugin resources for mod titanium
[12:27:04] [modloading-worker-0/INFO]: Constructed class DefaultResourceRegistryPlugin for plugin resources for mod titanium
[12:27:04] [modloading-worker-0/INFO]: Executing phase CONSTRUCTION for plugin class IndustrialForegoingResourcePlugin
[12:27:04] [modloading-worker-0/INFO]: Executing phase CONSTRUCTION for plugin class DefaultResourceRegistryPlugin
[12:27:05] [modloading-worker-0/INFO]: Optifine detected.
[12:27:05] [modloading-worker-0/INFO]: No shader config found.
[12:27:05] [modloading-worker-2/INFO]: Executing phase INIT for plugin class FTBChunksPlugin
[12:27:05] [modloading-worker-2/INFO]: Executing phase INIT for plugin class CuriosPlugin
[12:27:06] [modloading-worker-2/INFO]: Executing phase POST_INIT for plugin class FTBChunksPlugin
[12:27:06] [modloading-worker-2/INFO]: Executing phase POST_INIT for plugin class CuriosPlugin
[12:27:06] [modloading-worker-3/INFO]: Detected new forge version, registering events reflectively.
[12:27:10] [modloading-worker-0/INFO]: [FANCYMENU] Optifine compatibility mode!
[12:27:14] [modloading-worker-0/INFO]: ExpandAbility here, who dis?
[12:27:25] [main/INFO]: Registered 45 Block entries in 1,85ms.
[12:27:32] [main/INFO]: Registered 53 Item entries in 1,56ms.
[12:27:33] [main/INFO]: Potentially Dangerous alternative prefix `minecraft` for name `iron_horse_armor`, expected `cofh_core`. This could be a intended override, but in most cases indicates a broken mod.
[12:27:33] [main/INFO]: Potentially Dangerous alternative prefix `minecraft` for name `golden_horse_armor`, expected `cofh_core`. This could be a intended override, but in most cases indicates a broken mod.
[12:27:33] [main/INFO]: Potentially Dangerous alternative prefix `minecraft` for name `diamond_horse_armor`, expected `cofh_core`. This could be a intended override, but in most cases indicates a broken mod.
[12:27:33] [main/INFO]: Potentially Dangerous alternative prefix `minecraft` for name `leather_horse_armor`, expected `cofh_core`. This could be a intended override, but in most cases indicates a broken mod.
[12:27:33] [main/INFO]: Potentially Dangerous alternative prefix `minecraft` for name `shield`, expected `cofh_core`. This could be a intended override, but in most cases indicates a broken mod.
[12:27:34] [main/INFO]: Registered 11 GlobalLootModifierSerializer entries in 0,19ms.
[12:27:39] [main/INFO]: Registered 2 TileEntityType entries in 0,06ms.
[12:27:39] [main/INFO]: Potentially Dangerous alternative prefix `minecraft` for name `protection`, expected `ensorcellation`. This could be a intended override, but in most cases indicates a broken mod.
[12:27:39] [main/INFO]: Potentially Dangerous alternative prefix `minecraft` for name `blast_protection`, expected `ensorcellation`. This could be a intended override, but in most cases indicates a broken mod.
[12:27:39] [main/INFO]: Potentially Dangerous alternative prefix `minecraft` for name `feather_falling`, expected `ensorcellation`. This could be a intended override, but in most cases indicates a broken mod.
[12:27:39] [main/INFO]: Potentially Dangerous alternative prefix `minecraft` for name `fire_protection`, expected `ensorcellation`. This could be a intended override, but in most cases indicates a broken mod.
[12:27:39] [main/INFO]: Potentially Dangerous alternative prefix `minecraft` for name `projectile_protection`, expected `ensorcellation`. This could be a intended override, but in most cases indicates a broken mod.
[12:27:39] [main/INFO]: Potentially Dangerous alternative prefix `minecraft` for name `fire_aspect`, expected `ensorcellation`. This could be a intended override, but in most cases indicates a broken mod.
[12:27:39] [main/INFO]: Potentially Dangerous alternative prefix `minecraft` for name `frost_walker`, expected `ensorcellation`. This could be a intended override, but in most cases indicates a broken mod.
[12:27:39] [main/INFO]: Potentially Dangerous alternative prefix `minecraft` for name `knockback`, expected `ensorcellation`. This could be a intended override, but in most cases indicates a broken mod.
[12:27:39] [main/INFO]: Potentially Dangerous alternative prefix `minecraft` for name `looting`, expected `ensorcellation`. This could be a intended override, but in most cases indicates a broken mod.
[12:27:39] [main/INFO]: Potentially Dangerous alternative prefix `minecraft` for name `thorns`, expected `ensorcellation`. This could be a intended override, but in most cases indicates a broken mod.
[12:27:39] [main/INFO]: Potentially Dangerous alternative prefix `minecraft` for name `mending`, expected `ensorcellation`. This could be a intended override, but in most cases indicates a broken mod.
[12:27:40] [main/INFO]: Potentially Dangerous alternative prefix `minecraft` for name `milk`, expected `forge`. This could be a intended override, but in most cases indicates a broken mod.
[12:27:40] [main/INFO]: Potentially Dangerous alternative prefix `minecraft` for name `flowing_milk`, expected `forge`. This could be a intended override, but in most cases indicates a broken mod.
[12:27:43] [main/INFO]: Registered 22 ingredient serializers.
[12:27:43] [main/INFO]: Registered 5 IRecipeSerializer entries in 0,26ms.
[12:27:51] [main/INFO]: Narrator library for x64 successfully loaded
[12:27:52] [main/INFO]: Reloading ResourceManager: Default, Mod Resources
[12:27:52] [main/INFO]: [OptiFine] *** Reloading textures ***
[12:27:52] [main/INFO]: [OptiFine] Resource packs: Mod Resources
[12:27:52] [Worker-Main-7/INFO]: [OptiFine] Multitexture: false
[12:27:52] [main/INFO]: [OptiFine] *** Reflector Forge ***
[12:27:52] [main/INFO]: [OptiFine] (Reflector) Class not present: mods.betterfoliage.client.BetterFoliageClient
[12:27:52] [main/WARN]: [OptiFine] (Reflector) More than one method found: net.minecraftforge.client.ForgeHooksClient.renderMainMenu
[12:27:52] [main/WARN]: [OptiFine] (Reflector)  - public static void net.minecraftforge.client.ForgeHooksClient.renderMainMenu(net.minecraft.client.gui.screen.MainMenuScreen,com.mojang.blaze3d.matrix.MatrixStack,net.minecraft.client.gui.FontRenderer,int,int,int)
[12:27:52] [main/WARN]: [OptiFine] (Reflector)  - public static void net.minecraftforge.client.ForgeHooksClient.renderMainMenu(net.minecraft.client.gui.screen.MainMenuScreen,com.mojang.blaze3d.matrix.MatrixStack,net.minecraft.client.gui.FontRenderer,int,int)
[12:27:53] [main/INFO]: [OptiFine] (Reflector) Field not present: net.minecraftforge.client.model.pipeline.LightUtil.itemConsumer
[12:27:53] [main/INFO]: [OptiFine] (Reflector) Field not present: net.minecraftforge.client.model.pipeline.LightUtil.tessellator
[12:27:53] [main/INFO]: [OptiFine] (Reflector) Class not present: net.minecraftforge.fml.common.ModContainer
[12:27:53] [main/INFO]: [OptiFine] *** Reflector Vanilla ***
[12:27:53] [modloading-worker-1/INFO]: CLIENT CONFIG LOADED
[12:27:54] [modloading-worker-1/WARN]: Configuration file C:\Users\kaues\AppData\Roaming\.minecraft\versions\Ender Tech\config\compactmachines-common.toml is not correct. Correcting
[12:27:54] [modloading-worker-1/WARN]: Incorrect key recipes was corrected from null to its default, SimpleCommentedConfig:{}. 
[12:27:54] [modloading-worker-1/WARN]: Incorrect key recipes.vanillaRecipes was corrected from null to its default, true. 
[12:27:54] [modloading-worker-1/INFO]: Executing phase CONFIG_LOAD for plugin class FTBChunksPlugin
[12:27:54] [modloading-worker-1/INFO]: Executing phase CONFIG_LOAD for plugin class CuriosPlugin
[12:27:54] [modloading-worker-1/INFO]: Executing phase CONFIG_LOAD for plugin class FTBChunksPlugin
[12:27:54] [modloading-worker-1/INFO]: Executing phase CONFIG_LOAD for plugin class CuriosPlugin
[12:27:54] [modloading-worker-1/INFO]: Executing phase CONFIG_LOAD for plugin class FTBChunksPlugin
[12:27:54] [modloading-worker-1/INFO]: Executing phase CONFIG_LOAD for plugin class CuriosPlugin
[12:27:54] [Thread-1/INFO]: Executing phase CONFIG_RELOAD for plugin class FTBChunksPlugin
[12:27:54] [Thread-1/INFO]: Executing phase CONFIG_RELOAD for plugin class CuriosPlugin
[12:27:54] [Worker-Main-5/INFO]: [OptiFine] Multitexture: false
[12:27:54] [modloading-worker-1/INFO]: Executing phase CONFIG_LOAD for plugin class FTBChunksPlugin
[12:27:54] [modloading-worker-1/INFO]: Executing phase CONFIG_LOAD for plugin class CuriosPlugin
[12:27:54] [modloading-worker-1/INFO]: Executing phase CONFIG_LOAD for plugin class FTBChunksPlugin
[12:27:54] [modloading-worker-1/INFO]: Executing phase CONFIG_LOAD for plugin class CuriosPlugin
[12:27:54] [modloading-worker-1/INFO]: BLACKLIST RELOADED
[12:27:54] [modloading-worker-1/INFO]: COMMON CONFIG LOADED
[12:28:12] [Worker-Main-6/WARN]: Exception loading blockstate definition: industrialforegoing:blockstates/sludge_block.json: java.io.FileNotFoundException: industrialforegoing:blockstates/sludge_block.json
[12:28:12] [Worker-Main-6/WARN]: Exception loading blockstate definition: 'industrialforegoing:blockstates/sludge_block.json' missing model for variant: 'industrialforegoing:sludge_block#level=9'
[12:28:12] [Worker-Main-6/WARN]: Exception loading blockstate definition: 'industrialforegoing:blockstates/sludge_block.json' missing model for variant: 'industrialforegoing:sludge_block#level=8'
[12:28:12] [Worker-Main-6/WARN]: Exception loading blockstate definition: 'industrialforegoing:blockstates/sludge_block.json' missing model for variant: 'industrialforegoing:sludge_block#level=10'
[12:28:12] [Worker-Main-6/WARN]: Exception loading blockstate definition: 'industrialforegoing:blockstates/sludge_block.json' missing model for variant: 'industrialforegoing:sludge_block#level=11'
[12:28:12] [Worker-Main-6/WARN]: Exception loading blockstate definition: 'industrialforegoing:blockstates/sludge_block.json' missing model for variant: 'industrialforegoing:sludge_block#level=12'
[12:28:12] [Worker-Main-6/WARN]: Exception loading blockstate definition: 'industrialforegoing:blockstates/sludge_block.json' missing model for variant: 'industrialforegoing:sludge_block#level=13'
[12:28:12] [Worker-Main-6/WARN]: Exception loading blockstate definition: 'industrialforegoing:blockstates/sludge_block.json' missing model for variant: 'industrialforegoing:sludge_block#level=14'
[12:28:12] [Worker-Main-6/WARN]: Exception loading blockstate definition: 'industrialforegoing:blockstates/sludge_block.json' missing model for variant: 'industrialforegoing:sludge_block#level=15'
[12:28:12] [Worker-Main-6/WARN]: Exception loading blockstate definition: 'industrialforegoing:blockstates/sludge_block.json' missing model for variant: 'industrialforegoing:sludge_block#level=7'
[12:28:12] [Worker-Main-6/WARN]: Exception loading blockstate definition: 'industrialforegoing:blockstates/sludge_block.json' missing model for variant: 'industrialforegoing:sludge_block#level=6'
[12:28:12] [Worker-Main-6/WARN]: Exception loading blockstate definition: 'industrialforegoing:blockstates/sludge_block.json' missing model for variant: 'industrialforegoing:sludge_block#level=5'
[12:28:12] [Worker-Main-6/WARN]: Exception loading blockstate definition: 'industrialforegoing:blockstates/sludge_block.json' missing model for variant: 'industrialforegoing:sludge_block#level=4'
[12:28:12] [Worker-Main-6/WARN]: Exception loading blockstate definition: 'industrialforegoing:blockstates/sludge_block.json' missing model for variant: 'industrialforegoing:sludge_block#level=3'
[12:28:12] [Worker-Main-6/WARN]: Exception loading blockstate definition: 'industrialforegoing:blockstates/sludge_block.json' missing model for variant: 'industrialforegoing:sludge_block#level=2'
[12:28:12] [Worker-Main-6/WARN]: Exception loading blockstate definition: 'industrialforegoing:blockstates/sludge_block.json' missing model for variant: 'industrialforegoing:sludge_block#level=1'
[12:28:12] [Worker-Main-6/WARN]: Exception loading blockstate definition: 'industrialforegoing:blockstates/sludge_block.json' missing model for variant: 'industrialforegoing:sludge_block#level=0'
[12:28:12] [Worker-Main-6/WARN]: Exception loading blockstate definition: industrialforegoing:blockstates/ether_gas_block.json: java.io.FileNotFoundException: industrialforegoing:blockstates/ether_gas_block.json
[12:28:12] [Worker-Main-6/WARN]: Exception loading blockstate definition: 'industrialforegoing:blockstates/ether_gas_block.json' missing model for variant: 'industrialforegoing:ether_gas_block#level=6'
[12:28:12] [Worker-Main-6/WARN]: Exception loading blockstate definition: 'industrialforegoing:blockstates/ether_gas_block.json' missing model for variant: 'industrialforegoing:ether_gas_block#level=7'
[12:28:12] [Worker-Main-6/WARN]: Exception loading blockstate definition: 'industrialforegoing:blockstates/ether_gas_block.json' missing model for variant: 'industrialforegoing:ether_gas_block#level=8'
[12:28:12] [Worker-Main-6/WARN]: Exception loading blockstate definition: 'industrialforegoing:blockstates/ether_gas_block.json' missing model for variant: 'industrialforegoing:ether_gas_block#level=9'
[12:28:12] [Worker-Main-6/WARN]: Exception loading blockstate definition: 'industrialforegoing:blockstates/ether_gas_block.json' missing model for variant: 'industrialforegoing:ether_gas_block#level=2'
[12:28:12] [Worker-Main-6/WARN]: Exception loading blockstate definition: 'industrialforegoing:blockstates/ether_gas_block.json' missing model for variant: 'industrialforegoing:ether_gas_block#level=3'
[12:28:12] [Worker-Main-6/WARN]: Exception loading blockstate definition: 'industrialforegoing:blockstates/ether_gas_block.json' missing model for variant: 'industrialforegoing:ether_gas_block#level=4'
[12:28:12] [Worker-Main-6/WARN]: Exception loading blockstate definition: 'industrialforegoing:blockstates/ether_gas_block.json' missing model for variant: 'industrialforegoing:ether_gas_block#level=5'
[12:28:12] [Worker-Main-6/WARN]: Exception loading blockstate definition: 'industrialforegoing:blockstates/ether_gas_block.json' missing model for variant: 'industrialforegoing:ether_gas_block#level=15'
[12:28:12] [Worker-Main-6/WARN]: Exception loading blockstate definition: 'industrialforegoing:blockstates/ether_gas_block.json' missing model for variant: 'industrialforegoing:ether_gas_block#level=12'
[12:28:12] [Worker-Main-6/WARN]: Exception loading blockstate definition: 'industrialforegoing:blockstates/ether_gas_block.json' missing model for variant: 'industrialforegoing:ether_gas_block#level=11'
[12:28:12] [Worker-Main-6/WARN]: Exception loading blockstate definition: 'industrialforegoing:blockstates/ether_gas_block.json' missing model for variant: 'industrialforegoing:ether_gas_block#level=14'
[12:28:12] [Worker-Main-6/WARN]: Exception loading blockstate definition: 'industrialforegoing:blockstates/ether_gas_block.json' missing model for variant: 'industrialforegoing:ether_gas_block#level=13'
[12:28:12] [Worker-Main-6/WARN]: Exception loading blockstate definition: 'industrialforegoing:blockstates/ether_gas_block.json' missing model for variant: 'industrialforegoing:ether_gas_block#level=10'
[12:28:12] [Worker-Main-6/WARN]: Exception loading blockstate definition: 'industrialforegoing:blockstates/ether_gas_block.json' missing model for variant: 'industrialforegoing:ether_gas_block#level=0'
[12:28:12] [Worker-Main-6/WARN]: Exception loading blockstate definition: 'industrialforegoing:blockstates/ether_gas_block.json' missing model for variant: 'industrialforegoing:ether_gas_block#level=1'
[12:28:12] [Worker-Main-6/WARN]: Exception loading blockstate definition: industrialforegoing:blockstates/biofuel_block.json: java.io.FileNotFoundException: industrialforegoing:blockstates/biofuel_block.json
[12:28:12] [Worker-Main-6/WARN]: Exception loading blockstate definition: 'industrialforegoing:blockstates/biofuel_block.json' missing model for variant: 'industrialforegoing:biofuel_block#level=15'
[12:28:12] [Worker-Main-6/WARN]: Exception loading blockstate definition: 'industrialforegoing:blockstates/biofuel_block.json' missing model for variant: 'industrialforegoing:biofuel_block#level=14'
[12:28:12] [Worker-Main-6/WARN]: Exception loading blockstate definition: 'industrialforegoing:blockstates/biofuel_block.json' missing model for variant: 'industrialforegoing:biofuel_block#level=13'
[12:28:12] [Worker-Main-6/WARN]: Exception loading blockstate definition: 'industrialforegoing:blockstates/biofuel_block.json' missing model for variant: 'industrialforegoing:biofuel_block#level=12'
[12:28:12] [Worker-Main-6/WARN]: Exception loading blockstate definition: 'industrialforegoing:blockstates/biofuel_block.json' missing model for variant: 'industrialforegoing:biofuel_block#level=11'
[12:28:12] [Worker-Main-6/WARN]: Exception loading blockstate definition: 'industrialforegoing:blockstates/biofuel_block.json' missing model for variant: 'industrialforegoing:biofuel_block#level=10'
[12:28:12] [Worker-Main-6/WARN]: Exception loading blockstate definition: 'industrialforegoing:blockstates/biofuel_block.json' missing model for variant: 'industrialforegoing:biofuel_block#level=8'
[12:28:12] [Worker-Main-6/WARN]: Exception loading blockstate definition: 'industrialforegoing:blockstates/biofuel_block.json' missing model for variant: 'industrialforegoing:biofuel_block#level=9'
[12:28:12] [Worker-Main-6/WARN]: Exception loading blockstate definition: 'industrialforegoing:blockstates/biofuel_block.json' missing model for variant: 'industrialforegoing:biofuel_block#level=6'
[12:28:12] [Worker-Main-6/WARN]: Exception loading blockstate definition: 'industrialforegoing:blockstates/biofuel_block.json' missing model for variant: 'industrialforegoing:biofuel_block#level=7'
[12:28:12] [Worker-Main-6/WARN]: Exception loading blockstate definition: 'industrialforegoing:blockstates/biofuel_block.json' missing model for variant: 'industrialforegoing:biofuel_block#level=4'
[12:28:12] [Worker-Main-6/WARN]: Exception loading blockstate definition: 'industrialforegoing:blockstates/biofuel_block.json' missing model for variant: 'industrialforegoing:biofuel_block#level=5'
[12:28:12] [Worker-Main-6/WARN]: Exception loading blockstate definition: 'industrialforegoing:blockstates/biofuel_block.json' missing model for variant: 'industrialforegoing:biofuel_block#level=2'
[12:28:12] [Worker-Main-6/WARN]: Exception loading blockstate definition: 'industrialforegoing:blockstates/biofuel_block.json' missing model for variant: 'industrialforegoing:biofuel_block#level=3'
[12:28:12] [Worker-Main-6/WARN]: Exception loading blockstate definition: 'industrialforegoing:blockstates/biofuel_block.json' missing model for variant: 'industrialforegoing:biofuel_block#level=0'
[12:28:12] [Worker-Main-6/WARN]: Exception loading blockstate definition: 'industrialforegoing:blockstates/biofuel_block.json' missing model for variant: 'industrialforegoing:biofuel_block#level=1'
[12:28:12] [Worker-Main-6/WARN]: Exception loading blockstate definition: industrialforegoing:blockstates/essence_block.json: java.io.FileNotFoundException: industrialforegoing:blockstates/essence_block.json
[12:28:12] [Worker-Main-6/WARN]: Exception loading blockstate definition: 'industrialforegoing:blockstates/essence_block.json' missing model for variant: 'industrialforegoing:essence_block#level=10'
[12:28:12] [Worker-Main-6/WARN]: Exception loading blockstate definition: 'industrialforegoing:blockstates/essence_block.json' missing model for variant: 'industrialforegoing:essence_block#level=1'
[12:28:12] [Worker-Main-6/WARN]: Exception loading blockstate definition: 'industrialforegoing:blockstates/essence_block.json' missing model for variant: 'industrialforegoing:essence_block#level=0'
[12:28:12] [Worker-Main-6/WARN]: Exception loading blockstate definition: 'industrialforegoing:blockstates/essence_block.json' missing model for variant: 'industrialforegoing:essence_block#level=7'
[12:28:12] [Worker-Main-6/WARN]: Exception loading blockstate definition: 'industrialforegoing:blockstates/essence_block.json' missing model for variant: 'industrialforegoing:essence_block#level=6'
[12:28:12] [Worker-Main-6/WARN]: Exception loading blockstate definition: 'industrialforegoing:blockstates/essence_block.json' missing model for variant: 'industrialforegoing:essence_block#level=9'
[12:28:12] [Worker-Main-6/WARN]: Exception loading blockstate definition: 'industrialforegoing:blockstates/essence_block.json' missing model for variant: 'industrialforegoing:essence_block#level=8'
[12:28:12] [Worker-Main-6/WARN]: Exception loading blockstate definition: 'industrialforegoing:blockstates/essence_block.json' missing model for variant: 'industrialforegoing:essence_block#level=3'
[12:28:12] [Worker-Main-6/WARN]: Exception loading blockstate definition: 'industrialforegoing:blockstates/essence_block.json' missing model for variant: 'industrialforegoing:essence_block#level=2'
[12:28:12] [Worker-Main-6/WARN]: Exception loading blockstate definition: 'industrialforegoing:blockstates/essence_block.json' missing model for variant: 'industrialforegoing:essence_block#level=5'
[12:28:12] [Worker-Main-6/WARN]: Exception loading blockstate definition: 'industrialforegoing:blockstates/essence_block.json' missing model for variant: 'industrialforegoing:essence_block#level=4'
[12:28:13] [Worker-Main-6/WARN]: Exception loading blockstate definition: 'industrialforegoing:blockstates/essence_block.json' missing model for variant: 'industrialforegoing:essence_block#level=15'
[12:28:13] [Worker-Main-6/WARN]: Exception loading blockstate definition: 'industrialforegoing:blockstates/essence_block.json' missing model for variant: 'industrialforegoing:essence_block#level=12'
[12:28:13] [Worker-Main-6/WARN]: Exception loading blockstate definition: 'industrialforegoing:blockstates/essence_block.json' missing model for variant: 'industrialforegoing:essence_block#level=11'
[12:28:13] [Worker-Main-6/WARN]: Exception loading blockstate definition: 'industrialforegoing:blockstates/essence_block.json' missing model for variant: 'industrialforegoing:essence_block#level=14'
[12:28:13] [Worker-Main-6/WARN]: Exception loading blockstate definition: 'industrialforegoing:blockstates/essence_block.json' missing model for variant: 'industrialforegoing:essence_block#level=13'
[12:28:13] [Worker-Main-6/WARN]: Exception loading blockstate definition: industrialforegoing:blockstates/pink_slime_block.json: java.io.FileNotFoundException: industrialforegoing:blockstates/pink_slime_block.json
[12:28:13] [Worker-Main-6/WARN]: Exception loading blockstate definition: 'industrialforegoing:blockstates/pink_slime_block.json' missing model for variant: 'industrialforegoing:pink_slime_block#level=7'
[12:28:13] [Worker-Main-6/WARN]: Exception loading blockstate definition: 'industrialforegoing:blockstates/pink_slime_block.json' missing model for variant: 'industrialforegoing:pink_slime_block#level=8'
[12:28:13] [Worker-Main-6/WARN]: Exception loading blockstate definition: 'industrialforegoing:blockstates/pink_slime_block.json' missing model for variant: 'industrialforegoing:pink_slime_block#level=5'
[12:28:13] [Worker-Main-6/WARN]: Exception loading blockstate definition: 'industrialforegoing:blockstates/pink_slime_block.json' missing model for variant: 'industrialforegoing:pink_slime_block#level=6'
[12:28:13] [Worker-Main-6/WARN]: Exception loading blockstate definition: 'industrialforegoing:blockstates/pink_slime_block.json' missing model for variant: 'industrialforegoing:pink_slime_block#level=3'
[12:28:13] [Worker-Main-6/WARN]: Exception loading blockstate definition: 'industrialforegoing:blockstates/pink_slime_block.json' missing model for variant: 'industrialforegoing:pink_slime_block#level=4'
[12:28:13] [Worker-Main-6/WARN]: Exception loading blockstate definition: 'industrialforegoing:blockstates/pink_slime_block.json' missing model for variant: 'industrialforegoing:pink_slime_block#level=1'
[12:28:13] [Worker-Main-6/WARN]: Exception loading blockstate definition: 'industrialforegoing:blockstates/pink_slime_block.json' missing model for variant: 'industrialforegoing:pink_slime_block#level=2'
[12:28:13] [Worker-Main-6/WARN]: Exception loading blockstate definition: 'industrialforegoing:blockstates/pink_slime_block.json' missing model for variant: 'industrialforegoing:pink_slime_block#level=14'
[12:28:13] [Worker-Main-6/WARN]: Exception loading blockstate definition: 'industrialforegoing:blockstates/pink_slime_block.json' missing model for variant: 'industrialforegoing:pink_slime_block#level=15'
[12:28:13] [Worker-Main-6/WARN]: Exception loading blockstate definition: 'industrialforegoing:blockstates/pink_slime_block.json' missing model for variant: 'industrialforegoing:pink_slime_block#level=12'
[12:28:13] [Worker-Main-6/WARN]: Exception loading blockstate definition: 'industrialforegoing:blockstates/pink_slime_block.json' missing model for variant: 'industrialforegoing:pink_slime_block#level=13'
[12:28:13] [Worker-Main-6/WARN]: Exception loading blockstate definition: 'industrialforegoing:blockstates/pink_slime_block.json' missing model for variant: 'industrialforegoing:pink_slime_block#level=9'
[12:28:13] [Worker-Main-6/WARN]: Exception loading blockstate definition: 'industrialforegoing:blockstates/pink_slime_block.json' missing model for variant: 'industrialforegoing:pink_slime_block#level=10'
[12:28:13] [Worker-Main-6/WARN]: Exception loading blockstate definition: 'industrialforegoing:blockstates/pink_slime_block.json' missing model for variant: 'industrialforegoing:pink_slime_block#level=11'
[12:28:13] [Worker-Main-6/WARN]: Exception loading blockstate definition: 'industrialforegoing:blockstates/pink_slime_block.json' missing model for variant: 'industrialforegoing:pink_slime_block#level=0'
[12:28:13] [Worker-Main-6/WARN]: Exception loading blockstate definition: industrialforegoing:blockstates/latex_block.json: java.io.FileNotFoundException: industrialforegoing:blockstates/latex_block.json
[12:28:13] [Worker-Main-6/WARN]: Exception loading blockstate definition: 'industrialforegoing:blockstates/latex_block.json' missing model for variant: 'industrialforegoing:latex_block#level=6'
[12:28:13] [Worker-Main-6/WARN]: Exception loading blockstate definition: 'industrialforegoing:blockstates/latex_block.json' missing model for variant: 'industrialforegoing:latex_block#level=7'
[12:28:13] [Worker-Main-6/WARN]: Exception loading blockstate definition: 'industrialforegoing:blockstates/latex_block.json' missing model for variant: 'industrialforegoing:latex_block#level=4'
[12:28:13] [Worker-Main-6/WARN]: Exception loading blockstate definition: 'industrialforegoing:blockstates/latex_block.json' missing model for variant: 'industrialforegoing:latex_block#level=5'
[12:28:13] [Worker-Main-6/WARN]: Exception loading blockstate definition: 'industrialforegoing:blockstates/latex_block.json' missing model for variant: 'industrialforegoing:latex_block#level=8'
[12:28:13] [Worker-Main-6/WARN]: Exception loading blockstate definition: 'industrialforegoing:blockstates/latex_block.json' missing model for variant: 'industrialforegoing:latex_block#level=9'
[12:28:13] [Worker-Main-6/WARN]: Exception loading blockstate definition: 'industrialforegoing:blockstates/latex_block.json' missing model for variant: 'industrialforegoing:latex_block#level=15'
[12:28:13] [Worker-Main-6/WARN]: Exception loading blockstate definition: 'industrialforegoing:blockstates/latex_block.json' missing model for variant: 'industrialforegoing:latex_block#level=13'
[12:28:13] [Worker-Main-6/WARN]: Exception loading blockstate definition: 'industrialforegoing:blockstates/latex_block.json' missing model for variant: 'industrialforegoing:latex_block#level=14'
[12:28:13] [Worker-Main-6/WARN]: Exception loading blockstate definition: 'industrialforegoing:blockstates/latex_block.json' missing model for variant: 'industrialforegoing:latex_block#level=11'
[12:28:13] [Worker-Main-6/WARN]: Exception loading blockstate definition: 'industrialforegoing:blockstates/latex_block.json' missing model for variant: 'industrialforegoing:latex_block#level=12'
[12:28:13] [Worker-Main-6/WARN]: Exception loading blockstate definition: 'industrialforegoing:blockstates/latex_block.json' missing model for variant: 'industrialforegoing:latex_block#level=10'
[12:28:13] [Worker-Main-6/WARN]: Exception loading blockstate definition: 'industrialforegoing:blockstates/latex_block.json' missing model for variant: 'industrialforegoing:latex_block#level=2'
[12:28:13] [Worker-Main-6/WARN]: Exception loading blockstate definition: 'industrialforegoing:blockstates/latex_block.json' missing model for variant: 'industrialforegoing:latex_block#level=3'
[12:28:13] [Worker-Main-6/WARN]: Exception loading blockstate definition: 'industrialforegoing:blockstates/latex_block.json' missing model for variant: 'industrialforegoing:latex_block#level=0'
[12:28:13] [Worker-Main-6/WARN]: Exception loading blockstate definition: 'industrialforegoing:blockstates/latex_block.json' missing model for variant: 'industrialforegoing:latex_block#level=1'
[12:28:13] [Worker-Main-6/WARN]: Exception loading blockstate definition: industrialforegoing:blockstates/meat_block.json: java.io.FileNotFoundException: industrialforegoing:blockstates/meat_block.json
[12:28:13] [Worker-Main-6/WARN]: Exception loading blockstate definition: 'industrialforegoing:blockstates/meat_block.json' missing model for variant: 'industrialforegoing:meat_block#level=1'
[12:28:13] [Worker-Main-6/WARN]: Exception loading blockstate definition: 'industrialforegoing:blockstates/meat_block.json' missing model for variant: 'industrialforegoing:meat_block#level=2'
[12:28:13] [Worker-Main-6/WARN]: Exception loading blockstate definition: 'industrialforegoing:blockstates/meat_block.json' missing model for variant: 'industrialforegoing:meat_block#level=3'
[12:28:13] [Worker-Main-6/WARN]: Exception loading blockstate definition: 'industrialforegoing:blockstates/meat_block.json' missing model for variant: 'industrialforegoing:meat_block#level=4'
[12:28:13] [Worker-Main-6/WARN]: Exception loading blockstate definition: 'industrialforegoing:blockstates/meat_block.json' missing model for variant: 'industrialforegoing:meat_block#level=15'
[12:28:13] [Worker-Main-6/WARN]: Exception loading blockstate definition: 'industrialforegoing:blockstates/meat_block.json' missing model for variant: 'industrialforegoing:meat_block#level=14'
[12:28:13] [Worker-Main-6/WARN]: Exception loading blockstate definition: 'industrialforegoing:blockstates/meat_block.json' missing model for variant: 'industrialforegoing:meat_block#level=0'
[12:28:13] [Worker-Main-6/WARN]: Exception loading blockstate definition: 'industrialforegoing:blockstates/meat_block.json' missing model for variant: 'industrialforegoing:meat_block#level=9'
[12:28:13] [Worker-Main-6/WARN]: Exception loading blockstate definition: 'industrialforegoing:blockstates/meat_block.json' missing model for variant: 'industrialforegoing:meat_block#level=11'
[12:28:13] [Worker-Main-6/WARN]: Exception loading blockstate definition: 'industrialforegoing:blockstates/meat_block.json' missing model for variant: 'industrialforegoing:meat_block#level=10'
[12:28:13] [Worker-Main-6/WARN]: Exception loading blockstate definition: 'industrialforegoing:blockstates/meat_block.json' missing model for variant: 'industrialforegoing:meat_block#level=13'
[12:28:13] [Worker-Main-6/WARN]: Exception loading blockstate definition: 'industrialforegoing:blockstates/meat_block.json' missing model for variant: 'industrialforegoing:meat_block#level=12'
[12:28:13] [Worker-Main-6/WARN]: Exception loading blockstate definition: 'industrialforegoing:blockstates/meat_block.json' missing model for variant: 'industrialforegoing:meat_block#level=5'
[12:28:13] [Worker-Main-6/WARN]: Exception loading blockstate definition: 'industrialforegoing:blockstates/meat_block.json' missing model for variant: 'industrialforegoing:meat_block#level=6'
[12:28:13] [Worker-Main-6/WARN]: Exception loading blockstate definition: 'industrialforegoing:blockstates/meat_block.json' missing model for variant: 'industrialforegoing:meat_block#level=7'
[12:28:13] [Worker-Main-6/WARN]: Exception loading blockstate definition: 'industrialforegoing:blockstates/meat_block.json' missing model for variant: 'industrialforegoing:meat_block#level=8'
[12:28:13] [Worker-Main-6/WARN]: Exception loading blockstate definition: industrialforegoing:blockstates/raw_ore_meat_block.json: java.io.FileNotFoundException: industrialforegoing:blockstates/raw_ore_meat_block.json
[12:28:13] [Worker-Main-6/WARN]: Exception loading blockstate definition: 'industrialforegoing:blockstates/raw_ore_meat_block.json' missing model for variant: 'industrialforegoing:raw_ore_meat_block#level=10'
[12:28:13] [Worker-Main-6/WARN]: Exception loading blockstate definition: 'industrialforegoing:blockstates/raw_ore_meat_block.json' missing model for variant: 'industrialforegoing:raw_ore_meat_block#level=11'
[12:28:13] [Worker-Main-6/WARN]: Exception loading blockstate definition: 'industrialforegoing:blockstates/raw_ore_meat_block.json' missing model for variant: 'industrialforegoing:raw_ore_meat_block#level=12'
[12:28:13] [Worker-Main-6/WARN]: Exception loading blockstate definition: 'industrialforegoing:blockstates/raw_ore_meat_block.json' missing model for variant: 'industrialforegoing:raw_ore_meat_block#level=13'
[12:28:13] [Worker-Main-6/WARN]: Exception loading blockstate definition: 'industrialforegoing:blockstates/raw_ore_meat_block.json' missing model for variant: 'industrialforegoing:raw_ore_meat_block#level=14'
[12:28:13] [Worker-Main-6/WARN]: Exception loading blockstate definition: 'industrialforegoing:blockstates/raw_ore_meat_block.json' missing model for variant: 'industrialforegoing:raw_ore_meat_block#level=15'
[12:28:13] [Worker-Main-6/WARN]: Exception loading blockstate definition: 'industrialforegoing:blockstates/raw_ore_meat_block.json' missing model for variant: 'industrialforegoing:raw_ore_meat_block#level=0'
[12:28:13] [Worker-Main-6/WARN]: Exception loading blockstate definition: 'industrialforegoing:blockstates/raw_ore_meat_block.json' missing model for variant: 'industrialforegoing:raw_ore_meat_block#level=8'
[12:28:13] [Worker-Main-6/WARN]: Exception loading blockstate definition: 'industrialforegoing:blockstates/raw_ore_meat_block.json' missing model for variant: 'industrialforegoing:raw_ore_meat_block#level=7'
[12:28:13] [Worker-Main-6/WARN]: Exception loading blockstate definition: 'industrialforegoing:blockstates/raw_ore_meat_block.json' missing model for variant: 'industrialforegoing:raw_ore_meat_block#level=6'
[12:28:13] [Worker-Main-6/WARN]: Exception loading blockstate definition: 'industrialforegoing:blockstates/raw_ore_meat_block.json' missing model for variant: 'industrialforegoing:raw_ore_meat_block#level=5'
[12:28:13] [Worker-Main-6/WARN]: Exception loading blockstate definition: 'industrialforegoing:blockstates/raw_ore_meat_block.json' missing model for variant: 'industrialforegoing:raw_ore_meat_block#level=4'
[12:28:13] [Worker-Main-6/WARN]: Exception loading blockstate definition: 'industrialforegoing:blockstates/raw_ore_meat_block.json' missing model for variant: 'industrialforegoing:raw_ore_meat_block#level=3'
[12:28:13] [Worker-Main-6/WARN]: Exception loading blockstate definition: 'industrialforegoing:blockstates/raw_ore_meat_block.json' missing model for variant: 'industrialforegoing:raw_ore_meat_block#level=2'
[12:28:13] [Worker-Main-6/WARN]: Exception loading blockstate definition: 'industrialforegoing:blockstates/raw_ore_meat_block.json' missing model for variant: 'industrialforegoing:raw_ore_meat_block#level=1'
[12:28:13] [Worker-Main-6/WARN]: Exception loading blockstate definition: 'industrialforegoing:blockstates/raw_ore_meat_block.json' missing model for variant: 'industrialforegoing:raw_ore_meat_block#level=9'
[12:28:13] [Worker-Main-6/WARN]: Exception loading blockstate definition: industrialforegoing:blockstates/fermented_ore_meat_block.json: java.io.FileNotFoundException: industrialforegoing:blockstates/fermented_ore_meat_block.json
[12:28:13] [Worker-Main-6/WARN]: Exception loading blockstate definition: 'industrialforegoing:blockstates/fermented_ore_meat_block.json' missing model for variant: 'industrialforegoing:fermented_ore_meat_block#level=14'
[12:28:13] [Worker-Main-6/WARN]: Exception loading blockstate definition: 'industrialforegoing:blockstates/fermented_ore_meat_block.json' missing model for variant: 'industrialforegoing:fermented_ore_meat_block#level=15'
[12:28:13] [Worker-Main-6/WARN]: Exception loading blockstate definition: 'industrialforegoing:blockstates/fermented_ore_meat_block.json' missing model for variant: 'industrialforegoing:fermented_ore_meat_block#level=12'
[12:28:13] [Worker-Main-6/WARN]: Exception loading blockstate definition: 'industrialforegoing:blockstates/fermented_ore_meat_block.json' missing model for variant: 'industrialforegoing:fermented_ore_meat_block#level=9'
[12:28:13] [Worker-Main-6/WARN]: Exception loading blockstate definition: 'industrialforegoing:blockstates/fermented_ore_meat_block.json' missing model for variant: 'industrialforegoing:fermented_ore_meat_block#level=13'
[12:28:13] [Worker-Main-6/WARN]: Exception loading blockstate definition: 'industrialforegoing:blockstates/fermented_ore_meat_block.json' missing model for variant: 'industrialforegoing:fermented_ore_meat_block#level=10'
[12:28:13] [Worker-Main-6/WARN]: Exception loading blockstate definition: 'industrialforegoing:blockstates/fermented_ore_meat_block.json' missing model for variant: 'industrialforegoing:fermented_ore_meat_block#level=11'
[12:28:13] [Worker-Main-6/WARN]: Exception loading blockstate definition: 'industrialforegoing:blockstates/fermented_ore_meat_block.json' missing model for variant: 'industrialforegoing:fermented_ore_meat_block#level=6'
[12:28:13] [Worker-Main-6/WARN]: Exception loading blockstate definition: 'industrialforegoing:blockstates/fermented_ore_meat_block.json' missing model for variant: 'industrialforegoing:fermented_ore_meat_block#level=5'
[12:28:13] [Worker-Main-6/WARN]: Exception loading blockstate definition: 'industrialforegoing:blockstates/fermented_ore_meat_block.json' missing model for variant: 'industrialforegoing:fermented_ore_meat_block#level=8'
[12:28:13] [Worker-Main-6/WARN]: Exception loading blockstate definition: 'industrialforegoing:blockstates/fermented_ore_meat_block.json' missing model for variant: 'industrialforegoing:fermented_ore_meat_block#level=7'
[12:28:13] [Worker-Main-6/WARN]: Exception loading blockstate definition: 'industrialforegoing:blockstates/fermented_ore_meat_block.json' missing model for variant: 'industrialforegoing:fermented_ore_meat_block#level=2'
[12:28:13] [Worker-Main-6/WARN]: Exception loading blockstate definition: 'industrialforegoing:blockstates/fermented_ore_meat_block.json' missing model for variant: 'industrialforegoing:fermented_ore_meat_block#level=1'
[12:28:13] [Worker-Main-6/WARN]: Exception loading blockstate definition: 'industrialforegoing:blockstates/fermented_ore_meat_block.json' missing model for variant: 'industrialforegoing:fermented_ore_meat_block#level=4'
[12:28:13] [Worker-Main-6/WARN]: Exception loading blockstate definition: 'industrialforegoing:blockstates/fermented_ore_meat_block.json' missing model for variant: 'industrialforegoing:fermented_ore_meat_block#level=3'
[12:28:13] [Worker-Main-6/WARN]: Exception loading blockstate definition: 'industrialforegoing:blockstates/fermented_ore_meat_block.json' missing model for variant: 'industrialforegoing:fermented_ore_meat_block#level=0'
[12:28:13] [Worker-Main-6/WARN]: Exception loading blockstate definition: industrialforegoing:blockstates/machine_frame_pity.json: java.io.FileNotFoundException: industrialforegoing:blockstates/machine_frame_pity.json
[12:28:13] [Worker-Main-6/WARN]: Exception loading blockstate definition: 'industrialforegoing:blockstates/machine_frame_pity.json' missing model for variant: 'industrialforegoing:machine_frame_pity#'
[12:28:13] [Worker-Main-6/WARN]: Exception loading blockstate definition: industrialforegoing:blockstates/machine_frame_simple.json: java.io.FileNotFoundException: industrialforegoing:blockstates/machine_frame_simple.json
[12:28:13] [Worker-Main-6/WARN]: Exception loading blockstate definition: 'industrialforegoing:blockstates/machine_frame_simple.json' missing model for variant: 'industrialforegoing:machine_frame_simple#'
[12:28:13] [Worker-Main-6/WARN]: Exception loading blockstate definition: industrialforegoing:blockstates/machine_frame_advanced.json: java.io.FileNotFoundException: industrialforegoing:blockstates/machine_frame_advanced.json
[12:28:13] [Worker-Main-6/WARN]: Exception loading blockstate definition: 'industrialforegoing:blockstates/machine_frame_advanced.json' missing model for variant: 'industrialforegoing:machine_frame_advanced#'
[12:28:13] [Worker-Main-6/WARN]: Exception loading blockstate definition: industrialforegoing:blockstates/machine_frame_supreme.json: java.io.FileNotFoundException: industrialforegoing:blockstates/machine_frame_supreme.json
[12:28:13] [Worker-Main-6/WARN]: Exception loading blockstate definition: 'industrialforegoing:blockstates/machine_frame_supreme.json' missing model for variant: 'industrialforegoing:machine_frame_supreme#'
[12:28:13] [Worker-Main-6/WARN]: Exception loading blockstate definition: industrialforegoing:blockstates/sewage_block.json: java.io.FileNotFoundException: industrialforegoing:blockstates/sewage_block.json
[12:28:13] [Worker-Main-6/WARN]: Exception loading blockstate definition: 'industrialforegoing:blockstates/sewage_block.json' missing model for variant: 'industrialforegoing:sewage_block#level=10'
[12:28:13] [Worker-Main-6/WARN]: Exception loading blockstate definition: 'industrialforegoing:blockstates/sewage_block.json' missing model for variant: 'industrialforegoing:sewage_block#level=12'
[12:28:13] [Worker-Main-6/WARN]: Exception loading blockstate definition: 'industrialforegoing:blockstates/sewage_block.json' missing model for variant: 'industrialforegoing:sewage_block#level=11'
[12:28:13] [Worker-Main-6/WARN]: Exception loading blockstate definition: 'industrialforegoing:blockstates/sewage_block.json' missing model for variant: 'industrialforegoing:sewage_block#level=14'
[12:28:13] [Worker-Main-6/WARN]: Exception loading blockstate definition: 'industrialforegoing:blockstates/sewage_block.json' missing model for variant: 'industrialforegoing:sewage_block#level=13'
[12:28:13] [Worker-Main-6/WARN]: Exception loading blockstate definition: 'industrialforegoing:blockstates/sewage_block.json' missing model for variant: 'industrialforegoing:sewage_block#level=15'
[12:28:13] [Worker-Main-6/WARN]: Exception loading blockstate definition: 'industrialforegoing:blockstates/sewage_block.json' missing model for variant: 'industrialforegoing:sewage_block#level=5'
[12:28:13] [Worker-Main-6/WARN]: Exception loading blockstate definition: 'industrialforegoing:blockstates/sewage_block.json' missing model for variant: 'industrialforegoing:sewage_block#level=4'
[12:28:13] [Worker-Main-6/WARN]: Exception loading blockstate definition: 'industrialforegoing:blockstates/sewage_block.json' missing model for variant: 'industrialforegoing:sewage_block#level=7'
[12:28:13] [Worker-Main-6/WARN]: Exception loading blockstate definition: 'industrialforegoing:blockstates/sewage_block.json' missing model for variant: 'industrialforegoing:sewage_block#level=6'
[12:28:13] [Worker-Main-6/WARN]: Exception loading blockstate definition: 'industrialforegoing:blockstates/sewage_block.json' missing model for variant: 'industrialforegoing:sewage_block#level=9'
[12:28:13] [Worker-Main-6/WARN]: Exception loading blockstate definition: 'industrialforegoing:blockstates/sewage_block.json' missing model for variant: 'industrialforegoing:sewage_block#level=8'
[12:28:13] [Worker-Main-6/WARN]: Exception loading blockstate definition: 'industrialforegoing:blockstates/sewage_block.json' missing model for variant: 'industrialforegoing:sewage_block#level=1'
[12:28:13] [Worker-Main-6/WARN]: Exception loading blockstate definition: 'industrialforegoing:blockstates/sewage_block.json' missing model for variant: 'industrialforegoing:sewage_block#level=0'
[12:28:13] [Worker-Main-6/WARN]: Exception loading blockstate definition: 'industrialforegoing:blockstates/sewage_block.json' missing model for variant: 'industrialforegoing:sewage_block#level=3'
[12:28:13] [Worker-Main-6/WARN]: Exception loading blockstate definition: 'industrialforegoing:blockstates/sewage_block.json' missing model for variant: 'industrialforegoing:sewage_block#level=2'
[12:28:14] [Worker-Main-6/WARN]: Exception loading blockstate definition: allthemodium:blockstates/vapor_allthemodium_block.json: java.io.FileNotFoundException: allthemodium:blockstates/vapor_allthemodium_block.json
[12:28:14] [Worker-Main-6/WARN]: Exception loading blockstate definition: 'allthemodium:blockstates/vapor_allthemodium_block.json' missing model for variant: 'allthemodium:vapor_allthemodium_block#level=11'
[12:28:14] [Worker-Main-6/WARN]: Exception loading blockstate definition: 'allthemodium:blockstates/vapor_allthemodium_block.json' missing model for variant: 'allthemodium:vapor_allthemodium_block#level=12'
[12:28:14] [Worker-Main-6/WARN]: Exception loading blockstate definition: 'allthemodium:blockstates/vapor_allthemodium_block.json' missing model for variant: 'allthemodium:vapor_allthemodium_block#level=13'
[12:28:14] [Worker-Main-6/WARN]: Exception loading blockstate definition: 'allthemodium:blockstates/vapor_allthemodium_block.json' missing model for variant: 'allthemodium:vapor_allthemodium_block#level=14'
[12:28:14] [Worker-Main-6/WARN]: Exception loading blockstate definition: 'allthemodium:blockstates/vapor_allthemodium_block.json' missing model for variant: 'allthemodium:vapor_allthemodium_block#level=10'
[12:28:14] [Worker-Main-6/WARN]: Exception loading blockstate definition: 'allthemodium:blockstates/vapor_allthemodium_block.json' missing model for variant: 'allthemodium:vapor_allthemodium_block#level=15'
[12:28:14] [Worker-Main-6/WARN]: Exception loading blockstate definition: 'allthemodium:blockstates/vapor_allthemodium_block.json' missing model for variant: 'allthemodium:vapor_allthemodium_block#level=9'
[12:28:14] [Worker-Main-6/WARN]: Exception loading blockstate definition: 'allthemodium:blockstates/vapor_allthemodium_block.json' missing model for variant: 'allthemodium:vapor_allthemodium_block#level=8'
[12:28:14] [Worker-Main-6/WARN]: Exception loading blockstate definition: 'allthemodium:blockstates/vapor_allthemodium_block.json' missing model for variant: 'allthemodium:vapor_allthemodium_block#level=7'
[12:28:14] [Worker-Main-6/WARN]: Exception loading blockstate definition: 'allthemodium:blockstates/vapor_allthemodium_block.json' missing model for variant: 'allthemodium:vapor_allthemodium_block#level=6'
[12:28:15] [Worker-Main-6/WARN]: Exception loading blockstate definition: 'allthemodium:blockstates/vapor_allthemodium_block.json' missing model for variant: 'allthemodium:vapor_allthemodium_block#level=1'
[12:28:15] [Worker-Main-6/WARN]: Exception loading blockstate definition: 'allthemodium:blockstates/vapor_allthemodium_block.json' missing model for variant: 'allthemodium:vapor_allthemodium_block#level=0'
[12:28:15] [Worker-Main-6/WARN]: Exception loading blockstate definition: 'allthemodium:blockstates/vapor_allthemodium_block.json' missing model for variant: 'allthemodium:vapor_allthemodium_block#level=5'
[12:28:15] [Worker-Main-6/WARN]: Exception loading blockstate definition: 'allthemodium:blockstates/vapor_allthemodium_block.json' missing model for variant: 'allthemodium:vapor_allthemodium_block#level=4'
[12:28:15] [Worker-Main-6/WARN]: Exception loading blockstate definition: 'allthemodium:blockstates/vapor_allthemodium_block.json' missing model for variant: 'allthemodium:vapor_allthemodium_block#level=3'
[12:28:15] [Worker-Main-6/WARN]: Exception loading blockstate definition: 'allthemodium:blockstates/vapor_allthemodium_block.json' missing model for variant: 'allthemodium:vapor_allthemodium_block#level=2'
[12:28:15] [Worker-Main-6/WARN]: Exception loading blockstate definition: allthemodium:blockstates/vapor_vibranium_block.json: java.io.FileNotFoundException: allthemodium:blockstates/vapor_vibranium_block.json
[12:28:15] [Worker-Main-6/WARN]: Exception loading blockstate definition: 'allthemodium:blockstates/vapor_vibranium_block.json' missing model for variant: 'allthemodium:vapor_vibranium_block#level=8'
[12:28:15] [Worker-Main-6/WARN]: Exception loading blockstate definition: 'allthemodium:blockstates/vapor_vibranium_block.json' missing model for variant: 'allthemodium:vapor_vibranium_block#level=9'
[12:28:15] [Worker-Main-6/WARN]: Exception loading blockstate definition: 'allthemodium:blockstates/vapor_vibranium_block.json' missing model for variant: 'allthemodium:vapor_vibranium_block#level=6'
[12:28:15] [Worker-Main-6/WARN]: Exception loading blockstate definition: 'allthemodium:blockstates/vapor_vibranium_block.json' missing model for variant: 'allthemodium:vapor_vibranium_block#level=7'
[12:28:15] [Worker-Main-6/WARN]: Exception loading blockstate definition: 'allthemodium:blockstates/vapor_vibranium_block.json' missing model for variant: 'allthemodium:vapor_vibranium_block#level=4'
[12:28:15] [Worker-Main-6/WARN]: Exception loading blockstate definition: 'allthemodium:blockstates/vapor_vibranium_block.json' missing model for variant: 'allthemodium:vapor_vibranium_block#level=5'
[12:28:15] [Worker-Main-6/WARN]: Exception loading blockstate definition: 'allthemodium:blockstates/vapor_vibranium_block.json' missing model for variant: 'allthemodium:vapor_vibranium_block#level=2'
[12:28:15] [Worker-Main-6/WARN]: Exception loading blockstate definition: 'allthemodium:blockstates/vapor_vibranium_block.json' missing model for variant: 'allthemodium:vapor_vibranium_block#level=3'
[12:28:15] [Worker-Main-6/WARN]: Exception loading blockstate definition: 'allthemodium:blockstates/vapor_vibranium_block.json' missing model for variant: 'allthemodium:vapor_vibranium_block#level=15'
[12:28:15] [Worker-Main-6/WARN]: Exception loading blockstate definition: 'allthemodium:blockstates/vapor_vibranium_block.json' missing model for variant: 'allthemodium:vapor_vibranium_block#level=13'
[12:28:15] [Worker-Main-6/WARN]: Exception loading blockstate definition: 'allthemodium:blockstates/vapor_vibranium_block.json' missing model for variant: 'allthemodium:vapor_vibranium_block#level=14'
[12:28:15] [Worker-Main-6/WARN]: Exception loading blockstate definition: 'allthemodium:blockstates/vapor_vibranium_block.json' missing model for variant: 'allthemodium:vapor_vibranium_block#level=11'
[12:28:15] [Worker-Main-6/WARN]: Exception loading blockstate definition: 'allthemodium:blockstates/vapor_vibranium_block.json' missing model for variant: 'allthemodium:vapor_vibranium_block#level=12'
[12:28:15] [Worker-Main-6/WARN]: Exception loading blockstate definition: 'allthemodium:blockstates/vapor_vibranium_block.json' missing model for variant: 'allthemodium:vapor_vibranium_block#level=10'
[12:28:15] [Worker-Main-6/WARN]: Exception loading blockstate definition: 'allthemodium:blockstates/vapor_vibranium_block.json' missing model for variant: 'allthemodium:vapor_vibranium_block#level=0'
[12:28:15] [Worker-Main-6/WARN]: Exception loading blockstate definition: 'allthemodium:blockstates/vapor_vibranium_block.json' missing model for variant: 'allthemodium:vapor_vibranium_block#level=1'
[12:28:15] [Worker-Main-6/WARN]: Exception loading blockstate definition: allthemodium:blockstates/vapor_unobtainium_block.json: java.io.FileNotFoundException: allthemodium:blockstates/vapor_unobtainium_block.json
[12:28:15] [Worker-Main-6/WARN]: Exception loading blockstate definition: 'allthemodium:blockstates/vapor_unobtainium_block.json' missing model for variant: 'allthemodium:vapor_unobtainium_block#level=10'
[12:28:15] [Worker-Main-6/WARN]: Exception loading blockstate definition: 'allthemodium:blockstates/vapor_unobtainium_block.json' missing model for variant: 'allthemodium:vapor_unobtainium_block#level=11'
[12:28:15] [Worker-Main-6/WARN]: Exception loading blockstate definition: 'allthemodium:blockstates/vapor_unobtainium_block.json' missing model for variant: 'allthemodium:vapor_unobtainium_block#level=12'
[12:28:15] [Worker-Main-6/WARN]: Exception loading blockstate definition: 'allthemodium:blockstates/vapor_unobtainium_block.json' missing model for variant: 'allthemodium:vapor_unobtainium_block#level=0'
[12:28:15] [Worker-Main-6/WARN]: Exception loading blockstate definition: 'allthemodium:blockstates/vapor_unobtainium_block.json' missing model for variant: 'allthemodium:vapor_unobtainium_block#level=1'
[12:28:15] [Worker-Main-6/WARN]: Exception loading blockstate definition: 'allthemodium:blockstates/vapor_unobtainium_block.json' missing model for variant: 'allthemodium:vapor_unobtainium_block#level=2'
[12:28:15] [Worker-Main-6/WARN]: Exception loading blockstate definition: 'allthemodium:blockstates/vapor_unobtainium_block.json' missing model for variant: 'allthemodium:vapor_unobtainium_block#level=3'
[12:28:15] [Worker-Main-6/WARN]: Exception loading blockstate definition: 'allthemodium:blockstates/vapor_unobtainium_block.json' missing model for variant: 'allthemodium:vapor_unobtainium_block#level=4'
[12:28:15] [Worker-Main-6/WARN]: Exception loading blockstate definition: 'allthemodium:blockstates/vapor_unobtainium_block.json' missing model for variant: 'allthemodium:vapor_unobtainium_block#level=5'
[12:28:15] [Worker-Main-6/WARN]: Exception loading blockstate definition: 'allthemodium:blockstates/vapor_unobtainium_block.json' missing model for variant: 'allthemodium:vapor_unobtainium_block#level=6'
[12:28:15] [Worker-Main-6/WARN]: Exception loading blockstate definition: 'allthemodium:blockstates/vapor_unobtainium_block.json' missing model for variant: 'allthemodium:vapor_unobtainium_block#level=7'
[12:28:15] [Worker-Main-6/WARN]: Exception loading blockstate definition: 'allthemodium:blockstates/vapor_unobtainium_block.json' missing model for variant: 'allthemodium:vapor_unobtainium_block#level=8'
[12:28:15] [Worker-Main-6/WARN]: Exception loading blockstate definition: 'allthemodium:blockstates/vapor_unobtainium_block.json' missing model for variant: 'allthemodium:vapor_unobtainium_block#level=9'
[12:28:15] [Worker-Main-6/WARN]: Exception loading blockstate definition: 'allthemodium:blockstates/vapor_unobtainium_block.json' missing model for variant: 'allthemodium:vapor_unobtainium_block#level=13'
[12:28:15] [Worker-Main-6/WARN]: Exception loading blockstate definition: 'allthemodium:blockstates/vapor_unobtainium_block.json' missing model for variant: 'allthemodium:vapor_unobtainium_block#level=14'
[12:28:15] [Worker-Main-6/WARN]: Exception loading blockstate definition: 'allthemodium:blockstates/vapor_unobtainium_block.json' missing model for variant: 'allthemodium:vapor_unobtainium_block#level=15'
[12:28:18] [Worker-Main-6/WARN]: Exception loading blockstate definition: 'vehicle:blockstates/vehicle_crate.json' missing model for variant: 'vehicle:vehicle_crate#facing=west'
[12:28:18] [Worker-Main-6/WARN]: Exception loading blockstate definition: 'vehicle:blockstates/vehicle_crate.json' missing model for variant: 'vehicle:vehicle_crate#facing=north'
[12:28:18] [Worker-Main-6/WARN]: Exception loading blockstate definition: 'vehicle:blockstates/vehicle_crate.json' missing model for variant: 'vehicle:vehicle_crate#facing=south'
[12:28:18] [Worker-Main-6/WARN]: Exception loading blockstate definition: 'vehicle:blockstates/vehicle_crate.json' missing model for variant: 'vehicle:vehicle_crate#facing=east'
[12:28:18] [Worker-Main-6/WARN]: Exception loading blockstate definition: 'vehicle:blockstates/vehicle_crate.json' in resourcepack: 'Mod Resources': Missing model, expected to find a string
[12:28:29] [Worker-Main-6/WARN]: Unable to load model: 'industrialforegoing:item_transporter_type#inventory' referenced from: industrialforegoing:item_transporter_type#inventory: {}
[12:28:29] [Worker-Main-6/WARN]: java.io.FileNotFoundException: industrialforegoing:models/item/item_transporter_type.json
[12:28:29] [Worker-Main-6/WARN]: Unable to load model: 'industrialforegoing:fluid_transporter_type#inventory' referenced from: industrialforegoing:fluid_transporter_type#inventory: {}
[12:28:29] [Worker-Main-6/WARN]: java.io.FileNotFoundException: industrialforegoing:models/item/fluid_transporter_type.json
[12:28:29] [Worker-Main-6/WARN]: Unable to load model: 'industrialforegoing:world_transporter_type#inventory' referenced from: industrialforegoing:world_transporter_type#inventory: {}
[12:28:29] [Worker-Main-6/WARN]: java.io.FileNotFoundException: industrialforegoing:models/item/world_transporter_type.json
[12:28:29] [Worker-Main-6/WARN]: Unable to load model: 'industrialforegoing:transporter#inventory' referenced from: industrialforegoing:transporter#inventory: {}
[12:28:29] [Worker-Main-6/WARN]: java.io.FileNotFoundException: industrialforegoing:models/item/transporter.json
[12:28:31] [Worker-Main-6/WARN]: [OptiFine] Unknown resource pack file: mod_resources
[12:28:31] [Worker-Main-6/WARN]: [OptiFine] Unknown resource pack file: mod_resources
[12:28:31] [Worker-Main-6/WARN]: [OptiFine] Unknown resource pack file: mod_resources
[12:28:31] [Worker-Main-6/WARN]: [OptiFine] Unknown resource pack file: mod_resources
[12:28:40] [Worker-Main-6/WARN]: Unable to resolve texture reference: #missing in industrialforegoing:item/infinity_launcher_empty
[12:28:40] [Worker-Main-6/WARN]: Unable to resolve texture reference: #missing in industrialforegoing:item/infinity_launcher_full
[12:28:40] [Worker-Main-6/WARN]: Unable to resolve texture reference: #missing in vehicle:vehicle/dirt_bike_body
[12:28:40] [Worker-Main-6/WARN]: Unable to resolve texture reference: #missing in industrialforegoing:item/infinity_backpack
[12:28:40] [Worker-Main-6/INFO]: [OptiFine] Multitexture: false
[12:28:40] [Worker-Main-6/WARN]: [OptiFine] Unknown resource pack file: mod_resources
[12:28:40] [Worker-Main-6/INFO]: [OptiFine] Multipass connected textures: false
[12:28:41] [Worker-Main-6/INFO]: [OptiFine] ConnectedTextures: optifine/ctm/default/00_glass_white/glass_pane_white.properties
[12:28:41] [Worker-Main-6/INFO]: [OptiFine] ConnectedTextures: optifine/ctm/default/00_glass_white/glass_white.properties
[12:28:41] [Worker-Main-6/INFO]: [OptiFine] ConnectedTextures: optifine/ctm/default/01_glass_orange/glass_orange.properties
[12:28:42] [Worker-Main-6/INFO]: [OptiFine] ConnectedTextures: optifine/ctm/default/01_glass_orange/glass_pane_orange.properties
[12:28:42] [Worker-Main-6/INFO]: [OptiFine] ConnectedTextures: optifine/ctm/default/02_glass_magenta/glass_magenta.properties
[12:28:42] [Worker-Main-6/INFO]: [OptiFine] ConnectedTextures: optifine/ctm/default/02_glass_magenta/glass_pane_magenta.properties
[12:28:43] [Worker-Main-6/INFO]: [OptiFine] ConnectedTextures: optifine/ctm/default/03_glass_light_blue/glass_light_blue.properties
[12:28:43] [Worker-Main-6/INFO]: [OptiFine] ConnectedTextures: optifine/ctm/default/03_glass_light_blue/glass_pane_light_blue.properties
[12:28:43] [Worker-Main-6/INFO]: [OptiFine] ConnectedTextures: optifine/ctm/default/04_glass_yellow/glass_pane_yellow.properties
[12:28:43] [Worker-Main-6/INFO]: [OptiFine] ConnectedTextures: optifine/ctm/default/04_glass_yellow/glass_yellow.properties
[12:28:44] [Worker-Main-6/INFO]: [OptiFine] ConnectedTextures: optifine/ctm/default/05_glass_lime/glass_lime.properties
[12:28:44] [Worker-Main-6/INFO]: [OptiFine] ConnectedTextures: optifine/ctm/default/05_glass_lime/glass_pane_lime.properties
[12:28:44] [Worker-Main-6/INFO]: [OptiFine] ConnectedTextures: optifine/ctm/default/06_glass_pink/glass_pane_pink.properties
[12:28:45] [Worker-Main-6/INFO]: [OptiFine] ConnectedTextures: optifine/ctm/default/06_glass_pink/glass_pink.properties
[12:28:45] [Worker-Main-6/INFO]: [OptiFine] ConnectedTextures: optifine/ctm/default/07_glass_gray/glass_gray.properties
[12:28:45] [Worker-Main-6/INFO]: [OptiFine] ConnectedTextures: optifine/ctm/default/07_glass_gray/glass_pane_gray.properties
[12:28:45] [Worker-Main-6/INFO]: [OptiFine] ConnectedTextures: optifine/ctm/default/08_glass_light_gray/glass_light_gray.properties
[12:28:46] [Worker-Main-6/INFO]: [OptiFine] ConnectedTextures: optifine/ctm/default/08_glass_light_gray/glass_pane_light_gray.properties
[12:28:46] [Worker-Main-6/INFO]: [OptiFine] ConnectedTextures: optifine/ctm/default/09_glass_cyan/glass_cyan.properties
[12:28:46] [Worker-Main-6/INFO]: [OptiFine] ConnectedTextures: optifine/ctm/default/09_glass_cyan/glass_pane_cyan.properties
[12:28:47] [Worker-Main-6/INFO]: [OptiFine] ConnectedTextures: optifine/ctm/default/10_glass_purple/glass_pane_purple.properties
[12:28:47] [Worker-Main-6/INFO]: [OptiFine] ConnectedTextures: optifine/ctm/default/10_glass_purple/glass_purple.properties
[12:28:47] [Worker-Main-6/INFO]: [OptiFine] ConnectedTextures: optifine/ctm/default/11_glass_blue/glass_blue.properties
[12:28:47] [Worker-Main-6/INFO]: [OptiFine] ConnectedTextures: optifine/ctm/default/11_glass_blue/glass_pane_blue.properties
[12:28:48] [Worker-Main-6/INFO]: [OptiFine] ConnectedTextures: optifine/ctm/default/12_glass_brown/glass_brown.properties
[12:28:48] [Worker-Main-6/INFO]: [OptiFine] ConnectedTextures: optifine/ctm/default/12_glass_brown/glass_pane_brown.properties
[12:28:48] [Worker-Main-6/INFO]: [OptiFine] ConnectedTextures: optifine/ctm/default/13_glass_green/glass_green.properties
[12:28:49] [Worker-Main-6/INFO]: [OptiFine] ConnectedTextures: optifine/ctm/default/13_glass_green/glass_pane_green.properties
[12:28:49] [Worker-Main-6/INFO]: [OptiFine] ConnectedTextures: optifine/ctm/default/14_glass_red/glass_pane_red.properties
[12:28:49] [Worker-Main-6/INFO]: [OptiFine] ConnectedTextures: optifine/ctm/default/14_glass_red/glass_red.properties
[12:28:49] [Worker-Main-6/INFO]: [OptiFine] ConnectedTextures: optifine/ctm/default/15_glass_black/glass_black.properties
[12:28:50] [Worker-Main-6/INFO]: [OptiFine] ConnectedTextures: optifine/ctm/default/15_glass_black/glass_pane_black.properties
[12:28:50] [Worker-Main-6/INFO]: [OptiFine] ConnectedTextures: optifine/ctm/default/20_glass/glass.properties
[12:28:50] [Worker-Main-6/INFO]: [OptiFine] ConnectedTextures: optifine/ctm/default/20_glass/glass_pane.properties
[12:28:51] [Worker-Main-6/INFO]: [OptiFine] ConnectedTextures: optifine/ctm/default/30_bookshelf/bookshelf.properties
[12:28:51] [Worker-Main-6/INFO]: [OptiFine] ConnectedTextures: optifine/ctm/default/40_sandstone/sandstone.properties
[12:28:51] [Worker-Main-6/INFO]: [OptiFine] ConnectedTextures: optifine/ctm/default/41_red_sandstone/red_sandstone.properties
[12:28:51] [Worker-Main-6/INFO]: [OptiFine] Multipass connected textures: false
[12:28:51] [Worker-Main-6/INFO]: [OptiFine] BetterGrass: Parsing default configuration optifine/bettergrass.properties
[12:29:24] [Worker-Main-6/INFO]: [OptiFine] Mipmap levels: 4
[12:29:25] [Worker-Main-7/INFO]: [OptiFine] Scaled non power of 2: jei:gui/icons/recipe_transfer, 7 -> 14
[12:29:26] [Worker-Main-8/INFO]: [OptiFine] Multitexture: false
[12:29:26] [Worker-Main-7/INFO]: [OptiFine] Multitexture: false
[12:29:26] [Worker-Main-9/INFO]: [OptiFine] Multitexture: false
[12:29:26] [Worker-Main-10/INFO]: No plugins for JourneyMap API discovered.
[12:29:27] [Worker-Main-10/INFO]: Post Initialization ( started )
[12:29:27] [Worker-Main-10/INFO]: Post Initialization ( ended after 79ms )
[12:29:27] [Worker-Main-10/INFO]: Common Setup
[12:29:27] [Worker-Main-10/INFO]: Whitelisted Dimensions:
[12:29:27] [Worker-Main-10/INFO]: minecraft:overworld
[12:29:27] [Worker-Main-10/INFO]: Registering 3 command argument types.
[12:29:27] [Worker-Main-10/INFO]: Registering 13 loot conditions.
[12:29:27] [Worker-Main-10/INFO]: Loaded 'Mekanism Generators' module.
[12:29:28] [Worker-Main-10/INFO]: CraftTweaker has loaded successfully!
[12:29:28] [Worker-Main-10/INFO]: Version 10.1.2 initializing...
[12:29:28] [Worker-Main-10/INFO]: Fake player readout: UUID = 46e82cd0-d480-3d48-800a-77431ede078e, name = [Mekanism]
[12:29:28] [Worker-Main-10/INFO]: Loading complete.
[12:29:28] [Worker-Main-10/INFO]: Mod loaded.
[12:29:29] [Forge Version Check/INFO]: [cgm] Starting version check at https://raw.githubusercontent.com/MrCrayfish/ModUpdates/master/cgm/update.json
[12:29:29] [Worker-Main-10/INFO]: Executing phase COMMON_SETUP for plugin class FTBChunksPlugin
[12:29:29] [Worker-Main-10/INFO]: Executing phase COMMON_SETUP for plugin class CuriosPlugin
[12:29:29] [Forge Version Check/INFO]: [cgm] Found status: BETA Current: 1.1.0 Target: null
[12:29:29] [Forge Version Check/INFO]: [clumps] Starting version check at https://updates.blamejared.com/get?n=clumps&gv=1.16.5
[12:29:30] [Worker-Main-10/INFO]: New compacting rule 4 clay_ball = 1 clay
[12:29:30] [Worker-Main-10/INFO]: New compacting rule 4 snowball = 1 snow_block
[12:29:30] [Worker-Main-10/INFO]: New compacting rule 4 glowstone_dust = 1 glowstone
[12:29:30] [Worker-Main-10/INFO]: New compacting rule 4 brick = 1 bricks
[12:29:30] [Worker-Main-10/INFO]: New compacting rule 4 nether_brick = 1 nether_bricks
[12:29:30] [Worker-Main-10/INFO]: New compacting rule 9 nether_wart = 1 nether_wart_block
[12:29:30] [Worker-Main-10/INFO]: New compacting rule 4 quartz = 1 quartz_block
[12:29:30] [Worker-Main-10/INFO]: New compacting rule 9 melon_slice = 1 melon
[12:29:30] [Worker-Main-10/INFO]: New compacting rule 4 sand = 1 sandstone
[12:29:30] [Worker-Main-10/INFO]: New compacting rule 4 red_sand = 1 red_sandstone
[12:29:30] [Worker-Main-10/INFO]: New compacting rule 4 clay_ball = 1 clay
[12:29:30] [Forge Version Check/INFO]: [clumps] Found status: BETA Current: 6.0.0.28 Target: 6.0.0.28
[12:29:30] [Forge Version Check/INFO]: [journeymap] Starting version check at https://forge.curseupdate.com/32274/journeymap
[12:29:30] [Worker-Main-10/INFO]: Loaded 'Mekanism: Tools' module.
[12:29:30] [Worker-Main-10/INFO]: ConstructionWand says hello - may the odds be ever in your favor.
[12:29:31] [Forge Version Check/INFO]: [journeymap] Found status: UP_TO_DATE Current: 5.8.0 Target: null
[12:29:31] [Forge Version Check/INFO]: [bookshelf] Starting version check at https://updates.blamejared.com/get?n=bookshelf&gv=1.16.5
[12:29:31] [main/INFO]: Initializing Packet Registries
[12:29:31] [Forge Version Check/INFO]: [bookshelf] Found status: BETA_OUTDATED Current: 10.4.31 Target: 10.4.32
[12:29:31] [Forge Version Check/INFO]: [darkutils] Starting version check at https://updates.blamejared.com/get?n=darkutils&gv=1.16.4
[12:29:31] [main/INFO]: Registering Structure Piece Types
[12:29:31] [Forge Version Check/INFO]: [darkutils] Found status: BETA Current: 8.0.11 Target: null
[12:29:31] [Forge Version Check/INFO]: [crafttweaker] Starting version check at https://updates.blamejared.com/get?n=crafttweaker&gv=1.16.5
[12:29:31] [Forge Version Check/INFO]: [crafttweaker] Found status: BETA Current: 7.1.2.505 Target: 7.1.2.505
[12:29:31] [Forge Version Check/INFO]: [forge] Starting version check at https://files.minecraftforge.net/net/minecraftforge/forge/promotions_slim.json
[12:29:32] [Worker-Main-9/INFO]: CraftTweaker client has loaded successfully!
[12:29:32] [Worker-Main-9/INFO]: Executing phase CLIENT_SETUP for plugin class FTBChunksPlugin
[12:29:32] [Worker-Main-9/INFO]: Executing phase CLIENT_SETUP for plugin class CuriosPlugin
[12:29:32] [Worker-Main-8/INFO]: [KONKRETE] Client-side libs ready to use!
[12:29:32] [Worker-Main-8/INFO]: [de.keksuccino.konkrete.PostLoadingHandler:runPostLoadingEvents:14]: [KONKRETE] Running PostLoadingEvents for mod: assets/fancymenu
[12:29:32] [Worker-Main-7/INFO]: Initialized HolidayManager.
[12:29:32] [Forge Version Check/INFO]: [forge] Found status: AHEAD Current: 36.2.33 Target: null
[12:29:32] [Forge Version Check/INFO]: [cofh_core] Starting version check at https://raw.github.com/cofh/version/master/cofh_core/update.json
[12:29:33] [Worker-Main-8/INFO]: [de.keksuccino.konkrete.PostLoadingHandler:runPostLoadingEvents:20]: [KONKRETE] PostLoadingEvents completed for mod: assets/fancymenu
[12:29:34] [Forge Version Check/INFO]: [cofh_core] Found status: AHEAD Current: 1.4.2.9 Target: null
[12:29:34] [Forge Version Check/INFO]: [ensorcellation] Starting version check at https://raw.github.com/cofh/version/master/ensorcellation/update.json
[12:29:34] [main/INFO]: Journeymap Initializing
[12:29:34] [Forge Version Check/INFO]: [ensorcellation] Found status: AHEAD Current: 1.4.1.2 Target: null
[12:29:34] [Forge Version Check/INFO]: [mining_dimension] Starting version check at https://maxhenkel.de/update/mining_dimension.json
[12:29:35] [main/INFO]: JourneyMap log initialized.
[12:29:35] [main/INFO]: initialize ENTER
[12:29:35] [main/INFO]: [ClientAPI] built with JourneyMap API 1.8-SNAPSHOT
[12:29:35] [main/INFO]: Initializing plugins with Client API: journeymap.client.api.impl.ClientAPI
[12:29:36] [main/WARN]: core (Initialized) Bad configField entry during updateFrom(): optionsManagerViewed=null
[12:29:37] [main/INFO]: initialize EXIT, elapsed count 1 avg 2852,29ms
[12:29:37] [Forge Version Check/INFO]: [mining_dimension] Found status: UP_TO_DATE Current: 1.16.5-1.0.6 Target: null
[12:29:37] [Forge Version Check/INFO]: [gravestone] Starting version check at https://maxhenkel.de/update/gravestone.json
[12:29:37] [main/WARN]: Mod 'journeymap' took 2.917 s to run a deferred task.
[12:29:37] [Worker-Main-6/INFO]: [OptiFine] Multitexture: false
[12:29:37] [Worker-Main-6/INFO]: [OptiFine] Sprite size: 64
[12:29:37] [Worker-Main-6/INFO]: [OptiFine] Mipmap levels: 6
[12:29:37] [Worker-Main-6/INFO]: [OptiFine] Scaled too small texture: industrialforegoing:blocks/fluids/latex_flow, 32 -> 64
[12:29:37] [Worker-Main-6/INFO]: [OptiFine] Scaled too small texture: industrialforegoing:blocks/fluids/latex_still, 16 -> 64
[12:29:37] [Worker-Main-6/INFO]: [OptiFine] Multitexture: false
[12:29:38] [Worker-Main-6/INFO]: [OptiFine] Sprite size: 64
[12:29:38] [Worker-Main-6/INFO]: [OptiFine] Mipmap levels: 6
[12:29:38] [Worker-Main-6/INFO]: [OptiFine] Scaled too small texture: industrialforegoing:blocks/fluids/latex_flow, 32 -> 64
[12:29:38] [Worker-Main-6/INFO]: [OptiFine] Scaled too small texture: industrialforegoing:blocks/fluids/latex_still, 16 -> 64
[12:29:38] [Worker-Main-6/INFO]: [OptiFine] Multitexture: false
[12:29:38] [Worker-Main-6/INFO]: [OptiFine] Sprite size: 64
[12:29:38] [Worker-Main-6/INFO]: [OptiFine] Mipmap levels: 6
[12:29:38] [Worker-Main-6/INFO]: [OptiFine] Scaled too small texture: industrialforegoing:blocks/fluids/latex_flow, 32 -> 64
[12:29:38] [Worker-Main-6/INFO]: [OptiFine] Scaled too small texture: industrialforegoing:blocks/fluids/latex_still, 16 -> 64
[12:29:38] [Worker-Main-6/INFO]: [OptiFine] Multitexture: false
[12:29:38] [Worker-Main-6/INFO]: [OptiFine] Sprite size: 64
[12:29:38] [Worker-Main-6/INFO]: [OptiFine] Mipmap levels: 6
[12:29:38] [Worker-Main-6/INFO]: [OptiFine] Scaled too small texture: industrialforegoing:blocks/fluids/latex_flow, 32 -> 64
[12:29:38] [Worker-Main-6/INFO]: [OptiFine] Scaled too small texture: industrialforegoing:blocks/fluids/latex_still, 16 -> 64
[12:29:38] [Worker-Main-6/INFO]: [OptiFine] Multitexture: false
[12:29:38] [Worker-Main-6/INFO]: [OptiFine] Sprite size: 64
[12:29:38] [Worker-Main-6/INFO]: [OptiFine] Mipmap levels: 6
[12:29:38] [Worker-Main-6/INFO]: [OptiFine] Scaled too small texture: industrialforegoing:blocks/fluids/latex_flow, 32 -> 64
[12:29:38] [Worker-Main-6/INFO]: [OptiFine] Scaled too small texture: industrialforegoing:blocks/fluids/latex_still, 16 -> 64
[12:29:38] [Worker-Main-6/INFO]: [OptiFine] Multitexture: false
[12:29:38] [Worker-Main-6/INFO]: [OptiFine] Sprite size: 64
[12:29:38] [Worker-Main-6/INFO]: [OptiFine] Mipmap levels: 6
[12:29:38] [Worker-Main-6/INFO]: [OptiFine] Scaled too small texture: industrialforegoing:blocks/fluids/latex_flow, 32 -> 64
[12:29:38] [Worker-Main-6/INFO]: [OptiFine] Scaled too small texture: industrialforegoing:blocks/fluids/latex_still, 16 -> 64
[12:29:39] [main/INFO]: [stepsword.mahoutsukai.render.shader.ShaderHelper:shadersOn:146]: config found
[12:29:39] [main/INFO]: [stepsword.mahoutsukai.render.shader.ShaderHelper:shadersOn:153]: not isShaders
[12:29:39] [Forge Version Check/INFO]: [gravestone] Found status: AHEAD Current: 1.16.5-1.0.7 Target: null
[12:29:39] [Forge Version Check/INFO]: [securitycraft] Starting version check at https://www.github.com/Geforce132/SecurityCraft/raw/master/Updates/Forge.json
[12:29:39] [Forge Version Check/INFO]: [securitycraft] Found status: OUTDATED Current: v1.8.23 Target: v1.9.1
[12:29:39] [Forge Version Check/INFO]: [obfuscate] Starting version check at https://mrcrayfish.com/modupdatejson?id=obfuscate
[12:29:39] [main/INFO]: No shader config found.
[12:29:40] [Forge Version Check/INFO]: [obfuscate] Found status: BETA Current: 0.6.2 Target: 0.6.2
[12:29:40] [Forge Version Check/INFO]: [vehicle] Starting version check at https://raw.githubusercontent.com/MrCrayfish/ModUpdates/master/vehicle/update.json
[12:29:40] [Forge Version Check/INFO]: [vehicle] Found status: BETA Current: 0.45.2 Target: null
[12:29:40] [Forge Version Check/INFO]: [runelic] Starting version check at https://updates.blamejared.com/get?n=runelic&gv=1.16.5
[12:29:40] [main/INFO]: Loading context 'create:context/contraption'
[12:29:40] [main/ERROR]: Shader compilation log for create:rotating.vert: No errors.

[12:29:40] [main/ERROR]: Source for shader 'create:rotating.vert':
   1: #version 110
   2: #define DEBUG_RAINBOW
   3: 
   4: #define PI 3.1415926538
   5: 
   6: #if defined(USE_FOG)
   7: varying float FragDistance;
   8: #endif
   9: 
  10: varying vec3 BoxCoord;
  11: 
  12: uniform vec3 uLightBoxSize;
  13: uniform vec3 uLightBoxMin;
  14: uniform mat4 uModel;
  15: 
  16: uniform float uTime;
  17: uniform mat4 uViewProjection;
  18: uniform vec3 uCameraPos;
  19: 
  20: void FLWFinalizeWorldPos(inout vec4 worldPos) {
  21:     worldPos = uModel * worldPos;
  22: 
  23:     BoxCoord = (worldPos.xyz - uLightBoxMin) / uLightBoxSize;
  24: 
  25:     #if defined(USE_FOG)
  26:     FragDistance = length(worldPos.xyz);
  27:     #endif
  28: 
  29:     gl_Position = uViewProjection * worldPos;
  30: }
  31: 
  32: void FLWFinalizeNormal(inout vec3 normal) {
  33:     mat3 m;
  34:     m[0] = uModel[0].xyz;
  35:     m[1] = uModel[1].xyz;
  36:     m[2] = uModel[2].xyz;
  37:     normal = m * normal;
  38: }
  39: 
  40: 
  41: 
  42: mat4 rotate(vec3 axis, float angle) {
  43:     float s = sin(angle);
  44:     float c = cos(angle);
  45:     float oc = 1. - c;
  46: 
  47:     vec3 sa = axis * s;
  48: 
  49:     mat4 mr = mat4(1.);
  50:     mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
  51:     mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
  52:     mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);
  53: 
  54:     return mr;
  55: }
  56: 
  57: mat4 rotation(vec3 rot) {
  58:     return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
  59: }
  60: 
  61: mat3 modelToNormal(mat4 mat) {
  62:     // Discard the edges. This won't be accurate for scaled or skewed matrices,
  63:     // but we don't have to work with those often.
  64:     mat3 m;
  65:     m[0] = mat[0].xyz;
  66:     m[1] = mat[1].xyz;
  67:     m[2] = mat[2].xyz;
  68:     return m;
  69: }
  70: 
  71: float diffuse(vec3 normal) {
  72:     vec3 n2 = normal * normal * vec3(.6, .25, .8);
  73:     return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
  74: }
  75: 
  76: 
  77: struct Rotating {
  78:     vec2 light;
  79:     vec4 color;
  80:     vec3 pos;
  81:     float speed;
  82:     float offset;
  83:     vec3 axis;
  84: };
  85: 
  86: 
  87: struct Vertex {
  88:     vec3 pos;
  89:     vec3 normal;
  90:     vec2 texCoords;
  91: };
  92: 
  93: struct BlockFrag {
  94:     vec2 texCoords;
  95:     vec4 color;
  96:     float diffuse;
  97:     vec2 light;
  98: };
  99: 
 100: mat4 kineticRotation(float offset, float speed, vec3 axis) {
 101:     float degrees = offset + uTime * speed * 3./10.;
 102:     float angle = fract(degrees / 360.) * PI * 2.;
 103: 
 104:     return rotate(axis, angle);
 105: }
 106: 
 107: BlockFrag FLWMain(Vertex v, Rotating instance) {
 108:     mat4 spin = kineticRotation(instance.offset, instance.speed, instance.axis);
 109: 
 110:     vec4 worldPos = spin * vec4(v.pos - .5, 1.);
 111:     worldPos += vec4(instance.pos + .5, 0.);
 112: 
 113:     vec3 norm = modelToNormal(spin) * v.normal;
 114: 
 115:     FLWFinalizeWorldPos(worldPos);
 116:     FLWFinalizeNormal(norm);
 117: 
 118:     BlockFrag b;
 119:     b.diffuse = diffuse(norm);
 120:     b.texCoords = v.texCoords;
 121:     b.light = instance.light;
 122: 
 123:     #if defined(DEBUG_RAINBOW)
 124:     b.color = instance.color;
 125:     #elif defined(DEBUG_NORMAL)
 126:     b.color = vec4(norm, 1.);
 127:     #else
 128:     b.color = vec4(1.);
 129:     #endif
 130: 
 131:     return b;
 132: }
 133: attribute vec3 a_v_pos;
 134: attribute vec3 a_v_normal;
 135: attribute vec2 a_v_texCoords;
 136: 
 137: attribute vec2 a_i_light;
 138: attribute vec4 a_i_color;
 139: attribute vec3 a_i_pos;
 140: attribute float a_i_speed;
 141: attribute float a_i_offset;
 142: attribute vec3 a_i_axis;
 143: 
 144: 
 145: varying vec2 v2f_texCoords;
 146: varying vec4 v2f_color;
 147: varying float v2f_diffuse;
 148: varying vec2 v2f_light;
 149: 
 150: 
 151: void main() {
 152:     Vertex v;
 153:     v.pos = a_v_pos;
 154: v.normal = a_v_normal;
 155: v.texCoords = a_v_texCoords;
 156: 
 157: 
 158:     Rotating i;
 159:     i.light = a_i_light;
 160: i.color = a_i_color;
 161: i.pos = a_i_pos;
 162: i.speed = a_i_speed;
 163: i.offset = a_i_offset;
 164: i.axis = a_i_axis;
 165: 
 166: 
 167:     BlockFrag o = FLWMain(v, i);
 168: 
 169:     v2f_texCoords = o.texCoords;
 170: v2f_color = o.color;
 171: v2f_diffuse = o.diffuse;
 172: v2f_light = o.light;
 173: 
 174: }

[12:29:40] [main/ERROR]: Shader compilation log for flywheel:block.frag: No errors.

[12:29:40] [main/ERROR]: Source for shader 'flywheel:block.frag':
   1: #version 110
   2: #define DEBUG_RAINBOW
   3: 
   4: #if defined(USE_FOG)
   5: varying float FragDistance;
   6: uniform vec4 uFogColor;
   7: #endif
   8: 
   9: #if defined(USE_FOG_LINEAR)
  10: uniform vec2 uFogRange;
  11: 
  12: float FLWFogFactor() {
  13:     return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
  14: }
  15:     #endif
  16: 
  17:     #if defined(USE_FOG_EXP2)
  18: uniform float uFogDensity;
  19: 
  20: float FLWFogFactor() {
  21:     float dist = FragDistance * uFogDensity;
  22:     return 1. / exp2(dist * dist);
  23: }
  24:     #endif
  25: // Adjust the [0,1] normalized lightmap value based on the texture matrix from LightTexture#enableLightmap
  26: vec2 shiftLight(vec2 lm) {
  27:     return lm * 0.99609375 + 0.03125;// * 255/256 + 1/32
  28: }
  29: 
  30: varying vec3 BoxCoord;
  31: varying vec2 BoxLight;
  32: uniform sampler3D uLightVolume;
  33: 
  34: uniform sampler2D uBlockAtlas;
  35: uniform sampler2D uLightMap;
  36: 
  37: vec4 FLWBlockTexture(vec2 texCoords) {
  38:     return texture2D(uBlockAtlas, texCoords);
  39: }
  40: 
  41: void FLWFinalizeColor(vec4 color) {
  42:     #if defined(USE_FOG)
  43:     float a = color.a;
  44:     float fog = clamp(FLWFogFactor(), 0., 1.);
  45: 
  46:     color = mix(uFogColor, color, fog);
  47:     color.a = a;
  48:     #endif
  49: 
  50:     gl_FragColor = color;
  51: }
  52: 
  53: vec4 FLWLight(vec2 lightCoords) {
  54:     lightCoords = max(lightCoords, texture3D(uLightVolume, BoxCoord).rg);
  55: 
  56:     return texture2D(uLightMap, shiftLight(lightCoords));
  57: }
  58: 
  59: 
  60: 
  61: struct BlockFrag {
  62:     vec2 texCoords;
  63:     vec4 color;
  64:     float diffuse;
  65:     vec2 light;
  66: };
  67: 
  68: void FLWMain(BlockFrag r) {
  69:     vec4 tex = FLWBlockTexture(r.texCoords);
  70: 
  71:     vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;
  72: 
  73: //    flw_WorldPos = ;
  74: //    flw_Normal = ;
  75: //    flw_Albedo = tex.rgb;
  76: //    flw_Alpha = tex.a;
  77: //    flw_LightMap = r.light;
  78: //    flw_Tint = r.color;
  79:     FLWFinalizeColor(color);
  80: }
  81: 
  82: varying vec2 v2f_texCoords;
  83: varying vec4 v2f_color;
  84: varying float v2f_diffuse;
  85: varying vec2 v2f_light;
  86: 
  87: 
  88: //vec3 flw_WorldPos;
  89: //vec3 flw_Normal;
  90: //vec3 flw_Albedo;
  91: //float flw_Alpha;
  92: //vec2 flw_LightMap;
  93: //vec4 flw_Tint;
  94: 
  95: void main() {
  96:     BlockFrag f;
  97:     f.texCoords = v2f_texCoords;
  98: f.color = v2f_color;
  99: f.diffuse = v2f_diffuse;
 100: f.light = v2f_light;
 101: 
 102: 
 103:     FLWMain(f);
 104: }

[12:29:40] [main/ERROR]: Shader compilation log for create:rotating.vert: No errors.

[12:29:40] [main/ERROR]: Source for shader 'create:rotating.vert':
   1: #version 110
   2: #define DEBUG_NORMAL
   3: 
   4: #define PI 3.1415926538
   5: 
   6: #if defined(USE_FOG)
   7: varying float FragDistance;
   8: #endif
   9: 
  10: varying vec3 BoxCoord;
  11: 
  12: uniform vec3 uLightBoxSize;
  13: uniform vec3 uLightBoxMin;
  14: uniform mat4 uModel;
  15: 
  16: uniform float uTime;
  17: uniform mat4 uViewProjection;
  18: uniform vec3 uCameraPos;
  19: 
  20: void FLWFinalizeWorldPos(inout vec4 worldPos) {
  21:     worldPos = uModel * worldPos;
  22: 
  23:     BoxCoord = (worldPos.xyz - uLightBoxMin) / uLightBoxSize;
  24: 
  25:     #if defined(USE_FOG)
  26:     FragDistance = length(worldPos.xyz);
  27:     #endif
  28: 
  29:     gl_Position = uViewProjection * worldPos;
  30: }
  31: 
  32: void FLWFinalizeNormal(inout vec3 normal) {
  33:     mat3 m;
  34:     m[0] = uModel[0].xyz;
  35:     m[1] = uModel[1].xyz;
  36:     m[2] = uModel[2].xyz;
  37:     normal = m * normal;
  38: }
  39: 
  40: 
  41: 
  42: mat4 rotate(vec3 axis, float angle) {
  43:     float s = sin(angle);
  44:     float c = cos(angle);
  45:     float oc = 1. - c;
  46: 
  47:     vec3 sa = axis * s;
  48: 
  49:     mat4 mr = mat4(1.);
  50:     mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
  51:     mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
  52:     mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);
  53: 
  54:     return mr;
  55: }
  56: 
  57: mat4 rotation(vec3 rot) {
  58:     return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
  59: }
  60: 
  61: mat3 modelToNormal(mat4 mat) {
  62:     // Discard the edges. This won't be accurate for scaled or skewed matrices,
  63:     // but we don't have to work with those often.
  64:     mat3 m;
  65:     m[0] = mat[0].xyz;
  66:     m[1] = mat[1].xyz;
  67:     m[2] = mat[2].xyz;
  68:     return m;
  69: }
  70: 
  71: float diffuse(vec3 normal) {
  72:     vec3 n2 = normal * normal * vec3(.6, .25, .8);
  73:     return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
  74: }
  75: 
  76: 
  77: struct Rotating {
  78:     vec2 light;
  79:     vec4 color;
  80:     vec3 pos;
  81:     float speed;
  82:     float offset;
  83:     vec3 axis;
  84: };
  85: 
  86: 
  87: struct Vertex {
  88:     vec3 pos;
  89:     vec3 normal;
  90:     vec2 texCoords;
  91: };
  92: 
  93: struct BlockFrag {
  94:     vec2 texCoords;
  95:     vec4 color;
  96:     float diffuse;
  97:     vec2 light;
  98: };
  99: 
 100: mat4 kineticRotation(float offset, float speed, vec3 axis) {
 101:     float degrees = offset + uTime * speed * 3./10.;
 102:     float angle = fract(degrees / 360.) * PI * 2.;
 103: 
 104:     return rotate(axis, angle);
 105: }
 106: 
 107: BlockFrag FLWMain(Vertex v, Rotating instance) {
 108:     mat4 spin = kineticRotation(instance.offset, instance.speed, instance.axis);
 109: 
 110:     vec4 worldPos = spin * vec4(v.pos - .5, 1.);
 111:     worldPos += vec4(instance.pos + .5, 0.);
 112: 
 113:     vec3 norm = modelToNormal(spin) * v.normal;
 114: 
 115:     FLWFinalizeWorldPos(worldPos);
 116:     FLWFinalizeNormal(norm);
 117: 
 118:     BlockFrag b;
 119:     b.diffuse = diffuse(norm);
 120:     b.texCoords = v.texCoords;
 121:     b.light = instance.light;
 122: 
 123:     #if defined(DEBUG_RAINBOW)
 124:     b.color = instance.color;
 125:     #elif defined(DEBUG_NORMAL)
 126:     b.color = vec4(norm, 1.);
 127:     #else
 128:     b.color = vec4(1.);
 129:     #endif
 130: 
 131:     return b;
 132: }
 133: attribute vec3 a_v_pos;
 134: attribute vec3 a_v_normal;
 135: attribute vec2 a_v_texCoords;
 136: 
 137: attribute vec2 a_i_light;
 138: attribute vec4 a_i_color;
 139: attribute vec3 a_i_pos;
 140: attribute float a_i_speed;
 141: attribute float a_i_offset;
 142: attribute vec3 a_i_axis;
 143: 
 144: 
 145: varying vec2 v2f_texCoords;
 146: varying vec4 v2f_color;
 147: varying float v2f_diffuse;
 148: varying vec2 v2f_light;
 149: 
 150: 
 151: void main() {
 152:     Vertex v;
 153:     v.pos = a_v_pos;
 154: v.normal = a_v_normal;
 155: v.texCoords = a_v_texCoords;
 156: 
 157: 
 158:     Rotating i;
 159:     i.light = a_i_light;
 160: i.color = a_i_color;
 161: i.pos = a_i_pos;
 162: i.speed = a_i_speed;
 163: i.offset = a_i_offset;
 164: i.axis = a_i_axis;
 165: 
 166: 
 167:     BlockFrag o = FLWMain(v, i);
 168: 
 169:     v2f_texCoords = o.texCoords;
 170: v2f_color = o.color;
 171: v2f_diffuse = o.diffuse;
 172: v2f_light = o.light;
 173: 
 174: }

[12:29:40] [main/ERROR]: Shader compilation log for flywheel:block.frag: No errors.

[12:29:40] [main/ERROR]: Source for shader 'flywheel:block.frag':
   1: #version 110
   2: #define DEBUG_NORMAL
   3: 
   4: #if defined(USE_FOG)
   5: varying float FragDistance;
   6: uniform vec4 uFogColor;
   7: #endif
   8: 
   9: #if defined(USE_FOG_LINEAR)
  10: uniform vec2 uFogRange;
  11: 
  12: float FLWFogFactor() {
  13:     return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
  14: }
  15:     #endif
  16: 
  17:     #if defined(USE_FOG_EXP2)
  18: uniform float uFogDensity;
  19: 
  20: float FLWFogFactor() {
  21:     float dist = FragDistance * uFogDensity;
  22:     return 1. / exp2(dist * dist);
  23: }
  24:     #endif
  25: // Adjust the [0,1] normalized lightmap value based on the texture matrix from LightTexture#enableLightmap
  26: vec2 shiftLight(vec2 lm) {
  27:     return lm * 0.99609375 + 0.03125;// * 255/256 + 1/32
  28: }
  29: 
  30: varying vec3 BoxCoord;
  31: varying vec2 BoxLight;
  32: uniform sampler3D uLightVolume;
  33: 
  34: uniform sampler2D uBlockAtlas;
  35: uniform sampler2D uLightMap;
  36: 
  37: vec4 FLWBlockTexture(vec2 texCoords) {
  38:     return texture2D(uBlockAtlas, texCoords);
  39: }
  40: 
  41: void FLWFinalizeColor(vec4 color) {
  42:     #if defined(USE_FOG)
  43:     float a = color.a;
  44:     float fog = clamp(FLWFogFactor(), 0., 1.);
  45: 
  46:     color = mix(uFogColor, color, fog);
  47:     color.a = a;
  48:     #endif
  49: 
  50:     gl_FragColor = color;
  51: }
  52: 
  53: vec4 FLWLight(vec2 lightCoords) {
  54:     lightCoords = max(lightCoords, texture3D(uLightVolume, BoxCoord).rg);
  55: 
  56:     return texture2D(uLightMap, shiftLight(lightCoords));
  57: }
  58: 
  59: 
  60: 
  61: struct BlockFrag {
  62:     vec2 texCoords;
  63:     vec4 color;
  64:     float diffuse;
  65:     vec2 light;
  66: };
  67: 
  68: void FLWMain(BlockFrag r) {
  69:     vec4 tex = FLWBlockTexture(r.texCoords);
  70: 
  71:     vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;
  72: 
  73: //    flw_WorldPos = ;
  74: //    flw_Normal = ;
  75: //    flw_Albedo = tex.rgb;
  76: //    flw_Alpha = tex.a;
  77: //    flw_LightMap = r.light;
  78: //    flw_Tint = r.color;
  79:     FLWFinalizeColor(color);
  80: }
  81: 
  82: varying vec2 v2f_texCoords;
  83: varying vec4 v2f_color;
  84: varying float v2f_diffuse;
  85: varying vec2 v2f_light;
  86: 
  87: 
  88: //vec3 flw_WorldPos;
  89: //vec3 flw_Normal;
  90: //vec3 flw_Albedo;
  91: //float flw_Alpha;
  92: //vec2 flw_LightMap;
  93: //vec4 flw_Tint;
  94: 
  95: void main() {
  96:     BlockFrag f;
  97:     f.texCoords = v2f_texCoords;
  98: f.color = v2f_color;
  99: f.diffuse = v2f_diffuse;
 100: f.light = v2f_light;
 101: 
 102: 
 103:     FLWMain(f);
 104: }

[12:29:41] [main/ERROR]: Shader compilation log for create:rotating.vert: No errors.

[12:29:41] [main/ERROR]: Source for shader 'create:rotating.vert':
   1: #version 110
   2: #define USE_FOG
   3: #define USE_FOG_LINEAR
   4: 
   5: #define PI 3.1415926538
   6: 
   7: #if defined(USE_FOG)
   8: varying float FragDistance;
   9: #endif
  10: 
  11: varying vec3 BoxCoord;
  12: 
  13: uniform vec3 uLightBoxSize;
  14: uniform vec3 uLightBoxMin;
  15: uniform mat4 uModel;
  16: 
  17: uniform float uTime;
  18: uniform mat4 uViewProjection;
  19: uniform vec3 uCameraPos;
  20: 
  21: void FLWFinalizeWorldPos(inout vec4 worldPos) {
  22:     worldPos = uModel * worldPos;
  23: 
  24:     BoxCoord = (worldPos.xyz - uLightBoxMin) / uLightBoxSize;
  25: 
  26:     #if defined(USE_FOG)
  27:     FragDistance = length(worldPos.xyz);
  28:     #endif
  29: 
  30:     gl_Position = uViewProjection * worldPos;
  31: }
  32: 
  33: void FLWFinalizeNormal(inout vec3 normal) {
  34:     mat3 m;
  35:     m[0] = uModel[0].xyz;
  36:     m[1] = uModel[1].xyz;
  37:     m[2] = uModel[2].xyz;
  38:     normal = m * normal;
  39: }
  40: 
  41: 
  42: 
  43: mat4 rotate(vec3 axis, float angle) {
  44:     float s = sin(angle);
  45:     float c = cos(angle);
  46:     float oc = 1. - c;
  47: 
  48:     vec3 sa = axis * s;
  49: 
  50:     mat4 mr = mat4(1.);
  51:     mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
  52:     mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
  53:     mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);
  54: 
  55:     return mr;
  56: }
  57: 
  58: mat4 rotation(vec3 rot) {
  59:     return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
  60: }
  61: 
  62: mat3 modelToNormal(mat4 mat) {
  63:     // Discard the edges. This won't be accurate for scaled or skewed matrices,
  64:     // but we don't have to work with those often.
  65:     mat3 m;
  66:     m[0] = mat[0].xyz;
  67:     m[1] = mat[1].xyz;
  68:     m[2] = mat[2].xyz;
  69:     return m;
  70: }
  71: 
  72: float diffuse(vec3 normal) {
  73:     vec3 n2 = normal * normal * vec3(.6, .25, .8);
  74:     return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
  75: }
  76: 
  77: 
  78: struct Rotating {
  79:     vec2 light;
  80:     vec4 color;
  81:     vec3 pos;
  82:     float speed;
  83:     float offset;
  84:     vec3 axis;
  85: };
  86: 
  87: 
  88: struct Vertex {
  89:     vec3 pos;
  90:     vec3 normal;
  91:     vec2 texCoords;
  92: };
  93: 
  94: struct BlockFrag {
  95:     vec2 texCoords;
  96:     vec4 color;
  97:     float diffuse;
  98:     vec2 light;
  99: };
 100: 
 101: mat4 kineticRotation(float offset, float speed, vec3 axis) {
 102:     float degrees = offset + uTime * speed * 3./10.;
 103:     float angle = fract(degrees / 360.) * PI * 2.;
 104: 
 105:     return rotate(axis, angle);
 106: }
 107: 
 108: BlockFrag FLWMain(Vertex v, Rotating instance) {
 109:     mat4 spin = kineticRotation(instance.offset, instance.speed, instance.axis);
 110: 
 111:     vec4 worldPos = spin * vec4(v.pos - .5, 1.);
 112:     worldPos += vec4(instance.pos + .5, 0.);
 113: 
 114:     vec3 norm = modelToNormal(spin) * v.normal;
 115: 
 116:     FLWFinalizeWorldPos(worldPos);
 117:     FLWFinalizeNormal(norm);
 118: 
 119:     BlockFrag b;
 120:     b.diffuse = diffuse(norm);
 121:     b.texCoords = v.texCoords;
 122:     b.light = instance.light;
 123: 
 124:     #if defined(DEBUG_RAINBOW)
 125:     b.color = instance.color;
 126:     #elif defined(DEBUG_NORMAL)
 127:     b.color = vec4(norm, 1.);
 128:     #else
 129:     b.color = vec4(1.);
 130:     #endif
 131: 
 132:     return b;
 133: }
 134: attribute vec3 a_v_pos;
 135: attribute vec3 a_v_normal;
 136: attribute vec2 a_v_texCoords;
 137: 
 138: attribute vec2 a_i_light;
 139: attribute vec4 a_i_color;
 140: attribute vec3 a_i_pos;
 141: attribute float a_i_speed;
 142: attribute float a_i_offset;
 143: attribute vec3 a_i_axis;
 144: 
 145: 
 146: varying vec2 v2f_texCoords;
 147: varying vec4 v2f_color;
 148: varying float v2f_diffuse;
 149: varying vec2 v2f_light;
 150: 
 151: 
 152: void main() {
 153:     Vertex v;
 154:     v.pos = a_v_pos;
 155: v.normal = a_v_normal;
 156: v.texCoords = a_v_texCoords;
 157: 
 158: 
 159:     Rotating i;
 160:     i.light = a_i_light;
 161: i.color = a_i_color;
 162: i.pos = a_i_pos;
 163: i.speed = a_i_speed;
 164: i.offset = a_i_offset;
 165: i.axis = a_i_axis;
 166: 
 167: 
 168:     BlockFrag o = FLWMain(v, i);
 169: 
 170:     v2f_texCoords = o.texCoords;
 171: v2f_color = o.color;
 172: v2f_diffuse = o.diffuse;
 173: v2f_light = o.light;
 174: 
 175: }

[12:29:41] [main/ERROR]: Shader compilation log for flywheel:block.frag: No errors.

[12:29:41] [main/ERROR]: Source for shader 'flywheel:block.frag':
   1: #version 110
   2: #define USE_FOG
   3: #define USE_FOG_LINEAR
   4: 
   5: #if defined(USE_FOG)
   6: varying float FragDistance;
   7: uniform vec4 uFogColor;
   8: #endif
   9: 
  10: #if defined(USE_FOG_LINEAR)
  11: uniform vec2 uFogRange;
  12: 
  13: float FLWFogFactor() {
  14:     return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
  15: }
  16:     #endif
  17: 
  18:     #if defined(USE_FOG_EXP2)
  19: uniform float uFogDensity;
  20: 
  21: float FLWFogFactor() {
  22:     float dist = FragDistance * uFogDensity;
  23:     return 1. / exp2(dist * dist);
  24: }
  25:     #endif
  26: // Adjust the [0,1] normalized lightmap value based on the texture matrix from LightTexture#enableLightmap
  27: vec2 shiftLight(vec2 lm) {
  28:     return lm * 0.99609375 + 0.03125;// * 255/256 + 1/32
  29: }
  30: 
  31: varying vec3 BoxCoord;
  32: varying vec2 BoxLight;
  33: uniform sampler3D uLightVolume;
  34: 
  35: uniform sampler2D uBlockAtlas;
  36: uniform sampler2D uLightMap;
  37: 
  38: vec4 FLWBlockTexture(vec2 texCoords) {
  39:     return texture2D(uBlockAtlas, texCoords);
  40: }
  41: 
  42: void FLWFinalizeColor(vec4 color) {
  43:     #if defined(USE_FOG)
  44:     float a = color.a;
  45:     float fog = clamp(FLWFogFactor(), 0., 1.);
  46: 
  47:     color = mix(uFogColor, color, fog);
  48:     color.a = a;
  49:     #endif
  50: 
  51:     gl_FragColor = color;
  52: }
  53: 
  54: vec4 FLWLight(vec2 lightCoords) {
  55:     lightCoords = max(lightCoords, texture3D(uLightVolume, BoxCoord).rg);
  56: 
  57:     return texture2D(uLightMap, shiftLight(lightCoords));
  58: }
  59: 
  60: 
  61: 
  62: struct BlockFrag {
  63:     vec2 texCoords;
  64:     vec4 color;
  65:     float diffuse;
  66:     vec2 light;
  67: };
  68: 
  69: void FLWMain(BlockFrag r) {
  70:     vec4 tex = FLWBlockTexture(r.texCoords);
  71: 
  72:     vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;
  73: 
  74: //    flw_WorldPos = ;
  75: //    flw_Normal = ;
  76: //    flw_Albedo = tex.rgb;
  77: //    flw_Alpha = tex.a;
  78: //    flw_LightMap = r.light;
  79: //    flw_Tint = r.color;
  80:     FLWFinalizeColor(color);
  81: }
  82: 
  83: varying vec2 v2f_texCoords;
  84: varying vec4 v2f_color;
  85: varying float v2f_diffuse;
  86: varying vec2 v2f_light;
  87: 
  88: 
  89: //vec3 flw_WorldPos;
  90: //vec3 flw_Normal;
  91: //vec3 flw_Albedo;
  92: //float flw_Alpha;
  93: //vec2 flw_LightMap;
  94: //vec4 flw_Tint;
  95: 
  96: void main() {
  97:     BlockFrag f;
  98:     f.texCoords = v2f_texCoords;
  99: f.color = v2f_color;
 100: f.diffuse = v2f_diffuse;
 101: f.light = v2f_light;
 102: 
 103: 
 104:     FLWMain(f);
 105: }

[12:29:41] [main/ERROR]: Shader compilation log for create:rotating.vert: No errors.

[12:29:41] [main/ERROR]: Source for shader 'create:rotating.vert':
   1: #version 110
   2: #define USE_FOG
   3: #define USE_FOG_EXP2
   4: 
   5: #define PI 3.1415926538
   6: 
   7: #if defined(USE_FOG)
   8: varying float FragDistance;
   9: #endif
  10: 
  11: varying vec3 BoxCoord;
  12: 
  13: uniform vec3 uLightBoxSize;
  14: uniform vec3 uLightBoxMin;
  15: uniform mat4 uModel;
  16: 
  17: uniform float uTime;
  18: uniform mat4 uViewProjection;
  19: uniform vec3 uCameraPos;
  20: 
  21: void FLWFinalizeWorldPos(inout vec4 worldPos) {
  22:     worldPos = uModel * worldPos;
  23: 
  24:     BoxCoord = (worldPos.xyz - uLightBoxMin) / uLightBoxSize;
  25: 
  26:     #if defined(USE_FOG)
  27:     FragDistance = length(worldPos.xyz);
  28:     #endif
  29: 
  30:     gl_Position = uViewProjection * worldPos;
  31: }
  32: 
  33: void FLWFinalizeNormal(inout vec3 normal) {
  34:     mat3 m;
  35:     m[0] = uModel[0].xyz;
  36:     m[1] = uModel[1].xyz;
  37:     m[2] = uModel[2].xyz;
  38:     normal = m * normal;
  39: }
  40: 
  41: 
  42: 
  43: mat4 rotate(vec3 axis, float angle) {
  44:     float s = sin(angle);
  45:     float c = cos(angle);
  46:     float oc = 1. - c;
  47: 
  48:     vec3 sa = axis * s;
  49: 
  50:     mat4 mr = mat4(1.);
  51:     mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
  52:     mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
  53:     mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);
  54: 
  55:     return mr;
  56: }
  57: 
  58: mat4 rotation(vec3 rot) {
  59:     return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
  60: }
  61: 
  62: mat3 modelToNormal(mat4 mat) {
  63:     // Discard the edges. This won't be accurate for scaled or skewed matrices,
  64:     // but we don't have to work with those often.
  65:     mat3 m;
  66:     m[0] = mat[0].xyz;
  67:     m[1] = mat[1].xyz;
  68:     m[2] = mat[2].xyz;
  69:     return m;
  70: }
  71: 
  72: float diffuse(vec3 normal) {
  73:     vec3 n2 = normal * normal * vec3(.6, .25, .8);
  74:     return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
  75: }
  76: 
  77: 
  78: struct Rotating {
  79:     vec2 light;
  80:     vec4 color;
  81:     vec3 pos;
  82:     float speed;
  83:     float offset;
  84:     vec3 axis;
  85: };
  86: 
  87: 
  88: struct Vertex {
  89:     vec3 pos;
  90:     vec3 normal;
  91:     vec2 texCoords;
  92: };
  93: 
  94: struct BlockFrag {
  95:     vec2 texCoords;
  96:     vec4 color;
  97:     float diffuse;
  98:     vec2 light;
  99: };
 100: 
 101: mat4 kineticRotation(float offset, float speed, vec3 axis) {
 102:     float degrees = offset + uTime * speed * 3./10.;
 103:     float angle = fract(degrees / 360.) * PI * 2.;
 104: 
 105:     return rotate(axis, angle);
 106: }
 107: 
 108: BlockFrag FLWMain(Vertex v, Rotating instance) {
 109:     mat4 spin = kineticRotation(instance.offset, instance.speed, instance.axis);
 110: 
 111:     vec4 worldPos = spin * vec4(v.pos - .5, 1.);
 112:     worldPos += vec4(instance.pos + .5, 0.);
 113: 
 114:     vec3 norm = modelToNormal(spin) * v.normal;
 115: 
 116:     FLWFinalizeWorldPos(worldPos);
 117:     FLWFinalizeNormal(norm);
 118: 
 119:     BlockFrag b;
 120:     b.diffuse = diffuse(norm);
 121:     b.texCoords = v.texCoords;
 122:     b.light = instance.light;
 123: 
 124:     #if defined(DEBUG_RAINBOW)
 125:     b.color = instance.color;
 126:     #elif defined(DEBUG_NORMAL)
 127:     b.color = vec4(norm, 1.);
 128:     #else
 129:     b.color = vec4(1.);
 130:     #endif
 131: 
 132:     return b;
 133: }
 134: attribute vec3 a_v_pos;
 135: attribute vec3 a_v_normal;
 136: attribute vec2 a_v_texCoords;
 137: 
 138: attribute vec2 a_i_light;
 139: attribute vec4 a_i_color;
 140: attribute vec3 a_i_pos;
 141: attribute float a_i_speed;
 142: attribute float a_i_offset;
 143: attribute vec3 a_i_axis;
 144: 
 145: 
 146: varying vec2 v2f_texCoords;
 147: varying vec4 v2f_color;
 148: varying float v2f_diffuse;
 149: varying vec2 v2f_light;
 150: 
 151: 
 152: void main() {
 153:     Vertex v;
 154:     v.pos = a_v_pos;
 155: v.normal = a_v_normal;
 156: v.texCoords = a_v_texCoords;
 157: 
 158: 
 159:     Rotating i;
 160:     i.light = a_i_light;
 161: i.color = a_i_color;
 162: i.pos = a_i_pos;
 163: i.speed = a_i_speed;
 164: i.offset = a_i_offset;
 165: i.axis = a_i_axis;
 166: 
 167: 
 168:     BlockFrag o = FLWMain(v, i);
 169: 
 170:     v2f_texCoords = o.texCoords;
 171: v2f_color = o.color;
 172: v2f_diffuse = o.diffuse;
 173: v2f_light = o.light;
 174: 
 175: }

[12:29:41] [main/ERROR]: Shader compilation log for flywheel:block.frag: No errors.

[12:29:41] [main/ERROR]: Source for shader 'flywheel:block.frag':
   1: #version 110
   2: #define USE_FOG
   3: #define USE_FOG_EXP2
   4: 
   5: #if defined(USE_FOG)
   6: varying float FragDistance;
   7: uniform vec4 uFogColor;
   8: #endif
   9: 
  10: #if defined(USE_FOG_LINEAR)
  11: uniform vec2 uFogRange;
  12: 
  13: float FLWFogFactor() {
  14:     return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
  15: }
  16:     #endif
  17: 
  18:     #if defined(USE_FOG_EXP2)
  19: uniform float uFogDensity;
  20: 
  21: float FLWFogFactor() {
  22:     float dist = FragDistance * uFogDensity;
  23:     return 1. / exp2(dist * dist);
  24: }
  25:     #endif
  26: // Adjust the [0,1] normalized lightmap value based on the texture matrix from LightTexture#enableLightmap
  27: vec2 shiftLight(vec2 lm) {
  28:     return lm * 0.99609375 + 0.03125;// * 255/256 + 1/32
  29: }
  30: 
  31: varying vec3 BoxCoord;
  32: varying vec2 BoxLight;
  33: uniform sampler3D uLightVolume;
  34: 
  35: uniform sampler2D uBlockAtlas;
  36: uniform sampler2D uLightMap;
  37: 
  38: vec4 FLWBlockTexture(vec2 texCoords) {
  39:     return texture2D(uBlockAtlas, texCoords);
  40: }
  41: 
  42: void FLWFinalizeColor(vec4 color) {
  43:     #if defined(USE_FOG)
  44:     float a = color.a;
  45:     float fog = clamp(FLWFogFactor(), 0., 1.);
  46: 
  47:     color = mix(uFogColor, color, fog);
  48:     color.a = a;
  49:     #endif
  50: 
  51:     gl_FragColor = color;
  52: }
  53: 
  54: vec4 FLWLight(vec2 lightCoords) {
  55:     lightCoords = max(lightCoords, texture3D(uLightVolume, BoxCoord).rg);
  56: 
  57:     return texture2D(uLightMap, shiftLight(lightCoords));
  58: }
  59: 
  60: 
  61: 
  62: struct BlockFrag {
  63:     vec2 texCoords;
  64:     vec4 color;
  65:     float diffuse;
  66:     vec2 light;
  67: };
  68: 
  69: void FLWMain(BlockFrag r) {
  70:     vec4 tex = FLWBlockTexture(r.texCoords);
  71: 
  72:     vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;
  73: 
  74: //    flw_WorldPos = ;
  75: //    flw_Normal = ;
  76: //    flw_Albedo = tex.rgb;
  77: //    flw_Alpha = tex.a;
  78: //    flw_LightMap = r.light;
  79: //    flw_Tint = r.color;
  80:     FLWFinalizeColor(color);
  81: }
  82: 
  83: varying vec2 v2f_texCoords;
  84: varying vec4 v2f_color;
  85: varying float v2f_diffuse;
  86: varying vec2 v2f_light;
  87: 
  88: 
  89: //vec3 flw_WorldPos;
  90: //vec3 flw_Normal;
  91: //vec3 flw_Albedo;
  92: //float flw_Alpha;
  93: //vec2 flw_LightMap;
  94: //vec4 flw_Tint;
  95: 
  96: void main() {
  97:     BlockFrag f;
  98:     f.texCoords = v2f_texCoords;
  99: f.color = v2f_color;
 100: f.diffuse = v2f_diffuse;
 101: f.light = v2f_light;
 102: 
 103: 
 104:     FLWMain(f);
 105: }

[12:29:41] [main/ERROR]: Shader compilation log for create:rotating.vert: No errors.

[12:29:41] [main/ERROR]: Source for shader 'create:rotating.vert':
   1: #version 110
   2: 
   3: #define PI 3.1415926538
   4: 
   5: #if defined(USE_FOG)
   6: varying float FragDistance;
   7: #endif
   8: 
   9: varying vec3 BoxCoord;
  10: 
  11: uniform vec3 uLightBoxSize;
  12: uniform vec3 uLightBoxMin;
  13: uniform mat4 uModel;
  14: 
  15: uniform float uTime;
  16: uniform mat4 uViewProjection;
  17: uniform vec3 uCameraPos;
  18: 
  19: void FLWFinalizeWorldPos(inout vec4 worldPos) {
  20:     worldPos = uModel * worldPos;
  21: 
  22:     BoxCoord = (worldPos.xyz - uLightBoxMin) / uLightBoxSize;
  23: 
  24:     #if defined(USE_FOG)
  25:     FragDistance = length(worldPos.xyz);
  26:     #endif
  27: 
  28:     gl_Position = uViewProjection * worldPos;
  29: }
  30: 
  31: void FLWFinalizeNormal(inout vec3 normal) {
  32:     mat3 m;
  33:     m[0] = uModel[0].xyz;
  34:     m[1] = uModel[1].xyz;
  35:     m[2] = uModel[2].xyz;
  36:     normal = m * normal;
  37: }
  38: 
  39: 
  40: 
  41: mat4 rotate(vec3 axis, float angle) {
  42:     float s = sin(angle);
  43:     float c = cos(angle);
  44:     float oc = 1. - c;
  45: 
  46:     vec3 sa = axis * s;
  47: 
  48:     mat4 mr = mat4(1.);
  49:     mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
  50:     mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
  51:     mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);
  52: 
  53:     return mr;
  54: }
  55: 
  56: mat4 rotation(vec3 rot) {
  57:     return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
  58: }
  59: 
  60: mat3 modelToNormal(mat4 mat) {
  61:     // Discard the edges. This won't be accurate for scaled or skewed matrices,
  62:     // but we don't have to work with those often.
  63:     mat3 m;
  64:     m[0] = mat[0].xyz;
  65:     m[1] = mat[1].xyz;
  66:     m[2] = mat[2].xyz;
  67:     return m;
  68: }
  69: 
  70: float diffuse(vec3 normal) {
  71:     vec3 n2 = normal * normal * vec3(.6, .25, .8);
  72:     return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
  73: }
  74: 
  75: 
  76: struct Rotating {
  77:     vec2 light;
  78:     vec4 color;
  79:     vec3 pos;
  80:     float speed;
  81:     float offset;
  82:     vec3 axis;
  83: };
  84: 
  85: 
  86: struct Vertex {
  87:     vec3 pos;
  88:     vec3 normal;
  89:     vec2 texCoords;
  90: };
  91: 
  92: struct BlockFrag {
  93:     vec2 texCoords;
  94:     vec4 color;
  95:     float diffuse;
  96:     vec2 light;
  97: };
  98: 
  99: mat4 kineticRotation(float offset, float speed, vec3 axis) {
 100:     float degrees = offset + uTime * speed * 3./10.;
 101:     float angle = fract(degrees / 360.) * PI * 2.;
 102: 
 103:     return rotate(axis, angle);
 104: }
 105: 
 106: BlockFrag FLWMain(Vertex v, Rotating instance) {
 107:     mat4 spin = kineticRotation(instance.offset, instance.speed, instance.axis);
 108: 
 109:     vec4 worldPos = spin * vec4(v.pos - .5, 1.);
 110:     worldPos += vec4(instance.pos + .5, 0.);
 111: 
 112:     vec3 norm = modelToNormal(spin) * v.normal;
 113: 
 114:     FLWFinalizeWorldPos(worldPos);
 115:     FLWFinalizeNormal(norm);
 116: 
 117:     BlockFrag b;
 118:     b.diffuse = diffuse(norm);
 119:     b.texCoords = v.texCoords;
 120:     b.light = instance.light;
 121: 
 122:     #if defined(DEBUG_RAINBOW)
 123:     b.color = instance.color;
 124:     #elif defined(DEBUG_NORMAL)
 125:     b.color = vec4(norm, 1.);
 126:     #else
 127:     b.color = vec4(1.);
 128:     #endif
 129: 
 130:     return b;
 131: }
 132: attribute vec3 a_v_pos;
 133: attribute vec3 a_v_normal;
 134: attribute vec2 a_v_texCoords;
 135: 
 136: attribute vec2 a_i_light;
 137: attribute vec4 a_i_color;
 138: attribute vec3 a_i_pos;
 139: attribute float a_i_speed;
 140: attribute float a_i_offset;
 141: attribute vec3 a_i_axis;
 142: 
 143: 
 144: varying vec2 v2f_texCoords;
 145: varying vec4 v2f_color;
 146: varying float v2f_diffuse;
 147: varying vec2 v2f_light;
 148: 
 149: 
 150: void main() {
 151:     Vertex v;
 152:     v.pos = a_v_pos;
 153: v.normal = a_v_normal;
 154: v.texCoords = a_v_texCoords;
 155: 
 156: 
 157:     Rotating i;
 158:     i.light = a_i_light;
 159: i.color = a_i_color;
 160: i.pos = a_i_pos;
 161: i.speed = a_i_speed;
 162: i.offset = a_i_offset;
 163: i.axis = a_i_axis;
 164: 
 165: 
 166:     BlockFrag o = FLWMain(v, i);
 167: 
 168:     v2f_texCoords = o.texCoords;
 169: v2f_color = o.color;
 170: v2f_diffuse = o.diffuse;
 171: v2f_light = o.light;
 172: 
 173: }

[12:29:41] [main/ERROR]: Shader compilation log for flywheel:block.frag: No errors.

[12:29:41] [main/ERROR]: Source for shader 'flywheel:block.frag':
   1: #version 110
   2: 
   3: #if defined(USE_FOG)
   4: varying float FragDistance;
   5: uniform vec4 uFogColor;
   6: #endif
   7: 
   8: #if defined(USE_FOG_LINEAR)
   9: uniform vec2 uFogRange;
  10: 
  11: float FLWFogFactor() {
  12:     return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
  13: }
  14:     #endif
  15: 
  16:     #if defined(USE_FOG_EXP2)
  17: uniform float uFogDensity;
  18: 
  19: float FLWFogFactor() {
  20:     float dist = FragDistance * uFogDensity;
  21:     return 1. / exp2(dist * dist);
  22: }
  23:     #endif
  24: // Adjust the [0,1] normalized lightmap value based on the texture matrix from LightTexture#enableLightmap
  25: vec2 shiftLight(vec2 lm) {
  26:     return lm * 0.99609375 + 0.03125;// * 255/256 + 1/32
  27: }
  28: 
  29: varying vec3 BoxCoord;
  30: varying vec2 BoxLight;
  31: uniform sampler3D uLightVolume;
  32: 
  33: uniform sampler2D uBlockAtlas;
  34: uniform sampler2D uLightMap;
  35: 
  36: vec4 FLWBlockTexture(vec2 texCoords) {
  37:     return texture2D(uBlockAtlas, texCoords);
  38: }
  39: 
  40: void FLWFinalizeColor(vec4 color) {
  41:     #if defined(USE_FOG)
  42:     float a = color.a;
  43:     float fog = clamp(FLWFogFactor(), 0., 1.);
  44: 
  45:     color = mix(uFogColor, color, fog);
  46:     color.a = a;
  47:     #endif
  48: 
  49:     gl_FragColor = color;
  50: }
  51: 
  52: vec4 FLWLight(vec2 lightCoords) {
  53:     lightCoords = max(lightCoords, texture3D(uLightVolume, BoxCoord).rg);
  54: 
  55:     return texture2D(uLightMap, shiftLight(lightCoords));
  56: }
  57: 
  58: 
  59: 
  60: struct BlockFrag {
  61:     vec2 texCoords;
  62:     vec4 color;
  63:     float diffuse;
  64:     vec2 light;
  65: };
  66: 
  67: void FLWMain(BlockFrag r) {
  68:     vec4 tex = FLWBlockTexture(r.texCoords);
  69: 
  70:     vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;
  71: 
  72: //    flw_WorldPos = ;
  73: //    flw_Normal = ;
  74: //    flw_Albedo = tex.rgb;
  75: //    flw_Alpha = tex.a;
  76: //    flw_LightMap = r.light;
  77: //    flw_Tint = r.color;
  78:     FLWFinalizeColor(color);
  79: }
  80: 
  81: varying vec2 v2f_texCoords;
  82: varying vec4 v2f_color;
  83: varying float v2f_diffuse;
  84: varying vec2 v2f_light;
  85: 
  86: 
  87: //vec3 flw_WorldPos;
  88: //vec3 flw_Normal;
  89: //vec3 flw_Albedo;
  90: //float flw_Alpha;
  91: //vec2 flw_LightMap;
  92: //vec4 flw_Tint;
  93: 
  94: void main() {
  95:     BlockFrag f;
  96:     f.texCoords = v2f_texCoords;
  97: f.color = v2f_color;
  98: f.diffuse = v2f_diffuse;
  99: f.light = v2f_light;
 100: 
 101: 
 102:     FLWMain(f);
 103: }

[12:29:41] [main/ERROR]: Shader compilation log for create:contraption_actor.vert: No errors.

[12:29:41] [main/ERROR]: Source for shader 'create:contraption_actor.vert':
   1: #version 110
   2: #define DEBUG_NORMAL
   3: 
   4: #define PI 3.1415926538
   5: 
   6: #if defined(USE_FOG)
   7: varying float FragDistance;
   8: #endif
   9: 
  10: varying vec3 BoxCoord;
  11: 
  12: uniform vec3 uLightBoxSize;
  13: uniform vec3 uLightBoxMin;
  14: uniform mat4 uModel;
  15: 
  16: uniform float uTime;
  17: uniform mat4 uViewProjection;
  18: uniform vec3 uCameraPos;
  19: 
  20: void FLWFinalizeWorldPos(inout vec4 worldPos) {
  21:     worldPos = uModel * worldPos;
  22: 
  23:     BoxCoord = (worldPos.xyz - uLightBoxMin) / uLightBoxSize;
  24: 
  25:     #if defined(USE_FOG)
  26:     FragDistance = length(worldPos.xyz);
  27:     #endif
  28: 
  29:     gl_Position = uViewProjection * worldPos;
  30: }
  31: 
  32: void FLWFinalizeNormal(inout vec3 normal) {
  33:     mat3 m;
  34:     m[0] = uModel[0].xyz;
  35:     m[1] = uModel[1].xyz;
  36:     m[2] = uModel[2].xyz;
  37:     normal = m * normal;
  38: }
  39: 
  40: 
  41: 
  42: mat4 rotate(vec3 axis, float angle) {
  43:     float s = sin(angle);
  44:     float c = cos(angle);
  45:     float oc = 1. - c;
  46: 
  47:     vec3 sa = axis * s;
  48: 
  49:     mat4 mr = mat4(1.);
  50:     mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
  51:     mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
  52:     mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);
  53: 
  54:     return mr;
  55: }
  56: 
  57: mat4 rotation(vec3 rot) {
  58:     return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
  59: }
  60: 
  61: mat3 modelToNormal(mat4 mat) {
  62:     // Discard the edges. This won't be accurate for scaled or skewed matrices,
  63:     // but we don't have to work with those often.
  64:     mat3 m;
  65:     m[0] = mat[0].xyz;
  66:     m[1] = mat[1].xyz;
  67:     m[2] = mat[2].xyz;
  68:     return m;
  69: }
  70: 
  71: #define PIOVER2 1.5707963268
  72: 
  73: vec4 quat(vec3 axis, float angle) {
  74:     float halfAngle = angle * PIOVER2 / 180.0;
  75:     vec2 cs = sin(vec2(PIOVER2 - halfAngle, halfAngle)); // compute sin and cos in one instruction
  76:     return vec4(axis.xyz * cs.y,  cs.x);
  77: }
  78: 
  79: vec4 quatMult(vec4 q1, vec4 q2) {
  80:     // disgustingly vectorized quaternion multiplication
  81:     vec4 a = q1.w * q2.xyzw;
  82:     vec4 b = q1.x * q2.wzxy * vec4(1., -1., 1., -1.);
  83:     vec4 c = q1.y * q2.zwxy * vec4(1., 1., -1., -1.);
  84:     vec4 d = q1.z * q2.yxwz * vec4(-1., 1., 1., -1.);
  85: 
  86:     return a + b + c + d;
  87: }
  88: 
  89: vec3 rotateVertexByQuat(vec3 v, vec4 q) {
  90:     vec3 i = q.xyz;
  91:     return v + 2.0 * cross(i, cross(i, v) + q.w * v);
  92: }
  93: 
  94: vec3 rotateAbout(vec3 v, vec3 axis, float angle) {
  95:     return rotateVertexByQuat(v, quat(axis, angle));
  96: }
  97: 
  98: float diffuse(vec3 normal) {
  99:     vec3 n2 = normal * normal * vec3(.6, .25, .8);
 100:     return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
 101: }
 102: 
 103: 
 104: struct Actor {
 105:     vec3 pos;
 106:     vec2 light;
 107:     float offset;
 108:     vec3 axis;
 109:     vec4 rotation;
 110:     vec3 rotationCenter;
 111:     float speed;
 112: };
 113: 
 114: 
 115: struct Vertex {
 116:     vec3 pos;
 117:     vec3 normal;
 118:     vec2 texCoords;
 119: };
 120: 
 121: struct BlockFrag {
 122:     vec2 texCoords;
 123:     vec4 color;
 124:     float diffuse;
 125:     vec2 light;
 126: };
 127: 
 128: BlockFrag FLWMain(Vertex v, Actor instance) {
 129:     float degrees = instance.offset + uTime * instance.speed / 20.;
 130:     //float angle = fract(degrees / 360.) * PI * 2.;
 131: 
 132:     vec4 kineticRot = quat(instance.axis, degrees);
 133:     vec3 rotated = rotateVertexByQuat(v.pos - instance.rotationCenter, kineticRot) + instance.rotationCenter;
 134: 
 135:     vec4 worldPos = vec4(rotateVertexByQuat(rotated - .5, instance.rotation) + instance.pos + .5, 1.);
 136:     vec3 norm = rotateVertexByQuat(rotateVertexByQuat(v.normal, kineticRot), instance.rotation);
 137: 
 138:     FLWFinalizeWorldPos(worldPos);
 139:     FLWFinalizeNormal(norm);
 140: 
 141:     BlockFrag b;
 142:     b.diffuse = diffuse(norm);
 143:     b.texCoords = v.texCoords;
 144:     b.light = instance.light;
 145: 
 146:     #if defined(DEBUG_NORMAL)
 147:     b.color = vec4(norm, 1.);
 148:     #else
 149:     b.color = vec4(1.);
 150:     #endif
 151: 
 152:     return b;
 153: }
 154: attribute vec3 a_v_pos;
 155: attribute vec3 a_v_normal;
 156: attribute vec2 a_v_texCoords;
 157: 
 158: attribute vec3 a_i_pos;
 159: attribute vec2 a_i_light;
 160: attribute float a_i_offset;
 161: attribute vec3 a_i_axis;
 162: attribute vec4 a_i_rotation;
 163: attribute vec3 a_i_rotationCenter;
 164: attribute float a_i_speed;
 165: 
 166: 
 167: varying vec2 v2f_texCoords;
 168: varying vec4 v2f_color;
 169: varying float v2f_diffuse;
 170: varying vec2 v2f_light;
 171: 
 172: 
 173: void main() {
 174:     Vertex v;
 175:     v.pos = a_v_pos;
 176: v.normal = a_v_normal;
 177: v.texCoords = a_v_texCoords;
 178: 
 179: 
 180:     Actor i;
 181:     i.pos = a_i_pos;
 182: i.light = a_i_light;
 183: i.offset = a_i_offset;
 184: i.axis = a_i_axis;
 185: i.rotation = a_i_rotation;
 186: i.rotationCenter = a_i_rotationCenter;
 187: i.speed = a_i_speed;
 188: 
 189: 
 190:     BlockFrag o = FLWMain(v, i);
 191: 
 192:     v2f_texCoords = o.texCoords;
 193: v2f_color = o.color;
 194: v2f_diffuse = o.diffuse;
 195: v2f_light = o.light;
 196: 
 197: }

[12:29:41] [main/ERROR]: Shader compilation log for flywheel:block.frag: No errors.

[12:29:41] [main/ERROR]: Source for shader 'flywheel:block.frag':
   1: #version 110
   2: #define DEBUG_NORMAL
   3: 
   4: #if defined(USE_FOG)
   5: varying float FragDistance;
   6: uniform vec4 uFogColor;
   7: #endif
   8: 
   9: #if defined(USE_FOG_LINEAR)
  10: uniform vec2 uFogRange;
  11: 
  12: float FLWFogFactor() {
  13:     return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
  14: }
  15:     #endif
  16: 
  17:     #if defined(USE_FOG_EXP2)
  18: uniform float uFogDensity;
  19: 
  20: float FLWFogFactor() {
  21:     float dist = FragDistance * uFogDensity;
  22:     return 1. / exp2(dist * dist);
  23: }
  24:     #endif
  25: // Adjust the [0,1] normalized lightmap value based on the texture matrix from LightTexture#enableLightmap
  26: vec2 shiftLight(vec2 lm) {
  27:     return lm * 0.99609375 + 0.03125;// * 255/256 + 1/32
  28: }
  29: 
  30: varying vec3 BoxCoord;
  31: varying vec2 BoxLight;
  32: uniform sampler3D uLightVolume;
  33: 
  34: uniform sampler2D uBlockAtlas;
  35: uniform sampler2D uLightMap;
  36: 
  37: vec4 FLWBlockTexture(vec2 texCoords) {
  38:     return texture2D(uBlockAtlas, texCoords);
  39: }
  40: 
  41: void FLWFinalizeColor(vec4 color) {
  42:     #if defined(USE_FOG)
  43:     float a = color.a;
  44:     float fog = clamp(FLWFogFactor(), 0., 1.);
  45: 
  46:     color = mix(uFogColor, color, fog);
  47:     color.a = a;
  48:     #endif
  49: 
  50:     gl_FragColor = color;
  51: }
  52: 
  53: vec4 FLWLight(vec2 lightCoords) {
  54:     lightCoords = max(lightCoords, texture3D(uLightVolume, BoxCoord).rg);
  55: 
  56:     return texture2D(uLightMap, shiftLight(lightCoords));
  57: }
  58: 
  59: 
  60: 
  61: struct BlockFrag {
  62:     vec2 texCoords;
  63:     vec4 color;
  64:     float diffuse;
  65:     vec2 light;
  66: };
  67: 
  68: void FLWMain(BlockFrag r) {
  69:     vec4 tex = FLWBlockTexture(r.texCoords);
  70: 
  71:     vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;
  72: 
  73: //    flw_WorldPos = ;
  74: //    flw_Normal = ;
  75: //    flw_Albedo = tex.rgb;
  76: //    flw_Alpha = tex.a;
  77: //    flw_LightMap = r.light;
  78: //    flw_Tint = r.color;
  79:     FLWFinalizeColor(color);
  80: }
  81: 
  82: varying vec2 v2f_texCoords;
  83: varying vec4 v2f_color;
  84: varying float v2f_diffuse;
  85: varying vec2 v2f_light;
  86: 
  87: 
  88: //vec3 flw_WorldPos;
  89: //vec3 flw_Normal;
  90: //vec3 flw_Albedo;
  91: //float flw_Alpha;
  92: //vec2 flw_LightMap;
  93: //vec4 flw_Tint;
  94: 
  95: void main() {
  96:     BlockFrag f;
  97:     f.texCoords = v2f_texCoords;
  98: f.color = v2f_color;
  99: f.diffuse = v2f_diffuse;
 100: f.light = v2f_light;
 101: 
 102: 
 103:     FLWMain(f);
 104: }

[12:29:41] [main/ERROR]: Shader compilation log for create:contraption_actor.vert: No errors.

[12:29:41] [main/ERROR]: Source for shader 'create:contraption_actor.vert':
   1: #version 110
   2: #define USE_FOG
   3: #define USE_FOG_LINEAR
   4: 
   5: #define PI 3.1415926538
   6: 
   7: #if defined(USE_FOG)
   8: varying float FragDistance;
   9: #endif
  10: 
  11: varying vec3 BoxCoord;
  12: 
  13: uniform vec3 uLightBoxSize;
  14: uniform vec3 uLightBoxMin;
  15: uniform mat4 uModel;
  16: 
  17: uniform float uTime;
  18: uniform mat4 uViewProjection;
  19: uniform vec3 uCameraPos;
  20: 
  21: void FLWFinalizeWorldPos(inout vec4 worldPos) {
  22:     worldPos = uModel * worldPos;
  23: 
  24:     BoxCoord = (worldPos.xyz - uLightBoxMin) / uLightBoxSize;
  25: 
  26:     #if defined(USE_FOG)
  27:     FragDistance = length(worldPos.xyz);
  28:     #endif
  29: 
  30:     gl_Position = uViewProjection * worldPos;
  31: }
  32: 
  33: void FLWFinalizeNormal(inout vec3 normal) {
  34:     mat3 m;
  35:     m[0] = uModel[0].xyz;
  36:     m[1] = uModel[1].xyz;
  37:     m[2] = uModel[2].xyz;
  38:     normal = m * normal;
  39: }
  40: 
  41: 
  42: 
  43: mat4 rotate(vec3 axis, float angle) {
  44:     float s = sin(angle);
  45:     float c = cos(angle);
  46:     float oc = 1. - c;
  47: 
  48:     vec3 sa = axis * s;
  49: 
  50:     mat4 mr = mat4(1.);
  51:     mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
  52:     mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
  53:     mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);
  54: 
  55:     return mr;
  56: }
  57: 
  58: mat4 rotation(vec3 rot) {
  59:     return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
  60: }
  61: 
  62: mat3 modelToNormal(mat4 mat) {
  63:     // Discard the edges. This won't be accurate for scaled or skewed matrices,
  64:     // but we don't have to work with those often.
  65:     mat3 m;
  66:     m[0] = mat[0].xyz;
  67:     m[1] = mat[1].xyz;
  68:     m[2] = mat[2].xyz;
  69:     return m;
  70: }
  71: 
  72: #define PIOVER2 1.5707963268
  73: 
  74: vec4 quat(vec3 axis, float angle) {
  75:     float halfAngle = angle * PIOVER2 / 180.0;
  76:     vec2 cs = sin(vec2(PIOVER2 - halfAngle, halfAngle)); // compute sin and cos in one instruction
  77:     return vec4(axis.xyz * cs.y,  cs.x);
  78: }
  79: 
  80: vec4 quatMult(vec4 q1, vec4 q2) {
  81:     // disgustingly vectorized quaternion multiplication
  82:     vec4 a = q1.w * q2.xyzw;
  83:     vec4 b = q1.x * q2.wzxy * vec4(1., -1., 1., -1.);
  84:     vec4 c = q1.y * q2.zwxy * vec4(1., 1., -1., -1.);
  85:     vec4 d = q1.z * q2.yxwz * vec4(-1., 1., 1., -1.);
  86: 
  87:     return a + b + c + d;
  88: }
  89: 
  90: vec3 rotateVertexByQuat(vec3 v, vec4 q) {
  91:     vec3 i = q.xyz;
  92:     return v + 2.0 * cross(i, cross(i, v) + q.w * v);
  93: }
  94: 
  95: vec3 rotateAbout(vec3 v, vec3 axis, float angle) {
  96:     return rotateVertexByQuat(v, quat(axis, angle));
  97: }
  98: 
  99: float diffuse(vec3 normal) {
 100:     vec3 n2 = normal * normal * vec3(.6, .25, .8);
 101:     return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
 102: }
 103: 
 104: 
 105: struct Actor {
 106:     vec3 pos;
 107:     vec2 light;
 108:     float offset;
 109:     vec3 axis;
 110:     vec4 rotation;
 111:     vec3 rotationCenter;
 112:     float speed;
 113: };
 114: 
 115: 
 116: struct Vertex {
 117:     vec3 pos;
 118:     vec3 normal;
 119:     vec2 texCoords;
 120: };
 121: 
 122: struct BlockFrag {
 123:     vec2 texCoords;
 124:     vec4 color;
 125:     float diffuse;
 126:     vec2 light;
 127: };
 128: 
 129: BlockFrag FLWMain(Vertex v, Actor instance) {
 130:     float degrees = instance.offset + uTime * instance.speed / 20.;
 131:     //float angle = fract(degrees / 360.) * PI * 2.;
 132: 
 133:     vec4 kineticRot = quat(instance.axis, degrees);
 134:     vec3 rotated = rotateVertexByQuat(v.pos - instance.rotationCenter, kineticRot) + instance.rotationCenter;
 135: 
 136:     vec4 worldPos = vec4(rotateVertexByQuat(rotated - .5, instance.rotation) + instance.pos + .5, 1.);
 137:     vec3 norm = rotateVertexByQuat(rotateVertexByQuat(v.normal, kineticRot), instance.rotation);
 138: 
 139:     FLWFinalizeWorldPos(worldPos);
 140:     FLWFinalizeNormal(norm);
 141: 
 142:     BlockFrag b;
 143:     b.diffuse = diffuse(norm);
 144:     b.texCoords = v.texCoords;
 145:     b.light = instance.light;
 146: 
 147:     #if defined(DEBUG_NORMAL)
 148:     b.color = vec4(norm, 1.);
 149:     #else
 150:     b.color = vec4(1.);
 151:     #endif
 152: 
 153:     return b;
 154: }
 155: attribute vec3 a_v_pos;
 156: attribute vec3 a_v_normal;
 157: attribute vec2 a_v_texCoords;
 158: 
 159: attribute vec3 a_i_pos;
 160: attribute vec2 a_i_light;
 161: attribute float a_i_offset;
 162: attribute vec3 a_i_axis;
 163: attribute vec4 a_i_rotation;
 164: attribute vec3 a_i_rotationCenter;
 165: attribute float a_i_speed;
 166: 
 167: 
 168: varying vec2 v2f_texCoords;
 169: varying vec4 v2f_color;
 170: varying float v2f_diffuse;
 171: varying vec2 v2f_light;
 172: 
 173: 
 174: void main() {
 175:     Vertex v;
 176:     v.pos = a_v_pos;
 177: v.normal = a_v_normal;
 178: v.texCoords = a_v_texCoords;
 179: 
 180: 
 181:     Actor i;
 182:     i.pos = a_i_pos;
 183: i.light = a_i_light;
 184: i.offset = a_i_offset;
 185: i.axis = a_i_axis;
 186: i.rotation = a_i_rotation;
 187: i.rotationCenter = a_i_rotationCenter;
 188: i.speed = a_i_speed;
 189: 
 190: 
 191:     BlockFrag o = FLWMain(v, i);
 192: 
 193:     v2f_texCoords = o.texCoords;
 194: v2f_color = o.color;
 195: v2f_diffuse = o.diffuse;
 196: v2f_light = o.light;
 197: 
 198: }

[12:29:41] [main/ERROR]: Shader compilation log for flywheel:block.frag: No errors.

[12:29:41] [main/ERROR]: Source for shader 'flywheel:block.frag':
   1: #version 110
   2: #define USE_FOG
   3: #define USE_FOG_LINEAR
   4: 
   5: #if defined(USE_FOG)
   6: varying float FragDistance;
   7: uniform vec4 uFogColor;
   8: #endif
   9: 
  10: #if defined(USE_FOG_LINEAR)
  11: uniform vec2 uFogRange;
  12: 
  13: float FLWFogFactor() {
  14:     return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
  15: }
  16:     #endif
  17: 
  18:     #if defined(USE_FOG_EXP2)
  19: uniform float uFogDensity;
  20: 
  21: float FLWFogFactor() {
  22:     float dist = FragDistance * uFogDensity;
  23:     return 1. / exp2(dist * dist);
  24: }
  25:     #endif
  26: // Adjust the [0,1] normalized lightmap value based on the texture matrix from LightTexture#enableLightmap
  27: vec2 shiftLight(vec2 lm) {
  28:     return lm * 0.99609375 + 0.03125;// * 255/256 + 1/32
  29: }
  30: 
  31: varying vec3 BoxCoord;
  32: varying vec2 BoxLight;
  33: uniform sampler3D uLightVolume;
  34: 
  35: uniform sampler2D uBlockAtlas;
  36: uniform sampler2D uLightMap;
  37: 
  38: vec4 FLWBlockTexture(vec2 texCoords) {
  39:     return texture2D(uBlockAtlas, texCoords);
  40: }
  41: 
  42: void FLWFinalizeColor(vec4 color) {
  43:     #if defined(USE_FOG)
  44:     float a = color.a;
  45:     float fog = clamp(FLWFogFactor(), 0., 1.);
  46: 
  47:     color = mix(uFogColor, color, fog);
  48:     color.a = a;
  49:     #endif
  50: 
  51:     gl_FragColor = color;
  52: }
  53: 
  54: vec4 FLWLight(vec2 lightCoords) {
  55:     lightCoords = max(lightCoords, texture3D(uLightVolume, BoxCoord).rg);
  56: 
  57:     return texture2D(uLightMap, shiftLight(lightCoords));
  58: }
  59: 
  60: 
  61: 
  62: struct BlockFrag {
  63:     vec2 texCoords;
  64:     vec4 color;
  65:     float diffuse;
  66:     vec2 light;
  67: };
  68: 
  69: void FLWMain(BlockFrag r) {
  70:     vec4 tex = FLWBlockTexture(r.texCoords);
  71: 
  72:     vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;
  73: 
  74: //    flw_WorldPos = ;
  75: //    flw_Normal = ;
  76: //    flw_Albedo = tex.rgb;
  77: //    flw_Alpha = tex.a;
  78: //    flw_LightMap = r.light;
  79: //    flw_Tint = r.color;
  80:     FLWFinalizeColor(color);
  81: }
  82: 
  83: varying vec2 v2f_texCoords;
  84: varying vec4 v2f_color;
  85: varying float v2f_diffuse;
  86: varying vec2 v2f_light;
  87: 
  88: 
  89: //vec3 flw_WorldPos;
  90: //vec3 flw_Normal;
  91: //vec3 flw_Albedo;
  92: //float flw_Alpha;
  93: //vec2 flw_LightMap;
  94: //vec4 flw_Tint;
  95: 
  96: void main() {
  97:     BlockFrag f;
  98:     f.texCoords = v2f_texCoords;
  99: f.color = v2f_color;
 100: f.diffuse = v2f_diffuse;
 101: f.light = v2f_light;
 102: 
 103: 
 104:     FLWMain(f);
 105: }

[12:29:41] [main/ERROR]: Shader compilation log for create:contraption_actor.vert: No errors.

[12:29:41] [main/ERROR]: Source for shader 'create:contraption_actor.vert':
   1: #version 110
   2: #define USE_FOG
   3: #define USE_FOG_EXP2
   4: 
   5: #define PI 3.1415926538
   6: 
   7: #if defined(USE_FOG)
   8: varying float FragDistance;
   9: #endif
  10: 
  11: varying vec3 BoxCoord;
  12: 
  13: uniform vec3 uLightBoxSize;
  14: uniform vec3 uLightBoxMin;
  15: uniform mat4 uModel;
  16: 
  17: uniform float uTime;
  18: uniform mat4 uViewProjection;
  19: uniform vec3 uCameraPos;
  20: 
  21: void FLWFinalizeWorldPos(inout vec4 worldPos) {
  22:     worldPos = uModel * worldPos;
  23: 
  24:     BoxCoord = (worldPos.xyz - uLightBoxMin) / uLightBoxSize;
  25: 
  26:     #if defined(USE_FOG)
  27:     FragDistance = length(worldPos.xyz);
  28:     #endif
  29: 
  30:     gl_Position = uViewProjection * worldPos;
  31: }
  32: 
  33: void FLWFinalizeNormal(inout vec3 normal) {
  34:     mat3 m;
  35:     m[0] = uModel[0].xyz;
  36:     m[1] = uModel[1].xyz;
  37:     m[2] = uModel[2].xyz;
  38:     normal = m * normal;
  39: }
  40: 
  41: 
  42: 
  43: mat4 rotate(vec3 axis, float angle) {
  44:     float s = sin(angle);
  45:     float c = cos(angle);
  46:     float oc = 1. - c;
  47: 
  48:     vec3 sa = axis * s;
  49: 
  50:     mat4 mr = mat4(1.);
  51:     mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
  52:     mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
  53:     mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);
  54: 
  55:     return mr;
  56: }
  57: 
  58: mat4 rotation(vec3 rot) {
  59:     return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
  60: }
  61: 
  62: mat3 modelToNormal(mat4 mat) {
  63:     // Discard the edges. This won't be accurate for scaled or skewed matrices,
  64:     // but we don't have to work with those often.
  65:     mat3 m;
  66:     m[0] = mat[0].xyz;
  67:     m[1] = mat[1].xyz;
  68:     m[2] = mat[2].xyz;
  69:     return m;
  70: }
  71: 
  72: #define PIOVER2 1.5707963268
  73: 
  74: vec4 quat(vec3 axis, float angle) {
  75:     float halfAngle = angle * PIOVER2 / 180.0;
  76:     vec2 cs = sin(vec2(PIOVER2 - halfAngle, halfAngle)); // compute sin and cos in one instruction
  77:     return vec4(axis.xyz * cs.y,  cs.x);
  78: }
  79: 
  80: vec4 quatMult(vec4 q1, vec4 q2) {
  81:     // disgustingly vectorized quaternion multiplication
  82:     vec4 a = q1.w * q2.xyzw;
  83:     vec4 b = q1.x * q2.wzxy * vec4(1., -1., 1., -1.);
  84:     vec4 c = q1.y * q2.zwxy * vec4(1., 1., -1., -1.);
  85:     vec4 d = q1.z * q2.yxwz * vec4(-1., 1., 1., -1.);
  86: 
  87:     return a + b + c + d;
  88: }
  89: 
  90: vec3 rotateVertexByQuat(vec3 v, vec4 q) {
  91:     vec3 i = q.xyz;
  92:     return v + 2.0 * cross(i, cross(i, v) + q.w * v);
  93: }
  94: 
  95: vec3 rotateAbout(vec3 v, vec3 axis, float angle) {
  96:     return rotateVertexByQuat(v, quat(axis, angle));
  97: }
  98: 
  99: float diffuse(vec3 normal) {
 100:     vec3 n2 = normal * normal * vec3(.6, .25, .8);
 101:     return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
 102: }
 103: 
 104: 
 105: struct Actor {
 106:     vec3 pos;
 107:     vec2 light;
 108:     float offset;
 109:     vec3 axis;
 110:     vec4 rotation;
 111:     vec3 rotationCenter;
 112:     float speed;
 113: };
 114: 
 115: 
 116: struct Vertex {
 117:     vec3 pos;
 118:     vec3 normal;
 119:     vec2 texCoords;
 120: };
 121: 
 122: struct BlockFrag {
 123:     vec2 texCoords;
 124:     vec4 color;
 125:     float diffuse;
 126:     vec2 light;
 127: };
 128: 
 129: BlockFrag FLWMain(Vertex v, Actor instance) {
 130:     float degrees = instance.offset + uTime * instance.speed / 20.;
 131:     //float angle = fract(degrees / 360.) * PI * 2.;
 132: 
 133:     vec4 kineticRot = quat(instance.axis, degrees);
 134:     vec3 rotated = rotateVertexByQuat(v.pos - instance.rotationCenter, kineticRot) + instance.rotationCenter;
 135: 
 136:     vec4 worldPos = vec4(rotateVertexByQuat(rotated - .5, instance.rotation) + instance.pos + .5, 1.);
 137:     vec3 norm = rotateVertexByQuat(rotateVertexByQuat(v.normal, kineticRot), instance.rotation);
 138: 
 139:     FLWFinalizeWorldPos(worldPos);
 140:     FLWFinalizeNormal(norm);
 141: 
 142:     BlockFrag b;
 143:     b.diffuse = diffuse(norm);
 144:     b.texCoords = v.texCoords;
 145:     b.light = instance.light;
 146: 
 147:     #if defined(DEBUG_NORMAL)
 148:     b.color = vec4(norm, 1.);
 149:     #else
 150:     b.color = vec4(1.);
 151:     #endif
 152: 
 153:     return b;
 154: }
 155: attribute vec3 a_v_pos;
 156: attribute vec3 a_v_normal;
 157: attribute vec2 a_v_texCoords;
 158: 
 159: attribute vec3 a_i_pos;
 160: attribute vec2 a_i_light;
 161: attribute float a_i_offset;
 162: attribute vec3 a_i_axis;
 163: attribute vec4 a_i_rotation;
 164: attribute vec3 a_i_rotationCenter;
 165: attribute float a_i_speed;
 166: 
 167: 
 168: varying vec2 v2f_texCoords;
 169: varying vec4 v2f_color;
 170: varying float v2f_diffuse;
 171: varying vec2 v2f_light;
 172: 
 173: 
 174: void main() {
 175:     Vertex v;
 176:     v.pos = a_v_pos;
 177: v.normal = a_v_normal;
 178: v.texCoords = a_v_texCoords;
 179: 
 180: 
 181:     Actor i;
 182:     i.pos = a_i_pos;
 183: i.light = a_i_light;
 184: i.offset = a_i_offset;
 185: i.axis = a_i_axis;
 186: i.rotation = a_i_rotation;
 187: i.rotationCenter = a_i_rotationCenter;
 188: i.speed = a_i_speed;
 189: 
 190: 
 191:     BlockFrag o = FLWMain(v, i);
 192: 
 193:     v2f_texCoords = o.texCoords;
 194: v2f_color = o.color;
 195: v2f_diffuse = o.diffuse;
 196: v2f_light = o.light;
 197: 
 198: }

[12:29:41] [main/ERROR]: Shader compilation log for flywheel:block.frag: No errors.

[12:29:41] [main/ERROR]: Source for shader 'flywheel:block.frag':
   1: #version 110
   2: #define USE_FOG
   3: #define USE_FOG_EXP2
   4: 
   5: #if defined(USE_FOG)
   6: varying float FragDistance;
   7: uniform vec4 uFogColor;
   8: #endif
   9: 
  10: #if defined(USE_FOG_LINEAR)
  11: uniform vec2 uFogRange;
  12: 
  13: float FLWFogFactor() {
  14:     return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
  15: }
  16:     #endif
  17: 
  18:     #if defined(USE_FOG_EXP2)
  19: uniform float uFogDensity;
  20: 
  21: float FLWFogFactor() {
  22:     float dist = FragDistance * uFogDensity;
  23:     return 1. / exp2(dist * dist);
  24: }
  25:     #endif
  26: // Adjust the [0,1] normalized lightmap value based on the texture matrix from LightTexture#enableLightmap
  27: vec2 shiftLight(vec2 lm) {
  28:     return lm * 0.99609375 + 0.03125;// * 255/256 + 1/32
  29: }
  30: 
  31: varying vec3 BoxCoord;
  32: varying vec2 BoxLight;
  33: uniform sampler3D uLightVolume;
  34: 
  35: uniform sampler2D uBlockAtlas;
  36: uniform sampler2D uLightMap;
  37: 
  38: vec4 FLWBlockTexture(vec2 texCoords) {
  39:     return texture2D(uBlockAtlas, texCoords);
  40: }
  41: 
  42: void FLWFinalizeColor(vec4 color) {
  43:     #if defined(USE_FOG)
  44:     float a = color.a;
  45:     float fog = clamp(FLWFogFactor(), 0., 1.);
  46: 
  47:     color = mix(uFogColor, color, fog);
  48:     color.a = a;
  49:     #endif
  50: 
  51:     gl_FragColor = color;
  52: }
  53: 
  54: vec4 FLWLight(vec2 lightCoords) {
  55:     lightCoords = max(lightCoords, texture3D(uLightVolume, BoxCoord).rg);
  56: 
  57:     return texture2D(uLightMap, shiftLight(lightCoords));
  58: }
  59: 
  60: 
  61: 
  62: struct BlockFrag {
  63:     vec2 texCoords;
  64:     vec4 color;
  65:     float diffuse;
  66:     vec2 light;
  67: };
  68: 
  69: void FLWMain(BlockFrag r) {
  70:     vec4 tex = FLWBlockTexture(r.texCoords);
  71: 
  72:     vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;
  73: 
  74: //    flw_WorldPos = ;
  75: //    flw_Normal = ;
  76: //    flw_Albedo = tex.rgb;
  77: //    flw_Alpha = tex.a;
  78: //    flw_LightMap = r.light;
  79: //    flw_Tint = r.color;
  80:     FLWFinalizeColor(color);
  81: }
  82: 
  83: varying vec2 v2f_texCoords;
  84: varying vec4 v2f_color;
  85: varying float v2f_diffuse;
  86: varying vec2 v2f_light;
  87: 
  88: 
  89: //vec3 flw_WorldPos;
  90: //vec3 flw_Normal;
  91: //vec3 flw_Albedo;
  92: //float flw_Alpha;
  93: //vec2 flw_LightMap;
  94: //vec4 flw_Tint;
  95: 
  96: void main() {
  97:     BlockFrag f;
  98:     f.texCoords = v2f_texCoords;
  99: f.color = v2f_color;
 100: f.diffuse = v2f_diffuse;
 101: f.light = v2f_light;
 102: 
 103: 
 104:     FLWMain(f);
 105: }

[12:29:41] [Forge Version Check/INFO]: [runelic] Found status: BETA_OUTDATED Current: 7.0.2 Target: 7.0.3
[12:29:41] [Forge Version Check/INFO]: [cfm] Starting version check at https://mrcrayfish.com/modupdatejson?id=cfm
[12:29:41] [main/ERROR]: Shader compilation log for create:contraption_actor.vert: No errors.

[12:29:41] [main/ERROR]: Source for shader 'create:contraption_actor.vert':
   1: #version 110
   2: 
   3: #define PI 3.1415926538
   4: 
   5: #if defined(USE_FOG)
   6: varying float FragDistance;
   7: #endif
   8: 
   9: varying vec3 BoxCoord;
  10: 
  11: uniform vec3 uLightBoxSize;
  12: uniform vec3 uLightBoxMin;
  13: uniform mat4 uModel;
  14: 
  15: uniform float uTime;
  16: uniform mat4 uViewProjection;
  17: uniform vec3 uCameraPos;
  18: 
  19: void FLWFinalizeWorldPos(inout vec4 worldPos) {
  20:     worldPos = uModel * worldPos;
  21: 
  22:     BoxCoord = (worldPos.xyz - uLightBoxMin) / uLightBoxSize;
  23: 
  24:     #if defined(USE_FOG)
  25:     FragDistance = length(worldPos.xyz);
  26:     #endif
  27: 
  28:     gl_Position = uViewProjection * worldPos;
  29: }
  30: 
  31: void FLWFinalizeNormal(inout vec3 normal) {
  32:     mat3 m;
  33:     m[0] = uModel[0].xyz;
  34:     m[1] = uModel[1].xyz;
  35:     m[2] = uModel[2].xyz;
  36:     normal = m * normal;
  37: }
  38: 
  39: 
  40: 
  41: mat4 rotate(vec3 axis, float angle) {
  42:     float s = sin(angle);
  43:     float c = cos(angle);
  44:     float oc = 1. - c;
  45: 
  46:     vec3 sa = axis * s;
  47: 
  48:     mat4 mr = mat4(1.);
  49:     mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
  50:     mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
  51:     mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);
  52: 
  53:     return mr;
  54: }
  55: 
  56: mat4 rotation(vec3 rot) {
  57:     return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
  58: }
  59: 
  60: mat3 modelToNormal(mat4 mat) {
  61:     // Discard the edges. This won't be accurate for scaled or skewed matrices,
  62:     // but we don't have to work with those often.
  63:     mat3 m;
  64:     m[0] = mat[0].xyz;
  65:     m[1] = mat[1].xyz;
  66:     m[2] = mat[2].xyz;
  67:     return m;
  68: }
  69: 
  70: #define PIOVER2 1.5707963268
  71: 
  72: vec4 quat(vec3 axis, float angle) {
  73:     float halfAngle = angle * PIOVER2 / 180.0;
  74:     vec2 cs = sin(vec2(PIOVER2 - halfAngle, halfAngle)); // compute sin and cos in one instruction
  75:     return vec4(axis.xyz * cs.y,  cs.x);
  76: }
  77: 
  78: vec4 quatMult(vec4 q1, vec4 q2) {
  79:     // disgustingly vectorized quaternion multiplication
  80:     vec4 a = q1.w * q2.xyzw;
  81:     vec4 b = q1.x * q2.wzxy * vec4(1., -1., 1., -1.);
  82:     vec4 c = q1.y * q2.zwxy * vec4(1., 1., -1., -1.);
  83:     vec4 d = q1.z * q2.yxwz * vec4(-1., 1., 1., -1.);
  84: 
  85:     return a + b + c + d;
  86: }
  87: 
  88: vec3 rotateVertexByQuat(vec3 v, vec4 q) {
  89:     vec3 i = q.xyz;
  90:     return v + 2.0 * cross(i, cross(i, v) + q.w * v);
  91: }
  92: 
  93: vec3 rotateAbout(vec3 v, vec3 axis, float angle) {
  94:     return rotateVertexByQuat(v, quat(axis, angle));
  95: }
  96: 
  97: float diffuse(vec3 normal) {
  98:     vec3 n2 = normal * normal * vec3(.6, .25, .8);
  99:     return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
 100: }
 101: 
 102: 
 103: struct Actor {
 104:     vec3 pos;
 105:     vec2 light;
 106:     float offset;
 107:     vec3 axis;
 108:     vec4 rotation;
 109:     vec3 rotationCenter;
 110:     float speed;
 111: };
 112: 
 113: 
 114: struct Vertex {
 115:     vec3 pos;
 116:     vec3 normal;
 117:     vec2 texCoords;
 118: };
 119: 
 120: struct BlockFrag {
 121:     vec2 texCoords;
 122:     vec4 color;
 123:     float diffuse;
 124:     vec2 light;
 125: };
 126: 
 127: BlockFrag FLWMain(Vertex v, Actor instance) {
 128:     float degrees = instance.offset + uTime * instance.speed / 20.;
 129:     //float angle = fract(degrees / 360.) * PI * 2.;
 130: 
 131:     vec4 kineticRot = quat(instance.axis, degrees);
 132:     vec3 rotated = rotateVertexByQuat(v.pos - instance.rotationCenter, kineticRot) + instance.rotationCenter;
 133: 
 134:     vec4 worldPos = vec4(rotateVertexByQuat(rotated - .5, instance.rotation) + instance.pos + .5, 1.);
 135:     vec3 norm = rotateVertexByQuat(rotateVertexByQuat(v.normal, kineticRot), instance.rotation);
 136: 
 137:     FLWFinalizeWorldPos(worldPos);
 138:     FLWFinalizeNormal(norm);
 139: 
 140:     BlockFrag b;
 141:     b.diffuse = diffuse(norm);
 142:     b.texCoords = v.texCoords;
 143:     b.light = instance.light;
 144: 
 145:     #if defined(DEBUG_NORMAL)
 146:     b.color = vec4(norm, 1.);
 147:     #else
 148:     b.color = vec4(1.);
 149:     #endif
 150: 
 151:     return b;
 152: }
 153: attribute vec3 a_v_pos;
 154: attribute vec3 a_v_normal;
 155: attribute vec2 a_v_texCoords;
 156: 
 157: attribute vec3 a_i_pos;
 158: attribute vec2 a_i_light;
 159: attribute float a_i_offset;
 160: attribute vec3 a_i_axis;
 161: attribute vec4 a_i_rotation;
 162: attribute vec3 a_i_rotationCenter;
 163: attribute float a_i_speed;
 164: 
 165: 
 166: varying vec2 v2f_texCoords;
 167: varying vec4 v2f_color;
 168: varying float v2f_diffuse;
 169: varying vec2 v2f_light;
 170: 
 171: 
 172: void main() {
 173:     Vertex v;
 174:     v.pos = a_v_pos;
 175: v.normal = a_v_normal;
 176: v.texCoords = a_v_texCoords;
 177: 
 178: 
 179:     Actor i;
 180:     i.pos = a_i_pos;
 181: i.light = a_i_light;
 182: i.offset = a_i_offset;
 183: i.axis = a_i_axis;
 184: i.rotation = a_i_rotation;
 185: i.rotationCenter = a_i_rotationCenter;
 186: i.speed = a_i_speed;
 187: 
 188: 
 189:     BlockFrag o = FLWMain(v, i);
 190: 
 191:     v2f_texCoords = o.texCoords;
 192: v2f_color = o.color;
 193: v2f_diffuse = o.diffuse;
 194: v2f_light = o.light;
 195: 
 196: }

[12:29:41] [main/ERROR]: Shader compilation log for flywheel:block.frag: No errors.

[12:29:41] [main/ERROR]: Source for shader 'flywheel:block.frag':
   1: #version 110
   2: 
   3: #if defined(USE_FOG)
   4: varying float FragDistance;
   5: uniform vec4 uFogColor;
   6: #endif
   7: 
   8: #if defined(USE_FOG_LINEAR)
   9: uniform vec2 uFogRange;
  10: 
  11: float FLWFogFactor() {
  12:     return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
  13: }
  14:     #endif
  15: 
  16:     #if defined(USE_FOG_EXP2)
  17: uniform float uFogDensity;
  18: 
  19: float FLWFogFactor() {
  20:     float dist = FragDistance * uFogDensity;
  21:     return 1. / exp2(dist * dist);
  22: }
  23:     #endif
  24: // Adjust the [0,1] normalized lightmap value based on the texture matrix from LightTexture#enableLightmap
  25: vec2 shiftLight(vec2 lm) {
  26:     return lm * 0.99609375 + 0.03125;// * 255/256 + 1/32
  27: }
  28: 
  29: varying vec3 BoxCoord;
  30: varying vec2 BoxLight;
  31: uniform sampler3D uLightVolume;
  32: 
  33: uniform sampler2D uBlockAtlas;
  34: uniform sampler2D uLightMap;
  35: 
  36: vec4 FLWBlockTexture(vec2 texCoords) {
  37:     return texture2D(uBlockAtlas, texCoords);
  38: }
  39: 
  40: void FLWFinalizeColor(vec4 color) {
  41:     #if defined(USE_FOG)
  42:     float a = color.a;
  43:     float fog = clamp(FLWFogFactor(), 0., 1.);
  44: 
  45:     color = mix(uFogColor, color, fog);
  46:     color.a = a;
  47:     #endif
  48: 
  49:     gl_FragColor = color;
  50: }
  51: 
  52: vec4 FLWLight(vec2 lightCoords) {
  53:     lightCoords = max(lightCoords, texture3D(uLightVolume, BoxCoord).rg);
  54: 
  55:     return texture2D(uLightMap, shiftLight(lightCoords));
  56: }
  57: 
  58: 
  59: 
  60: struct BlockFrag {
  61:     vec2 texCoords;
  62:     vec4 color;
  63:     float diffuse;
  64:     vec2 light;
  65: };
  66: 
  67: void FLWMain(BlockFrag r) {
  68:     vec4 tex = FLWBlockTexture(r.texCoords);
  69: 
  70:     vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;
  71: 
  72: //    flw_WorldPos = ;
  73: //    flw_Normal = ;
  74: //    flw_Albedo = tex.rgb;
  75: //    flw_Alpha = tex.a;
  76: //    flw_LightMap = r.light;
  77: //    flw_Tint = r.color;
  78:     FLWFinalizeColor(color);
  79: }
  80: 
  81: varying vec2 v2f_texCoords;
  82: varying vec4 v2f_color;
  83: varying float v2f_diffuse;
  84: varying vec2 v2f_light;
  85: 
  86: 
  87: //vec3 flw_WorldPos;
  88: //vec3 flw_Normal;
  89: //vec3 flw_Albedo;
  90: //float flw_Alpha;
  91: //vec2 flw_LightMap;
  92: //vec4 flw_Tint;
  93: 
  94: void main() {
  95:     BlockFrag f;
  96:     f.texCoords = v2f_texCoords;
  97: f.color = v2f_color;
  98: f.diffuse = v2f_diffuse;
  99: f.light = v2f_light;
 100: 
 101: 
 102:     FLWMain(f);
 103: }

[12:29:41] [main/ERROR]: Shader compilation log for create:flap.vert: No errors.

[12:29:41] [main/ERROR]: Source for shader 'create:flap.vert':
   1: #version 110
   2: #define DEBUG_NORMAL
   3: 
   4: #define PI 3.1415926538
   5: 
   6: #if defined(USE_FOG)
   7: varying float FragDistance;
   8: #endif
   9: 
  10: varying vec3 BoxCoord;
  11: 
  12: uniform vec3 uLightBoxSize;
  13: uniform vec3 uLightBoxMin;
  14: uniform mat4 uModel;
  15: 
  16: uniform float uTime;
  17: uniform mat4 uViewProjection;
  18: uniform vec3 uCameraPos;
  19: 
  20: void FLWFinalizeWorldPos(inout vec4 worldPos) {
  21:     worldPos = uModel * worldPos;
  22: 
  23:     BoxCoord = (worldPos.xyz - uLightBoxMin) / uLightBoxSize;
  24: 
  25:     #if defined(USE_FOG)
  26:     FragDistance = length(worldPos.xyz);
  27:     #endif
  28: 
  29:     gl_Position = uViewProjection * worldPos;
  30: }
  31: 
  32: void FLWFinalizeNormal(inout vec3 normal) {
  33:     mat3 m;
  34:     m[0] = uModel[0].xyz;
  35:     m[1] = uModel[1].xyz;
  36:     m[2] = uModel[2].xyz;
  37:     normal = m * normal;
  38: }
  39: 
  40: 
  41: 
  42: mat4 rotate(vec3 axis, float angle) {
  43:     float s = sin(angle);
  44:     float c = cos(angle);
  45:     float oc = 1. - c;
  46: 
  47:     vec3 sa = axis * s;
  48: 
  49:     mat4 mr = mat4(1.);
  50:     mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
  51:     mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
  52:     mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);
  53: 
  54:     return mr;
  55: }
  56: 
  57: mat4 rotation(vec3 rot) {
  58:     return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
  59: }
  60: 
  61: mat3 modelToNormal(mat4 mat) {
  62:     // Discard the edges. This won't be accurate for scaled or skewed matrices,
  63:     // but we don't have to work with those often.
  64:     mat3 m;
  65:     m[0] = mat[0].xyz;
  66:     m[1] = mat[1].xyz;
  67:     m[2] = mat[2].xyz;
  68:     return m;
  69: }
  70: 
  71: #define PIOVER2 1.5707963268
  72: 
  73: vec4 quat(vec3 axis, float angle) {
  74:     float halfAngle = angle * PIOVER2 / 180.0;
  75:     vec2 cs = sin(vec2(PIOVER2 - halfAngle, halfAngle)); // compute sin and cos in one instruction
  76:     return vec4(axis.xyz * cs.y,  cs.x);
  77: }
  78: 
  79: vec4 quatMult(vec4 q1, vec4 q2) {
  80:     // disgustingly vectorized quaternion multiplication
  81:     vec4 a = q1.w * q2.xyzw;
  82:     vec4 b = q1.x * q2.wzxy * vec4(1., -1., 1., -1.);
  83:     vec4 c = q1.y * q2.zwxy * vec4(1., 1., -1., -1.);
  84:     vec4 d = q1.z * q2.yxwz * vec4(-1., 1., 1., -1.);
  85: 
  86:     return a + b + c + d;
  87: }
  88: 
  89: vec3 rotateVertexByQuat(vec3 v, vec4 q) {
  90:     vec3 i = q.xyz;
  91:     return v + 2.0 * cross(i, cross(i, v) + q.w * v);
  92: }
  93: 
  94: vec3 rotateAbout(vec3 v, vec3 axis, float angle) {
  95:     return rotateVertexByQuat(v, quat(axis, angle));
  96: }
  97: 
  98: float diffuse(vec3 normal) {
  99:     vec3 n2 = normal * normal * vec3(.6, .25, .8);
 100:     return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
 101: }
 102: 
 103: 
 104: struct Flap {
 105:     vec3 instancePos;
 106:     vec2 light;
 107:     vec3 segmentOffset;
 108:     vec3 pivot;
 109:     float horizontalAngle;
 110:     float intensity;
 111:     float flapScale;
 112:     float flapness;
 113: };
 114: 
 115: 
 116: struct Vertex {
 117:     vec3 pos;
 118:     vec3 normal;
 119:     vec2 texCoords;
 120: };
 121: 
 122: struct BlockFrag {
 123:     vec2 texCoords;
 124:     vec4 color;
 125:     float diffuse;
 126:     vec2 light;
 127: };
 128: 
 129: 
 130: float toRad(float degrees) {
 131:     return fract(degrees / 360.) * PI * 2.;
 132: }
 133: 
 134: float getFlapAngle(float flapness, float intensity, float scale) {
 135:     float absFlap = abs(flapness);
 136: 
 137:     float angle = sin((1. - absFlap) * PI * intensity) * 30. * flapness * scale;
 138: 
 139:     float halfAngle = angle * 0.5;
 140: 
 141:     float which = step(0., flapness);// 0 if negative, 1 if positive
 142:     float degrees = which * halfAngle + (1. - which) * angle;// branchless conditional multiply
 143: 
 144:     return degrees;
 145: }
 146: 
 147: BlockFrag FLWMain(Vertex v, Flap flap) {
 148:     float flapAngle = getFlapAngle(flap.flapness, flap.intensity, flap.flapScale);
 149: 
 150:     vec4 orientation = quat(vec3(0., 1., 0.), -flap.horizontalAngle);
 151:     vec4 flapRotation = quat(vec3(1., 0., 0.), flapAngle);
 152: 
 153:     vec3 rotated = rotateVertexByQuat(v.pos - flap.pivot, flapRotation) + flap.pivot + flap.segmentOffset;
 154:     rotated = rotateVertexByQuat(rotated - .5, orientation) + flap.instancePos + .5;
 155: 
 156:     vec4 worldPos = vec4(rotated, 1.);
 157:     vec3 norm = rotateVertexByQuat(rotateVertexByQuat(v.normal, flapRotation), orientation);
 158: 
 159:     FLWFinalizeWorldPos(worldPos);
 160:     FLWFinalizeNormal(norm);
 161: 
 162:     BlockFrag b;
 163:     b.diffuse = diffuse(norm);
 164:     b.texCoords = v.texCoords;
 165:     b.light = flap.light;
 166:     #if defined(DEBUG_NORMAL)
 167:     b.color = vec4(norm, 1.);
 168:     #else
 169:     b.color = vec4(1.);
 170:     #endif
 171:     return b;
 172: }
 173: attribute vec3 a_v_pos;
 174: attribute vec3 a_v_normal;
 175: attribute vec2 a_v_texCoords;
 176: 
 177: attribute vec3 a_i_instancePos;
 178: attribute vec2 a_i_light;
 179: attribute vec3 a_i_segmentOffset;
 180: attribute vec3 a_i_pivot;
 181: attribute float a_i_horizontalAngle;
 182: attribute float a_i_intensity;
 183: attribute float a_i_flapScale;
 184: attribute float a_i_flapness;
 185: 
 186: 
 187: varying vec2 v2f_texCoords;
 188: varying vec4 v2f_color;
 189: varying float v2f_diffuse;
 190: varying vec2 v2f_light;
 191: 
 192: 
 193: void main() {
 194:     Vertex v;
 195:     v.pos = a_v_pos;
 196: v.normal = a_v_normal;
 197: v.texCoords = a_v_texCoords;
 198: 
 199: 
 200:     Flap i;
 201:     i.instancePos = a_i_instancePos;
 202: i.light = a_i_light;
 203: i.segmentOffset = a_i_segmentOffset;
 204: i.pivot = a_i_pivot;
 205: i.horizontalAngle = a_i_horizontalAngle;
 206: i.intensity = a_i_intensity;
 207: i.flapScale = a_i_flapScale;
 208: i.flapness = a_i_flapness;
 209: 
 210: 
 211:     BlockFrag o = FLWMain(v, i);
 212: 
 213:     v2f_texCoords = o.texCoords;
 214: v2f_color = o.color;
 215: v2f_diffuse = o.diffuse;
 216: v2f_light = o.light;
 217: 
 218: }

[12:29:41] [main/ERROR]: Shader compilation log for flywheel:block.frag: No errors.

[12:29:41] [main/ERROR]: Source for shader 'flywheel:block.frag':
   1: #version 110
   2: #define DEBUG_NORMAL
   3: 
   4: #if defined(USE_FOG)
   5: varying float FragDistance;
   6: uniform vec4 uFogColor;
   7: #endif
   8: 
   9: #if defined(USE_FOG_LINEAR)
  10: uniform vec2 uFogRange;
  11: 
  12: float FLWFogFactor() {
  13:     return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
  14: }
  15:     #endif
  16: 
  17:     #if defined(USE_FOG_EXP2)
  18: uniform float uFogDensity;
  19: 
  20: float FLWFogFactor() {
  21:     float dist = FragDistance * uFogDensity;
  22:     return 1. / exp2(dist * dist);
  23: }
  24:     #endif
  25: // Adjust the [0,1] normalized lightmap value based on the texture matrix from LightTexture#enableLightmap
  26: vec2 shiftLight(vec2 lm) {
  27:     return lm * 0.99609375 + 0.03125;// * 255/256 + 1/32
  28: }
  29: 
  30: varying vec3 BoxCoord;
  31: varying vec2 BoxLight;
  32: uniform sampler3D uLightVolume;
  33: 
  34: uniform sampler2D uBlockAtlas;
  35: uniform sampler2D uLightMap;
  36: 
  37: vec4 FLWBlockTexture(vec2 texCoords) {
  38:     return texture2D(uBlockAtlas, texCoords);
  39: }
  40: 
  41: void FLWFinalizeColor(vec4 color) {
  42:     #if defined(USE_FOG)
  43:     float a = color.a;
  44:     float fog = clamp(FLWFogFactor(), 0., 1.);
  45: 
  46:     color = mix(uFogColor, color, fog);
  47:     color.a = a;
  48:     #endif
  49: 
  50:     gl_FragColor = color;
  51: }
  52: 
  53: vec4 FLWLight(vec2 lightCoords) {
  54:     lightCoords = max(lightCoords, texture3D(uLightVolume, BoxCoord).rg);
  55: 
  56:     return texture2D(uLightMap, shiftLight(lightCoords));
  57: }
  58: 
  59: 
  60: 
  61: struct BlockFrag {
  62:     vec2 texCoords;
  63:     vec4 color;
  64:     float diffuse;
  65:     vec2 light;
  66: };
  67: 
  68: void FLWMain(BlockFrag r) {
  69:     vec4 tex = FLWBlockTexture(r.texCoords);
  70: 
  71:     vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;
  72: 
  73: //    flw_WorldPos = ;
  74: //    flw_Normal = ;
  75: //    flw_Albedo = tex.rgb;
  76: //    flw_Alpha = tex.a;
  77: //    flw_LightMap = r.light;
  78: //    flw_Tint = r.color;
  79:     FLWFinalizeColor(color);
  80: }
  81: 
  82: varying vec2 v2f_texCoords;
  83: varying vec4 v2f_color;
  84: varying float v2f_diffuse;
  85: varying vec2 v2f_light;
  86: 
  87: 
  88: //vec3 flw_WorldPos;
  89: //vec3 flw_Normal;
  90: //vec3 flw_Albedo;
  91: //float flw_Alpha;
  92: //vec2 flw_LightMap;
  93: //vec4 flw_Tint;
  94: 
  95: void main() {
  96:     BlockFrag f;
  97:     f.texCoords = v2f_texCoords;
  98: f.color = v2f_color;
  99: f.diffuse = v2f_diffuse;
 100: f.light = v2f_light;
 101: 
 102: 
 103:     FLWMain(f);
 104: }

[12:29:41] [main/ERROR]: Shader compilation log for create:flap.vert: No errors.

[12:29:41] [main/ERROR]: Source for shader 'create:flap.vert':
   1: #version 110
   2: #define USE_FOG
   3: #define USE_FOG_LINEAR
   4: 
   5: #define PI 3.1415926538
   6: 
   7: #if defined(USE_FOG)
   8: varying float FragDistance;
   9: #endif
  10: 
  11: varying vec3 BoxCoord;
  12: 
  13: uniform vec3 uLightBoxSize;
  14: uniform vec3 uLightBoxMin;
  15: uniform mat4 uModel;
  16: 
  17: uniform float uTime;
  18: uniform mat4 uViewProjection;
  19: uniform vec3 uCameraPos;
  20: 
  21: void FLWFinalizeWorldPos(inout vec4 worldPos) {
  22:     worldPos = uModel * worldPos;
  23: 
  24:     BoxCoord = (worldPos.xyz - uLightBoxMin) / uLightBoxSize;
  25: 
  26:     #if defined(USE_FOG)
  27:     FragDistance = length(worldPos.xyz);
  28:     #endif
  29: 
  30:     gl_Position = uViewProjection * worldPos;
  31: }
  32: 
  33: void FLWFinalizeNormal(inout vec3 normal) {
  34:     mat3 m;
  35:     m[0] = uModel[0].xyz;
  36:     m[1] = uModel[1].xyz;
  37:     m[2] = uModel[2].xyz;
  38:     normal = m * normal;
  39: }
  40: 
  41: 
  42: 
  43: mat4 rotate(vec3 axis, float angle) {
  44:     float s = sin(angle);
  45:     float c = cos(angle);
  46:     float oc = 1. - c;
  47: 
  48:     vec3 sa = axis * s;
  49: 
  50:     mat4 mr = mat4(1.);
  51:     mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
  52:     mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
  53:     mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);
  54: 
  55:     return mr;
  56: }
  57: 
  58: mat4 rotation(vec3 rot) {
  59:     return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
  60: }
  61: 
  62: mat3 modelToNormal(mat4 mat) {
  63:     // Discard the edges. This won't be accurate for scaled or skewed matrices,
  64:     // but we don't have to work with those often.
  65:     mat3 m;
  66:     m[0] = mat[0].xyz;
  67:     m[1] = mat[1].xyz;
  68:     m[2] = mat[2].xyz;
  69:     return m;
  70: }
  71: 
  72: #define PIOVER2 1.5707963268
  73: 
  74: vec4 quat(vec3 axis, float angle) {
  75:     float halfAngle = angle * PIOVER2 / 180.0;
  76:     vec2 cs = sin(vec2(PIOVER2 - halfAngle, halfAngle)); // compute sin and cos in one instruction
  77:     return vec4(axis.xyz * cs.y,  cs.x);
  78: }
  79: 
  80: vec4 quatMult(vec4 q1, vec4 q2) {
  81:     // disgustingly vectorized quaternion multiplication
  82:     vec4 a = q1.w * q2.xyzw;
  83:     vec4 b = q1.x * q2.wzxy * vec4(1., -1., 1., -1.);
  84:     vec4 c = q1.y * q2.zwxy * vec4(1., 1., -1., -1.);
  85:     vec4 d = q1.z * q2.yxwz * vec4(-1., 1., 1., -1.);
  86: 
  87:     return a + b + c + d;
  88: }
  89: 
  90: vec3 rotateVertexByQuat(vec3 v, vec4 q) {
  91:     vec3 i = q.xyz;
  92:     return v + 2.0 * cross(i, cross(i, v) + q.w * v);
  93: }
  94: 
  95: vec3 rotateAbout(vec3 v, vec3 axis, float angle) {
  96:     return rotateVertexByQuat(v, quat(axis, angle));
  97: }
  98: 
  99: float diffuse(vec3 normal) {
 100:     vec3 n2 = normal * normal * vec3(.6, .25, .8);
 101:     return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
 102: }
 103: 
 104: 
 105: struct Flap {
 106:     vec3 instancePos;
 107:     vec2 light;
 108:     vec3 segmentOffset;
 109:     vec3 pivot;
 110:     float horizontalAngle;
 111:     float intensity;
 112:     float flapScale;
 113:     float flapness;
 114: };
 115: 
 116: 
 117: struct Vertex {
 118:     vec3 pos;
 119:     vec3 normal;
 120:     vec2 texCoords;
 121: };
 122: 
 123: struct BlockFrag {
 124:     vec2 texCoords;
 125:     vec4 color;
 126:     float diffuse;
 127:     vec2 light;
 128: };
 129: 
 130: 
 131: float toRad(float degrees) {
 132:     return fract(degrees / 360.) * PI * 2.;
 133: }
 134: 
 135: float getFlapAngle(float flapness, float intensity, float scale) {
 136:     float absFlap = abs(flapness);
 137: 
 138:     float angle = sin((1. - absFlap) * PI * intensity) * 30. * flapness * scale;
 139: 
 140:     float halfAngle = angle * 0.5;
 141: 
 142:     float which = step(0., flapness);// 0 if negative, 1 if positive
 143:     float degrees = which * halfAngle + (1. - which) * angle;// branchless conditional multiply
 144: 
 145:     return degrees;
 146: }
 147: 
 148: BlockFrag FLWMain(Vertex v, Flap flap) {
 149:     float flapAngle = getFlapAngle(flap.flapness, flap.intensity, flap.flapScale);
 150: 
 151:     vec4 orientation = quat(vec3(0., 1., 0.), -flap.horizontalAngle);
 152:     vec4 flapRotation = quat(vec3(1., 0., 0.), flapAngle);
 153: 
 154:     vec3 rotated = rotateVertexByQuat(v.pos - flap.pivot, flapRotation) + flap.pivot + flap.segmentOffset;
 155:     rotated = rotateVertexByQuat(rotated - .5, orientation) + flap.instancePos + .5;
 156: 
 157:     vec4 worldPos = vec4(rotated, 1.);
 158:     vec3 norm = rotateVertexByQuat(rotateVertexByQuat(v.normal, flapRotation), orientation);
 159: 
 160:     FLWFinalizeWorldPos(worldPos);
 161:     FLWFinalizeNormal(norm);
 162: 
 163:     BlockFrag b;
 164:     b.diffuse = diffuse(norm);
 165:     b.texCoords = v.texCoords;
 166:     b.light = flap.light;
 167:     #if defined(DEBUG_NORMAL)
 168:     b.color = vec4(norm, 1.);
 169:     #else
 170:     b.color = vec4(1.);
 171:     #endif
 172:     return b;
 173: }
 174: attribute vec3 a_v_pos;
 175: attribute vec3 a_v_normal;
 176: attribute vec2 a_v_texCoords;
 177: 
 178: attribute vec3 a_i_instancePos;
 179: attribute vec2 a_i_light;
 180: attribute vec3 a_i_segmentOffset;
 181: attribute vec3 a_i_pivot;
 182: attribute float a_i_horizontalAngle;
 183: attribute float a_i_intensity;
 184: attribute float a_i_flapScale;
 185: attribute float a_i_flapness;
 186: 
 187: 
 188: varying vec2 v2f_texCoords;
 189: varying vec4 v2f_color;
 190: varying float v2f_diffuse;
 191: varying vec2 v2f_light;
 192: 
 193: 
 194: void main() {
 195:     Vertex v;
 196:     v.pos = a_v_pos;
 197: v.normal = a_v_normal;
 198: v.texCoords = a_v_texCoords;
 199: 
 200: 
 201:     Flap i;
 202:     i.instancePos = a_i_instancePos;
 203: i.light = a_i_light;
 204: i.segmentOffset = a_i_segmentOffset;
 205: i.pivot = a_i_pivot;
 206: i.horizontalAngle = a_i_horizontalAngle;
 207: i.intensity = a_i_intensity;
 208: i.flapScale = a_i_flapScale;
 209: i.flapness = a_i_flapness;
 210: 
 211: 
 212:     BlockFrag o = FLWMain(v, i);
 213: 
 214:     v2f_texCoords = o.texCoords;
 215: v2f_color = o.color;
 216: v2f_diffuse = o.diffuse;
 217: v2f_light = o.light;
 218: 
 219: }

[12:29:41] [main/ERROR]: Shader compilation log for flywheel:block.frag: No errors.

[12:29:41] [main/ERROR]: Source for shader 'flywheel:block.frag':
   1: #version 110
   2: #define USE_FOG
   3: #define USE_FOG_LINEAR
   4: 
   5: #if defined(USE_FOG)
   6: varying float FragDistance;
   7: uniform vec4 uFogColor;
   8: #endif
   9: 
  10: #if defined(USE_FOG_LINEAR)
  11: uniform vec2 uFogRange;
  12: 
  13: float FLWFogFactor() {
  14:     return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
  15: }
  16:     #endif
  17: 
  18:     #if defined(USE_FOG_EXP2)
  19: uniform float uFogDensity;
  20: 
  21: float FLWFogFactor() {
  22:     float dist = FragDistance * uFogDensity;
  23:     return 1. / exp2(dist * dist);
  24: }
  25:     #endif
  26: // Adjust the [0,1] normalized lightmap value based on the texture matrix from LightTexture#enableLightmap
  27: vec2 shiftLight(vec2 lm) {
  28:     return lm * 0.99609375 + 0.03125;// * 255/256 + 1/32
  29: }
  30: 
  31: varying vec3 BoxCoord;
  32: varying vec2 BoxLight;
  33: uniform sampler3D uLightVolume;
  34: 
  35: uniform sampler2D uBlockAtlas;
  36: uniform sampler2D uLightMap;
  37: 
  38: vec4 FLWBlockTexture(vec2 texCoords) {
  39:     return texture2D(uBlockAtlas, texCoords);
  40: }
  41: 
  42: void FLWFinalizeColor(vec4 color) {
  43:     #if defined(USE_FOG)
  44:     float a = color.a;
  45:     float fog = clamp(FLWFogFactor(), 0., 1.);
  46: 
  47:     color = mix(uFogColor, color, fog);
  48:     color.a = a;
  49:     #endif
  50: 
  51:     gl_FragColor = color;
  52: }
  53: 
  54: vec4 FLWLight(vec2 lightCoords) {
  55:     lightCoords = max(lightCoords, texture3D(uLightVolume, BoxCoord).rg);
  56: 
  57:     return texture2D(uLightMap, shiftLight(lightCoords));
  58: }
  59: 
  60: 
  61: 
  62: struct BlockFrag {
  63:     vec2 texCoords;
  64:     vec4 color;
  65:     float diffuse;
  66:     vec2 light;
  67: };
  68: 
  69: void FLWMain(BlockFrag r) {
  70:     vec4 tex = FLWBlockTexture(r.texCoords);
  71: 
  72:     vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;
  73: 
  74: //    flw_WorldPos = ;
  75: //    flw_Normal = ;
  76: //    flw_Albedo = tex.rgb;
  77: //    flw_Alpha = tex.a;
  78: //    flw_LightMap = r.light;
  79: //    flw_Tint = r.color;
  80:     FLWFinalizeColor(color);
  81: }
  82: 
  83: varying vec2 v2f_texCoords;
  84: varying vec4 v2f_color;
  85: varying float v2f_diffuse;
  86: varying vec2 v2f_light;
  87: 
  88: 
  89: //vec3 flw_WorldPos;
  90: //vec3 flw_Normal;
  91: //vec3 flw_Albedo;
  92: //float flw_Alpha;
  93: //vec2 flw_LightMap;
  94: //vec4 flw_Tint;
  95: 
  96: void main() {
  97:     BlockFrag f;
  98:     f.texCoords = v2f_texCoords;
  99: f.color = v2f_color;
 100: f.diffuse = v2f_diffuse;
 101: f.light = v2f_light;
 102: 
 103: 
 104:     FLWMain(f);
 105: }

[12:29:41] [Forge Version Check/INFO]: [cfm] Found status: BETA Current: 7.0.0-pre22 Target: 7.0.0-pre22
[12:29:41] [Forge Version Check/INFO]: [morecfm] Starting version check at https://mrcrayfish.com/modupdatejson?id=morecfm
[12:29:41] [main/ERROR]: Shader compilation log for create:flap.vert: No errors.

[12:29:41] [main/ERROR]: Source for shader 'create:flap.vert':
   1: #version 110
   2: #define USE_FOG
   3: #define USE_FOG_EXP2
   4: 
   5: #define PI 3.1415926538
   6: 
   7: #if defined(USE_FOG)
   8: varying float FragDistance;
   9: #endif
  10: 
  11: varying vec3 BoxCoord;
  12: 
  13: uniform vec3 uLightBoxSize;
  14: uniform vec3 uLightBoxMin;
  15: uniform mat4 uModel;
  16: 
  17: uniform float uTime;
  18: uniform mat4 uViewProjection;
  19: uniform vec3 uCameraPos;
  20: 
  21: void FLWFinalizeWorldPos(inout vec4 worldPos) {
  22:     worldPos = uModel * worldPos;
  23: 
  24:     BoxCoord = (worldPos.xyz - uLightBoxMin) / uLightBoxSize;
  25: 
  26:     #if defined(USE_FOG)
  27:     FragDistance = length(worldPos.xyz);
  28:     #endif
  29: 
  30:     gl_Position = uViewProjection * worldPos;
  31: }
  32: 
  33: void FLWFinalizeNormal(inout vec3 normal) {
  34:     mat3 m;
  35:     m[0] = uModel[0].xyz;
  36:     m[1] = uModel[1].xyz;
  37:     m[2] = uModel[2].xyz;
  38:     normal = m * normal;
  39: }
  40: 
  41: 
  42: 
  43: mat4 rotate(vec3 axis, float angle) {
  44:     float s = sin(angle);
  45:     float c = cos(angle);
  46:     float oc = 1. - c;
  47: 
  48:     vec3 sa = axis * s;
  49: 
  50:     mat4 mr = mat4(1.);
  51:     mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
  52:     mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
  53:     mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);
  54: 
  55:     return mr;
  56: }
  57: 
  58: mat4 rotation(vec3 rot) {
  59:     return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
  60: }
  61: 
  62: mat3 modelToNormal(mat4 mat) {
  63:     // Discard the edges. This won't be accurate for scaled or skewed matrices,
  64:     // but we don't have to work with those often.
  65:     mat3 m;
  66:     m[0] = mat[0].xyz;
  67:     m[1] = mat[1].xyz;
  68:     m[2] = mat[2].xyz;
  69:     return m;
  70: }
  71: 
  72: #define PIOVER2 1.5707963268
  73: 
  74: vec4 quat(vec3 axis, float angle) {
  75:     float halfAngle = angle * PIOVER2 / 180.0;
  76:     vec2 cs = sin(vec2(PIOVER2 - halfAngle, halfAngle)); // compute sin and cos in one instruction
  77:     return vec4(axis.xyz * cs.y,  cs.x);
  78: }
  79: 
  80: vec4 quatMult(vec4 q1, vec4 q2) {
  81:     // disgustingly vectorized quaternion multiplication
  82:     vec4 a = q1.w * q2.xyzw;
  83:     vec4 b = q1.x * q2.wzxy * vec4(1., -1., 1., -1.);
  84:     vec4 c = q1.y * q2.zwxy * vec4(1., 1., -1., -1.);
  85:     vec4 d = q1.z * q2.yxwz * vec4(-1., 1., 1., -1.);
  86: 
  87:     return a + b + c + d;
  88: }
  89: 
  90: vec3 rotateVertexByQuat(vec3 v, vec4 q) {
  91:     vec3 i = q.xyz;
  92:     return v + 2.0 * cross(i, cross(i, v) + q.w * v);
  93: }
  94: 
  95: vec3 rotateAbout(vec3 v, vec3 axis, float angle) {
  96:     return rotateVertexByQuat(v, quat(axis, angle));
  97: }
  98: 
  99: float diffuse(vec3 normal) {
 100:     vec3 n2 = normal * normal * vec3(.6, .25, .8);
 101:     return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
 102: }
 103: 
 104: 
 105: struct Flap {
 106:     vec3 instancePos;
 107:     vec2 light;
 108:     vec3 segmentOffset;
 109:     vec3 pivot;
 110:     float horizontalAngle;
 111:     float intensity;
 112:     float flapScale;
 113:     float flapness;
 114: };
 115: 
 116: 
 117: struct Vertex {
 118:     vec3 pos;
 119:     vec3 normal;
 120:     vec2 texCoords;
 121: };
 122: 
 123: struct BlockFrag {
 124:     vec2 texCoords;
 125:     vec4 color;
 126:     float diffuse;
 127:     vec2 light;
 128: };
 129: 
 130: 
 131: float toRad(float degrees) {
 132:     return fract(degrees / 360.) * PI * 2.;
 133: }
 134: 
 135: float getFlapAngle(float flapness, float intensity, float scale) {
 136:     float absFlap = abs(flapness);
 137: 
 138:     float angle = sin((1. - absFlap) * PI * intensity) * 30. * flapness * scale;
 139: 
 140:     float halfAngle = angle * 0.5;
 141: 
 142:     float which = step(0., flapness);// 0 if negative, 1 if positive
 143:     float degrees = which * halfAngle + (1. - which) * angle;// branchless conditional multiply
 144: 
 145:     return degrees;
 146: }
 147: 
 148: BlockFrag FLWMain(Vertex v, Flap flap) {
 149:     float flapAngle = getFlapAngle(flap.flapness, flap.intensity, flap.flapScale);
 150: 
 151:     vec4 orientation = quat(vec3(0., 1., 0.), -flap.horizontalAngle);
 152:     vec4 flapRotation = quat(vec3(1., 0., 0.), flapAngle);
 153: 
 154:     vec3 rotated = rotateVertexByQuat(v.pos - flap.pivot, flapRotation) + flap.pivot + flap.segmentOffset;
 155:     rotated = rotateVertexByQuat(rotated - .5, orientation) + flap.instancePos + .5;
 156: 
 157:     vec4 worldPos = vec4(rotated, 1.);
 158:     vec3 norm = rotateVertexByQuat(rotateVertexByQuat(v.normal, flapRotation), orientation);
 159: 
 160:     FLWFinalizeWorldPos(worldPos);
 161:     FLWFinalizeNormal(norm);
 162: 
 163:     BlockFrag b;
 164:     b.diffuse = diffuse(norm);
 165:     b.texCoords = v.texCoords;
 166:     b.light = flap.light;
 167:     #if defined(DEBUG_NORMAL)
 168:     b.color = vec4(norm, 1.);
 169:     #else
 170:     b.color = vec4(1.);
 171:     #endif
 172:     return b;
 173: }
 174: attribute vec3 a_v_pos;
 175: attribute vec3 a_v_normal;
 176: attribute vec2 a_v_texCoords;
 177: 
 178: attribute vec3 a_i_instancePos;
 179: attribute vec2 a_i_light;
 180: attribute vec3 a_i_segmentOffset;
 181: attribute vec3 a_i_pivot;
 182: attribute float a_i_horizontalAngle;
 183: attribute float a_i_intensity;
 184: attribute float a_i_flapScale;
 185: attribute float a_i_flapness;
 186: 
 187: 
 188: varying vec2 v2f_texCoords;
 189: varying vec4 v2f_color;
 190: varying float v2f_diffuse;
 191: varying vec2 v2f_light;
 192: 
 193: 
 194: void main() {
 195:     Vertex v;
 196:     v.pos = a_v_pos;
 197: v.normal = a_v_normal;
 198: v.texCoords = a_v_texCoords;
 199: 
 200: 
 201:     Flap i;
 202:     i.instancePos = a_i_instancePos;
 203: i.light = a_i_light;
 204: i.segmentOffset = a_i_segmentOffset;
 205: i.pivot = a_i_pivot;
 206: i.horizontalAngle = a_i_horizontalAngle;
 207: i.intensity = a_i_intensity;
 208: i.flapScale = a_i_flapScale;
 209: i.flapness = a_i_flapness;
 210: 
 211: 
 212:     BlockFrag o = FLWMain(v, i);
 213: 
 214:     v2f_texCoords = o.texCoords;
 215: v2f_color = o.color;
 216: v2f_diffuse = o.diffuse;
 217: v2f_light = o.light;
 218: 
 219: }

[12:29:41] [main/ERROR]: Shader compilation log for flywheel:block.frag: No errors.

[12:29:41] [main/ERROR]: Source for shader 'flywheel:block.frag':
   1: #version 110
   2: #define USE_FOG
   3: #define USE_FOG_EXP2
   4: 
   5: #if defined(USE_FOG)
   6: varying float FragDistance;
   7: uniform vec4 uFogColor;
   8: #endif
   9: 
  10: #if defined(USE_FOG_LINEAR)
  11: uniform vec2 uFogRange;
  12: 
  13: float FLWFogFactor() {
  14:     return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
  15: }
  16:     #endif
  17: 
  18:     #if defined(USE_FOG_EXP2)
  19: uniform float uFogDensity;
  20: 
  21: float FLWFogFactor() {
  22:     float dist = FragDistance * uFogDensity;
  23:     return 1. / exp2(dist * dist);
  24: }
  25:     #endif
  26: // Adjust the [0,1] normalized lightmap value based on the texture matrix from LightTexture#enableLightmap
  27: vec2 shiftLight(vec2 lm) {
  28:     return lm * 0.99609375 + 0.03125;// * 255/256 + 1/32
  29: }
  30: 
  31: varying vec3 BoxCoord;
  32: varying vec2 BoxLight;
  33: uniform sampler3D uLightVolume;
  34: 
  35: uniform sampler2D uBlockAtlas;
  36: uniform sampler2D uLightMap;
  37: 
  38: vec4 FLWBlockTexture(vec2 texCoords) {
  39:     return texture2D(uBlockAtlas, texCoords);
  40: }
  41: 
  42: void FLWFinalizeColor(vec4 color) {
  43:     #if defined(USE_FOG)
  44:     float a = color.a;
  45:     float fog = clamp(FLWFogFactor(), 0., 1.);
  46: 
  47:     color = mix(uFogColor, color, fog);
  48:     color.a = a;
  49:     #endif
  50: 
  51:     gl_FragColor = color;
  52: }
  53: 
  54: vec4 FLWLight(vec2 lightCoords) {
  55:     lightCoords = max(lightCoords, texture3D(uLightVolume, BoxCoord).rg);
  56: 
  57:     return texture2D(uLightMap, shiftLight(lightCoords));
  58: }
  59: 
  60: 
  61: 
  62: struct BlockFrag {
  63:     vec2 texCoords;
  64:     vec4 color;
  65:     float diffuse;
  66:     vec2 light;
  67: };
  68: 
  69: void FLWMain(BlockFrag r) {
  70:     vec4 tex = FLWBlockTexture(r.texCoords);
  71: 
  72:     vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;
  73: 
  74: //    flw_WorldPos = ;
  75: //    flw_Normal = ;
  76: //    flw_Albedo = tex.rgb;
  77: //    flw_Alpha = tex.a;
  78: //    flw_LightMap = r.light;
  79: //    flw_Tint = r.color;
  80:     FLWFinalizeColor(color);
  81: }
  82: 
  83: varying vec2 v2f_texCoords;
  84: varying vec4 v2f_color;
  85: varying float v2f_diffuse;
  86: varying vec2 v2f_light;
  87: 
  88: 
  89: //vec3 flw_WorldPos;
  90: //vec3 flw_Normal;
  91: //vec3 flw_Albedo;
  92: //float flw_Alpha;
  93: //vec2 flw_LightMap;
  94: //vec4 flw_Tint;
  95: 
  96: void main() {
  97:     BlockFrag f;
  98:     f.texCoords = v2f_texCoords;
  99: f.color = v2f_color;
 100: f.diffuse = v2f_diffuse;
 101: f.light = v2f_light;
 102: 
 103: 
 104:     FLWMain(f);
 105: }

[12:29:41] [main/ERROR]: Shader compilation log for create:flap.vert: No errors.

[12:29:41] [main/ERROR]: Source for shader 'create:flap.vert':
   1: #version 110
   2: 
   3: #define PI 3.1415926538
   4: 
   5: #if defined(USE_FOG)
   6: varying float FragDistance;
   7: #endif
   8: 
   9: varying vec3 BoxCoord;
  10: 
  11: uniform vec3 uLightBoxSize;
  12: uniform vec3 uLightBoxMin;
  13: uniform mat4 uModel;
  14: 
  15: uniform float uTime;
  16: uniform mat4 uViewProjection;
  17: uniform vec3 uCameraPos;
  18: 
  19: void FLWFinalizeWorldPos(inout vec4 worldPos) {
  20:     worldPos = uModel * worldPos;
  21: 
  22:     BoxCoord = (worldPos.xyz - uLightBoxMin) / uLightBoxSize;
  23: 
  24:     #if defined(USE_FOG)
  25:     FragDistance = length(worldPos.xyz);
  26:     #endif
  27: 
  28:     gl_Position = uViewProjection * worldPos;
  29: }
  30: 
  31: void FLWFinalizeNormal(inout vec3 normal) {
  32:     mat3 m;
  33:     m[0] = uModel[0].xyz;
  34:     m[1] = uModel[1].xyz;
  35:     m[2] = uModel[2].xyz;
  36:     normal = m * normal;
  37: }
  38: 
  39: 
  40: 
  41: mat4 rotate(vec3 axis, float angle) {
  42:     float s = sin(angle);
  43:     float c = cos(angle);
  44:     float oc = 1. - c;
  45: 
  46:     vec3 sa = axis * s;
  47: 
  48:     mat4 mr = mat4(1.);
  49:     mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
  50:     mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
  51:     mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);
  52: 
  53:     return mr;
  54: }
  55: 
  56: mat4 rotation(vec3 rot) {
  57:     return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
  58: }
  59: 
  60: mat3 modelToNormal(mat4 mat) {
  61:     // Discard the edges. This won't be accurate for scaled or skewed matrices,
  62:     // but we don't have to work with those often.
  63:     mat3 m;
  64:     m[0] = mat[0].xyz;
  65:     m[1] = mat[1].xyz;
  66:     m[2] = mat[2].xyz;
  67:     return m;
  68: }
  69: 
  70: #define PIOVER2 1.5707963268
  71: 
  72: vec4 quat(vec3 axis, float angle) {
  73:     float halfAngle = angle * PIOVER2 / 180.0;
  74:     vec2 cs = sin(vec2(PIOVER2 - halfAngle, halfAngle)); // compute sin and cos in one instruction
  75:     return vec4(axis.xyz * cs.y,  cs.x);
  76: }
  77: 
  78: vec4 quatMult(vec4 q1, vec4 q2) {
  79:     // disgustingly vectorized quaternion multiplication
  80:     vec4 a = q1.w * q2.xyzw;
  81:     vec4 b = q1.x * q2.wzxy * vec4(1., -1., 1., -1.);
  82:     vec4 c = q1.y * q2.zwxy * vec4(1., 1., -1., -1.);
  83:     vec4 d = q1.z * q2.yxwz * vec4(-1., 1., 1., -1.);
  84: 
  85:     return a + b + c + d;
  86: }
  87: 
  88: vec3 rotateVertexByQuat(vec3 v, vec4 q) {
  89:     vec3 i = q.xyz;
  90:     return v + 2.0 * cross(i, cross(i, v) + q.w * v);
  91: }
  92: 
  93: vec3 rotateAbout(vec3 v, vec3 axis, float angle) {
  94:     return rotateVertexByQuat(v, quat(axis, angle));
  95: }
  96: 
  97: float diffuse(vec3 normal) {
  98:     vec3 n2 = normal * normal * vec3(.6, .25, .8);
  99:     return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
 100: }
 101: 
 102: 
 103: struct Flap {
 104:     vec3 instancePos;
 105:     vec2 light;
 106:     vec3 segmentOffset;
 107:     vec3 pivot;
 108:     float horizontalAngle;
 109:     float intensity;
 110:     float flapScale;
 111:     float flapness;
 112: };
 113: 
 114: 
 115: struct Vertex {
 116:     vec3 pos;
 117:     vec3 normal;
 118:     vec2 texCoords;
 119: };
 120: 
 121: struct BlockFrag {
 122:     vec2 texCoords;
 123:     vec4 color;
 124:     float diffuse;
 125:     vec2 light;
 126: };
 127: 
 128: 
 129: float toRad(float degrees) {
 130:     return fract(degrees / 360.) * PI * 2.;
 131: }
 132: 
 133: float getFlapAngle(float flapness, float intensity, float scale) {
 134:     float absFlap = abs(flapness);
 135: 
 136:     float angle = sin((1. - absFlap) * PI * intensity) * 30. * flapness * scale;
 137: 
 138:     float halfAngle = angle * 0.5;
 139: 
 140:     float which = step(0., flapness);// 0 if negative, 1 if positive
 141:     float degrees = which * halfAngle + (1. - which) * angle;// branchless conditional multiply
 142: 
 143:     return degrees;
 144: }
 145: 
 146: BlockFrag FLWMain(Vertex v, Flap flap) {
 147:     float flapAngle = getFlapAngle(flap.flapness, flap.intensity, flap.flapScale);
 148: 
 149:     vec4 orientation = quat(vec3(0., 1., 0.), -flap.horizontalAngle);
 150:     vec4 flapRotation = quat(vec3(1., 0., 0.), flapAngle);
 151: 
 152:     vec3 rotated = rotateVertexByQuat(v.pos - flap.pivot, flapRotation) + flap.pivot + flap.segmentOffset;
 153:     rotated = rotateVertexByQuat(rotated - .5, orientation) + flap.instancePos + .5;
 154: 
 155:     vec4 worldPos = vec4(rotated, 1.);
 156:     vec3 norm = rotateVertexByQuat(rotateVertexByQuat(v.normal, flapRotation), orientation);
 157: 
 158:     FLWFinalizeWorldPos(worldPos);
 159:     FLWFinalizeNormal(norm);
 160: 
 161:     BlockFrag b;
 162:     b.diffuse = diffuse(norm);
 163:     b.texCoords = v.texCoords;
 164:     b.light = flap.light;
 165:     #if defined(DEBUG_NORMAL)
 166:     b.color = vec4(norm, 1.);
 167:     #else
 168:     b.color = vec4(1.);
 169:     #endif
 170:     return b;
 171: }
 172: attribute vec3 a_v_pos;
 173: attribute vec3 a_v_normal;
 174: attribute vec2 a_v_texCoords;
 175: 
 176: attribute vec3 a_i_instancePos;
 177: attribute vec2 a_i_light;
 178: attribute vec3 a_i_segmentOffset;
 179: attribute vec3 a_i_pivot;
 180: attribute float a_i_horizontalAngle;
 181: attribute float a_i_intensity;
 182: attribute float a_i_flapScale;
 183: attribute float a_i_flapness;
 184: 
 185: 
 186: varying vec2 v2f_texCoords;
 187: varying vec4 v2f_color;
 188: varying float v2f_diffuse;
 189: varying vec2 v2f_light;
 190: 
 191: 
 192: void main() {
 193:     Vertex v;
 194:     v.pos = a_v_pos;
 195: v.normal = a_v_normal;
 196: v.texCoords = a_v_texCoords;
 197: 
 198: 
 199:     Flap i;
 200:     i.instancePos = a_i_instancePos;
 201: i.light = a_i_light;
 202: i.segmentOffset = a_i_segmentOffset;
 203: i.pivot = a_i_pivot;
 204: i.horizontalAngle = a_i_horizontalAngle;
 205: i.intensity = a_i_intensity;
 206: i.flapScale = a_i_flapScale;
 207: i.flapness = a_i_flapness;
 208: 
 209: 
 210:     BlockFrag o = FLWMain(v, i);
 211: 
 212:     v2f_texCoords = o.texCoords;
 213: v2f_color = o.color;
 214: v2f_diffuse = o.diffuse;
 215: v2f_light = o.light;
 216: 
 217: }

[12:29:41] [main/ERROR]: Shader compilation log for flywheel:block.frag: No errors.

[12:29:41] [main/ERROR]: Source for shader 'flywheel:block.frag':
   1: #version 110
   2: 
   3: #if defined(USE_FOG)
   4: varying float FragDistance;
   5: uniform vec4 uFogColor;
   6: #endif
   7: 
   8: #if defined(USE_FOG_LINEAR)
   9: uniform vec2 uFogRange;
  10: 
  11: float FLWFogFactor() {
  12:     return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
  13: }
  14:     #endif
  15: 
  16:     #if defined(USE_FOG_EXP2)
  17: uniform float uFogDensity;
  18: 
  19: float FLWFogFactor() {
  20:     float dist = FragDistance * uFogDensity;
  21:     return 1. / exp2(dist * dist);
  22: }
  23:     #endif
  24: // Adjust the [0,1] normalized lightmap value based on the texture matrix from LightTexture#enableLightmap
  25: vec2 shiftLight(vec2 lm) {
  26:     return lm * 0.99609375 + 0.03125;// * 255/256 + 1/32
  27: }
  28: 
  29: varying vec3 BoxCoord;
  30: varying vec2 BoxLight;
  31: uniform sampler3D uLightVolume;
  32: 
  33: uniform sampler2D uBlockAtlas;
  34: uniform sampler2D uLightMap;
  35: 
  36: vec4 FLWBlockTexture(vec2 texCoords) {
  37:     return texture2D(uBlockAtlas, texCoords);
  38: }
  39: 
  40: void FLWFinalizeColor(vec4 color) {
  41:     #if defined(USE_FOG)
  42:     float a = color.a;
  43:     float fog = clamp(FLWFogFactor(), 0., 1.);
  44: 
  45:     color = mix(uFogColor, color, fog);
  46:     color.a = a;
  47:     #endif
  48: 
  49:     gl_FragColor = color;
  50: }
  51: 
  52: vec4 FLWLight(vec2 lightCoords) {
  53:     lightCoords = max(lightCoords, texture3D(uLightVolume, BoxCoord).rg);
  54: 
  55:     return texture2D(uLightMap, shiftLight(lightCoords));
  56: }
  57: 
  58: 
  59: 
  60: struct BlockFrag {
  61:     vec2 texCoords;
  62:     vec4 color;
  63:     float diffuse;
  64:     vec2 light;
  65: };
  66: 
  67: void FLWMain(BlockFrag r) {
  68:     vec4 tex = FLWBlockTexture(r.texCoords);
  69: 
  70:     vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;
  71: 
  72: //    flw_WorldPos = ;
  73: //    flw_Normal = ;
  74: //    flw_Albedo = tex.rgb;
  75: //    flw_Alpha = tex.a;
  76: //    flw_LightMap = r.light;
  77: //    flw_Tint = r.color;
  78:     FLWFinalizeColor(color);
  79: }
  80: 
  81: varying vec2 v2f_texCoords;
  82: varying vec4 v2f_color;
  83: varying float v2f_diffuse;
  84: varying vec2 v2f_light;
  85: 
  86: 
  87: //vec3 flw_WorldPos;
  88: //vec3 flw_Normal;
  89: //vec3 flw_Albedo;
  90: //float flw_Alpha;
  91: //vec2 flw_LightMap;
  92: //vec4 flw_Tint;
  93: 
  94: void main() {
  95:     BlockFrag f;
  96:     f.texCoords = v2f_texCoords;
  97: f.color = v2f_color;
  98: f.diffuse = v2f_diffuse;
  99: f.light = v2f_light;
 100: 
 101: 
 102:     FLWMain(f);
 103: }

[12:29:41] [Forge Version Check/INFO]: [morecfm] Found status: BETA Current: 1.3.1 Target: 1.3.1
[12:29:41] [Forge Version Check/INFO]: [fallingtree] Starting version check at https://raw.githubusercontent.com/RakSrinaNa/FallingTree/1.16.5/update.json
[12:29:42] [main/ERROR]: Shader compilation log for create:belt.vert: No errors.

[12:29:42] [main/ERROR]: Source for shader 'create:belt.vert':
   1: #version 110
   2: #define DEBUG_RAINBOW
   3: 
   4: #define PI 3.1415926538
   5: 
   6: #if defined(USE_FOG)
   7: varying float FragDistance;
   8: #endif
   9: 
  10: varying vec3 BoxCoord;
  11: 
  12: uniform vec3 uLightBoxSize;
  13: uniform vec3 uLightBoxMin;
  14: uniform mat4 uModel;
  15: 
  16: uniform float uTime;
  17: uniform mat4 uViewProjection;
  18: uniform vec3 uCameraPos;
  19: 
  20: void FLWFinalizeWorldPos(inout vec4 worldPos) {
  21:     worldPos = uModel * worldPos;
  22: 
  23:     BoxCoord = (worldPos.xyz - uLightBoxMin) / uLightBoxSize;
  24: 
  25:     #if defined(USE_FOG)
  26:     FragDistance = length(worldPos.xyz);
  27:     #endif
  28: 
  29:     gl_Position = uViewProjection * worldPos;
  30: }
  31: 
  32: void FLWFinalizeNormal(inout vec3 normal) {
  33:     mat3 m;
  34:     m[0] = uModel[0].xyz;
  35:     m[1] = uModel[1].xyz;
  36:     m[2] = uModel[2].xyz;
  37:     normal = m * normal;
  38: }
  39: 
  40: 
  41: 
  42: #define PIOVER2 1.5707963268
  43: 
  44: vec4 quat(vec3 axis, float angle) {
  45:     float halfAngle = angle * PIOVER2 / 180.0;
  46:     vec2 cs = sin(vec2(PIOVER2 - halfAngle, halfAngle)); // compute sin and cos in one instruction
  47:     return vec4(axis.xyz * cs.y,  cs.x);
  48: }
  49: 
  50: vec4 quatMult(vec4 q1, vec4 q2) {
  51:     // disgustingly vectorized quaternion multiplication
  52:     vec4 a = q1.w * q2.xyzw;
  53:     vec4 b = q1.x * q2.wzxy * vec4(1., -1., 1., -1.);
  54:     vec4 c = q1.y * q2.zwxy * vec4(1., 1., -1., -1.);
  55:     vec4 d = q1.z * q2.yxwz * vec4(-1., 1., 1., -1.);
  56: 
  57:     return a + b + c + d;
  58: }
  59: 
  60: vec3 rotateVertexByQuat(vec3 v, vec4 q) {
  61:     vec3 i = q.xyz;
  62:     return v + 2.0 * cross(i, cross(i, v) + q.w * v);
  63: }
  64: 
  65: vec3 rotateAbout(vec3 v, vec3 axis, float angle) {
  66:     return rotateVertexByQuat(v, quat(axis, angle));
  67: }
  68: 
  69: mat4 rotate(vec3 axis, float angle) {
  70:     float s = sin(angle);
  71:     float c = cos(angle);
  72:     float oc = 1. - c;
  73: 
  74:     vec3 sa = axis * s;
  75: 
  76:     mat4 mr = mat4(1.);
  77:     mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
  78:     mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
  79:     mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);
  80: 
  81:     return mr;
  82: }
  83: 
  84: mat4 rotation(vec3 rot) {
  85:     return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
  86: }
  87: 
  88: mat3 modelToNormal(mat4 mat) {
  89:     // Discard the edges. This won't be accurate for scaled or skewed matrices,
  90:     // but we don't have to work with those often.
  91:     mat3 m;
  92:     m[0] = mat[0].xyz;
  93:     m[1] = mat[1].xyz;
  94:     m[2] = mat[2].xyz;
  95:     return m;
  96: }
  97: 
  98: float diffuse(vec3 normal) {
  99:     vec3 n2 = normal * normal * vec3(.6, .25, .8);
 100:     return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
 101: }
 102: 
 103: 
 104: struct Belt {
 105:     vec2 light;
 106:     vec4 color;
 107:     vec3 pos;
 108:     float speed;
 109:     float offset;
 110:     vec4 rotation;
 111:     vec2 sourceTexture;
 112:     vec4 scrollTexture;
 113:     float scrollMult;
 114: };
 115: 
 116: 
 117: struct Vertex {
 118:     vec3 pos;
 119:     vec3 normal;
 120:     vec2 texCoords;
 121: };
 122: 
 123: struct BlockFrag {
 124:     vec2 texCoords;
 125:     vec4 color;
 126:     float diffuse;
 127:     vec2 light;
 128: };
 129: 
 130: BlockFrag FLWMain(Vertex v, Belt instance) {
 131:     vec3 rotated = rotateVertexByQuat(v.pos - .5, instance.rotation) + instance.pos + .5;
 132: 
 133:     vec4 worldPos = vec4(rotated, 1.);
 134: 
 135:     vec3 norm = rotateVertexByQuat(v.normal, instance.rotation);
 136: 
 137:     FLWFinalizeWorldPos(worldPos);
 138:     FLWFinalizeNormal(norm);
 139: 
 140:     float scrollSize = instance.scrollTexture.w - instance.scrollTexture.y;
 141:     float scroll = fract(instance.speed * uTime / (31.5 * 16.) + instance.offset) * scrollSize * instance.scrollMult;
 142: 
 143:     BlockFrag b;
 144:     b.diffuse = diffuse(norm);
 145:     b.texCoords = v.texCoords - instance.sourceTexture + instance.scrollTexture.xy + vec2(0, scroll);
 146:     b.light = instance.light;
 147: 
 148:     #if defined(DEBUG_RAINBOW)
 149:     b.color = instance.color;
 150:     #elif defined(DEBUG_NORMAL)
 151:     b.color = vec4(norm, 1.);
 152:     #else
 153:     b.color = vec4(1.);
 154:     #endif
 155: 
 156:     return b;
 157: }
 158: attribute vec3 a_v_pos;
 159: attribute vec3 a_v_normal;
 160: attribute vec2 a_v_texCoords;
 161: 
 162: attribute vec2 a_i_light;
 163: attribute vec4 a_i_color;
 164: attribute vec3 a_i_pos;
 165: attribute float a_i_speed;
 166: attribute float a_i_offset;
 167: attribute vec4 a_i_rotation;
 168: attribute vec2 a_i_sourceTexture;
 169: attribute vec4 a_i_scrollTexture;
 170: attribute float a_i_scrollMult;
 171: 
 172: 
 173: varying vec2 v2f_texCoords;
 174: varying vec4 v2f_color;
 175: varying float v2f_diffuse;
 176: varying vec2 v2f_light;
 177: 
 178: 
 179: void main() {
 180:     Vertex v;
 181:     v.pos = a_v_pos;
 182: v.normal = a_v_normal;
 183: v.texCoords = a_v_texCoords;
 184: 
 185: 
 186:     Belt i;
 187:     i.light = a_i_light;
 188: i.color = a_i_color;
 189: i.pos = a_i_pos;
 190: i.speed = a_i_speed;
 191: i.offset = a_i_offset;
 192: i.rotation = a_i_rotation;
 193: i.sourceTexture = a_i_sourceTexture;
 194: i.scrollTexture = a_i_scrollTexture;
 195: i.scrollMult = a_i_scrollMult;
 196: 
 197: 
 198:     BlockFrag o = FLWMain(v, i);
 199: 
 200:     v2f_texCoords = o.texCoords;
 201: v2f_color = o.color;
 202: v2f_diffuse = o.diffuse;
 203: v2f_light = o.light;
 204: 
 205: }

[12:29:42] [main/ERROR]: Shader compilation log for flywheel:block.frag: No errors.

[12:29:42] [main/ERROR]: Source for shader 'flywheel:block.frag':
   1: #version 110
   2: #define DEBUG_RAINBOW
   3: 
   4: #if defined(USE_FOG)
   5: varying float FragDistance;
   6: uniform vec4 uFogColor;
   7: #endif
   8: 
   9: #if defined(USE_FOG_LINEAR)
  10: uniform vec2 uFogRange;
  11: 
  12: float FLWFogFactor() {
  13:     return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
  14: }
  15:     #endif
  16: 
  17:     #if defined(USE_FOG_EXP2)
  18: uniform float uFogDensity;
  19: 
  20: float FLWFogFactor() {
  21:     float dist = FragDistance * uFogDensity;
  22:     return 1. / exp2(dist * dist);
  23: }
  24:     #endif
  25: // Adjust the [0,1] normalized lightmap value based on the texture matrix from LightTexture#enableLightmap
  26: vec2 shiftLight(vec2 lm) {
  27:     return lm * 0.99609375 + 0.03125;// * 255/256 + 1/32
  28: }
  29: 
  30: varying vec3 BoxCoord;
  31: varying vec2 BoxLight;
  32: uniform sampler3D uLightVolume;
  33: 
  34: uniform sampler2D uBlockAtlas;
  35: uniform sampler2D uLightMap;
  36: 
  37: vec4 FLWBlockTexture(vec2 texCoords) {
  38:     return texture2D(uBlockAtlas, texCoords);
  39: }
  40: 
  41: void FLWFinalizeColor(vec4 color) {
  42:     #if defined(USE_FOG)
  43:     float a = color.a;
  44:     float fog = clamp(FLWFogFactor(), 0., 1.);
  45: 
  46:     color = mix(uFogColor, color, fog);
  47:     color.a = a;
  48:     #endif
  49: 
  50:     gl_FragColor = color;
  51: }
  52: 
  53: vec4 FLWLight(vec2 lightCoords) {
  54:     lightCoords = max(lightCoords, texture3D(uLightVolume, BoxCoord).rg);
  55: 
  56:     return texture2D(uLightMap, shiftLight(lightCoords));
  57: }
  58: 
  59: 
  60: 
  61: struct BlockFrag {
  62:     vec2 texCoords;
  63:     vec4 color;
  64:     float diffuse;
  65:     vec2 light;
  66: };
  67: 
  68: void FLWMain(BlockFrag r) {
  69:     vec4 tex = FLWBlockTexture(r.texCoords);
  70: 
  71:     vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;
  72: 
  73: //    flw_WorldPos = ;
  74: //    flw_Normal = ;
  75: //    flw_Albedo = tex.rgb;
  76: //    flw_Alpha = tex.a;
  77: //    flw_LightMap = r.light;
  78: //    flw_Tint = r.color;
  79:     FLWFinalizeColor(color);
  80: }
  81: 
  82: varying vec2 v2f_texCoords;
  83: varying vec4 v2f_color;
  84: varying float v2f_diffuse;
  85: varying vec2 v2f_light;
  86: 
  87: 
  88: //vec3 flw_WorldPos;
  89: //vec3 flw_Normal;
  90: //vec3 flw_Albedo;
  91: //float flw_Alpha;
  92: //vec2 flw_LightMap;
  93: //vec4 flw_Tint;
  94: 
  95: void main() {
  96:     BlockFrag f;
  97:     f.texCoords = v2f_texCoords;
  98: f.color = v2f_color;
  99: f.diffuse = v2f_diffuse;
 100: f.light = v2f_light;
 101: 
 102: 
 103:     FLWMain(f);
 104: }

[12:29:42] [main/ERROR]: Shader compilation log for create:belt.vert: No errors.

[12:29:42] [main/ERROR]: Source for shader 'create:belt.vert':
   1: #version 110
   2: #define DEBUG_NORMAL
   3: 
   4: #define PI 3.1415926538
   5: 
   6: #if defined(USE_FOG)
   7: varying float FragDistance;
   8: #endif
   9: 
  10: varying vec3 BoxCoord;
  11: 
  12: uniform vec3 uLightBoxSize;
  13: uniform vec3 uLightBoxMin;
  14: uniform mat4 uModel;
  15: 
  16: uniform float uTime;
  17: uniform mat4 uViewProjection;
  18: uniform vec3 uCameraPos;
  19: 
  20: void FLWFinalizeWorldPos(inout vec4 worldPos) {
  21:     worldPos = uModel * worldPos;
  22: 
  23:     BoxCoord = (worldPos.xyz - uLightBoxMin) / uLightBoxSize;
  24: 
  25:     #if defined(USE_FOG)
  26:     FragDistance = length(worldPos.xyz);
  27:     #endif
  28: 
  29:     gl_Position = uViewProjection * worldPos;
  30: }
  31: 
  32: void FLWFinalizeNormal(inout vec3 normal) {
  33:     mat3 m;
  34:     m[0] = uModel[0].xyz;
  35:     m[1] = uModel[1].xyz;
  36:     m[2] = uModel[2].xyz;
  37:     normal = m * normal;
  38: }
  39: 
  40: 
  41: 
  42: #define PIOVER2 1.5707963268
  43: 
  44: vec4 quat(vec3 axis, float angle) {
  45:     float halfAngle = angle * PIOVER2 / 180.0;
  46:     vec2 cs = sin(vec2(PIOVER2 - halfAngle, halfAngle)); // compute sin and cos in one instruction
  47:     return vec4(axis.xyz * cs.y,  cs.x);
  48: }
  49: 
  50: vec4 quatMult(vec4 q1, vec4 q2) {
  51:     // disgustingly vectorized quaternion multiplication
  52:     vec4 a = q1.w * q2.xyzw;
  53:     vec4 b = q1.x * q2.wzxy * vec4(1., -1., 1., -1.);
  54:     vec4 c = q1.y * q2.zwxy * vec4(1., 1., -1., -1.);
  55:     vec4 d = q1.z * q2.yxwz * vec4(-1., 1., 1., -1.);
  56: 
  57:     return a + b + c + d;
  58: }
  59: 
  60: vec3 rotateVertexByQuat(vec3 v, vec4 q) {
  61:     vec3 i = q.xyz;
  62:     return v + 2.0 * cross(i, cross(i, v) + q.w * v);
  63: }
  64: 
  65: vec3 rotateAbout(vec3 v, vec3 axis, float angle) {
  66:     return rotateVertexByQuat(v, quat(axis, angle));
  67: }
  68: 
  69: mat4 rotate(vec3 axis, float angle) {
  70:     float s = sin(angle);
  71:     float c = cos(angle);
  72:     float oc = 1. - c;
  73: 
  74:     vec3 sa = axis * s;
  75: 
  76:     mat4 mr = mat4(1.);
  77:     mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
  78:     mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
  79:     mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);
  80: 
  81:     return mr;
  82: }
  83: 
  84: mat4 rotation(vec3 rot) {
  85:     return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
  86: }
  87: 
  88: mat3 modelToNormal(mat4 mat) {
  89:     // Discard the edges. This won't be accurate for scaled or skewed matrices,
  90:     // but we don't have to work with those often.
  91:     mat3 m;
  92:     m[0] = mat[0].xyz;
  93:     m[1] = mat[1].xyz;
  94:     m[2] = mat[2].xyz;
  95:     return m;
  96: }
  97: 
  98: float diffuse(vec3 normal) {
  99:     vec3 n2 = normal * normal * vec3(.6, .25, .8);
 100:     return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
 101: }
 102: 
 103: 
 104: struct Belt {
 105:     vec2 light;
 106:     vec4 color;
 107:     vec3 pos;
 108:     float speed;
 109:     float offset;
 110:     vec4 rotation;
 111:     vec2 sourceTexture;
 112:     vec4 scrollTexture;
 113:     float scrollMult;
 114: };
 115: 
 116: 
 117: struct Vertex {
 118:     vec3 pos;
 119:     vec3 normal;
 120:     vec2 texCoords;
 121: };
 122: 
 123: struct BlockFrag {
 124:     vec2 texCoords;
 125:     vec4 color;
 126:     float diffuse;
 127:     vec2 light;
 128: };
 129: 
 130: BlockFrag FLWMain(Vertex v, Belt instance) {
 131:     vec3 rotated = rotateVertexByQuat(v.pos - .5, instance.rotation) + instance.pos + .5;
 132: 
 133:     vec4 worldPos = vec4(rotated, 1.);
 134: 
 135:     vec3 norm = rotateVertexByQuat(v.normal, instance.rotation);
 136: 
 137:     FLWFinalizeWorldPos(worldPos);
 138:     FLWFinalizeNormal(norm);
 139: 
 140:     float scrollSize = instance.scrollTexture.w - instance.scrollTexture.y;
 141:     float scroll = fract(instance.speed * uTime / (31.5 * 16.) + instance.offset) * scrollSize * instance.scrollMult;
 142: 
 143:     BlockFrag b;
 144:     b.diffuse = diffuse(norm);
 145:     b.texCoords = v.texCoords - instance.sourceTexture + instance.scrollTexture.xy + vec2(0, scroll);
 146:     b.light = instance.light;
 147: 
 148:     #if defined(DEBUG_RAINBOW)
 149:     b.color = instance.color;
 150:     #elif defined(DEBUG_NORMAL)
 151:     b.color = vec4(norm, 1.);
 152:     #else
 153:     b.color = vec4(1.);
 154:     #endif
 155: 
 156:     return b;
 157: }
 158: attribute vec3 a_v_pos;
 159: attribute vec3 a_v_normal;
 160: attribute vec2 a_v_texCoords;
 161: 
 162: attribute vec2 a_i_light;
 163: attribute vec4 a_i_color;
 164: attribute vec3 a_i_pos;
 165: attribute float a_i_speed;
 166: attribute float a_i_offset;
 167: attribute vec4 a_i_rotation;
 168: attribute vec2 a_i_sourceTexture;
 169: attribute vec4 a_i_scrollTexture;
 170: attribute float a_i_scrollMult;
 171: 
 172: 
 173: varying vec2 v2f_texCoords;
 174: varying vec4 v2f_color;
 175: varying float v2f_diffuse;
 176: varying vec2 v2f_light;
 177: 
 178: 
 179: void main() {
 180:     Vertex v;
 181:     v.pos = a_v_pos;
 182: v.normal = a_v_normal;
 183: v.texCoords = a_v_texCoords;
 184: 
 185: 
 186:     Belt i;
 187:     i.light = a_i_light;
 188: i.color = a_i_color;
 189: i.pos = a_i_pos;
 190: i.speed = a_i_speed;
 191: i.offset = a_i_offset;
 192: i.rotation = a_i_rotation;
 193: i.sourceTexture = a_i_sourceTexture;
 194: i.scrollTexture = a_i_scrollTexture;
 195: i.scrollMult = a_i_scrollMult;
 196: 
 197: 
 198:     BlockFrag o = FLWMain(v, i);
 199: 
 200:     v2f_texCoords = o.texCoords;
 201: v2f_color = o.color;
 202: v2f_diffuse = o.diffuse;
 203: v2f_light = o.light;
 204: 
 205: }

[12:29:42] [main/ERROR]: Shader compilation log for flywheel:block.frag: No errors.

[12:29:42] [main/ERROR]: Source for shader 'flywheel:block.frag':
   1: #version 110
   2: #define DEBUG_NORMAL
   3: 
   4: #if defined(USE_FOG)
   5: varying float FragDistance;
   6: uniform vec4 uFogColor;
   7: #endif
   8: 
   9: #if defined(USE_FOG_LINEAR)
  10: uniform vec2 uFogRange;
  11: 
  12: float FLWFogFactor() {
  13:     return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
  14: }
  15:     #endif
  16: 
  17:     #if defined(USE_FOG_EXP2)
  18: uniform float uFogDensity;
  19: 
  20: float FLWFogFactor() {
  21:     float dist = FragDistance * uFogDensity;
  22:     return 1. / exp2(dist * dist);
  23: }
  24:     #endif
  25: // Adjust the [0,1] normalized lightmap value based on the texture matrix from LightTexture#enableLightmap
  26: vec2 shiftLight(vec2 lm) {
  27:     return lm * 0.99609375 + 0.03125;// * 255/256 + 1/32
  28: }
  29: 
  30: varying vec3 BoxCoord;
  31: varying vec2 BoxLight;
  32: uniform sampler3D uLightVolume;
  33: 
  34: uniform sampler2D uBlockAtlas;
  35: uniform sampler2D uLightMap;
  36: 
  37: vec4 FLWBlockTexture(vec2 texCoords) {
  38:     return texture2D(uBlockAtlas, texCoords);
  39: }
  40: 
  41: void FLWFinalizeColor(vec4 color) {
  42:     #if defined(USE_FOG)
  43:     float a = color.a;
  44:     float fog = clamp(FLWFogFactor(), 0., 1.);
  45: 
  46:     color = mix(uFogColor, color, fog);
  47:     color.a = a;
  48:     #endif
  49: 
  50:     gl_FragColor = color;
  51: }
  52: 
  53: vec4 FLWLight(vec2 lightCoords) {
  54:     lightCoords = max(lightCoords, texture3D(uLightVolume, BoxCoord).rg);
  55: 
  56:     return texture2D(uLightMap, shiftLight(lightCoords));
  57: }
  58: 
  59: 
  60: 
  61: struct BlockFrag {
  62:     vec2 texCoords;
  63:     vec4 color;
  64:     float diffuse;
  65:     vec2 light;
  66: };
  67: 
  68: void FLWMain(BlockFrag r) {
  69:     vec4 tex = FLWBlockTexture(r.texCoords);
  70: 
  71:     vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;
  72: 
  73: //    flw_WorldPos = ;
  74: //    flw_Normal = ;
  75: //    flw_Albedo = tex.rgb;
  76: //    flw_Alpha = tex.a;
  77: //    flw_LightMap = r.light;
  78: //    flw_Tint = r.color;
  79:     FLWFinalizeColor(color);
  80: }
  81: 
  82: varying vec2 v2f_texCoords;
  83: varying vec4 v2f_color;
  84: varying float v2f_diffuse;
  85: varying vec2 v2f_light;
  86: 
  87: 
  88: //vec3 flw_WorldPos;
  89: //vec3 flw_Normal;
  90: //vec3 flw_Albedo;
  91: //float flw_Alpha;
  92: //vec2 flw_LightMap;
  93: //vec4 flw_Tint;
  94: 
  95: void main() {
  96:     BlockFrag f;
  97:     f.texCoords = v2f_texCoords;
  98: f.color = v2f_color;
  99: f.diffuse = v2f_diffuse;
 100: f.light = v2f_light;
 101: 
 102: 
 103:     FLWMain(f);
 104: }

[12:29:42] [Forge Version Check/INFO]: [fallingtree] Found status: UP_TO_DATE Current: 2.11.5 Target: null
[12:29:42] [Forge Version Check/INFO]: [codechickenlib] Starting version check at https://version-check.covers1624.net/check/?mod=CodeChickenLib&mc=1.16.5
[12:29:42] [main/ERROR]: Shader compilation log for create:belt.vert: No errors.

[12:29:42] [main/ERROR]: Source for shader 'create:belt.vert':
   1: #version 110
   2: #define USE_FOG
   3: #define USE_FOG_LINEAR
   4: 
   5: #define PI 3.1415926538
   6: 
   7: #if defined(USE_FOG)
   8: varying float FragDistance;
   9: #endif
  10: 
  11: varying vec3 BoxCoord;
  12: 
  13: uniform vec3 uLightBoxSize;
  14: uniform vec3 uLightBoxMin;
  15: uniform mat4 uModel;
  16: 
  17: uniform float uTime;
  18: uniform mat4 uViewProjection;
  19: uniform vec3 uCameraPos;
  20: 
  21: void FLWFinalizeWorldPos(inout vec4 worldPos) {
  22:     worldPos = uModel * worldPos;
  23: 
  24:     BoxCoord = (worldPos.xyz - uLightBoxMin) / uLightBoxSize;
  25: 
  26:     #if defined(USE_FOG)
  27:     FragDistance = length(worldPos.xyz);
  28:     #endif
  29: 
  30:     gl_Position = uViewProjection * worldPos;
  31: }
  32: 
  33: void FLWFinalizeNormal(inout vec3 normal) {
  34:     mat3 m;
  35:     m[0] = uModel[0].xyz;
  36:     m[1] = uModel[1].xyz;
  37:     m[2] = uModel[2].xyz;
  38:     normal = m * normal;
  39: }
  40: 
  41: 
  42: 
  43: #define PIOVER2 1.5707963268
  44: 
  45: vec4 quat(vec3 axis, float angle) {
  46:     float halfAngle = angle * PIOVER2 / 180.0;
  47:     vec2 cs = sin(vec2(PIOVER2 - halfAngle, halfAngle)); // compute sin and cos in one instruction
  48:     return vec4(axis.xyz * cs.y,  cs.x);
  49: }
  50: 
  51: vec4 quatMult(vec4 q1, vec4 q2) {
  52:     // disgustingly vectorized quaternion multiplication
  53:     vec4 a = q1.w * q2.xyzw;
  54:     vec4 b = q1.x * q2.wzxy * vec4(1., -1., 1., -1.);
  55:     vec4 c = q1.y * q2.zwxy * vec4(1., 1., -1., -1.);
  56:     vec4 d = q1.z * q2.yxwz * vec4(-1., 1., 1., -1.);
  57: 
  58:     return a + b + c + d;
  59: }
  60: 
  61: vec3 rotateVertexByQuat(vec3 v, vec4 q) {
  62:     vec3 i = q.xyz;
  63:     return v + 2.0 * cross(i, cross(i, v) + q.w * v);
  64: }
  65: 
  66: vec3 rotateAbout(vec3 v, vec3 axis, float angle) {
  67:     return rotateVertexByQuat(v, quat(axis, angle));
  68: }
  69: 
  70: mat4 rotate(vec3 axis, float angle) {
  71:     float s = sin(angle);
  72:     float c = cos(angle);
  73:     float oc = 1. - c;
  74: 
  75:     vec3 sa = axis * s;
  76: 
  77:     mat4 mr = mat4(1.);
  78:     mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
  79:     mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
  80:     mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);
  81: 
  82:     return mr;
  83: }
  84: 
  85: mat4 rotation(vec3 rot) {
  86:     return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
  87: }
  88: 
  89: mat3 modelToNormal(mat4 mat) {
  90:     // Discard the edges. This won't be accurate for scaled or skewed matrices,
  91:     // but we don't have to work with those often.
  92:     mat3 m;
  93:     m[0] = mat[0].xyz;
  94:     m[1] = mat[1].xyz;
  95:     m[2] = mat[2].xyz;
  96:     return m;
  97: }
  98: 
  99: float diffuse(vec3 normal) {
 100:     vec3 n2 = normal * normal * vec3(.6, .25, .8);
 101:     return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
 102: }
 103: 
 104: 
 105: struct Belt {
 106:     vec2 light;
 107:     vec4 color;
 108:     vec3 pos;
 109:     float speed;
 110:     float offset;
 111:     vec4 rotation;
 112:     vec2 sourceTexture;
 113:     vec4 scrollTexture;
 114:     float scrollMult;
 115: };
 116: 
 117: 
 118: struct Vertex {
 119:     vec3 pos;
 120:     vec3 normal;
 121:     vec2 texCoords;
 122: };
 123: 
 124: struct BlockFrag {
 125:     vec2 texCoords;
 126:     vec4 color;
 127:     float diffuse;
 128:     vec2 light;
 129: };
 130: 
 131: BlockFrag FLWMain(Vertex v, Belt instance) {
 132:     vec3 rotated = rotateVertexByQuat(v.pos - .5, instance.rotation) + instance.pos + .5;
 133: 
 134:     vec4 worldPos = vec4(rotated, 1.);
 135: 
 136:     vec3 norm = rotateVertexByQuat(v.normal, instance.rotation);
 137: 
 138:     FLWFinalizeWorldPos(worldPos);
 139:     FLWFinalizeNormal(norm);
 140: 
 141:     float scrollSize = instance.scrollTexture.w - instance.scrollTexture.y;
 142:     float scroll = fract(instance.speed * uTime / (31.5 * 16.) + instance.offset) * scrollSize * instance.scrollMult;
 143: 
 144:     BlockFrag b;
 145:     b.diffuse = diffuse(norm);
 146:     b.texCoords = v.texCoords - instance.sourceTexture + instance.scrollTexture.xy + vec2(0, scroll);
 147:     b.light = instance.light;
 148: 
 149:     #if defined(DEBUG_RAINBOW)
 150:     b.color = instance.color;
 151:     #elif defined(DEBUG_NORMAL)
 152:     b.color = vec4(norm, 1.);
 153:     #else
 154:     b.color = vec4(1.);
 155:     #endif
 156: 
 157:     return b;
 158: }
 159: attribute vec3 a_v_pos;
 160: attribute vec3 a_v_normal;
 161: attribute vec2 a_v_texCoords;
 162: 
 163: attribute vec2 a_i_light;
 164: attribute vec4 a_i_color;
 165: attribute vec3 a_i_pos;
 166: attribute float a_i_speed;
 167: attribute float a_i_offset;
 168: attribute vec4 a_i_rotation;
 169: attribute vec2 a_i_sourceTexture;
 170: attribute vec4 a_i_scrollTexture;
 171: attribute float a_i_scrollMult;
 172: 
 173: 
 174: varying vec2 v2f_texCoords;
 175: varying vec4 v2f_color;
 176: varying float v2f_diffuse;
 177: varying vec2 v2f_light;
 178: 
 179: 
 180: void main() {
 181:     Vertex v;
 182:     v.pos = a_v_pos;
 183: v.normal = a_v_normal;
 184: v.texCoords = a_v_texCoords;
 185: 
 186: 
 187:     Belt i;
 188:     i.light = a_i_light;
 189: i.color = a_i_color;
 190: i.pos = a_i_pos;
 191: i.speed = a_i_speed;
 192: i.offset = a_i_offset;
 193: i.rotation = a_i_rotation;
 194: i.sourceTexture = a_i_sourceTexture;
 195: i.scrollTexture = a_i_scrollTexture;
 196: i.scrollMult = a_i_scrollMult;
 197: 
 198: 
 199:     BlockFrag o = FLWMain(v, i);
 200: 
 201:     v2f_texCoords = o.texCoords;
 202: v2f_color = o.color;
 203: v2f_diffuse = o.diffuse;
 204: v2f_light = o.light;
 205: 
 206: }

[12:29:42] [main/ERROR]: Shader compilation log for flywheel:block.frag: No errors.

[12:29:42] [main/ERROR]: Source for shader 'flywheel:block.frag':
   1: #version 110
   2: #define USE_FOG
   3: #define USE_FOG_LINEAR
   4: 
   5: #if defined(USE_FOG)
   6: varying float FragDistance;
   7: uniform vec4 uFogColor;
   8: #endif
   9: 
  10: #if defined(USE_FOG_LINEAR)
  11: uniform vec2 uFogRange;
  12: 
  13: float FLWFogFactor() {
  14:     return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
  15: }
  16:     #endif
  17: 
  18:     #if defined(USE_FOG_EXP2)
  19: uniform float uFogDensity;
  20: 
  21: float FLWFogFactor() {
  22:     float dist = FragDistance * uFogDensity;
  23:     return 1. / exp2(dist * dist);
  24: }
  25:     #endif
  26: // Adjust the [0,1] normalized lightmap value based on the texture matrix from LightTexture#enableLightmap
  27: vec2 shiftLight(vec2 lm) {
  28:     return lm * 0.99609375 + 0.03125;// * 255/256 + 1/32
  29: }
  30: 
  31: varying vec3 BoxCoord;
  32: varying vec2 BoxLight;
  33: uniform sampler3D uLightVolume;
  34: 
  35: uniform sampler2D uBlockAtlas;
  36: uniform sampler2D uLightMap;
  37: 
  38: vec4 FLWBlockTexture(vec2 texCoords) {
  39:     return texture2D(uBlockAtlas, texCoords);
  40: }
  41: 
  42: void FLWFinalizeColor(vec4 color) {
  43:     #if defined(USE_FOG)
  44:     float a = color.a;
  45:     float fog = clamp(FLWFogFactor(), 0., 1.);
  46: 
  47:     color = mix(uFogColor, color, fog);
  48:     color.a = a;
  49:     #endif
  50: 
  51:     gl_FragColor = color;
  52: }
  53: 
  54: vec4 FLWLight(vec2 lightCoords) {
  55:     lightCoords = max(lightCoords, texture3D(uLightVolume, BoxCoord).rg);
  56: 
  57:     return texture2D(uLightMap, shiftLight(lightCoords));
  58: }
  59: 
  60: 
  61: 
  62: struct BlockFrag {
  63:     vec2 texCoords;
  64:     vec4 color;
  65:     float diffuse;
  66:     vec2 light;
  67: };
  68: 
  69: void FLWMain(BlockFrag r) {
  70:     vec4 tex = FLWBlockTexture(r.texCoords);
  71: 
  72:     vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;
  73: 
  74: //    flw_WorldPos = ;
  75: //    flw_Normal = ;
  76: //    flw_Albedo = tex.rgb;
  77: //    flw_Alpha = tex.a;
  78: //    flw_LightMap = r.light;
  79: //    flw_Tint = r.color;
  80:     FLWFinalizeColor(color);
  81: }
  82: 
  83: varying vec2 v2f_texCoords;
  84: varying vec4 v2f_color;
  85: varying float v2f_diffuse;
  86: varying vec2 v2f_light;
  87: 
  88: 
  89: //vec3 flw_WorldPos;
  90: //vec3 flw_Normal;
  91: //vec3 flw_Albedo;
  92: //float flw_Alpha;
  93: //vec2 flw_LightMap;
  94: //vec4 flw_Tint;
  95: 
  96: void main() {
  97:     BlockFrag f;
  98:     f.texCoords = v2f_texCoords;
  99: f.color = v2f_color;
 100: f.diffuse = v2f_diffuse;
 101: f.light = v2f_light;
 102: 
 103: 
 104:     FLWMain(f);
 105: }

[12:29:42] [main/ERROR]: Shader compilation log for create:belt.vert: No errors.

[12:29:42] [main/ERROR]: Source for shader 'create:belt.vert':
   1: #version 110
   2: #define USE_FOG
   3: #define USE_FOG_EXP2
   4: 
   5: #define PI 3.1415926538
   6: 
   7: #if defined(USE_FOG)
   8: varying float FragDistance;
   9: #endif
  10: 
  11: varying vec3 BoxCoord;
  12: 
  13: uniform vec3 uLightBoxSize;
  14: uniform vec3 uLightBoxMin;
  15: uniform mat4 uModel;
  16: 
  17: uniform float uTime;
  18: uniform mat4 uViewProjection;
  19: uniform vec3 uCameraPos;
  20: 
  21: void FLWFinalizeWorldPos(inout vec4 worldPos) {
  22:     worldPos = uModel * worldPos;
  23: 
  24:     BoxCoord = (worldPos.xyz - uLightBoxMin) / uLightBoxSize;
  25: 
  26:     #if defined(USE_FOG)
  27:     FragDistance = length(worldPos.xyz);
  28:     #endif
  29: 
  30:     gl_Position = uViewProjection * worldPos;
  31: }
  32: 
  33: void FLWFinalizeNormal(inout vec3 normal) {
  34:     mat3 m;
  35:     m[0] = uModel[0].xyz;
  36:     m[1] = uModel[1].xyz;
  37:     m[2] = uModel[2].xyz;
  38:     normal = m * normal;
  39: }
  40: 
  41: 
  42: 
  43: #define PIOVER2 1.5707963268
  44: 
  45: vec4 quat(vec3 axis, float angle) {
  46:     float halfAngle = angle * PIOVER2 / 180.0;
  47:     vec2 cs = sin(vec2(PIOVER2 - halfAngle, halfAngle)); // compute sin and cos in one instruction
  48:     return vec4(axis.xyz * cs.y,  cs.x);
  49: }
  50: 
  51: vec4 quatMult(vec4 q1, vec4 q2) {
  52:     // disgustingly vectorized quaternion multiplication
  53:     vec4 a = q1.w * q2.xyzw;
  54:     vec4 b = q1.x * q2.wzxy * vec4(1., -1., 1., -1.);
  55:     vec4 c = q1.y * q2.zwxy * vec4(1., 1., -1., -1.);
  56:     vec4 d = q1.z * q2.yxwz * vec4(-1., 1., 1., -1.);
  57: 
  58:     return a + b + c + d;
  59: }
  60: 
  61: vec3 rotateVertexByQuat(vec3 v, vec4 q) {
  62:     vec3 i = q.xyz;
  63:     return v + 2.0 * cross(i, cross(i, v) + q.w * v);
  64: }
  65: 
  66: vec3 rotateAbout(vec3 v, vec3 axis, float angle) {
  67:     return rotateVertexByQuat(v, quat(axis, angle));
  68: }
  69: 
  70: mat4 rotate(vec3 axis, float angle) {
  71:     float s = sin(angle);
  72:     float c = cos(angle);
  73:     float oc = 1. - c;
  74: 
  75:     vec3 sa = axis * s;
  76: 
  77:     mat4 mr = mat4(1.);
  78:     mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
  79:     mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
  80:     mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);
  81: 
  82:     return mr;
  83: }
  84: 
  85: mat4 rotation(vec3 rot) {
  86:     return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
  87: }
  88: 
  89: mat3 modelToNormal(mat4 mat) {
  90:     // Discard the edges. This won't be accurate for scaled or skewed matrices,
  91:     // but we don't have to work with those often.
  92:     mat3 m;
  93:     m[0] = mat[0].xyz;
  94:     m[1] = mat[1].xyz;
  95:     m[2] = mat[2].xyz;
  96:     return m;
  97: }
  98: 
  99: float diffuse(vec3 normal) {
 100:     vec3 n2 = normal * normal * vec3(.6, .25, .8);
 101:     return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
 102: }
 103: 
 104: 
 105: struct Belt {
 106:     vec2 light;
 107:     vec4 color;
 108:     vec3 pos;
 109:     float speed;
 110:     float offset;
 111:     vec4 rotation;
 112:     vec2 sourceTexture;
 113:     vec4 scrollTexture;
 114:     float scrollMult;
 115: };
 116: 
 117: 
 118: struct Vertex {
 119:     vec3 pos;
 120:     vec3 normal;
 121:     vec2 texCoords;
 122: };
 123: 
 124: struct BlockFrag {
 125:     vec2 texCoords;
 126:     vec4 color;
 127:     float diffuse;
 128:     vec2 light;
 129: };
 130: 
 131: BlockFrag FLWMain(Vertex v, Belt instance) {
 132:     vec3 rotated = rotateVertexByQuat(v.pos - .5, instance.rotation) + instance.pos + .5;
 133: 
 134:     vec4 worldPos = vec4(rotated, 1.);
 135: 
 136:     vec3 norm = rotateVertexByQuat(v.normal, instance.rotation);
 137: 
 138:     FLWFinalizeWorldPos(worldPos);
 139:     FLWFinalizeNormal(norm);
 140: 
 141:     float scrollSize = instance.scrollTexture.w - instance.scrollTexture.y;
 142:     float scroll = fract(instance.speed * uTime / (31.5 * 16.) + instance.offset) * scrollSize * instance.scrollMult;
 143: 
 144:     BlockFrag b;
 145:     b.diffuse = diffuse(norm);
 146:     b.texCoords = v.texCoords - instance.sourceTexture + instance.scrollTexture.xy + vec2(0, scroll);
 147:     b.light = instance.light;
 148: 
 149:     #if defined(DEBUG_RAINBOW)
 150:     b.color = instance.color;
 151:     #elif defined(DEBUG_NORMAL)
 152:     b.color = vec4(norm, 1.);
 153:     #else
 154:     b.color = vec4(1.);
 155:     #endif
 156: 
 157:     return b;
 158: }
 159: attribute vec3 a_v_pos;
 160: attribute vec3 a_v_normal;
 161: attribute vec2 a_v_texCoords;
 162: 
 163: attribute vec2 a_i_light;
 164: attribute vec4 a_i_color;
 165: attribute vec3 a_i_pos;
 166: attribute float a_i_speed;
 167: attribute float a_i_offset;
 168: attribute vec4 a_i_rotation;
 169: attribute vec2 a_i_sourceTexture;
 170: attribute vec4 a_i_scrollTexture;
 171: attribute float a_i_scrollMult;
 172: 
 173: 
 174: varying vec2 v2f_texCoords;
 175: varying vec4 v2f_color;
 176: varying float v2f_diffuse;
 177: varying vec2 v2f_light;
 178: 
 179: 
 180: void main() {
 181:     Vertex v;
 182:     v.pos = a_v_pos;
 183: v.normal = a_v_normal;
 184: v.texCoords = a_v_texCoords;
 185: 
 186: 
 187:     Belt i;
 188:     i.light = a_i_light;
 189: i.color = a_i_color;
 190: i.pos = a_i_pos;
 191: i.speed = a_i_speed;
 192: i.offset = a_i_offset;
 193: i.rotation = a_i_rotation;
 194: i.sourceTexture = a_i_sourceTexture;
 195: i.scrollTexture = a_i_scrollTexture;
 196: i.scrollMult = a_i_scrollMult;
 197: 
 198: 
 199:     BlockFrag o = FLWMain(v, i);
 200: 
 201:     v2f_texCoords = o.texCoords;
 202: v2f_color = o.color;
 203: v2f_diffuse = o.diffuse;
 204: v2f_light = o.light;
 205: 
 206: }

[12:29:42] [main/ERROR]: Shader compilation log for flywheel:block.frag: No errors.

[12:29:42] [main/ERROR]: Source for shader 'flywheel:block.frag':
   1: #version 110
   2: #define USE_FOG
   3: #define USE_FOG_EXP2
   4: 
   5: #if defined(USE_FOG)
   6: varying float FragDistance;
   7: uniform vec4 uFogColor;
   8: #endif
   9: 
  10: #if defined(USE_FOG_LINEAR)
  11: uniform vec2 uFogRange;
  12: 
  13: float FLWFogFactor() {
  14:     return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
  15: }
  16:     #endif
  17: 
  18:     #if defined(USE_FOG_EXP2)
  19: uniform float uFogDensity;
  20: 
  21: float FLWFogFactor() {
  22:     float dist = FragDistance * uFogDensity;
  23:     return 1. / exp2(dist * dist);
  24: }
  25:     #endif
  26: // Adjust the [0,1] normalized lightmap value based on the texture matrix from LightTexture#enableLightmap
  27: vec2 shiftLight(vec2 lm) {
  28:     return lm * 0.99609375 + 0.03125;// * 255/256 + 1/32
  29: }
  30: 
  31: varying vec3 BoxCoord;
  32: varying vec2 BoxLight;
  33: uniform sampler3D uLightVolume;
  34: 
  35: uniform sampler2D uBlockAtlas;
  36: uniform sampler2D uLightMap;
  37: 
  38: vec4 FLWBlockTexture(vec2 texCoords) {
  39:     return texture2D(uBlockAtlas, texCoords);
  40: }
  41: 
  42: void FLWFinalizeColor(vec4 color) {
  43:     #if defined(USE_FOG)
  44:     float a = color.a;
  45:     float fog = clamp(FLWFogFactor(), 0., 1.);
  46: 
  47:     color = mix(uFogColor, color, fog);
  48:     color.a = a;
  49:     #endif
  50: 
  51:     gl_FragColor = color;
  52: }
  53: 
  54: vec4 FLWLight(vec2 lightCoords) {
  55:     lightCoords = max(lightCoords, texture3D(uLightVolume, BoxCoord).rg);
  56: 
  57:     return texture2D(uLightMap, shiftLight(lightCoords));
  58: }
  59: 
  60: 
  61: 
  62: struct BlockFrag {
  63:     vec2 texCoords;
  64:     vec4 color;
  65:     float diffuse;
  66:     vec2 light;
  67: };
  68: 
  69: void FLWMain(BlockFrag r) {
  70:     vec4 tex = FLWBlockTexture(r.texCoords);
  71: 
  72:     vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;
  73: 
  74: //    flw_WorldPos = ;
  75: //    flw_Normal = ;
  76: //    flw_Albedo = tex.rgb;
  77: //    flw_Alpha = tex.a;
  78: //    flw_LightMap = r.light;
  79: //    flw_Tint = r.color;
  80:     FLWFinalizeColor(color);
  81: }
  82: 
  83: varying vec2 v2f_texCoords;
  84: varying vec4 v2f_color;
  85: varying float v2f_diffuse;
  86: varying vec2 v2f_light;
  87: 
  88: 
  89: //vec3 flw_WorldPos;
  90: //vec3 flw_Normal;
  91: //vec3 flw_Albedo;
  92: //float flw_Alpha;
  93: //vec2 flw_LightMap;
  94: //vec4 flw_Tint;
  95: 
  96: void main() {
  97:     BlockFrag f;
  98:     f.texCoords = v2f_texCoords;
  99: f.color = v2f_color;
 100: f.diffuse = v2f_diffuse;
 101: f.light = v2f_light;
 102: 
 103: 
 104:     FLWMain(f);
 105: }

[12:29:42] [main/ERROR]: Shader compilation log for create:belt.vert: No errors.

[12:29:42] [main/ERROR]: Source for shader 'create:belt.vert':
   1: #version 110
   2: 
   3: #define PI 3.1415926538
   4: 
   5: #if defined(USE_FOG)
   6: varying float FragDistance;
   7: #endif
   8: 
   9: varying vec3 BoxCoord;
  10: 
  11: uniform vec3 uLightBoxSize;
  12: uniform vec3 uLightBoxMin;
  13: uniform mat4 uModel;
  14: 
  15: uniform float uTime;
  16: uniform mat4 uViewProjection;
  17: uniform vec3 uCameraPos;
  18: 
  19: void FLWFinalizeWorldPos(inout vec4 worldPos) {
  20:     worldPos = uModel * worldPos;
  21: 
  22:     BoxCoord = (worldPos.xyz - uLightBoxMin) / uLightBoxSize;
  23: 
  24:     #if defined(USE_FOG)
  25:     FragDistance = length(worldPos.xyz);
  26:     #endif
  27: 
  28:     gl_Position = uViewProjection * worldPos;
  29: }
  30: 
  31: void FLWFinalizeNormal(inout vec3 normal) {
  32:     mat3 m;
  33:     m[0] = uModel[0].xyz;
  34:     m[1] = uModel[1].xyz;
  35:     m[2] = uModel[2].xyz;
  36:     normal = m * normal;
  37: }
  38: 
  39: 
  40: 
  41: #define PIOVER2 1.5707963268
  42: 
  43: vec4 quat(vec3 axis, float angle) {
  44:     float halfAngle = angle * PIOVER2 / 180.0;
  45:     vec2 cs = sin(vec2(PIOVER2 - halfAngle, halfAngle)); // compute sin and cos in one instruction
  46:     return vec4(axis.xyz * cs.y,  cs.x);
  47: }
  48: 
  49: vec4 quatMult(vec4 q1, vec4 q2) {
  50:     // disgustingly vectorized quaternion multiplication
  51:     vec4 a = q1.w * q2.xyzw;
  52:     vec4 b = q1.x * q2.wzxy * vec4(1., -1., 1., -1.);
  53:     vec4 c = q1.y * q2.zwxy * vec4(1., 1., -1., -1.);
  54:     vec4 d = q1.z * q2.yxwz * vec4(-1., 1., 1., -1.);
  55: 
  56:     return a + b + c + d;
  57: }
  58: 
  59: vec3 rotateVertexByQuat(vec3 v, vec4 q) {
  60:     vec3 i = q.xyz;
  61:     return v + 2.0 * cross(i, cross(i, v) + q.w * v);
  62: }
  63: 
  64: vec3 rotateAbout(vec3 v, vec3 axis, float angle) {
  65:     return rotateVertexByQuat(v, quat(axis, angle));
  66: }
  67: 
  68: mat4 rotate(vec3 axis, float angle) {
  69:     float s = sin(angle);
  70:     float c = cos(angle);
  71:     float oc = 1. - c;
  72: 
  73:     vec3 sa = axis * s;
  74: 
  75:     mat4 mr = mat4(1.);
  76:     mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
  77:     mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
  78:     mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);
  79: 
  80:     return mr;
  81: }
  82: 
  83: mat4 rotation(vec3 rot) {
  84:     return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
  85: }
  86: 
  87: mat3 modelToNormal(mat4 mat) {
  88:     // Discard the edges. This won't be accurate for scaled or skewed matrices,
  89:     // but we don't have to work with those often.
  90:     mat3 m;
  91:     m[0] = mat[0].xyz;
  92:     m[1] = mat[1].xyz;
  93:     m[2] = mat[2].xyz;
  94:     return m;
  95: }
  96: 
  97: float diffuse(vec3 normal) {
  98:     vec3 n2 = normal * normal * vec3(.6, .25, .8);
  99:     return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
 100: }
 101: 
 102: 
 103: struct Belt {
 104:     vec2 light;
 105:     vec4 color;
 106:     vec3 pos;
 107:     float speed;
 108:     float offset;
 109:     vec4 rotation;
 110:     vec2 sourceTexture;
 111:     vec4 scrollTexture;
 112:     float scrollMult;
 113: };
 114: 
 115: 
 116: struct Vertex {
 117:     vec3 pos;
 118:     vec3 normal;
 119:     vec2 texCoords;
 120: };
 121: 
 122: struct BlockFrag {
 123:     vec2 texCoords;
 124:     vec4 color;
 125:     float diffuse;
 126:     vec2 light;
 127: };
 128: 
 129: BlockFrag FLWMain(Vertex v, Belt instance) {
 130:     vec3 rotated = rotateVertexByQuat(v.pos - .5, instance.rotation) + instance.pos + .5;
 131: 
 132:     vec4 worldPos = vec4(rotated, 1.);
 133: 
 134:     vec3 norm = rotateVertexByQuat(v.normal, instance.rotation);
 135: 
 136:     FLWFinalizeWorldPos(worldPos);
 137:     FLWFinalizeNormal(norm);
 138: 
 139:     float scrollSize = instance.scrollTexture.w - instance.scrollTexture.y;
 140:     float scroll = fract(instance.speed * uTime / (31.5 * 16.) + instance.offset) * scrollSize * instance.scrollMult;
 141: 
 142:     BlockFrag b;
 143:     b.diffuse = diffuse(norm);
 144:     b.texCoords = v.texCoords - instance.sourceTexture + instance.scrollTexture.xy + vec2(0, scroll);
 145:     b.light = instance.light;
 146: 
 147:     #if defined(DEBUG_RAINBOW)
 148:     b.color = instance.color;
 149:     #elif defined(DEBUG_NORMAL)
 150:     b.color = vec4(norm, 1.);
 151:     #else
 152:     b.color = vec4(1.);
 153:     #endif
 154: 
 155:     return b;
 156: }
 157: attribute vec3 a_v_pos;
 158: attribute vec3 a_v_normal;
 159: attribute vec2 a_v_texCoords;
 160: 
 161: attribute vec2 a_i_light;
 162: attribute vec4 a_i_color;
 163: attribute vec3 a_i_pos;
 164: attribute float a_i_speed;
 165: attribute float a_i_offset;
 166: attribute vec4 a_i_rotation;
 167: attribute vec2 a_i_sourceTexture;
 168: attribute vec4 a_i_scrollTexture;
 169: attribute float a_i_scrollMult;
 170: 
 171: 
 172: varying vec2 v2f_texCoords;
 173: varying vec4 v2f_color;
 174: varying float v2f_diffuse;
 175: varying vec2 v2f_light;
 176: 
 177: 
 178: void main() {
 179:     Vertex v;
 180:     v.pos = a_v_pos;
 181: v.normal = a_v_normal;
 182: v.texCoords = a_v_texCoords;
 183: 
 184: 
 185:     Belt i;
 186:     i.light = a_i_light;
 187: i.color = a_i_color;
 188: i.pos = a_i_pos;
 189: i.speed = a_i_speed;
 190: i.offset = a_i_offset;
 191: i.rotation = a_i_rotation;
 192: i.sourceTexture = a_i_sourceTexture;
 193: i.scrollTexture = a_i_scrollTexture;
 194: i.scrollMult = a_i_scrollMult;
 195: 
 196: 
 197:     BlockFrag o = FLWMain(v, i);
 198: 
 199:     v2f_texCoords = o.texCoords;
 200: v2f_color = o.color;
 201: v2f_diffuse = o.diffuse;
 202: v2f_light = o.light;
 203: 
 204: }

[12:29:42] [main/ERROR]: Shader compilation log for flywheel:block.frag: No errors.

[12:29:42] [main/ERROR]: Source for shader 'flywheel:block.frag':
   1: #version 110
   2: 
   3: #if defined(USE_FOG)
   4: varying float FragDistance;
   5: uniform vec4 uFogColor;
   6: #endif
   7: 
   8: #if defined(USE_FOG_LINEAR)
   9: uniform vec2 uFogRange;
  10: 
  11: float FLWFogFactor() {
  12:     return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
  13: }
  14:     #endif
  15: 
  16:     #if defined(USE_FOG_EXP2)
  17: uniform float uFogDensity;
  18: 
  19: float FLWFogFactor() {
  20:     float dist = FragDistance * uFogDensity;
  21:     return 1. / exp2(dist * dist);
  22: }
  23:     #endif
  24: // Adjust the [0,1] normalized lightmap value based on the texture matrix from LightTexture#enableLightmap
  25: vec2 shiftLight(vec2 lm) {
  26:     return lm * 0.99609375 + 0.03125;// * 255/256 + 1/32
  27: }
  28: 
  29: varying vec3 BoxCoord;
  30: varying vec2 BoxLight;
  31: uniform sampler3D uLightVolume;
  32: 
  33: uniform sampler2D uBlockAtlas;
  34: uniform sampler2D uLightMap;
  35: 
  36: vec4 FLWBlockTexture(vec2 texCoords) {
  37:     return texture2D(uBlockAtlas, texCoords);
  38: }
  39: 
  40: void FLWFinalizeColor(vec4 color) {
  41:     #if defined(USE_FOG)
  42:     float a = color.a;
  43:     float fog = clamp(FLWFogFactor(), 0., 1.);
  44: 
  45:     color = mix(uFogColor, color, fog);
  46:     color.a = a;
  47:     #endif
  48: 
  49:     gl_FragColor = color;
  50: }
  51: 
  52: vec4 FLWLight(vec2 lightCoords) {
  53:     lightCoords = max(lightCoords, texture3D(uLightVolume, BoxCoord).rg);
  54: 
  55:     return texture2D(uLightMap, shiftLight(lightCoords));
  56: }
  57: 
  58: 
  59: 
  60: struct BlockFrag {
  61:     vec2 texCoords;
  62:     vec4 color;
  63:     float diffuse;
  64:     vec2 light;
  65: };
  66: 
  67: void FLWMain(BlockFrag r) {
  68:     vec4 tex = FLWBlockTexture(r.texCoords);
  69: 
  70:     vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;
  71: 
  72: //    flw_WorldPos = ;
  73: //    flw_Normal = ;
  74: //    flw_Albedo = tex.rgb;
  75: //    flw_Alpha = tex.a;
  76: //    flw_LightMap = r.light;
  77: //    flw_Tint = r.color;
  78:     FLWFinalizeColor(color);
  79: }
  80: 
  81: varying vec2 v2f_texCoords;
  82: varying vec4 v2f_color;
  83: varying float v2f_diffuse;
  84: varying vec2 v2f_light;
  85: 
  86: 
  87: //vec3 flw_WorldPos;
  88: //vec3 flw_Normal;
  89: //vec3 flw_Albedo;
  90: //float flw_Alpha;
  91: //vec2 flw_LightMap;
  92: //vec4 flw_Tint;
  93: 
  94: void main() {
  95:     BlockFrag f;
  96:     f.texCoords = v2f_texCoords;
  97: f.color = v2f_color;
  98: f.diffuse = v2f_diffuse;
  99: f.light = v2f_light;
 100: 
 101: 
 102:     FLWMain(f);
 103: }

[12:29:42] [main/ERROR]: Shader compilation log for flywheel:oriented.vert: No errors.

[12:29:42] [main/ERROR]: Source for shader 'flywheel:oriented.vert':
   1: #version 110
   2: #define DEBUG_NORMAL
   3: 
   4: #if defined(USE_FOG)
   5: varying float FragDistance;
   6: #endif
   7: 
   8: varying vec3 BoxCoord;
   9: 
  10: uniform vec3 uLightBoxSize;
  11: uniform vec3 uLightBoxMin;
  12: uniform mat4 uModel;
  13: 
  14: uniform float uTime;
  15: uniform mat4 uViewProjection;
  16: uniform vec3 uCameraPos;
  17: 
  18: void FLWFinalizeWorldPos(inout vec4 worldPos) {
  19:     worldPos = uModel * worldPos;
  20: 
  21:     BoxCoord = (worldPos.xyz - uLightBoxMin) / uLightBoxSize;
  22: 
  23:     #if defined(USE_FOG)
  24:     FragDistance = length(worldPos.xyz);
  25:     #endif
  26: 
  27:     gl_Position = uViewProjection * worldPos;
  28: }
  29: 
  30: void FLWFinalizeNormal(inout vec3 normal) {
  31:     mat3 m;
  32:     m[0] = uModel[0].xyz;
  33:     m[1] = uModel[1].xyz;
  34:     m[2] = uModel[2].xyz;
  35:     normal = m * normal;
  36: }
  37: 
  38: 
  39: 
  40: mat4 rotate(vec3 axis, float angle) {
  41:     float s = sin(angle);
  42:     float c = cos(angle);
  43:     float oc = 1. - c;
  44: 
  45:     vec3 sa = axis * s;
  46: 
  47:     mat4 mr = mat4(1.);
  48:     mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
  49:     mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
  50:     mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);
  51: 
  52:     return mr;
  53: }
  54: 
  55: mat4 rotation(vec3 rot) {
  56:     return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
  57: }
  58: 
  59: mat3 modelToNormal(mat4 mat) {
  60:     // Discard the edges. This won't be accurate for scaled or skewed matrices,
  61:     // but we don't have to work with those often.
  62:     mat3 m;
  63:     m[0] = mat[0].xyz;
  64:     m[1] = mat[1].xyz;
  65:     m[2] = mat[2].xyz;
  66:     return m;
  67: }
  68: 
  69: #define PIOVER2 1.5707963268
  70: 
  71: vec4 quat(vec3 axis, float angle) {
  72:     float halfAngle = angle * PIOVER2 / 180.0;
  73:     vec2 cs = sin(vec2(PIOVER2 - halfAngle, halfAngle)); // compute sin and cos in one instruction
  74:     return vec4(axis.xyz * cs.y,  cs.x);
  75: }
  76: 
  77: vec4 quatMult(vec4 q1, vec4 q2) {
  78:     // disgustingly vectorized quaternion multiplication
  79:     vec4 a = q1.w * q2.xyzw;
  80:     vec4 b = q1.x * q2.wzxy * vec4(1., -1., 1., -1.);
  81:     vec4 c = q1.y * q2.zwxy * vec4(1., 1., -1., -1.);
  82:     vec4 d = q1.z * q2.yxwz * vec4(-1., 1., 1., -1.);
  83: 
  84:     return a + b + c + d;
  85: }
  86: 
  87: vec3 rotateVertexByQuat(vec3 v, vec4 q) {
  88:     vec3 i = q.xyz;
  89:     return v + 2.0 * cross(i, cross(i, v) + q.w * v);
  90: }
  91: 
  92: vec3 rotateAbout(vec3 v, vec3 axis, float angle) {
  93:     return rotateVertexByQuat(v, quat(axis, angle));
  94: }
  95: 
  96: float diffuse(vec3 normal) {
  97:     vec3 n2 = normal * normal * vec3(.6, .25, .8);
  98:     return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
  99: }
 100: 
 101: 
 102: struct Oriented {
 103:     vec2 light;
 104:     vec4 color;
 105:     vec3 pos;
 106:     vec3 pivot;
 107:     vec4 rotation;
 108: };
 109: 
 110: 
 111: struct Vertex {
 112:     vec3 pos;
 113:     vec3 normal;
 114:     vec2 texCoords;
 115: };
 116: 
 117: struct BlockFrag {
 118:     vec2 texCoords;
 119:     vec4 color;
 120:     float diffuse;
 121:     vec2 light;
 122: };
 123: 
 124: BlockFrag FLWMain(Vertex v, Oriented o) {
 125:     vec4 worldPos = vec4(rotateVertexByQuat(v.pos - o.pivot, o.rotation) + o.pivot + o.pos, 1.);
 126: 
 127:     vec3 norm = rotateVertexByQuat(v.normal, o.rotation);
 128: 
 129:     FLWFinalizeWorldPos(worldPos);
 130:     FLWFinalizeNormal(norm);
 131: 
 132:     BlockFrag b;
 133:     b.diffuse = diffuse(norm);
 134:     b.texCoords = v.texCoords;
 135:     b.light = o.light;
 136:     #if defined(DEBUG_NORMAL)
 137:     b.color = vec4(norm, 1.);
 138:     #else
 139:     b.color = o.color;
 140:     #endif
 141:     return b;
 142: }
 143: attribute vec3 a_v_pos;
 144: attribute vec3 a_v_normal;
 145: attribute vec2 a_v_texCoords;
 146: 
 147: attribute vec2 a_i_light;
 148: attribute vec4 a_i_color;
 149: attribute vec3 a_i_pos;
 150: attribute vec3 a_i_pivot;
 151: attribute vec4 a_i_rotation;
 152: 
 153: 
 154: varying vec2 v2f_texCoords;
 155: varying vec4 v2f_color;
 156: varying float v2f_diffuse;
 157: varying vec2 v2f_light;
 158: 
 159: 
 160: void main() {
 161:     Vertex v;
 162:     v.pos = a_v_pos;
 163: v.normal = a_v_normal;
 164: v.texCoords = a_v_texCoords;
 165: 
 166: 
 167:     Oriented i;
 168:     i.light = a_i_light;
 169: i.color = a_i_color;
 170: i.pos = a_i_pos;
 171: i.pivot = a_i_pivot;
 172: i.rotation = a_i_rotation;
 173: 
 174: 
 175:     BlockFrag o = FLWMain(v, i);
 176: 
 177:     v2f_texCoords = o.texCoords;
 178: v2f_color = o.color;
 179: v2f_diffuse = o.diffuse;
 180: v2f_light = o.light;
 181: 
 182: }

[12:29:42] [main/ERROR]: Shader compilation log for flywheel:block.frag: No errors.

[12:29:42] [main/ERROR]: Source for shader 'flywheel:block.frag':
   1: #version 110
   2: #define DEBUG_NORMAL
   3: 
   4: #if defined(USE_FOG)
   5: varying float FragDistance;
   6: uniform vec4 uFogColor;
   7: #endif
   8: 
   9: #if defined(USE_FOG_LINEAR)
  10: uniform vec2 uFogRange;
  11: 
  12: float FLWFogFactor() {
  13:     return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
  14: }
  15:     #endif
  16: 
  17:     #if defined(USE_FOG_EXP2)
  18: uniform float uFogDensity;
  19: 
  20: float FLWFogFactor() {
  21:     float dist = FragDistance * uFogDensity;
  22:     return 1. / exp2(dist * dist);
  23: }
  24:     #endif
  25: // Adjust the [0,1] normalized lightmap value based on the texture matrix from LightTexture#enableLightmap
  26: vec2 shiftLight(vec2 lm) {
  27:     return lm * 0.99609375 + 0.03125;// * 255/256 + 1/32
  28: }
  29: 
  30: varying vec3 BoxCoord;
  31: varying vec2 BoxLight;
  32: uniform sampler3D uLightVolume;
  33: 
  34: uniform sampler2D uBlockAtlas;
  35: uniform sampler2D uLightMap;
  36: 
  37: vec4 FLWBlockTexture(vec2 texCoords) {
  38:     return texture2D(uBlockAtlas, texCoords);
  39: }
  40: 
  41: void FLWFinalizeColor(vec4 color) {
  42:     #if defined(USE_FOG)
  43:     float a = color.a;
  44:     float fog = clamp(FLWFogFactor(), 0., 1.);
  45: 
  46:     color = mix(uFogColor, color, fog);
  47:     color.a = a;
  48:     #endif
  49: 
  50:     gl_FragColor = color;
  51: }
  52: 
  53: vec4 FLWLight(vec2 lightCoords) {
  54:     lightCoords = max(lightCoords, texture3D(uLightVolume, BoxCoord).rg);
  55: 
  56:     return texture2D(uLightMap, shiftLight(lightCoords));
  57: }
  58: 
  59: 
  60: 
  61: struct BlockFrag {
  62:     vec2 texCoords;
  63:     vec4 color;
  64:     float diffuse;
  65:     vec2 light;
  66: };
  67: 
  68: void FLWMain(BlockFrag r) {
  69:     vec4 tex = FLWBlockTexture(r.texCoords);
  70: 
  71:     vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;
  72: 
  73: //    flw_WorldPos = ;
  74: //    flw_Normal = ;
  75: //    flw_Albedo = tex.rgb;
  76: //    flw_Alpha = tex.a;
  77: //    flw_LightMap = r.light;
  78: //    flw_Tint = r.color;
  79:     FLWFinalizeColor(color);
  80: }
  81: 
  82: varying vec2 v2f_texCoords;
  83: varying vec4 v2f_color;
  84: varying float v2f_diffuse;
  85: varying vec2 v2f_light;
  86: 
  87: 
  88: //vec3 flw_WorldPos;
  89: //vec3 flw_Normal;
  90: //vec3 flw_Albedo;
  91: //float flw_Alpha;
  92: //vec2 flw_LightMap;
  93: //vec4 flw_Tint;
  94: 
  95: void main() {
  96:     BlockFrag f;
  97:     f.texCoords = v2f_texCoords;
  98: f.color = v2f_color;
  99: f.diffuse = v2f_diffuse;
 100: f.light = v2f_light;
 101: 
 102: 
 103:     FLWMain(f);
 104: }

[12:29:42] [main/ERROR]: Shader compilation log for flywheel:oriented.vert: No errors.

[12:29:42] [main/ERROR]: Source for shader 'flywheel:oriented.vert':
   1: #version 110
   2: #define USE_FOG
   3: #define USE_FOG_LINEAR
   4: 
   5: #if defined(USE_FOG)
   6: varying float FragDistance;
   7: #endif
   8: 
   9: varying vec3 BoxCoord;
  10: 
  11: uniform vec3 uLightBoxSize;
  12: uniform vec3 uLightBoxMin;
  13: uniform mat4 uModel;
  14: 
  15: uniform float uTime;
  16: uniform mat4 uViewProjection;
  17: uniform vec3 uCameraPos;
  18: 
  19: void FLWFinalizeWorldPos(inout vec4 worldPos) {
  20:     worldPos = uModel * worldPos;
  21: 
  22:     BoxCoord = (worldPos.xyz - uLightBoxMin) / uLightBoxSize;
  23: 
  24:     #if defined(USE_FOG)
  25:     FragDistance = length(worldPos.xyz);
  26:     #endif
  27: 
  28:     gl_Position = uViewProjection * worldPos;
  29: }
  30: 
  31: void FLWFinalizeNormal(inout vec3 normal) {
  32:     mat3 m;
  33:     m[0] = uModel[0].xyz;
  34:     m[1] = uModel[1].xyz;
  35:     m[2] = uModel[2].xyz;
  36:     normal = m * normal;
  37: }
  38: 
  39: 
  40: 
  41: mat4 rotate(vec3 axis, float angle) {
  42:     float s = sin(angle);
  43:     float c = cos(angle);
  44:     float oc = 1. - c;
  45: 
  46:     vec3 sa = axis * s;
  47: 
  48:     mat4 mr = mat4(1.);
  49:     mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
  50:     mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
  51:     mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);
  52: 
  53:     return mr;
  54: }
  55: 
  56: mat4 rotation(vec3 rot) {
  57:     return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
  58: }
  59: 
  60: mat3 modelToNormal(mat4 mat) {
  61:     // Discard the edges. This won't be accurate for scaled or skewed matrices,
  62:     // but we don't have to work with those often.
  63:     mat3 m;
  64:     m[0] = mat[0].xyz;
  65:     m[1] = mat[1].xyz;
  66:     m[2] = mat[2].xyz;
  67:     return m;
  68: }
  69: 
  70: #define PIOVER2 1.5707963268
  71: 
  72: vec4 quat(vec3 axis, float angle) {
  73:     float halfAngle = angle * PIOVER2 / 180.0;
  74:     vec2 cs = sin(vec2(PIOVER2 - halfAngle, halfAngle)); // compute sin and cos in one instruction
  75:     return vec4(axis.xyz * cs.y,  cs.x);
  76: }
  77: 
  78: vec4 quatMult(vec4 q1, vec4 q2) {
  79:     // disgustingly vectorized quaternion multiplication
  80:     vec4 a = q1.w * q2.xyzw;
  81:     vec4 b = q1.x * q2.wzxy * vec4(1., -1., 1., -1.);
  82:     vec4 c = q1.y * q2.zwxy * vec4(1., 1., -1., -1.);
  83:     vec4 d = q1.z * q2.yxwz * vec4(-1., 1., 1., -1.);
  84: 
  85:     return a + b + c + d;
  86: }
  87: 
  88: vec3 rotateVertexByQuat(vec3 v, vec4 q) {
  89:     vec3 i = q.xyz;
  90:     return v + 2.0 * cross(i, cross(i, v) + q.w * v);
  91: }
  92: 
  93: vec3 rotateAbout(vec3 v, vec3 axis, float angle) {
  94:     return rotateVertexByQuat(v, quat(axis, angle));
  95: }
  96: 
  97: float diffuse(vec3 normal) {
  98:     vec3 n2 = normal * normal * vec3(.6, .25, .8);
  99:     return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
 100: }
 101: 
 102: 
 103: struct Oriented {
 104:     vec2 light;
 105:     vec4 color;
 106:     vec3 pos;
 107:     vec3 pivot;
 108:     vec4 rotation;
 109: };
 110: 
 111: 
 112: struct Vertex {
 113:     vec3 pos;
 114:     vec3 normal;
 115:     vec2 texCoords;
 116: };
 117: 
 118: struct BlockFrag {
 119:     vec2 texCoords;
 120:     vec4 color;
 121:     float diffuse;
 122:     vec2 light;
 123: };
 124: 
 125: BlockFrag FLWMain(Vertex v, Oriented o) {
 126:     vec4 worldPos = vec4(rotateVertexByQuat(v.pos - o.pivot, o.rotation) + o.pivot + o.pos, 1.);
 127: 
 128:     vec3 norm = rotateVertexByQuat(v.normal, o.rotation);
 129: 
 130:     FLWFinalizeWorldPos(worldPos);
 131:     FLWFinalizeNormal(norm);
 132: 
 133:     BlockFrag b;
 134:     b.diffuse = diffuse(norm);
 135:     b.texCoords = v.texCoords;
 136:     b.light = o.light;
 137:     #if defined(DEBUG_NORMAL)
 138:     b.color = vec4(norm, 1.);
 139:     #else
 140:     b.color = o.color;
 141:     #endif
 142:     return b;
 143: }
 144: attribute vec3 a_v_pos;
 145: attribute vec3 a_v_normal;
 146: attribute vec2 a_v_texCoords;
 147: 
 148: attribute vec2 a_i_light;
 149: attribute vec4 a_i_color;
 150: attribute vec3 a_i_pos;
 151: attribute vec3 a_i_pivot;
 152: attribute vec4 a_i_rotation;
 153: 
 154: 
 155: varying vec2 v2f_texCoords;
 156: varying vec4 v2f_color;
 157: varying float v2f_diffuse;
 158: varying vec2 v2f_light;
 159: 
 160: 
 161: void main() {
 162:     Vertex v;
 163:     v.pos = a_v_pos;
 164: v.normal = a_v_normal;
 165: v.texCoords = a_v_texCoords;
 166: 
 167: 
 168:     Oriented i;
 169:     i.light = a_i_light;
 170: i.color = a_i_color;
 171: i.pos = a_i_pos;
 172: i.pivot = a_i_pivot;
 173: i.rotation = a_i_rotation;
 174: 
 175: 
 176:     BlockFrag o = FLWMain(v, i);
 177: 
 178:     v2f_texCoords = o.texCoords;
 179: v2f_color = o.color;
 180: v2f_diffuse = o.diffuse;
 181: v2f_light = o.light;
 182: 
 183: }

[12:29:42] [main/ERROR]: Shader compilation log for flywheel:block.frag: No errors.

[12:29:42] [main/ERROR]: Source for shader 'flywheel:block.frag':
   1: #version 110
   2: #define USE_FOG
   3: #define USE_FOG_LINEAR
   4: 
   5: #if defined(USE_FOG)
   6: varying float FragDistance;
   7: uniform vec4 uFogColor;
   8: #endif
   9: 
  10: #if defined(USE_FOG_LINEAR)
  11: uniform vec2 uFogRange;
  12: 
  13: float FLWFogFactor() {
  14:     return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
  15: }
  16:     #endif
  17: 
  18:     #if defined(USE_FOG_EXP2)
  19: uniform float uFogDensity;
  20: 
  21: float FLWFogFactor() {
  22:     float dist = FragDistance * uFogDensity;
  23:     return 1. / exp2(dist * dist);
  24: }
  25:     #endif
  26: // Adjust the [0,1] normalized lightmap value based on the texture matrix from LightTexture#enableLightmap
  27: vec2 shiftLight(vec2 lm) {
  28:     return lm * 0.99609375 + 0.03125;// * 255/256 + 1/32
  29: }
  30: 
  31: varying vec3 BoxCoord;
  32: varying vec2 BoxLight;
  33: uniform sampler3D uLightVolume;
  34: 
  35: uniform sampler2D uBlockAtlas;
  36: uniform sampler2D uLightMap;
  37: 
  38: vec4 FLWBlockTexture(vec2 texCoords) {
  39:     return texture2D(uBlockAtlas, texCoords);
  40: }
  41: 
  42: void FLWFinalizeColor(vec4 color) {
  43:     #if defined(USE_FOG)
  44:     float a = color.a;
  45:     float fog = clamp(FLWFogFactor(), 0., 1.);
  46: 
  47:     color = mix(uFogColor, color, fog);
  48:     color.a = a;
  49:     #endif
  50: 
  51:     gl_FragColor = color;
  52: }
  53: 
  54: vec4 FLWLight(vec2 lightCoords) {
  55:     lightCoords = max(lightCoords, texture3D(uLightVolume, BoxCoord).rg);
  56: 
  57:     return texture2D(uLightMap, shiftLight(lightCoords));
  58: }
  59: 
  60: 
  61: 
  62: struct BlockFrag {
  63:     vec2 texCoords;
  64:     vec4 color;
  65:     float diffuse;
  66:     vec2 light;
  67: };
  68: 
  69: void FLWMain(BlockFrag r) {
  70:     vec4 tex = FLWBlockTexture(r.texCoords);
  71: 
  72:     vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;
  73: 
  74: //    flw_WorldPos = ;
  75: //    flw_Normal = ;
  76: //    flw_Albedo = tex.rgb;
  77: //    flw_Alpha = tex.a;
  78: //    flw_LightMap = r.light;
  79: //    flw_Tint = r.color;
  80:     FLWFinalizeColor(color);
  81: }
  82: 
  83: varying vec2 v2f_texCoords;
  84: varying vec4 v2f_color;
  85: varying float v2f_diffuse;
  86: varying vec2 v2f_light;
  87: 
  88: 
  89: //vec3 flw_WorldPos;
  90: //vec3 flw_Normal;
  91: //vec3 flw_Albedo;
  92: //float flw_Alpha;
  93: //vec2 flw_LightMap;
  94: //vec4 flw_Tint;
  95: 
  96: void main() {
  97:     BlockFrag f;
  98:     f.texCoords = v2f_texCoords;
  99: f.color = v2f_color;
 100: f.diffuse = v2f_diffuse;
 101: f.light = v2f_light;
 102: 
 103: 
 104:     FLWMain(f);
 105: }

[12:29:42] [main/ERROR]: Shader compilation log for flywheel:oriented.vert: No errors.

[12:29:42] [main/ERROR]: Source for shader 'flywheel:oriented.vert':
   1: #version 110
   2: #define USE_FOG
   3: #define USE_FOG_EXP2
   4: 
   5: #if defined(USE_FOG)
   6: varying float FragDistance;
   7: #endif
   8: 
   9: varying vec3 BoxCoord;
  10: 
  11: uniform vec3 uLightBoxSize;
  12: uniform vec3 uLightBoxMin;
  13: uniform mat4 uModel;
  14: 
  15: uniform float uTime;
  16: uniform mat4 uViewProjection;
  17: uniform vec3 uCameraPos;
  18: 
  19: void FLWFinalizeWorldPos(inout vec4 worldPos) {
  20:     worldPos = uModel * worldPos;
  21: 
  22:     BoxCoord = (worldPos.xyz - uLightBoxMin) / uLightBoxSize;
  23: 
  24:     #if defined(USE_FOG)
  25:     FragDistance = length(worldPos.xyz);
  26:     #endif
  27: 
  28:     gl_Position = uViewProjection * worldPos;
  29: }
  30: 
  31: void FLWFinalizeNormal(inout vec3 normal) {
  32:     mat3 m;
  33:     m[0] = uModel[0].xyz;
  34:     m[1] = uModel[1].xyz;
  35:     m[2] = uModel[2].xyz;
  36:     normal = m * normal;
  37: }
  38: 
  39: 
  40: 
  41: mat4 rotate(vec3 axis, float angle) {
  42:     float s = sin(angle);
  43:     float c = cos(angle);
  44:     float oc = 1. - c;
  45: 
  46:     vec3 sa = axis * s;
  47: 
  48:     mat4 mr = mat4(1.);
  49:     mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
  50:     mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
  51:     mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);
  52: 
  53:     return mr;
  54: }
  55: 
  56: mat4 rotation(vec3 rot) {
  57:     return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
  58: }
  59: 
  60: mat3 modelToNormal(mat4 mat) {
  61:     // Discard the edges. This won't be accurate for scaled or skewed matrices,
  62:     // but we don't have to work with those often.
  63:     mat3 m;
  64:     m[0] = mat[0].xyz;
  65:     m[1] = mat[1].xyz;
  66:     m[2] = mat[2].xyz;
  67:     return m;
  68: }
  69: 
  70: #define PIOVER2 1.5707963268
  71: 
  72: vec4 quat(vec3 axis, float angle) {
  73:     float halfAngle = angle * PIOVER2 / 180.0;
  74:     vec2 cs = sin(vec2(PIOVER2 - halfAngle, halfAngle)); // compute sin and cos in one instruction
  75:     return vec4(axis.xyz * cs.y,  cs.x);
  76: }
  77: 
  78: vec4 quatMult(vec4 q1, vec4 q2) {
  79:     // disgustingly vectorized quaternion multiplication
  80:     vec4 a = q1.w * q2.xyzw;
  81:     vec4 b = q1.x * q2.wzxy * vec4(1., -1., 1., -1.);
  82:     vec4 c = q1.y * q2.zwxy * vec4(1., 1., -1., -1.);
  83:     vec4 d = q1.z * q2.yxwz * vec4(-1., 1., 1., -1.);
  84: 
  85:     return a + b + c + d;
  86: }
  87: 
  88: vec3 rotateVertexByQuat(vec3 v, vec4 q) {
  89:     vec3 i = q.xyz;
  90:     return v + 2.0 * cross(i, cross(i, v) + q.w * v);
  91: }
  92: 
  93: vec3 rotateAbout(vec3 v, vec3 axis, float angle) {
  94:     return rotateVertexByQuat(v, quat(axis, angle));
  95: }
  96: 
  97: float diffuse(vec3 normal) {
  98:     vec3 n2 = normal * normal * vec3(.6, .25, .8);
  99:     return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
 100: }
 101: 
 102: 
 103: struct Oriented {
 104:     vec2 light;
 105:     vec4 color;
 106:     vec3 pos;
 107:     vec3 pivot;
 108:     vec4 rotation;
 109: };
 110: 
 111: 
 112: struct Vertex {
 113:     vec3 pos;
 114:     vec3 normal;
 115:     vec2 texCoords;
 116: };
 117: 
 118: struct BlockFrag {
 119:     vec2 texCoords;
 120:     vec4 color;
 121:     float diffuse;
 122:     vec2 light;
 123: };
 124: 
 125: BlockFrag FLWMain(Vertex v, Oriented o) {
 126:     vec4 worldPos = vec4(rotateVertexByQuat(v.pos - o.pivot, o.rotation) + o.pivot + o.pos, 1.);
 127: 
 128:     vec3 norm = rotateVertexByQuat(v.normal, o.rotation);
 129: 
 130:     FLWFinalizeWorldPos(worldPos);
 131:     FLWFinalizeNormal(norm);
 132: 
 133:     BlockFrag b;
 134:     b.diffuse = diffuse(norm);
 135:     b.texCoords = v.texCoords;
 136:     b.light = o.light;
 137:     #if defined(DEBUG_NORMAL)
 138:     b.color = vec4(norm, 1.);
 139:     #else
 140:     b.color = o.color;
 141:     #endif
 142:     return b;
 143: }
 144: attribute vec3 a_v_pos;
 145: attribute vec3 a_v_normal;
 146: attribute vec2 a_v_texCoords;
 147: 
 148: attribute vec2 a_i_light;
 149: attribute vec4 a_i_color;
 150: attribute vec3 a_i_pos;
 151: attribute vec3 a_i_pivot;
 152: attribute vec4 a_i_rotation;
 153: 
 154: 
 155: varying vec2 v2f_texCoords;
 156: varying vec4 v2f_color;
 157: varying float v2f_diffuse;
 158: varying vec2 v2f_light;
 159: 
 160: 
 161: void main() {
 162:     Vertex v;
 163:     v.pos = a_v_pos;
 164: v.normal = a_v_normal;
 165: v.texCoords = a_v_texCoords;
 166: 
 167: 
 168:     Oriented i;
 169:     i.light = a_i_light;
 170: i.color = a_i_color;
 171: i.pos = a_i_pos;
 172: i.pivot = a_i_pivot;
 173: i.rotation = a_i_rotation;
 174: 
 175: 
 176:     BlockFrag o = FLWMain(v, i);
 177: 
 178:     v2f_texCoords = o.texCoords;
 179: v2f_color = o.color;
 180: v2f_diffuse = o.diffuse;
 181: v2f_light = o.light;
 182: 
 183: }

[12:29:42] [main/ERROR]: Shader compilation log for flywheel:block.frag: No errors.

[12:29:42] [main/ERROR]: Source for shader 'flywheel:block.frag':
   1: #version 110
   2: #define USE_FOG
   3: #define USE_FOG_EXP2
   4: 
   5: #if defined(USE_FOG)
   6: varying float FragDistance;
   7: uniform vec4 uFogColor;
   8: #endif
   9: 
  10: #if defined(USE_FOG_LINEAR)
  11: uniform vec2 uFogRange;
  12: 
  13: float FLWFogFactor() {
  14:     return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
  15: }
  16:     #endif
  17: 
  18:     #if defined(USE_FOG_EXP2)
  19: uniform float uFogDensity;
  20: 
  21: float FLWFogFactor() {
  22:     float dist = FragDistance * uFogDensity;
  23:     return 1. / exp2(dist * dist);
  24: }
  25:     #endif
  26: // Adjust the [0,1] normalized lightmap value based on the texture matrix from LightTexture#enableLightmap
  27: vec2 shiftLight(vec2 lm) {
  28:     return lm * 0.99609375 + 0.03125;// * 255/256 + 1/32
  29: }
  30: 
  31: varying vec3 BoxCoord;
  32: varying vec2 BoxLight;
  33: uniform sampler3D uLightVolume;
  34: 
  35: uniform sampler2D uBlockAtlas;
  36: uniform sampler2D uLightMap;
  37: 
  38: vec4 FLWBlockTexture(vec2 texCoords) {
  39:     return texture2D(uBlockAtlas, texCoords);
  40: }
  41: 
  42: void FLWFinalizeColor(vec4 color) {
  43:     #if defined(USE_FOG)
  44:     float a = color.a;
  45:     float fog = clamp(FLWFogFactor(), 0., 1.);
  46: 
  47:     color = mix(uFogColor, color, fog);
  48:     color.a = a;
  49:     #endif
  50: 
  51:     gl_FragColor = color;
  52: }
  53: 
  54: vec4 FLWLight(vec2 lightCoords) {
  55:     lightCoords = max(lightCoords, texture3D(uLightVolume, BoxCoord).rg);
  56: 
  57:     return texture2D(uLightMap, shiftLight(lightCoords));
  58: }
  59: 
  60: 
  61: 
  62: struct BlockFrag {
  63:     vec2 texCoords;
  64:     vec4 color;
  65:     float diffuse;
  66:     vec2 light;
  67: };
  68: 
  69: void FLWMain(BlockFrag r) {
  70:     vec4 tex = FLWBlockTexture(r.texCoords);
  71: 
  72:     vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;
  73: 
  74: //    flw_WorldPos = ;
  75: //    flw_Normal = ;
  76: //    flw_Albedo = tex.rgb;
  77: //    flw_Alpha = tex.a;
  78: //    flw_LightMap = r.light;
  79: //    flw_Tint = r.color;
  80:     FLWFinalizeColor(color);
  81: }
  82: 
  83: varying vec2 v2f_texCoords;
  84: varying vec4 v2f_color;
  85: varying float v2f_diffuse;
  86: varying vec2 v2f_light;
  87: 
  88: 
  89: //vec3 flw_WorldPos;
  90: //vec3 flw_Normal;
  91: //vec3 flw_Albedo;
  92: //float flw_Alpha;
  93: //vec2 flw_LightMap;
  94: //vec4 flw_Tint;
  95: 
  96: void main() {
  97:     BlockFrag f;
  98:     f.texCoords = v2f_texCoords;
  99: f.color = v2f_color;
 100: f.diffuse = v2f_diffuse;
 101: f.light = v2f_light;
 102: 
 103: 
 104:     FLWMain(f);
 105: }

[12:29:42] [main/ERROR]: Shader compilation log for flywheel:oriented.vert: No errors.

[12:29:42] [main/ERROR]: Source for shader 'flywheel:oriented.vert':
   1: #version 110
   2: 
   3: #if defined(USE_FOG)
   4: varying float FragDistance;
   5: #endif
   6: 
   7: varying vec3 BoxCoord;
   8: 
   9: uniform vec3 uLightBoxSize;
  10: uniform vec3 uLightBoxMin;
  11: uniform mat4 uModel;
  12: 
  13: uniform float uTime;
  14: uniform mat4 uViewProjection;
  15: uniform vec3 uCameraPos;
  16: 
  17: void FLWFinalizeWorldPos(inout vec4 worldPos) {
  18:     worldPos = uModel * worldPos;
  19: 
  20:     BoxCoord = (worldPos.xyz - uLightBoxMin) / uLightBoxSize;
  21: 
  22:     #if defined(USE_FOG)
  23:     FragDistance = length(worldPos.xyz);
  24:     #endif
  25: 
  26:     gl_Position = uViewProjection * worldPos;
  27: }
  28: 
  29: void FLWFinalizeNormal(inout vec3 normal) {
  30:     mat3 m;
  31:     m[0] = uModel[0].xyz;
  32:     m[1] = uModel[1].xyz;
  33:     m[2] = uModel[2].xyz;
  34:     normal = m * normal;
  35: }
  36: 
  37: 
  38: 
  39: mat4 rotate(vec3 axis, float angle) {
  40:     float s = sin(angle);
  41:     float c = cos(angle);
  42:     float oc = 1. - c;
  43: 
  44:     vec3 sa = axis * s;
  45: 
  46:     mat4 mr = mat4(1.);
  47:     mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
  48:     mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
  49:     mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);
  50: 
  51:     return mr;
  52: }
  53: 
  54: mat4 rotation(vec3 rot) {
  55:     return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
  56: }
  57: 
  58: mat3 modelToNormal(mat4 mat) {
  59:     // Discard the edges. This won't be accurate for scaled or skewed matrices,
  60:     // but we don't have to work with those often.
  61:     mat3 m;
  62:     m[0] = mat[0].xyz;
  63:     m[1] = mat[1].xyz;
  64:     m[2] = mat[2].xyz;
  65:     return m;
  66: }
  67: 
  68: #define PIOVER2 1.5707963268
  69: 
  70: vec4 quat(vec3 axis, float angle) {
  71:     float halfAngle = angle * PIOVER2 / 180.0;
  72:     vec2 cs = sin(vec2(PIOVER2 - halfAngle, halfAngle)); // compute sin and cos in one instruction
  73:     return vec4(axis.xyz * cs.y,  cs.x);
  74: }
  75: 
  76: vec4 quatMult(vec4 q1, vec4 q2) {
  77:     // disgustingly vectorized quaternion multiplication
  78:     vec4 a = q1.w * q2.xyzw;
  79:     vec4 b = q1.x * q2.wzxy * vec4(1., -1., 1., -1.);
  80:     vec4 c = q1.y * q2.zwxy * vec4(1., 1., -1., -1.);
  81:     vec4 d = q1.z * q2.yxwz * vec4(-1., 1., 1., -1.);
  82: 
  83:     return a + b + c + d;
  84: }
  85: 
  86: vec3 rotateVertexByQuat(vec3 v, vec4 q) {
  87:     vec3 i = q.xyz;
  88:     return v + 2.0 * cross(i, cross(i, v) + q.w * v);
  89: }
  90: 
  91: vec3 rotateAbout(vec3 v, vec3 axis, float angle) {
  92:     return rotateVertexByQuat(v, quat(axis, angle));
  93: }
  94: 
  95: float diffuse(vec3 normal) {
  96:     vec3 n2 = normal * normal * vec3(.6, .25, .8);
  97:     return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
  98: }
  99: 
 100: 
 101: struct Oriented {
 102:     vec2 light;
 103:     vec4 color;
 104:     vec3 pos;
 105:     vec3 pivot;
 106:     vec4 rotation;
 107: };
 108: 
 109: 
 110: struct Vertex {
 111:     vec3 pos;
 112:     vec3 normal;
 113:     vec2 texCoords;
 114: };
 115: 
 116: struct BlockFrag {
 117:     vec2 texCoords;
 118:     vec4 color;
 119:     float diffuse;
 120:     vec2 light;
 121: };
 122: 
 123: BlockFrag FLWMain(Vertex v, Oriented o) {
 124:     vec4 worldPos = vec4(rotateVertexByQuat(v.pos - o.pivot, o.rotation) + o.pivot + o.pos, 1.);
 125: 
 126:     vec3 norm = rotateVertexByQuat(v.normal, o.rotation);
 127: 
 128:     FLWFinalizeWorldPos(worldPos);
 129:     FLWFinalizeNormal(norm);
 130: 
 131:     BlockFrag b;
 132:     b.diffuse = diffuse(norm);
 133:     b.texCoords = v.texCoords;
 134:     b.light = o.light;
 135:     #if defined(DEBUG_NORMAL)
 136:     b.color = vec4(norm, 1.);
 137:     #else
 138:     b.color = o.color;
 139:     #endif
 140:     return b;
 141: }
 142: attribute vec3 a_v_pos;
 143: attribute vec3 a_v_normal;
 144: attribute vec2 a_v_texCoords;
 145: 
 146: attribute vec2 a_i_light;
 147: attribute vec4 a_i_color;
 148: attribute vec3 a_i_pos;
 149: attribute vec3 a_i_pivot;
 150: attribute vec4 a_i_rotation;
 151: 
 152: 
 153: varying vec2 v2f_texCoords;
 154: varying vec4 v2f_color;
 155: varying float v2f_diffuse;
 156: varying vec2 v2f_light;
 157: 
 158: 
 159: void main() {
 160:     Vertex v;
 161:     v.pos = a_v_pos;
 162: v.normal = a_v_normal;
 163: v.texCoords = a_v_texCoords;
 164: 
 165: 
 166:     Oriented i;
 167:     i.light = a_i_light;
 168: i.color = a_i_color;
 169: i.pos = a_i_pos;
 170: i.pivot = a_i_pivot;
 171: i.rotation = a_i_rotation;
 172: 
 173: 
 174:     BlockFrag o = FLWMain(v, i);
 175: 
 176:     v2f_texCoords = o.texCoords;
 177: v2f_color = o.color;
 178: v2f_diffuse = o.diffuse;
 179: v2f_light = o.light;
 180: 
 181: }

[12:29:42] [main/ERROR]: Shader compilation log for flywheel:block.frag: No errors.

[12:29:42] [main/ERROR]: Source for shader 'flywheel:block.frag':
   1: #version 110
   2: 
   3: #if defined(USE_FOG)
   4: varying float FragDistance;
   5: uniform vec4 uFogColor;
   6: #endif
   7: 
   8: #if defined(USE_FOG_LINEAR)
   9: uniform vec2 uFogRange;
  10: 
  11: float FLWFogFactor() {
  12:     return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
  13: }
  14:     #endif
  15: 
  16:     #if defined(USE_FOG_EXP2)
  17: uniform float uFogDensity;
  18: 
  19: float FLWFogFactor() {
  20:     float dist = FragDistance * uFogDensity;
  21:     return 1. / exp2(dist * dist);
  22: }
  23:     #endif
  24: // Adjust the [0,1] normalized lightmap value based on the texture matrix from LightTexture#enableLightmap
  25: vec2 shiftLight(vec2 lm) {
  26:     return lm * 0.99609375 + 0.03125;// * 255/256 + 1/32
  27: }
  28: 
  29: varying vec3 BoxCoord;
  30: varying vec2 BoxLight;
  31: uniform sampler3D uLightVolume;
  32: 
  33: uniform sampler2D uBlockAtlas;
  34: uniform sampler2D uLightMap;
  35: 
  36: vec4 FLWBlockTexture(vec2 texCoords) {
  37:     return texture2D(uBlockAtlas, texCoords);
  38: }
  39: 
  40: void FLWFinalizeColor(vec4 color) {
  41:     #if defined(USE_FOG)
  42:     float a = color.a;
  43:     float fog = clamp(FLWFogFactor(), 0., 1.);
  44: 
  45:     color = mix(uFogColor, color, fog);
  46:     color.a = a;
  47:     #endif
  48: 
  49:     gl_FragColor = color;
  50: }
  51: 
  52: vec4 FLWLight(vec2 lightCoords) {
  53:     lightCoords = max(lightCoords, texture3D(uLightVolume, BoxCoord).rg);
  54: 
  55:     return texture2D(uLightMap, shiftLight(lightCoords));
  56: }
  57: 
  58: 
  59: 
  60: struct BlockFrag {
  61:     vec2 texCoords;
  62:     vec4 color;
  63:     float diffuse;
  64:     vec2 light;
  65: };
  66: 
  67: void FLWMain(BlockFrag r) {
  68:     vec4 tex = FLWBlockTexture(r.texCoords);
  69: 
  70:     vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;
  71: 
  72: //    flw_WorldPos = ;
  73: //    flw_Normal = ;
  74: //    flw_Albedo = tex.rgb;
  75: //    flw_Alpha = tex.a;
  76: //    flw_LightMap = r.light;
  77: //    flw_Tint = r.color;
  78:     FLWFinalizeColor(color);
  79: }
  80: 
  81: varying vec2 v2f_texCoords;
  82: varying vec4 v2f_color;
  83: varying float v2f_diffuse;
  84: varying vec2 v2f_light;
  85: 
  86: 
  87: //vec3 flw_WorldPos;
  88: //vec3 flw_Normal;
  89: //vec3 flw_Albedo;
  90: //float flw_Alpha;
  91: //vec2 flw_LightMap;
  92: //vec4 flw_Tint;
  93: 
  94: void main() {
  95:     BlockFrag f;
  96:     f.texCoords = v2f_texCoords;
  97: f.color = v2f_color;
  98: f.diffuse = v2f_diffuse;
  99: f.light = v2f_light;
 100: 
 101: 
 102:     FLWMain(f);
 103: }

[12:29:42] [main/ERROR]: Shader compilation log for flywheel:model.vert: No errors.

[12:29:42] [main/ERROR]: Source for shader 'flywheel:model.vert':
   1: #version 110
   2: #define DEBUG_NORMAL
   3: 
   4: #if defined(USE_FOG)
   5: varying float FragDistance;
   6: #endif
   7: 
   8: varying vec3 BoxCoord;
   9: 
  10: uniform vec3 uLightBoxSize;
  11: uniform vec3 uLightBoxMin;
  12: uniform mat4 uModel;
  13: 
  14: uniform float uTime;
  15: uniform mat4 uViewProjection;
  16: uniform vec3 uCameraPos;
  17: 
  18: void FLWFinalizeWorldPos(inout vec4 worldPos) {
  19:     worldPos = uModel * worldPos;
  20: 
  21:     BoxCoord = (worldPos.xyz - uLightBoxMin) / uLightBoxSize;
  22: 
  23:     #if defined(USE_FOG)
  24:     FragDistance = length(worldPos.xyz);
  25:     #endif
  26: 
  27:     gl_Position = uViewProjection * worldPos;
  28: }
  29: 
  30: void FLWFinalizeNormal(inout vec3 normal) {
  31:     mat3 m;
  32:     m[0] = uModel[0].xyz;
  33:     m[1] = uModel[1].xyz;
  34:     m[2] = uModel[2].xyz;
  35:     normal = m * normal;
  36: }
  37: 
  38: 
  39: 
  40: float diffuse(vec3 normal) {
  41:     vec3 n2 = normal * normal * vec3(.6, .25, .8);
  42:     return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
  43: }
  44: 
  45: 
  46: struct Vertex {
  47:     vec3 pos;
  48:     vec3 normal;
  49:     vec2 texCoords;
  50: };
  51: 
  52: struct BlockFrag {
  53:     vec2 texCoords;
  54:     vec4 color;
  55:     float diffuse;
  56:     vec2 light;
  57: };
  58: 
  59: 
  60: struct Instance {
  61:     vec2 light;
  62:     vec4 color;
  63:     mat4 transform;
  64:     mat3 normalMat;
  65: };
  66: 
  67: BlockFrag FLWMain(Vertex v, Instance i) {
  68:     vec4 worldPos = i.transform * vec4(v.pos, 1.);
  69: 
  70:     vec3 norm = i.normalMat * v.normal;
  71: 
  72:     FLWFinalizeWorldPos(worldPos);
  73:     FLWFinalizeNormal(norm);
  74: 
  75:     norm = normalize(norm);
  76: 
  77:     BlockFrag b;
  78:     b.diffuse = diffuse(norm);
  79:     b.texCoords = v.texCoords;
  80:     b.light = i.light;
  81:     #if defined(DEBUG_NORMAL)
  82:     b.color = vec4(norm, 1.);
  83:     #else
  84:     b.color = i.color;
  85:     #endif
  86:     return b;
  87: }
  88: attribute vec3 a_v_pos;
  89: attribute vec3 a_v_normal;
  90: attribute vec2 a_v_texCoords;
  91: 
  92: attribute vec2 a_i_light;
  93: attribute vec4 a_i_color;
  94: attribute mat4 a_i_transform;
  95: attribute mat3 a_i_normalMat;
  96: 
  97: 
  98: varying vec2 v2f_texCoords;
  99: varying vec4 v2f_color;
 100: varying float v2f_diffuse;
 101: varying vec2 v2f_light;
 102: 
 103: 
 104: void main() {
 105:     Vertex v;
 106:     v.pos = a_v_pos;
 107: v.normal = a_v_normal;
 108: v.texCoords = a_v_texCoords;
 109: 
 110: 
 111:     Instance i;
 112:     i.light = a_i_light;
 113: i.color = a_i_color;
 114: i.transform = a_i_transform;
 115: i.normalMat = a_i_normalMat;
 116: 
 117: 
 118:     BlockFrag o = FLWMain(v, i);
 119: 
 120:     v2f_texCoords = o.texCoords;
 121: v2f_color = o.color;
 122: v2f_diffuse = o.diffuse;
 123: v2f_light = o.light;
 124: 
 125: }

[12:29:42] [main/ERROR]: Shader compilation log for flywheel:block.frag: No errors.

[12:29:42] [main/ERROR]: Source for shader 'flywheel:block.frag':
   1: #version 110
   2: #define DEBUG_NORMAL
   3: 
   4: #if defined(USE_FOG)
   5: varying float FragDistance;
   6: uniform vec4 uFogColor;
   7: #endif
   8: 
   9: #if defined(USE_FOG_LINEAR)
  10: uniform vec2 uFogRange;
  11: 
  12: float FLWFogFactor() {
  13:     return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
  14: }
  15:     #endif
  16: 
  17:     #if defined(USE_FOG_EXP2)
  18: uniform float uFogDensity;
  19: 
  20: float FLWFogFactor() {
  21:     float dist = FragDistance * uFogDensity;
  22:     return 1. / exp2(dist * dist);
  23: }
  24:     #endif
  25: // Adjust the [0,1] normalized lightmap value based on the texture matrix from LightTexture#enableLightmap
  26: vec2 shiftLight(vec2 lm) {
  27:     return lm * 0.99609375 + 0.03125;// * 255/256 + 1/32
  28: }
  29: 
  30: varying vec3 BoxCoord;
  31: varying vec2 BoxLight;
  32: uniform sampler3D uLightVolume;
  33: 
  34: uniform sampler2D uBlockAtlas;
  35: uniform sampler2D uLightMap;
  36: 
  37: vec4 FLWBlockTexture(vec2 texCoords) {
  38:     return texture2D(uBlockAtlas, texCoords);
  39: }
  40: 
  41: void FLWFinalizeColor(vec4 color) {
  42:     #if defined(USE_FOG)
  43:     float a = color.a;
  44:     float fog = clamp(FLWFogFactor(), 0., 1.);
  45: 
  46:     color = mix(uFogColor, color, fog);
  47:     color.a = a;
  48:     #endif
  49: 
  50:     gl_FragColor = color;
  51: }
  52: 
  53: vec4 FLWLight(vec2 lightCoords) {
  54:     lightCoords = max(lightCoords, texture3D(uLightVolume, BoxCoord).rg);
  55: 
  56:     return texture2D(uLightMap, shiftLight(lightCoords));
  57: }
  58: 
  59: 
  60: 
  61: struct BlockFrag {
  62:     vec2 texCoords;
  63:     vec4 color;
  64:     float diffuse;
  65:     vec2 light;
  66: };
  67: 
  68: void FLWMain(BlockFrag r) {
  69:     vec4 tex = FLWBlockTexture(r.texCoords);
  70: 
  71:     vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;
  72: 
  73: //    flw_WorldPos = ;
  74: //    flw_Normal = ;
  75: //    flw_Albedo = tex.rgb;
  76: //    flw_Alpha = tex.a;
  77: //    flw_LightMap = r.light;
  78: //    flw_Tint = r.color;
  79:     FLWFinalizeColor(color);
  80: }
  81: 
  82: varying vec2 v2f_texCoords;
  83: varying vec4 v2f_color;
  84: varying float v2f_diffuse;
  85: varying vec2 v2f_light;
  86: 
  87: 
  88: //vec3 flw_WorldPos;
  89: //vec3 flw_Normal;
  90: //vec3 flw_Albedo;
  91: //float flw_Alpha;
  92: //vec2 flw_LightMap;
  93: //vec4 flw_Tint;
  94: 
  95: void main() {
  96:     BlockFrag f;
  97:     f.texCoords = v2f_texCoords;
  98: f.color = v2f_color;
  99: f.diffuse = v2f_diffuse;
 100: f.light = v2f_light;
 101: 
 102: 
 103:     FLWMain(f);
 104: }

[12:29:42] [main/ERROR]: Shader compilation log for flywheel:model.vert: No errors.

[12:29:42] [main/ERROR]: Source for shader 'flywheel:model.vert':
   1: #version 110
   2: #define USE_FOG
   3: #define USE_FOG_LINEAR
   4: 
   5: #if defined(USE_FOG)
   6: varying float FragDistance;
   7: #endif
   8: 
   9: varying vec3 BoxCoord;
  10: 
  11: uniform vec3 uLightBoxSize;
  12: uniform vec3 uLightBoxMin;
  13: uniform mat4 uModel;
  14: 
  15: uniform float uTime;
  16: uniform mat4 uViewProjection;
  17: uniform vec3 uCameraPos;
  18: 
  19: void FLWFinalizeWorldPos(inout vec4 worldPos) {
  20:     worldPos = uModel * worldPos;
  21: 
  22:     BoxCoord = (worldPos.xyz - uLightBoxMin) / uLightBoxSize;
  23: 
  24:     #if defined(USE_FOG)
  25:     FragDistance = length(worldPos.xyz);
  26:     #endif
  27: 
  28:     gl_Position = uViewProjection * worldPos;
  29: }
  30: 
  31: void FLWFinalizeNormal(inout vec3 normal) {
  32:     mat3 m;
  33:     m[0] = uModel[0].xyz;
  34:     m[1] = uModel[1].xyz;
  35:     m[2] = uModel[2].xyz;
  36:     normal = m * normal;
  37: }
  38: 
  39: 
  40: 
  41: float diffuse(vec3 normal) {
  42:     vec3 n2 = normal * normal * vec3(.6, .25, .8);
  43:     return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
  44: }
  45: 
  46: 
  47: struct Vertex {
  48:     vec3 pos;
  49:     vec3 normal;
  50:     vec2 texCoords;
  51: };
  52: 
  53: struct BlockFrag {
  54:     vec2 texCoords;
  55:     vec4 color;
  56:     float diffuse;
  57:     vec2 light;
  58: };
  59: 
  60: 
  61: struct Instance {
  62:     vec2 light;
  63:     vec4 color;
  64:     mat4 transform;
  65:     mat3 normalMat;
  66: };
  67: 
  68: BlockFrag FLWMain(Vertex v, Instance i) {
  69:     vec4 worldPos = i.transform * vec4(v.pos, 1.);
  70: 
  71:     vec3 norm = i.normalMat * v.normal;
  72: 
  73:     FLWFinalizeWorldPos(worldPos);
  74:     FLWFinalizeNormal(norm);
  75: 
  76:     norm = normalize(norm);
  77: 
  78:     BlockFrag b;
  79:     b.diffuse = diffuse(norm);
  80:     b.texCoords = v.texCoords;
  81:     b.light = i.light;
  82:     #if defined(DEBUG_NORMAL)
  83:     b.color = vec4(norm, 1.);
  84:     #else
  85:     b.color = i.color;
  86:     #endif
  87:     return b;
  88: }
  89: attribute vec3 a_v_pos;
  90: attribute vec3 a_v_normal;
  91: attribute vec2 a_v_texCoords;
  92: 
  93: attribute vec2 a_i_light;
  94: attribute vec4 a_i_color;
  95: attribute mat4 a_i_transform;
  96: attribute mat3 a_i_normalMat;
  97: 
  98: 
  99: varying vec2 v2f_texCoords;
 100: varying vec4 v2f_color;
 101: varying float v2f_diffuse;
 102: varying vec2 v2f_light;
 103: 
 104: 
 105: void main() {
 106:     Vertex v;
 107:     v.pos = a_v_pos;
 108: v.normal = a_v_normal;
 109: v.texCoords = a_v_texCoords;
 110: 
 111: 
 112:     Instance i;
 113:     i.light = a_i_light;
 114: i.color = a_i_color;
 115: i.transform = a_i_transform;
 116: i.normalMat = a_i_normalMat;
 117: 
 118: 
 119:     BlockFrag o = FLWMain(v, i);
 120: 
 121:     v2f_texCoords = o.texCoords;
 122: v2f_color = o.color;
 123: v2f_diffuse = o.diffuse;
 124: v2f_light = o.light;
 125: 
 126: }

[12:29:42] [main/ERROR]: Shader compilation log for flywheel:block.frag: No errors.

[12:29:42] [main/ERROR]: Source for shader 'flywheel:block.frag':
   1: #version 110
   2: #define USE_FOG
   3: #define USE_FOG_LINEAR
   4: 
   5: #if defined(USE_FOG)
   6: varying float FragDistance;
   7: uniform vec4 uFogColor;
   8: #endif
   9: 
  10: #if defined(USE_FOG_LINEAR)
  11: uniform vec2 uFogRange;
  12: 
  13: float FLWFogFactor() {
  14:     return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
  15: }
  16:     #endif
  17: 
  18:     #if defined(USE_FOG_EXP2)
  19: uniform float uFogDensity;
  20: 
  21: float FLWFogFactor() {
  22:     float dist = FragDistance * uFogDensity;
  23:     return 1. / exp2(dist * dist);
  24: }
  25:     #endif
  26: // Adjust the [0,1] normalized lightmap value based on the texture matrix from LightTexture#enableLightmap
  27: vec2 shiftLight(vec2 lm) {
  28:     return lm * 0.99609375 + 0.03125;// * 255/256 + 1/32
  29: }
  30: 
  31: varying vec3 BoxCoord;
  32: varying vec2 BoxLight;
  33: uniform sampler3D uLightVolume;
  34: 
  35: uniform sampler2D uBlockAtlas;
  36: uniform sampler2D uLightMap;
  37: 
  38: vec4 FLWBlockTexture(vec2 texCoords) {
  39:     return texture2D(uBlockAtlas, texCoords);
  40: }
  41: 
  42: void FLWFinalizeColor(vec4 color) {
  43:     #if defined(USE_FOG)
  44:     float a = color.a;
  45:     float fog = clamp(FLWFogFactor(), 0., 1.);
  46: 
  47:     color = mix(uFogColor, color, fog);
  48:     color.a = a;
  49:     #endif
  50: 
  51:     gl_FragColor = color;
  52: }
  53: 
  54: vec4 FLWLight(vec2 lightCoords) {
  55:     lightCoords = max(lightCoords, texture3D(uLightVolume, BoxCoord).rg);
  56: 
  57:     return texture2D(uLightMap, shiftLight(lightCoords));
  58: }
  59: 
  60: 
  61: 
  62: struct BlockFrag {
  63:     vec2 texCoords;
  64:     vec4 color;
  65:     float diffuse;
  66:     vec2 light;
  67: };
  68: 
  69: void FLWMain(BlockFrag r) {
  70:     vec4 tex = FLWBlockTexture(r.texCoords);
  71: 
  72:     vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;
  73: 
  74: //    flw_WorldPos = ;
  75: //    flw_Normal = ;
  76: //    flw_Albedo = tex.rgb;
  77: //    flw_Alpha = tex.a;
  78: //    flw_LightMap = r.light;
  79: //    flw_Tint = r.color;
  80:     FLWFinalizeColor(color);
  81: }
  82: 
  83: varying vec2 v2f_texCoords;
  84: varying vec4 v2f_color;
  85: varying float v2f_diffuse;
  86: varying vec2 v2f_light;
  87: 
  88: 
  89: //vec3 flw_WorldPos;
  90: //vec3 flw_Normal;
  91: //vec3 flw_Albedo;
  92: //float flw_Alpha;
  93: //vec2 flw_LightMap;
  94: //vec4 flw_Tint;
  95: 
  96: void main() {
  97:     BlockFrag f;
  98:     f.texCoords = v2f_texCoords;
  99: f.color = v2f_color;
 100: f.diffuse = v2f_diffuse;
 101: f.light = v2f_light;
 102: 
 103: 
 104:     FLWMain(f);
 105: }

[12:29:42] [main/ERROR]: Shader compilation log for flywheel:model.vert: No errors.

[12:29:42] [main/ERROR]: Source for shader 'flywheel:model.vert':
   1: #version 110
   2: #define USE_FOG
   3: #define USE_FOG_EXP2
   4: 
   5: #if defined(USE_FOG)
   6: varying float FragDistance;
   7: #endif
   8: 
   9: varying vec3 BoxCoord;
  10: 
  11: uniform vec3 uLightBoxSize;
  12: uniform vec3 uLightBoxMin;
  13: uniform mat4 uModel;
  14: 
  15: uniform float uTime;
  16: uniform mat4 uViewProjection;
  17: uniform vec3 uCameraPos;
  18: 
  19: void FLWFinalizeWorldPos(inout vec4 worldPos) {
  20:     worldPos = uModel * worldPos;
  21: 
  22:     BoxCoord = (worldPos.xyz - uLightBoxMin) / uLightBoxSize;
  23: 
  24:     #if defined(USE_FOG)
  25:     FragDistance = length(worldPos.xyz);
  26:     #endif
  27: 
  28:     gl_Position = uViewProjection * worldPos;
  29: }
  30: 
  31: void FLWFinalizeNormal(inout vec3 normal) {
  32:     mat3 m;
  33:     m[0] = uModel[0].xyz;
  34:     m[1] = uModel[1].xyz;
  35:     m[2] = uModel[2].xyz;
  36:     normal = m * normal;
  37: }
  38: 
  39: 
  40: 
  41: float diffuse(vec3 normal) {
  42:     vec3 n2 = normal * normal * vec3(.6, .25, .8);
  43:     return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
  44: }
  45: 
  46: 
  47: struct Vertex {
  48:     vec3 pos;
  49:     vec3 normal;
  50:     vec2 texCoords;
  51: };
  52: 
  53: struct BlockFrag {
  54:     vec2 texCoords;
  55:     vec4 color;
  56:     float diffuse;
  57:     vec2 light;
  58: };
  59: 
  60: 
  61: struct Instance {
  62:     vec2 light;
  63:     vec4 color;
  64:     mat4 transform;
  65:     mat3 normalMat;
  66: };
  67: 
  68: BlockFrag FLWMain(Vertex v, Instance i) {
  69:     vec4 worldPos = i.transform * vec4(v.pos, 1.);
  70: 
  71:     vec3 norm = i.normalMat * v.normal;
  72: 
  73:     FLWFinalizeWorldPos(worldPos);
  74:     FLWFinalizeNormal(norm);
  75: 
  76:     norm = normalize(norm);
  77: 
  78:     BlockFrag b;
  79:     b.diffuse = diffuse(norm);
  80:     b.texCoords = v.texCoords;
  81:     b.light = i.light;
  82:     #if defined(DEBUG_NORMAL)
  83:     b.color = vec4(norm, 1.);
  84:     #else
  85:     b.color = i.color;
  86:     #endif
  87:     return b;
  88: }
  89: attribute vec3 a_v_pos;
  90: attribute vec3 a_v_normal;
  91: attribute vec2 a_v_texCoords;
  92: 
  93: attribute vec2 a_i_light;
  94: attribute vec4 a_i_color;
  95: attribute mat4 a_i_transform;
  96: attribute mat3 a_i_normalMat;
  97: 
  98: 
  99: varying vec2 v2f_texCoords;
 100: varying vec4 v2f_color;
 101: varying float v2f_diffuse;
 102: varying vec2 v2f_light;
 103: 
 104: 
 105: void main() {
 106:     Vertex v;
 107:     v.pos = a_v_pos;
 108: v.normal = a_v_normal;
 109: v.texCoords = a_v_texCoords;
 110: 
 111: 
 112:     Instance i;
 113:     i.light = a_i_light;
 114: i.color = a_i_color;
 115: i.transform = a_i_transform;
 116: i.normalMat = a_i_normalMat;
 117: 
 118: 
 119:     BlockFrag o = FLWMain(v, i);
 120: 
 121:     v2f_texCoords = o.texCoords;
 122: v2f_color = o.color;
 123: v2f_diffuse = o.diffuse;
 124: v2f_light = o.light;
 125: 
 126: }

[12:29:42] [main/ERROR]: Shader compilation log for flywheel:block.frag: No errors.

[12:29:42] [main/ERROR]: Source for shader 'flywheel:block.frag':
   1: #version 110
   2: #define USE_FOG
   3: #define USE_FOG_EXP2
   4: 
   5: #if defined(USE_FOG)
   6: varying float FragDistance;
   7: uniform vec4 uFogColor;
   8: #endif
   9: 
  10: #if defined(USE_FOG_LINEAR)
  11: uniform vec2 uFogRange;
  12: 
  13: float FLWFogFactor() {
  14:     return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
  15: }
  16:     #endif
  17: 
  18:     #if defined(USE_FOG_EXP2)
  19: uniform float uFogDensity;
  20: 
  21: float FLWFogFactor() {
  22:     float dist = FragDistance * uFogDensity;
  23:     return 1. / exp2(dist * dist);
  24: }
  25:     #endif
  26: // Adjust the [0,1] normalized lightmap value based on the texture matrix from LightTexture#enableLightmap
  27: vec2 shiftLight(vec2 lm) {
  28:     return lm * 0.99609375 + 0.03125;// * 255/256 + 1/32
  29: }
  30: 
  31: varying vec3 BoxCoord;
  32: varying vec2 BoxLight;
  33: uniform sampler3D uLightVolume;
  34: 
  35: uniform sampler2D uBlockAtlas;
  36: uniform sampler2D uLightMap;
  37: 
  38: vec4 FLWBlockTexture(vec2 texCoords) {
  39:     return texture2D(uBlockAtlas, texCoords);
  40: }
  41: 
  42: void FLWFinalizeColor(vec4 color) {
  43:     #if defined(USE_FOG)
  44:     float a = color.a;
  45:     float fog = clamp(FLWFogFactor(), 0., 1.);
  46: 
  47:     color = mix(uFogColor, color, fog);
  48:     color.a = a;
  49:     #endif
  50: 
  51:     gl_FragColor = color;
  52: }
  53: 
  54: vec4 FLWLight(vec2 lightCoords) {
  55:     lightCoords = max(lightCoords, texture3D(uLightVolume, BoxCoord).rg);
  56: 
  57:     return texture2D(uLightMap, shiftLight(lightCoords));
  58: }
  59: 
  60: 
  61: 
  62: struct BlockFrag {
  63:     vec2 texCoords;
  64:     vec4 color;
  65:     float diffuse;
  66:     vec2 light;
  67: };
  68: 
  69: void FLWMain(BlockFrag r) {
  70:     vec4 tex = FLWBlockTexture(r.texCoords);
  71: 
  72:     vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;
  73: 
  74: //    flw_WorldPos = ;
  75: //    flw_Normal = ;
  76: //    flw_Albedo = tex.rgb;
  77: //    flw_Alpha = tex.a;
  78: //    flw_LightMap = r.light;
  79: //    flw_Tint = r.color;
  80:     FLWFinalizeColor(color);
  81: }
  82: 
  83: varying vec2 v2f_texCoords;
  84: varying vec4 v2f_color;
  85: varying float v2f_diffuse;
  86: varying vec2 v2f_light;
  87: 
  88: 
  89: //vec3 flw_WorldPos;
  90: //vec3 flw_Normal;
  91: //vec3 flw_Albedo;
  92: //float flw_Alpha;
  93: //vec2 flw_LightMap;
  94: //vec4 flw_Tint;
  95: 
  96: void main() {
  97:     BlockFrag f;
  98:     f.texCoords = v2f_texCoords;
  99: f.color = v2f_color;
 100: f.diffuse = v2f_diffuse;
 101: f.light = v2f_light;
 102: 
 103: 
 104:     FLWMain(f);
 105: }

[12:29:42] [main/ERROR]: Shader compilation log for flywheel:model.vert: No errors.

[12:29:42] [main/ERROR]: Source for shader 'flywheel:model.vert':
   1: #version 110
   2: 
   3: #if defined(USE_FOG)
   4: varying float FragDistance;
   5: #endif
   6: 
   7: varying vec3 BoxCoord;
   8: 
   9: uniform vec3 uLightBoxSize;
  10: uniform vec3 uLightBoxMin;
  11: uniform mat4 uModel;
  12: 
  13: uniform float uTime;
  14: uniform mat4 uViewProjection;
  15: uniform vec3 uCameraPos;
  16: 
  17: void FLWFinalizeWorldPos(inout vec4 worldPos) {
  18:     worldPos = uModel * worldPos;
  19: 
  20:     BoxCoord = (worldPos.xyz - uLightBoxMin) / uLightBoxSize;
  21: 
  22:     #if defined(USE_FOG)
  23:     FragDistance = length(worldPos.xyz);
  24:     #endif
  25: 
  26:     gl_Position = uViewProjection * worldPos;
  27: }
  28: 
  29: void FLWFinalizeNormal(inout vec3 normal) {
  30:     mat3 m;
  31:     m[0] = uModel[0].xyz;
  32:     m[1] = uModel[1].xyz;
  33:     m[2] = uModel[2].xyz;
  34:     normal = m * normal;
  35: }
  36: 
  37: 
  38: 
  39: float diffuse(vec3 normal) {
  40:     vec3 n2 = normal * normal * vec3(.6, .25, .8);
  41:     return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
  42: }
  43: 
  44: 
  45: struct Vertex {
  46:     vec3 pos;
  47:     vec3 normal;
  48:     vec2 texCoords;
  49: };
  50: 
  51: struct BlockFrag {
  52:     vec2 texCoords;
  53:     vec4 color;
  54:     float diffuse;
  55:     vec2 light;
  56: };
  57: 
  58: 
  59: struct Instance {
  60:     vec2 light;
  61:     vec4 color;
  62:     mat4 transform;
  63:     mat3 normalMat;
  64: };
  65: 
  66: BlockFrag FLWMain(Vertex v, Instance i) {
  67:     vec4 worldPos = i.transform * vec4(v.pos, 1.);
  68: 
  69:     vec3 norm = i.normalMat * v.normal;
  70: 
  71:     FLWFinalizeWorldPos(worldPos);
  72:     FLWFinalizeNormal(norm);
  73: 
  74:     norm = normalize(norm);
  75: 
  76:     BlockFrag b;
  77:     b.diffuse = diffuse(norm);
  78:     b.texCoords = v.texCoords;
  79:     b.light = i.light;
  80:     #if defined(DEBUG_NORMAL)
  81:     b.color = vec4(norm, 1.);
  82:     #else
  83:     b.color = i.color;
  84:     #endif
  85:     return b;
  86: }
  87: attribute vec3 a_v_pos;
  88: attribute vec3 a_v_normal;
  89: attribute vec2 a_v_texCoords;
  90: 
  91: attribute vec2 a_i_light;
  92: attribute vec4 a_i_color;
  93: attribute mat4 a_i_transform;
  94: attribute mat3 a_i_normalMat;
  95: 
  96: 
  97: varying vec2 v2f_texCoords;
  98: varying vec4 v2f_color;
  99: varying float v2f_diffuse;
 100: varying vec2 v2f_light;
 101: 
 102: 
 103: void main() {
 104:     Vertex v;
 105:     v.pos = a_v_pos;
 106: v.normal = a_v_normal;
 107: v.texCoords = a_v_texCoords;
 108: 
 109: 
 110:     Instance i;
 111:     i.light = a_i_light;
 112: i.color = a_i_color;
 113: i.transform = a_i_transform;
 114: i.normalMat = a_i_normalMat;
 115: 
 116: 
 117:     BlockFrag o = FLWMain(v, i);
 118: 
 119:     v2f_texCoords = o.texCoords;
 120: v2f_color = o.color;
 121: v2f_diffuse = o.diffuse;
 122: v2f_light = o.light;
 123: 
 124: }

[12:29:42] [main/ERROR]: Shader compilation log for flywheel:block.frag: No errors.

[12:29:42] [main/ERROR]: Source for shader 'flywheel:block.frag':
   1: #version 110
   2: 
   3: #if defined(USE_FOG)
   4: varying float FragDistance;
   5: uniform vec4 uFogColor;
   6: #endif
   7: 
   8: #if defined(USE_FOG_LINEAR)
   9: uniform vec2 uFogRange;
  10: 
  11: float FLWFogFactor() {
  12:     return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
  13: }
  14:     #endif
  15: 
  16:     #if defined(USE_FOG_EXP2)
  17: uniform float uFogDensity;
  18: 
  19: float FLWFogFactor() {
  20:     float dist = FragDistance * uFogDensity;
  21:     return 1. / exp2(dist * dist);
  22: }
  23:     #endif
  24: // Adjust the [0,1] normalized lightmap value based on the texture matrix from LightTexture#enableLightmap
  25: vec2 shiftLight(vec2 lm) {
  26:     return lm * 0.99609375 + 0.03125;// * 255/256 + 1/32
  27: }
  28: 
  29: varying vec3 BoxCoord;
  30: varying vec2 BoxLight;
  31: uniform sampler3D uLightVolume;
  32: 
  33: uniform sampler2D uBlockAtlas;
  34: uniform sampler2D uLightMap;
  35: 
  36: vec4 FLWBlockTexture(vec2 texCoords) {
  37:     return texture2D(uBlockAtlas, texCoords);
  38: }
  39: 
  40: void FLWFinalizeColor(vec4 color) {
  41:     #if defined(USE_FOG)
  42:     float a = color.a;
  43:     float fog = clamp(FLWFogFactor(), 0., 1.);
  44: 
  45:     color = mix(uFogColor, color, fog);
  46:     color.a = a;
  47:     #endif
  48: 
  49:     gl_FragColor = color;
  50: }
  51: 
  52: vec4 FLWLight(vec2 lightCoords) {
  53:     lightCoords = max(lightCoords, texture3D(uLightVolume, BoxCoord).rg);
  54: 
  55:     return texture2D(uLightMap, shiftLight(lightCoords));
  56: }
  57: 
  58: 
  59: 
  60: struct BlockFrag {
  61:     vec2 texCoords;
  62:     vec4 color;
  63:     float diffuse;
  64:     vec2 light;
  65: };
  66: 
  67: void FLWMain(BlockFrag r) {
  68:     vec4 tex = FLWBlockTexture(r.texCoords);
  69: 
  70:     vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;
  71: 
  72: //    flw_WorldPos = ;
  73: //    flw_Normal = ;
  74: //    flw_Albedo = tex.rgb;
  75: //    flw_Alpha = tex.a;
  76: //    flw_LightMap = r.light;
  77: //    flw_Tint = r.color;
  78:     FLWFinalizeColor(color);
  79: }
  80: 
  81: varying vec2 v2f_texCoords;
  82: varying vec4 v2f_color;
  83: varying float v2f_diffuse;
  84: varying vec2 v2f_light;
  85: 
  86: 
  87: //vec3 flw_WorldPos;
  88: //vec3 flw_Normal;
  89: //vec3 flw_Albedo;
  90: //float flw_Alpha;
  91: //vec2 flw_LightMap;
  92: //vec4 flw_Tint;
  93: 
  94: void main() {
  95:     BlockFrag f;
  96:     f.texCoords = v2f_texCoords;
  97: f.color = v2f_color;
  98: f.diffuse = v2f_diffuse;
  99: f.light = v2f_light;
 100: 
 101: 
 102:     FLWMain(f);
 103: }

[12:29:42] [main/INFO]: Loading context 'create:context/contraption'
[12:29:42] [main/ERROR]: Shader compilation log for create:contraption_structure.vert: No errors.

[12:29:42] [main/ERROR]: Source for shader 'create:contraption_structure.vert':
   1: #version 110
   2: #define DEBUG_NORMAL
   3: 
   4: #define PI 3.1415926538
   5: 
   6: #if defined(USE_FOG)
   7: varying float FragDistance;
   8: #endif
   9: 
  10: varying vec3 BoxCoord;
  11: 
  12: uniform vec3 uLightBoxSize;
  13: uniform vec3 uLightBoxMin;
  14: uniform mat4 uModel;
  15: 
  16: uniform float uTime;
  17: uniform mat4 uViewProjection;
  18: uniform vec3 uCameraPos;
  19: 
  20: void FLWFinalizeWorldPos(inout vec4 worldPos) {
  21:     worldPos = uModel * worldPos;
  22: 
  23:     BoxCoord = (worldPos.xyz - uLightBoxMin) / uLightBoxSize;
  24: 
  25:     #if defined(USE_FOG)
  26:     FragDistance = length(worldPos.xyz);
  27:     #endif
  28: 
  29:     gl_Position = uViewProjection * worldPos;
  30: }
  31: 
  32: void FLWFinalizeNormal(inout vec3 normal) {
  33:     mat3 m;
  34:     m[0] = uModel[0].xyz;
  35:     m[1] = uModel[1].xyz;
  36:     m[2] = uModel[2].xyz;
  37:     normal = m * normal;
  38: }
  39: 
  40: 
  41: 
  42: mat4 rotate(vec3 axis, float angle) {
  43:     float s = sin(angle);
  44:     float c = cos(angle);
  45:     float oc = 1. - c;
  46: 
  47:     vec3 sa = axis * s;
  48: 
  49:     mat4 mr = mat4(1.);
  50:     mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
  51:     mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
  52:     mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);
  53: 
  54:     return mr;
  55: }
  56: 
  57: mat4 rotation(vec3 rot) {
  58:     return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
  59: }
  60: 
  61: mat3 modelToNormal(mat4 mat) {
  62:     // Discard the edges. This won't be accurate for scaled or skewed matrices,
  63:     // but we don't have to work with those often.
  64:     mat3 m;
  65:     m[0] = mat[0].xyz;
  66:     m[1] = mat[1].xyz;
  67:     m[2] = mat[2].xyz;
  68:     return m;
  69: }
  70: 
  71: float diffuse(vec3 normal) {
  72:     vec3 n2 = normal * normal * vec3(.6, .25, .8);
  73:     return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
  74: }
  75: 
  76: 
  77: struct Vertex {
  78:     vec3 pos;
  79:     vec3 normal;
  80:     vec2 texCoords;
  81:     vec4 color;
  82:     vec2 modelLight;
  83: };
  84: 
  85: 
  86: struct BlockFrag {
  87:     vec2 texCoords;
  88:     vec4 color;
  89:     float diffuse;
  90:     vec2 light;
  91: };
  92: 
  93: BlockFrag FLWMain(Vertex v) {
  94:     vec4 worldPos = vec4(v.pos, 1.);
  95:     vec3 norm = v.normal;
  96: 
  97:     FLWFinalizeWorldPos(worldPos);
  98:     FLWFinalizeNormal(norm);
  99: 
 100:     BlockFrag b;
 101:     b.diffuse = diffuse(norm);
 102:     b.texCoords = v.texCoords;
 103:     b.light = v.modelLight;
 104: 
 105:     #if defined(DEBUG_NORMAL)
 106:     b.color = vec4(norm, 1.);
 107:     #else
 108:     b.color = vec4(v.color.rgb / diffuse(v.normal), v.color.a);
 109:     #endif
 110: 
 111:     return b;
 112: }
 113: attribute vec3 a_v_pos;
 114: attribute vec3 a_v_normal;
 115: attribute vec2 a_v_texCoords;
 116: attribute vec4 a_v_color;
 117: attribute vec2 a_v_modelLight;
 118: 
 119: 
 120: varying vec2 v2f_texCoords;
 121: varying vec4 v2f_color;
 122: varying float v2f_diffuse;
 123: varying vec2 v2f_light;
 124: 
 125: 
 126: void main() {
 127:     Vertex v;
 128:     v.pos = a_v_pos;
 129: v.normal = a_v_normal;
 130: v.texCoords = a_v_texCoords;
 131: v.color = a_v_color;
 132: v.modelLight = a_v_modelLight;
 133: 
 134: 
 135:     BlockFrag o = FLWMain(v);
 136: 
 137:     v2f_texCoords = o.texCoords;
 138: v2f_color = o.color;
 139: v2f_diffuse = o.diffuse;
 140: v2f_light = o.light;
 141: 
 142: }

[12:29:42] [main/ERROR]: Shader compilation log for flywheel:block.frag: No errors.

[12:29:42] [main/ERROR]: Source for shader 'flywheel:block.frag':
   1: #version 110
   2: #define DEBUG_NORMAL
   3: 
   4: #if defined(USE_FOG)
   5: varying float FragDistance;
   6: uniform vec4 uFogColor;
   7: #endif
   8: 
   9: #if defined(USE_FOG_LINEAR)
  10: uniform vec2 uFogRange;
  11: 
  12: float FLWFogFactor() {
  13:     return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
  14: }
  15:     #endif
  16: 
  17:     #if defined(USE_FOG_EXP2)
  18: uniform float uFogDensity;
  19: 
  20: float FLWFogFactor() {
  21:     float dist = FragDistance * uFogDensity;
  22:     return 1. / exp2(dist * dist);
  23: }
  24:     #endif
  25: // Adjust the [0,1] normalized lightmap value based on the texture matrix from LightTexture#enableLightmap
  26: vec2 shiftLight(vec2 lm) {
  27:     return lm * 0.99609375 + 0.03125;// * 255/256 + 1/32
  28: }
  29: 
  30: varying vec3 BoxCoord;
  31: varying vec2 BoxLight;
  32: uniform sampler3D uLightVolume;
  33: 
  34: uniform sampler2D uBlockAtlas;
  35: uniform sampler2D uLightMap;
  36: 
  37: vec4 FLWBlockTexture(vec2 texCoords) {
  38:     return texture2D(uBlockAtlas, texCoords);
  39: }
  40: 
  41: void FLWFinalizeColor(vec4 color) {
  42:     #if defined(USE_FOG)
  43:     float a = color.a;
  44:     float fog = clamp(FLWFogFactor(), 0., 1.);
  45: 
  46:     color = mix(uFogColor, color, fog);
  47:     color.a = a;
  48:     #endif
  49: 
  50:     gl_FragColor = color;
  51: }
  52: 
  53: vec4 FLWLight(vec2 lightCoords) {
  54:     lightCoords = max(lightCoords, texture3D(uLightVolume, BoxCoord).rg);
  55: 
  56:     return texture2D(uLightMap, shiftLight(lightCoords));
  57: }
  58: 
  59: 
  60: 
  61: struct BlockFrag {
  62:     vec2 texCoords;
  63:     vec4 color;
  64:     float diffuse;
  65:     vec2 light;
  66: };
  67: 
  68: void FLWMain(BlockFrag r) {
  69:     vec4 tex = FLWBlockTexture(r.texCoords);
  70: 
  71:     vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;
  72: 
  73: //    flw_WorldPos = ;
  74: //    flw_Normal = ;
  75: //    flw_Albedo = tex.rgb;
  76: //    flw_Alpha = tex.a;
  77: //    flw_LightMap = r.light;
  78: //    flw_Tint = r.color;
  79:     FLWFinalizeColor(color);
  80: }
  81: 
  82: varying vec2 v2f_texCoords;
  83: varying vec4 v2f_color;
  84: varying float v2f_diffuse;
  85: varying vec2 v2f_light;
  86: 
  87: 
  88: void main() {
  89:     BlockFrag f;
  90:     f.texCoords = v2f_texCoords;
  91: f.color = v2f_color;
  92: f.diffuse = v2f_diffuse;
  93: f.light = v2f_light;
  94: 
  95: 
  96:     FLWMain(f);
  97: }

[12:29:42] [main/ERROR]: Shader compilation log for create:contraption_structure.vert: No errors.

[12:29:42] [main/ERROR]: Source for shader 'create:contraption_structure.vert':
   1: #version 110
   2: #define USE_FOG
   3: #define USE_FOG_LINEAR
   4: 
   5: #define PI 3.1415926538
   6: 
   7: #if defined(USE_FOG)
   8: varying float FragDistance;
   9: #endif
  10: 
  11: varying vec3 BoxCoord;
  12: 
  13: uniform vec3 uLightBoxSize;
  14: uniform vec3 uLightBoxMin;
  15: uniform mat4 uModel;
  16: 
  17: uniform float uTime;
  18: uniform mat4 uViewProjection;
  19: uniform vec3 uCameraPos;
  20: 
  21: void FLWFinalizeWorldPos(inout vec4 worldPos) {
  22:     worldPos = uModel * worldPos;
  23: 
  24:     BoxCoord = (worldPos.xyz - uLightBoxMin) / uLightBoxSize;
  25: 
  26:     #if defined(USE_FOG)
  27:     FragDistance = length(worldPos.xyz);
  28:     #endif
  29: 
  30:     gl_Position = uViewProjection * worldPos;
  31: }
  32: 
  33: void FLWFinalizeNormal(inout vec3 normal) {
  34:     mat3 m;
  35:     m[0] = uModel[0].xyz;
  36:     m[1] = uModel[1].xyz;
  37:     m[2] = uModel[2].xyz;
  38:     normal = m * normal;
  39: }
  40: 
  41: 
  42: 
  43: mat4 rotate(vec3 axis, float angle) {
  44:     float s = sin(angle);
  45:     float c = cos(angle);
  46:     float oc = 1. - c;
  47: 
  48:     vec3 sa = axis * s;
  49: 
  50:     mat4 mr = mat4(1.);
  51:     mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
  52:     mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
  53:     mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);
  54: 
  55:     return mr;
  56: }
  57: 
  58: mat4 rotation(vec3 rot) {
  59:     return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
  60: }
  61: 
  62: mat3 modelToNormal(mat4 mat) {
  63:     // Discard the edges. This won't be accurate for scaled or skewed matrices,
  64:     // but we don't have to work with those often.
  65:     mat3 m;
  66:     m[0] = mat[0].xyz;
  67:     m[1] = mat[1].xyz;
  68:     m[2] = mat[2].xyz;
  69:     return m;
  70: }
  71: 
  72: float diffuse(vec3 normal) {
  73:     vec3 n2 = normal * normal * vec3(.6, .25, .8);
  74:     return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
  75: }
  76: 
  77: 
  78: struct Vertex {
  79:     vec3 pos;
  80:     vec3 normal;
  81:     vec2 texCoords;
  82:     vec4 color;
  83:     vec2 modelLight;
  84: };
  85: 
  86: 
  87: struct BlockFrag {
  88:     vec2 texCoords;
  89:     vec4 color;
  90:     float diffuse;
  91:     vec2 light;
  92: };
  93: 
  94: BlockFrag FLWMain(Vertex v) {
  95:     vec4 worldPos = vec4(v.pos, 1.);
  96:     vec3 norm = v.normal;
  97: 
  98:     FLWFinalizeWorldPos(worldPos);
  99:     FLWFinalizeNormal(norm);
 100: 
 101:     BlockFrag b;
 102:     b.diffuse = diffuse(norm);
 103:     b.texCoords = v.texCoords;
 104:     b.light = v.modelLight;
 105: 
 106:     #if defined(DEBUG_NORMAL)
 107:     b.color = vec4(norm, 1.);
 108:     #else
 109:     b.color = vec4(v.color.rgb / diffuse(v.normal), v.color.a);
 110:     #endif
 111: 
 112:     return b;
 113: }
 114: attribute vec3 a_v_pos;
 115: attribute vec3 a_v_normal;
 116: attribute vec2 a_v_texCoords;
 117: attribute vec4 a_v_color;
 118: attribute vec2 a_v_modelLight;
 119: 
 120: 
 121: varying vec2 v2f_texCoords;
 122: varying vec4 v2f_color;
 123: varying float v2f_diffuse;
 124: varying vec2 v2f_light;
 125: 
 126: 
 127: void main() {
 128:     Vertex v;
 129:     v.pos = a_v_pos;
 130: v.normal = a_v_normal;
 131: v.texCoords = a_v_texCoords;
 132: v.color = a_v_color;
 133: v.modelLight = a_v_modelLight;
 134: 
 135: 
 136:     BlockFrag o = FLWMain(v);
 137: 
 138:     v2f_texCoords = o.texCoords;
 139: v2f_color = o.color;
 140: v2f_diffuse = o.diffuse;
 141: v2f_light = o.light;
 142: 
 143: }

[12:29:42] [main/ERROR]: Shader compilation log for flywheel:block.frag: No errors.

[12:29:42] [main/ERROR]: Source for shader 'flywheel:block.frag':
   1: #version 110
   2: #define USE_FOG
   3: #define USE_FOG_LINEAR
   4: 
   5: #if defined(USE_FOG)
   6: varying float FragDistance;
   7: uniform vec4 uFogColor;
   8: #endif
   9: 
  10: #if defined(USE_FOG_LINEAR)
  11: uniform vec2 uFogRange;
  12: 
  13: float FLWFogFactor() {
  14:     return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
  15: }
  16:     #endif
  17: 
  18:     #if defined(USE_FOG_EXP2)
  19: uniform float uFogDensity;
  20: 
  21: float FLWFogFactor() {
  22:     float dist = FragDistance * uFogDensity;
  23:     return 1. / exp2(dist * dist);
  24: }
  25:     #endif
  26: // Adjust the [0,1] normalized lightmap value based on the texture matrix from LightTexture#enableLightmap
  27: vec2 shiftLight(vec2 lm) {
  28:     return lm * 0.99609375 + 0.03125;// * 255/256 + 1/32
  29: }
  30: 
  31: varying vec3 BoxCoord;
  32: varying vec2 BoxLight;
  33: uniform sampler3D uLightVolume;
  34: 
  35: uniform sampler2D uBlockAtlas;
  36: uniform sampler2D uLightMap;
  37: 
  38: vec4 FLWBlockTexture(vec2 texCoords) {
  39:     return texture2D(uBlockAtlas, texCoords);
  40: }
  41: 
  42: void FLWFinalizeColor(vec4 color) {
  43:     #if defined(USE_FOG)
  44:     float a = color.a;
  45:     float fog = clamp(FLWFogFactor(), 0., 1.);
  46: 
  47:     color = mix(uFogColor, color, fog);
  48:     color.a = a;
  49:     #endif
  50: 
  51:     gl_FragColor = color;
  52: }
  53: 
  54: vec4 FLWLight(vec2 lightCoords) {
  55:     lightCoords = max(lightCoords, texture3D(uLightVolume, BoxCoord).rg);
  56: 
  57:     return texture2D(uLightMap, shiftLight(lightCoords));
  58: }
  59: 
  60: 
  61: 
  62: struct BlockFrag {
  63:     vec2 texCoords;
  64:     vec4 color;
  65:     float diffuse;
  66:     vec2 light;
  67: };
  68: 
  69: void FLWMain(BlockFrag r) {
  70:     vec4 tex = FLWBlockTexture(r.texCoords);
  71: 
  72:     vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;
  73: 
  74: //    flw_WorldPos = ;
  75: //    flw_Normal = ;
  76: //    flw_Albedo = tex.rgb;
  77: //    flw_Alpha = tex.a;
  78: //    flw_LightMap = r.light;
  79: //    flw_Tint = r.color;
  80:     FLWFinalizeColor(color);
  81: }
  82: 
  83: varying vec2 v2f_texCoords;
  84: varying vec4 v2f_color;
  85: varying float v2f_diffuse;
  86: varying vec2 v2f_light;
  87: 
  88: 
  89: void main() {
  90:     BlockFrag f;
  91:     f.texCoords = v2f_texCoords;
  92: f.color = v2f_color;
  93: f.diffuse = v2f_diffuse;
  94: f.light = v2f_light;
  95: 
  96: 
  97:     FLWMain(f);
  98: }

[12:29:42] [main/ERROR]: Shader compilation log for create:contraption_structure.vert: No errors.

[12:29:42] [main/ERROR]: Source for shader 'create:contraption_structure.vert':
   1: #version 110
   2: #define USE_FOG
   3: #define USE_FOG_EXP2
   4: 
   5: #define PI 3.1415926538
   6: 
   7: #if defined(USE_FOG)
   8: varying float FragDistance;
   9: #endif
  10: 
  11: varying vec3 BoxCoord;
  12: 
  13: uniform vec3 uLightBoxSize;
  14: uniform vec3 uLightBoxMin;
  15: uniform mat4 uModel;
  16: 
  17: uniform float uTime;
  18: uniform mat4 uViewProjection;
  19: uniform vec3 uCameraPos;
  20: 
  21: void FLWFinalizeWorldPos(inout vec4 worldPos) {
  22:     worldPos = uModel * worldPos;
  23: 
  24:     BoxCoord = (worldPos.xyz - uLightBoxMin) / uLightBoxSize;
  25: 
  26:     #if defined(USE_FOG)
  27:     FragDistance = length(worldPos.xyz);
  28:     #endif
  29: 
  30:     gl_Position = uViewProjection * worldPos;
  31: }
  32: 
  33: void FLWFinalizeNormal(inout vec3 normal) {
  34:     mat3 m;
  35:     m[0] = uModel[0].xyz;
  36:     m[1] = uModel[1].xyz;
  37:     m[2] = uModel[2].xyz;
  38:     normal = m * normal;
  39: }
  40: 
  41: 
  42: 
  43: mat4 rotate(vec3 axis, float angle) {
  44:     float s = sin(angle);
  45:     float c = cos(angle);
  46:     float oc = 1. - c;
  47: 
  48:     vec3 sa = axis * s;
  49: 
  50:     mat4 mr = mat4(1.);
  51:     mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
  52:     mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
  53:     mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);
  54: 
  55:     return mr;
  56: }
  57: 
  58: mat4 rotation(vec3 rot) {
  59:     return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
  60: }
  61: 
  62: mat3 modelToNormal(mat4 mat) {
  63:     // Discard the edges. This won't be accurate for scaled or skewed matrices,
  64:     // but we don't have to work with those often.
  65:     mat3 m;
  66:     m[0] = mat[0].xyz;
  67:     m[1] = mat[1].xyz;
  68:     m[2] = mat[2].xyz;
  69:     return m;
  70: }
  71: 
  72: float diffuse(vec3 normal) {
  73:     vec3 n2 = normal * normal * vec3(.6, .25, .8);
  74:     return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
  75: }
  76: 
  77: 
  78: struct Vertex {
  79:     vec3 pos;
  80:     vec3 normal;
  81:     vec2 texCoords;
  82:     vec4 color;
  83:     vec2 modelLight;
  84: };
  85: 
  86: 
  87: struct BlockFrag {
  88:     vec2 texCoords;
  89:     vec4 color;
  90:     float diffuse;
  91:     vec2 light;
  92: };
  93: 
  94: BlockFrag FLWMain(Vertex v) {
  95:     vec4 worldPos = vec4(v.pos, 1.);
  96:     vec3 norm = v.normal;
  97: 
  98:     FLWFinalizeWorldPos(worldPos);
  99:     FLWFinalizeNormal(norm);
 100: 
 101:     BlockFrag b;
 102:     b.diffuse = diffuse(norm);
 103:     b.texCoords = v.texCoords;
 104:     b.light = v.modelLight;
 105: 
 106:     #if defined(DEBUG_NORMAL)
 107:     b.color = vec4(norm, 1.);
 108:     #else
 109:     b.color = vec4(v.color.rgb / diffuse(v.normal), v.color.a);
 110:     #endif
 111: 
 112:     return b;
 113: }
 114: attribute vec3 a_v_pos;
 115: attribute vec3 a_v_normal;
 116: attribute vec2 a_v_texCoords;
 117: attribute vec4 a_v_color;
 118: attribute vec2 a_v_modelLight;
 119: 
 120: 
 121: varying vec2 v2f_texCoords;
 122: varying vec4 v2f_color;
 123: varying float v2f_diffuse;
 124: varying vec2 v2f_light;
 125: 
 126: 
 127: void main() {
 128:     Vertex v;
 129:     v.pos = a_v_pos;
 130: v.normal = a_v_normal;
 131: v.texCoords = a_v_texCoords;
 132: v.color = a_v_color;
 133: v.modelLight = a_v_modelLight;
 134: 
 135: 
 136:     BlockFrag o = FLWMain(v);
 137: 
 138:     v2f_texCoords = o.texCoords;
 139: v2f_color = o.color;
 140: v2f_diffuse = o.diffuse;
 141: v2f_light = o.light;
 142: 
 143: }

[12:29:42] [main/ERROR]: Shader compilation log for flywheel:block.frag: No errors.

[12:29:42] [main/ERROR]: Source for shader 'flywheel:block.frag':
   1: #version 110
   2: #define USE_FOG
   3: #define USE_FOG_EXP2
   4: 
   5: #if defined(USE_FOG)
   6: varying float FragDistance;
   7: uniform vec4 uFogColor;
   8: #endif
   9: 
  10: #if defined(USE_FOG_LINEAR)
  11: uniform vec2 uFogRange;
  12: 
  13: float FLWFogFactor() {
  14:     return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
  15: }
  16:     #endif
  17: 
  18:     #if defined(USE_FOG_EXP2)
  19: uniform float uFogDensity;
  20: 
  21: float FLWFogFactor() {
  22:     float dist = FragDistance * uFogDensity;
  23:     return 1. / exp2(dist * dist);
  24: }
  25:     #endif
  26: // Adjust the [0,1] normalized lightmap value based on the texture matrix from LightTexture#enableLightmap
  27: vec2 shiftLight(vec2 lm) {
  28:     return lm * 0.99609375 + 0.03125;// * 255/256 + 1/32
  29: }
  30: 
  31: varying vec3 BoxCoord;
  32: varying vec2 BoxLight;
  33: uniform sampler3D uLightVolume;
  34: 
  35: uniform sampler2D uBlockAtlas;
  36: uniform sampler2D uLightMap;
  37: 
  38: vec4 FLWBlockTexture(vec2 texCoords) {
  39:     return texture2D(uBlockAtlas, texCoords);
  40: }
  41: 
  42: void FLWFinalizeColor(vec4 color) {
  43:     #if defined(USE_FOG)
  44:     float a = color.a;
  45:     float fog = clamp(FLWFogFactor(), 0., 1.);
  46: 
  47:     color = mix(uFogColor, color, fog);
  48:     color.a = a;
  49:     #endif
  50: 
  51:     gl_FragColor = color;
  52: }
  53: 
  54: vec4 FLWLight(vec2 lightCoords) {
  55:     lightCoords = max(lightCoords, texture3D(uLightVolume, BoxCoord).rg);
  56: 
  57:     return texture2D(uLightMap, shiftLight(lightCoords));
  58: }
  59: 
  60: 
  61: 
  62: struct BlockFrag {
  63:     vec2 texCoords;
  64:     vec4 color;
  65:     float diffuse;
  66:     vec2 light;
  67: };
  68: 
  69: void FLWMain(BlockFrag r) {
  70:     vec4 tex = FLWBlockTexture(r.texCoords);
  71: 
  72:     vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;
  73: 
  74: //    flw_WorldPos = ;
  75: //    flw_Normal = ;
  76: //    flw_Albedo = tex.rgb;
  77: //    flw_Alpha = tex.a;
  78: //    flw_LightMap = r.light;
  79: //    flw_Tint = r.color;
  80:     FLWFinalizeColor(color);
  81: }
  82: 
  83: varying vec2 v2f_texCoords;
  84: varying vec4 v2f_color;
  85: varying float v2f_diffuse;
  86: varying vec2 v2f_light;
  87: 
  88: 
  89: void main() {
  90:     BlockFrag f;
  91:     f.texCoords = v2f_texCoords;
  92: f.color = v2f_color;
  93: f.diffuse = v2f_diffuse;
  94: f.light = v2f_light;
  95: 
  96: 
  97:     FLWMain(f);
  98: }

[12:29:42] [main/ERROR]: Shader compilation log for create:contraption_structure.vert: No errors.

[12:29:42] [main/ERROR]: Source for shader 'create:contraption_structure.vert':
   1: #version 110
   2: 
   3: #define PI 3.1415926538
   4: 
   5: #if defined(USE_FOG)
   6: varying float FragDistance;
   7: #endif
   8: 
   9: varying vec3 BoxCoord;
  10: 
  11: uniform vec3 uLightBoxSize;
  12: uniform vec3 uLightBoxMin;
  13: uniform mat4 uModel;
  14: 
  15: uniform float uTime;
  16: uniform mat4 uViewProjection;
  17: uniform vec3 uCameraPos;
  18: 
  19: void FLWFinalizeWorldPos(inout vec4 worldPos) {
  20:     worldPos = uModel * worldPos;
  21: 
  22:     BoxCoord = (worldPos.xyz - uLightBoxMin) / uLightBoxSize;
  23: 
  24:     #if defined(USE_FOG)
  25:     FragDistance = length(worldPos.xyz);
  26:     #endif
  27: 
  28:     gl_Position = uViewProjection * worldPos;
  29: }
  30: 
  31: void FLWFinalizeNormal(inout vec3 normal) {
  32:     mat3 m;
  33:     m[0] = uModel[0].xyz;
  34:     m[1] = uModel[1].xyz;
  35:     m[2] = uModel[2].xyz;
  36:     normal = m * normal;
  37: }
  38: 
  39: 
  40: 
  41: mat4 rotate(vec3 axis, float angle) {
  42:     float s = sin(angle);
  43:     float c = cos(angle);
  44:     float oc = 1. - c;
  45: 
  46:     vec3 sa = axis * s;
  47: 
  48:     mat4 mr = mat4(1.);
  49:     mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
  50:     mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
  51:     mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);
  52: 
  53:     return mr;
  54: }
  55: 
  56: mat4 rotation(vec3 rot) {
  57:     return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
  58: }
  59: 
  60: mat3 modelToNormal(mat4 mat) {
  61:     // Discard the edges. This won't be accurate for scaled or skewed matrices,
  62:     // but we don't have to work with those often.
  63:     mat3 m;
  64:     m[0] = mat[0].xyz;
  65:     m[1] = mat[1].xyz;
  66:     m[2] = mat[2].xyz;
  67:     return m;
  68: }
  69: 
  70: float diffuse(vec3 normal) {
  71:     vec3 n2 = normal * normal * vec3(.6, .25, .8);
  72:     return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
  73: }
  74: 
  75: 
  76: struct Vertex {
  77:     vec3 pos;
  78:     vec3 normal;
  79:     vec2 texCoords;
  80:     vec4 color;
  81:     vec2 modelLight;
  82: };
  83: 
  84: 
  85: struct BlockFrag {
  86:     vec2 texCoords;
  87:     vec4 color;
  88:     float diffuse;
  89:     vec2 light;
  90: };
  91: 
  92: BlockFrag FLWMain(Vertex v) {
  93:     vec4 worldPos = vec4(v.pos, 1.);
  94:     vec3 norm = v.normal;
  95: 
  96:     FLWFinalizeWorldPos(worldPos);
  97:     FLWFinalizeNormal(norm);
  98: 
  99:     BlockFrag b;
 100:     b.diffuse = diffuse(norm);
 101:     b.texCoords = v.texCoords;
 102:     b.light = v.modelLight;
 103: 
 104:     #if defined(DEBUG_NORMAL)
 105:     b.color = vec4(norm, 1.);
 106:     #else
 107:     b.color = vec4(v.color.rgb / diffuse(v.normal), v.color.a);
 108:     #endif
 109: 
 110:     return b;
 111: }
 112: attribute vec3 a_v_pos;
 113: attribute vec3 a_v_normal;
 114: attribute vec2 a_v_texCoords;
 115: attribute vec4 a_v_color;
 116: attribute vec2 a_v_modelLight;
 117: 
 118: 
 119: varying vec2 v2f_texCoords;
 120: varying vec4 v2f_color;
 121: varying float v2f_diffuse;
 122: varying vec2 v2f_light;
 123: 
 124: 
 125: void main() {
 126:     Vertex v;
 127:     v.pos = a_v_pos;
 128: v.normal = a_v_normal;
 129: v.texCoords = a_v_texCoords;
 130: v.color = a_v_color;
 131: v.modelLight = a_v_modelLight;
 132: 
 133: 
 134:     BlockFrag o = FLWMain(v);
 135: 
 136:     v2f_texCoords = o.texCoords;
 137: v2f_color = o.color;
 138: v2f_diffuse = o.diffuse;
 139: v2f_light = o.light;
 140: 
 141: }

[12:29:42] [main/ERROR]: Shader compilation log for flywheel:block.frag: No errors.

[12:29:42] [main/ERROR]: Source for shader 'flywheel:block.frag':
   1: #version 110
   2: 
   3: #if defined(USE_FOG)
   4: varying float FragDistance;
   5: uniform vec4 uFogColor;
   6: #endif
   7: 
   8: #if defined(USE_FOG_LINEAR)
   9: uniform vec2 uFogRange;
  10: 
  11: float FLWFogFactor() {
  12:     return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
  13: }
  14:     #endif
  15: 
  16:     #if defined(USE_FOG_EXP2)
  17: uniform float uFogDensity;
  18: 
  19: float FLWFogFactor() {
  20:     float dist = FragDistance * uFogDensity;
  21:     return 1. / exp2(dist * dist);
  22: }
  23:     #endif
  24: // Adjust the [0,1] normalized lightmap value based on the texture matrix from LightTexture#enableLightmap
  25: vec2 shiftLight(vec2 lm) {
  26:     return lm * 0.99609375 + 0.03125;// * 255/256 + 1/32
  27: }
  28: 
  29: varying vec3 BoxCoord;
  30: varying vec2 BoxLight;
  31: uniform sampler3D uLightVolume;
  32: 
  33: uniform sampler2D uBlockAtlas;
  34: uniform sampler2D uLightMap;
  35: 
  36: vec4 FLWBlockTexture(vec2 texCoords) {
  37:     return texture2D(uBlockAtlas, texCoords);
  38: }
  39: 
  40: void FLWFinalizeColor(vec4 color) {
  41:     #if defined(USE_FOG)
  42:     float a = color.a;
  43:     float fog = clamp(FLWFogFactor(), 0., 1.);
  44: 
  45:     color = mix(uFogColor, color, fog);
  46:     color.a = a;
  47:     #endif
  48: 
  49:     gl_FragColor = color;
  50: }
  51: 
  52: vec4 FLWLight(vec2 lightCoords) {
  53:     lightCoords = max(lightCoords, texture3D(uLightVolume, BoxCoord).rg);
  54: 
  55:     return texture2D(uLightMap, shiftLight(lightCoords));
  56: }
  57: 
  58: 
  59: 
  60: struct BlockFrag {
  61:     vec2 texCoords;
  62:     vec4 color;
  63:     float diffuse;
  64:     vec2 light;
  65: };
  66: 
  67: void FLWMain(BlockFrag r) {
  68:     vec4 tex = FLWBlockTexture(r.texCoords);
  69: 
  70:     vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;
  71: 
  72: //    flw_WorldPos = ;
  73: //    flw_Normal = ;
  74: //    flw_Albedo = tex.rgb;
  75: //    flw_Alpha = tex.a;
  76: //    flw_LightMap = r.light;
  77: //    flw_Tint = r.color;
  78:     FLWFinalizeColor(color);
  79: }
  80: 
  81: varying vec2 v2f_texCoords;
  82: varying vec4 v2f_color;
  83: varying float v2f_diffuse;
  84: varying vec2 v2f_light;
  85: 
  86: 
  87: void main() {
  88:     BlockFrag f;
  89:     f.texCoords = v2f_texCoords;
  90: f.color = v2f_color;
  91: f.diffuse = v2f_diffuse;
  92: f.light = v2f_light;
  93: 
  94: 
  95:     FLWMain(f);
  96: }

[12:29:42] [main/INFO]: Loading context 'flywheel:context/crumbling'
[12:29:42] [main/ERROR]: Shader compilation log for create:rotating.vert: No errors.

[12:29:42] [main/ERROR]: Source for shader 'create:rotating.vert':
   1: #version 110
   2: #define DEBUG_RAINBOW
   3: 
   4: #define PI 3.1415926538
   5: 
   6: uniform float uTime;
   7: uniform mat4 uViewProjection;
   8: uniform vec3 uCameraPos;
   9: 
  10: #if defined(USE_FOG)
  11: varying float FragDistance;
  12: #endif
  13: 
  14: void FLWFinalizeWorldPos(inout vec4 worldPos) {
  15:     #if defined(USE_FOG)
  16:     FragDistance = length(worldPos.xyz - uCameraPos);
  17:     #endif
  18: 
  19:     gl_Position = uViewProjection * worldPos;
  20: }
  21: 
  22: void FLWFinalizeNormal(inout vec3 normal) {
  23:     // noop
  24: }
  25: 
  26: 
  27: mat4 rotate(vec3 axis, float angle) {
  28:     float s = sin(angle);
  29:     float c = cos(angle);
  30:     float oc = 1. - c;
  31: 
  32:     vec3 sa = axis * s;
  33: 
  34:     mat4 mr = mat4(1.);
  35:     mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
  36:     mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
  37:     mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);
  38: 
  39:     return mr;
  40: }
  41: 
  42: mat4 rotation(vec3 rot) {
  43:     return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
  44: }
  45: 
  46: mat3 modelToNormal(mat4 mat) {
  47:     // Discard the edges. This won't be accurate for scaled or skewed matrices,
  48:     // but we don't have to work with those often.
  49:     mat3 m;
  50:     m[0] = mat[0].xyz;
  51:     m[1] = mat[1].xyz;
  52:     m[2] = mat[2].xyz;
  53:     return m;
  54: }
  55: 
  56: float diffuse(vec3 normal) {
  57:     vec3 n2 = normal * normal * vec3(.6, .25, .8);
  58:     return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
  59: }
  60: 
  61: 
  62: struct Rotating {
  63:     vec2 light;
  64:     vec4 color;
  65:     vec3 pos;
  66:     float speed;
  67:     float offset;
  68:     vec3 axis;
  69: };
  70: 
  71: 
  72: struct Vertex {
  73:     vec3 pos;
  74:     vec3 normal;
  75:     vec2 texCoords;
  76: };
  77: 
  78: struct BlockFrag {
  79:     vec2 texCoords;
  80:     vec4 color;
  81:     float diffuse;
  82:     vec2 light;
  83: };
  84: 
  85: mat4 kineticRotation(float offset, float speed, vec3 axis) {
  86:     float degrees = offset + uTime * speed * 3./10.;
  87:     float angle = fract(degrees / 360.) * PI * 2.;
  88: 
  89:     return rotate(axis, angle);
  90: }
  91: 
  92: BlockFrag FLWMain(Vertex v, Rotating instance) {
  93:     mat4 spin = kineticRotation(instance.offset, instance.speed, instance.axis);
  94: 
  95:     vec4 worldPos = spin * vec4(v.pos - .5, 1.);
  96:     worldPos += vec4(instance.pos + .5, 0.);
  97: 
  98:     vec3 norm = modelToNormal(spin) * v.normal;
  99: 
 100:     FLWFinalizeWorldPos(worldPos);
 101:     FLWFinalizeNormal(norm);
 102: 
 103:     BlockFrag b;
 104:     b.diffuse = diffuse(norm);
 105:     b.texCoords = v.texCoords;
 106:     b.light = instance.light;
 107: 
 108:     #if defined(DEBUG_RAINBOW)
 109:     b.color = instance.color;
 110:     #elif defined(DEBUG_NORMAL)
 111:     b.color = vec4(norm, 1.);
 112:     #else
 113:     b.color = vec4(1.);
 114:     #endif
 115: 
 116:     return b;
 117: }
 118: attribute vec3 a_v_pos;
 119: attribute vec3 a_v_normal;
 120: attribute vec2 a_v_texCoords;
 121: 
 122: attribute vec2 a_i_light;
 123: attribute vec4 a_i_color;
 124: attribute vec3 a_i_pos;
 125: attribute float a_i_speed;
 126: attribute float a_i_offset;
 127: attribute vec3 a_i_axis;
 128: 
 129: 
 130: varying vec2 v2f_texCoords;
 131: varying vec4 v2f_color;
 132: varying float v2f_diffuse;
 133: varying vec2 v2f_light;
 134: 
 135: 
 136: void main() {
 137:     Vertex v;
 138:     v.pos = a_v_pos;
 139: v.normal = a_v_normal;
 140: v.texCoords = a_v_texCoords;
 141: 
 142: 
 143:     Rotating i;
 144:     i.light = a_i_light;
 145: i.color = a_i_color;
 146: i.pos = a_i_pos;
 147: i.speed = a_i_speed;
 148: i.offset = a_i_offset;
 149: i.axis = a_i_axis;
 150: 
 151: 
 152:     BlockFrag o = FLWMain(v, i);
 153: 
 154:     v2f_texCoords = o.texCoords;
 155: v2f_color = o.color;
 156: v2f_diffuse = o.diffuse;
 157: v2f_light = o.light;
 158: 
 159: }

[12:29:42] [main/ERROR]: Shader compilation log for flywheel:block.frag: No errors.

[12:29:42] [main/ERROR]: Source for shader 'flywheel:block.frag':
   1: #version 110
   2: #define DEBUG_RAINBOW
   3: 
   4: #if defined(USE_FOG)
   5: varying float FragDistance;
   6: uniform vec4 uFogColor;
   7: #endif
   8: 
   9: #if defined(USE_FOG_LINEAR)
  10: uniform vec2 uFogRange;
  11: 
  12: float FLWFogFactor() {
  13:     return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
  14: }
  15:     #endif
  16: 
  17:     #if defined(USE_FOG_EXP2)
  18: uniform float uFogDensity;
  19: 
  20: float FLWFogFactor() {
  21:     float dist = FragDistance * uFogDensity;
  22:     return 1. / exp2(dist * dist);
  23: }
  24:     #endif
  25: 
  26: uniform vec2 uTextureScale;
  27: uniform sampler2D uBlockAtlas;
  28: uniform sampler2D uLightMap;
  29: uniform sampler2D uCrumbling;
  30: 
  31: vec4 FLWBlockTexture(vec2 texCoords) {
  32:     vec4 cr = texture2D(uCrumbling, texCoords * uTextureScale);
  33:     float diffuseAlpha = texture2D(uBlockAtlas, texCoords).a;
  34:     cr.a = cr.a * diffuseAlpha;
  35:     return cr;
  36: }
  37: 
  38: void FLWFinalizeColor(vec4 color) {
  39:     #if defined(USE_FOG)
  40:     float a = color.a;
  41:     float fog = clamp(FLWFogFactor(), 0., 1.);
  42: 
  43:     color = mix(uFogColor, color, fog);
  44:     color.a = a;
  45:     #endif
  46: 
  47:     gl_FragColor = color;
  48: }
  49: 
  50: vec4 FLWLight(vec2 lightCoords) {
  51:     return vec4(1.);
  52: }
  53: 
  54: 
  55: 
  56: struct BlockFrag {
  57:     vec2 texCoords;
  58:     vec4 color;
  59:     float diffuse;
  60:     vec2 light;
  61: };
  62: 
  63: void FLWMain(BlockFrag r) {
  64:     vec4 tex = FLWBlockTexture(r.texCoords);
  65: 
  66:     vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;
  67: 
  68: //    flw_WorldPos = ;
  69: //    flw_Normal = ;
  70: //    flw_Albedo = tex.rgb;
  71: //    flw_Alpha = tex.a;
  72: //    flw_LightMap = r.light;
  73: //    flw_Tint = r.color;
  74:     FLWFinalizeColor(color);
  75: }
  76: 
  77: varying vec2 v2f_texCoords;
  78: varying vec4 v2f_color;
  79: varying float v2f_diffuse;
  80: varying vec2 v2f_light;
  81: 
  82: 
  83: //vec3 flw_WorldPos;
  84: //vec3 flw_Normal;
  85: //vec3 flw_Albedo;
  86: //float flw_Alpha;
  87: //vec2 flw_LightMap;
  88: //vec4 flw_Tint;
  89: 
  90: void main() {
  91:     BlockFrag f;
  92:     f.texCoords = v2f_texCoords;
  93: f.color = v2f_color;
  94: f.diffuse = v2f_diffuse;
  95: f.light = v2f_light;
  96: 
  97: 
  98:     FLWMain(f);
  99: }

[12:29:43] [main/ERROR]: Shader compilation log for create:rotating.vert: No errors.

[12:29:43] [main/ERROR]: Source for shader 'create:rotating.vert':
   1: #version 110
   2: #define DEBUG_NORMAL
   3: 
   4: #define PI 3.1415926538
   5: 
   6: uniform float uTime;
   7: uniform mat4 uViewProjection;
   8: uniform vec3 uCameraPos;
   9: 
  10: #if defined(USE_FOG)
  11: varying float FragDistance;
  12: #endif
  13: 
  14: void FLWFinalizeWorldPos(inout vec4 worldPos) {
  15:     #if defined(USE_FOG)
  16:     FragDistance = length(worldPos.xyz - uCameraPos);
  17:     #endif
  18: 
  19:     gl_Position = uViewProjection * worldPos;
  20: }
  21: 
  22: void FLWFinalizeNormal(inout vec3 normal) {
  23:     // noop
  24: }
  25: 
  26: 
  27: mat4 rotate(vec3 axis, float angle) {
  28:     float s = sin(angle);
  29:     float c = cos(angle);
  30:     float oc = 1. - c;
  31: 
  32:     vec3 sa = axis * s;
  33: 
  34:     mat4 mr = mat4(1.);
  35:     mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
  36:     mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
  37:     mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);
  38: 
  39:     return mr;
  40: }
  41: 
  42: mat4 rotation(vec3 rot) {
  43:     return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
  44: }
  45: 
  46: mat3 modelToNormal(mat4 mat) {
  47:     // Discard the edges. This won't be accurate for scaled or skewed matrices,
  48:     // but we don't have to work with those often.
  49:     mat3 m;
  50:     m[0] = mat[0].xyz;
  51:     m[1] = mat[1].xyz;
  52:     m[2] = mat[2].xyz;
  53:     return m;
  54: }
  55: 
  56: float diffuse(vec3 normal) {
  57:     vec3 n2 = normal * normal * vec3(.6, .25, .8);
  58:     return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
  59: }
  60: 
  61: 
  62: struct Rotating {
  63:     vec2 light;
  64:     vec4 color;
  65:     vec3 pos;
  66:     float speed;
  67:     float offset;
  68:     vec3 axis;
  69: };
  70: 
  71: 
  72: struct Vertex {
  73:     vec3 pos;
  74:     vec3 normal;
  75:     vec2 texCoords;
  76: };
  77: 
  78: struct BlockFrag {
  79:     vec2 texCoords;
  80:     vec4 color;
  81:     float diffuse;
  82:     vec2 light;
  83: };
  84: 
  85: mat4 kineticRotation(float offset, float speed, vec3 axis) {
  86:     float degrees = offset + uTime * speed * 3./10.;
  87:     float angle = fract(degrees / 360.) * PI * 2.;
  88: 
  89:     return rotate(axis, angle);
  90: }
  91: 
  92: BlockFrag FLWMain(Vertex v, Rotating instance) {
  93:     mat4 spin = kineticRotation(instance.offset, instance.speed, instance.axis);
  94: 
  95:     vec4 worldPos = spin * vec4(v.pos - .5, 1.);
  96:     worldPos += vec4(instance.pos + .5, 0.);
  97: 
  98:     vec3 norm = modelToNormal(spin) * v.normal;
  99: 
 100:     FLWFinalizeWorldPos(worldPos);
 101:     FLWFinalizeNormal(norm);
 102: 
 103:     BlockFrag b;
 104:     b.diffuse = diffuse(norm);
 105:     b.texCoords = v.texCoords;
 106:     b.light = instance.light;
 107: 
 108:     #if defined(DEBUG_RAINBOW)
 109:     b.color = instance.color;
 110:     #elif defined(DEBUG_NORMAL)
 111:     b.color = vec4(norm, 1.);
 112:     #else
 113:     b.color = vec4(1.);
 114:     #endif
 115: 
 116:     return b;
 117: }
 118: attribute vec3 a_v_pos;
 119: attribute vec3 a_v_normal;
 120: attribute vec2 a_v_texCoords;
 121: 
 122: attribute vec2 a_i_light;
 123: attribute vec4 a_i_color;
 124: attribute vec3 a_i_pos;
 125: attribute float a_i_speed;
 126: attribute float a_i_offset;
 127: attribute vec3 a_i_axis;
 128: 
 129: 
 130: varying vec2 v2f_texCoords;
 131: varying vec4 v2f_color;
 132: varying float v2f_diffuse;
 133: varying vec2 v2f_light;
 134: 
 135: 
 136: void main() {
 137:     Vertex v;
 138:     v.pos = a_v_pos;
 139: v.normal = a_v_normal;
 140: v.texCoords = a_v_texCoords;
 141: 
 142: 
 143:     Rotating i;
 144:     i.light = a_i_light;
 145: i.color = a_i_color;
 146: i.pos = a_i_pos;
 147: i.speed = a_i_speed;
 148: i.offset = a_i_offset;
 149: i.axis = a_i_axis;
 150: 
 151: 
 152:     BlockFrag o = FLWMain(v, i);
 153: 
 154:     v2f_texCoords = o.texCoords;
 155: v2f_color = o.color;
 156: v2f_diffuse = o.diffuse;
 157: v2f_light = o.light;
 158: 
 159: }

[12:29:43] [main/ERROR]: Shader compilation log for flywheel:block.frag: No errors.

[12:29:43] [main/ERROR]: Source for shader 'flywheel:block.frag':
   1: #version 110
   2: #define DEBUG_NORMAL
   3: 
   4: #if defined(USE_FOG)
   5: varying float FragDistance;
   6: uniform vec4 uFogColor;
   7: #endif
   8: 
   9: #if defined(USE_FOG_LINEAR)
  10: uniform vec2 uFogRange;
  11: 
  12: float FLWFogFactor() {
  13:     return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
  14: }
  15:     #endif
  16: 
  17:     #if defined(USE_FOG_EXP2)
  18: uniform float uFogDensity;
  19: 
  20: float FLWFogFactor() {
  21:     float dist = FragDistance * uFogDensity;
  22:     return 1. / exp2(dist * dist);
  23: }
  24:     #endif
  25: 
  26: uniform vec2 uTextureScale;
  27: uniform sampler2D uBlockAtlas;
  28: uniform sampler2D uLightMap;
  29: uniform sampler2D uCrumbling;
  30: 
  31: vec4 FLWBlockTexture(vec2 texCoords) {
  32:     vec4 cr = texture2D(uCrumbling, texCoords * uTextureScale);
  33:     float diffuseAlpha = texture2D(uBlockAtlas, texCoords).a;
  34:     cr.a = cr.a * diffuseAlpha;
  35:     return cr;
  36: }
  37: 
  38: void FLWFinalizeColor(vec4 color) {
  39:     #if defined(USE_FOG)
  40:     float a = color.a;
  41:     float fog = clamp(FLWFogFactor(), 0., 1.);
  42: 
  43:     color = mix(uFogColor, color, fog);
  44:     color.a = a;
  45:     #endif
  46: 
  47:     gl_FragColor = color;
  48: }
  49: 
  50: vec4 FLWLight(vec2 lightCoords) {
  51:     return vec4(1.);
  52: }
  53: 
  54: 
  55: 
  56: struct BlockFrag {
  57:     vec2 texCoords;
  58:     vec4 color;
  59:     float diffuse;
  60:     vec2 light;
  61: };
  62: 
  63: void FLWMain(BlockFrag r) {
  64:     vec4 tex = FLWBlockTexture(r.texCoords);
  65: 
  66:     vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;
  67: 
  68: //    flw_WorldPos = ;
  69: //    flw_Normal = ;
  70: //    flw_Albedo = tex.rgb;
  71: //    flw_Alpha = tex.a;
  72: //    flw_LightMap = r.light;
  73: //    flw_Tint = r.color;
  74:     FLWFinalizeColor(color);
  75: }
  76: 
  77: varying vec2 v2f_texCoords;
  78: varying vec4 v2f_color;
  79: varying float v2f_diffuse;
  80: varying vec2 v2f_light;
  81: 
  82: 
  83: //vec3 flw_WorldPos;
  84: //vec3 flw_Normal;
  85: //vec3 flw_Albedo;
  86: //float flw_Alpha;
  87: //vec2 flw_LightMap;
  88: //vec4 flw_Tint;
  89: 
  90: void main() {
  91:     BlockFrag f;
  92:     f.texCoords = v2f_texCoords;
  93: f.color = v2f_color;
  94: f.diffuse = v2f_diffuse;
  95: f.light = v2f_light;
  96: 
  97: 
  98:     FLWMain(f);
  99: }

[12:29:43] [main/ERROR]: Shader compilation log for create:rotating.vert: No errors.

[12:29:43] [main/ERROR]: Source for shader 'create:rotating.vert':
   1: #version 110
   2: #define USE_FOG
   3: #define USE_FOG_LINEAR
   4: 
   5: #define PI 3.1415926538
   6: 
   7: uniform float uTime;
   8: uniform mat4 uViewProjection;
   9: uniform vec3 uCameraPos;
  10: 
  11: #if defined(USE_FOG)
  12: varying float FragDistance;
  13: #endif
  14: 
  15: void FLWFinalizeWorldPos(inout vec4 worldPos) {
  16:     #if defined(USE_FOG)
  17:     FragDistance = length(worldPos.xyz - uCameraPos);
  18:     #endif
  19: 
  20:     gl_Position = uViewProjection * worldPos;
  21: }
  22: 
  23: void FLWFinalizeNormal(inout vec3 normal) {
  24:     // noop
  25: }
  26: 
  27: 
  28: mat4 rotate(vec3 axis, float angle) {
  29:     float s = sin(angle);
  30:     float c = cos(angle);
  31:     float oc = 1. - c;
  32: 
  33:     vec3 sa = axis * s;
  34: 
  35:     mat4 mr = mat4(1.);
  36:     mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
  37:     mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
  38:     mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);
  39: 
  40:     return mr;
  41: }
  42: 
  43: mat4 rotation(vec3 rot) {
  44:     return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
  45: }
  46: 
  47: mat3 modelToNormal(mat4 mat) {
  48:     // Discard the edges. This won't be accurate for scaled or skewed matrices,
  49:     // but we don't have to work with those often.
  50:     mat3 m;
  51:     m[0] = mat[0].xyz;
  52:     m[1] = mat[1].xyz;
  53:     m[2] = mat[2].xyz;
  54:     return m;
  55: }
  56: 
  57: float diffuse(vec3 normal) {
  58:     vec3 n2 = normal * normal * vec3(.6, .25, .8);
  59:     return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
  60: }
  61: 
  62: 
  63: struct Rotating {
  64:     vec2 light;
  65:     vec4 color;
  66:     vec3 pos;
  67:     float speed;
  68:     float offset;
  69:     vec3 axis;
  70: };
  71: 
  72: 
  73: struct Vertex {
  74:     vec3 pos;
  75:     vec3 normal;
  76:     vec2 texCoords;
  77: };
  78: 
  79: struct BlockFrag {
  80:     vec2 texCoords;
  81:     vec4 color;
  82:     float diffuse;
  83:     vec2 light;
  84: };
  85: 
  86: mat4 kineticRotation(float offset, float speed, vec3 axis) {
  87:     float degrees = offset + uTime * speed * 3./10.;
  88:     float angle = fract(degrees / 360.) * PI * 2.;
  89: 
  90:     return rotate(axis, angle);
  91: }
  92: 
  93: BlockFrag FLWMain(Vertex v, Rotating instance) {
  94:     mat4 spin = kineticRotation(instance.offset, instance.speed, instance.axis);
  95: 
  96:     vec4 worldPos = spin * vec4(v.pos - .5, 1.);
  97:     worldPos += vec4(instance.pos + .5, 0.);
  98: 
  99:     vec3 norm = modelToNormal(spin) * v.normal;
 100: 
 101:     FLWFinalizeWorldPos(worldPos);
 102:     FLWFinalizeNormal(norm);
 103: 
 104:     BlockFrag b;
 105:     b.diffuse = diffuse(norm);
 106:     b.texCoords = v.texCoords;
 107:     b.light = instance.light;
 108: 
 109:     #if defined(DEBUG_RAINBOW)
 110:     b.color = instance.color;
 111:     #elif defined(DEBUG_NORMAL)
 112:     b.color = vec4(norm, 1.);
 113:     #else
 114:     b.color = vec4(1.);
 115:     #endif
 116: 
 117:     return b;
 118: }
 119: attribute vec3 a_v_pos;
 120: attribute vec3 a_v_normal;
 121: attribute vec2 a_v_texCoords;
 122: 
 123: attribute vec2 a_i_light;
 124: attribute vec4 a_i_color;
 125: attribute vec3 a_i_pos;
 126: attribute float a_i_speed;
 127: attribute float a_i_offset;
 128: attribute vec3 a_i_axis;
 129: 
 130: 
 131: varying vec2 v2f_texCoords;
 132: varying vec4 v2f_color;
 133: varying float v2f_diffuse;
 134: varying vec2 v2f_light;
 135: 
 136: 
 137: void main() {
 138:     Vertex v;
 139:     v.pos = a_v_pos;
 140: v.normal = a_v_normal;
 141: v.texCoords = a_v_texCoords;
 142: 
 143: 
 144:     Rotating i;
 145:     i.light = a_i_light;
 146: i.color = a_i_color;
 147: i.pos = a_i_pos;
 148: i.speed = a_i_speed;
 149: i.offset = a_i_offset;
 150: i.axis = a_i_axis;
 151: 
 152: 
 153:     BlockFrag o = FLWMain(v, i);
 154: 
 155:     v2f_texCoords = o.texCoords;
 156: v2f_color = o.color;
 157: v2f_diffuse = o.diffuse;
 158: v2f_light = o.light;
 159: 
 160: }

[12:29:43] [main/ERROR]: Shader compilation log for flywheel:block.frag: No errors.

[12:29:43] [main/ERROR]: Source for shader 'flywheel:block.frag':
   1: #version 110
   2: #define USE_FOG
   3: #define USE_FOG_LINEAR
   4: 
   5: #if defined(USE_FOG)
   6: varying float FragDistance;
   7: uniform vec4 uFogColor;
   8: #endif
   9: 
  10: #if defined(USE_FOG_LINEAR)
  11: uniform vec2 uFogRange;
  12: 
  13: float FLWFogFactor() {
  14:     return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
  15: }
  16:     #endif
  17: 
  18:     #if defined(USE_FOG_EXP2)
  19: uniform float uFogDensity;
  20: 
  21: float FLWFogFactor() {
  22:     float dist = FragDistance * uFogDensity;
  23:     return 1. / exp2(dist * dist);
  24: }
  25:     #endif
  26: 
  27: uniform vec2 uTextureScale;
  28: uniform sampler2D uBlockAtlas;
  29: uniform sampler2D uLightMap;
  30: uniform sampler2D uCrumbling;
  31: 
  32: vec4 FLWBlockTexture(vec2 texCoords) {
  33:     vec4 cr = texture2D(uCrumbling, texCoords * uTextureScale);
  34:     float diffuseAlpha = texture2D(uBlockAtlas, texCoords).a;
  35:     cr.a = cr.a * diffuseAlpha;
  36:     return cr;
  37: }
  38: 
  39: void FLWFinalizeColor(vec4 color) {
  40:     #if defined(USE_FOG)
  41:     float a = color.a;
  42:     float fog = clamp(FLWFogFactor(), 0., 1.);
  43: 
  44:     color = mix(uFogColor, color, fog);
  45:     color.a = a;
  46:     #endif
  47: 
  48:     gl_FragColor = color;
  49: }
  50: 
  51: vec4 FLWLight(vec2 lightCoords) {
  52:     return vec4(1.);
  53: }
  54: 
  55: 
  56: 
  57: struct BlockFrag {
  58:     vec2 texCoords;
  59:     vec4 color;
  60:     float diffuse;
  61:     vec2 light;
  62: };
  63: 
  64: void FLWMain(BlockFrag r) {
  65:     vec4 tex = FLWBlockTexture(r.texCoords);
  66: 
  67:     vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;
  68: 
  69: //    flw_WorldPos = ;
  70: //    flw_Normal = ;
  71: //    flw_Albedo = tex.rgb;
  72: //    flw_Alpha = tex.a;
  73: //    flw_LightMap = r.light;
  74: //    flw_Tint = r.color;
  75:     FLWFinalizeColor(color);
  76: }
  77: 
  78: varying vec2 v2f_texCoords;
  79: varying vec4 v2f_color;
  80: varying float v2f_diffuse;
  81: varying vec2 v2f_light;
  82: 
  83: 
  84: //vec3 flw_WorldPos;
  85: //vec3 flw_Normal;
  86: //vec3 flw_Albedo;
  87: //float flw_Alpha;
  88: //vec2 flw_LightMap;
  89: //vec4 flw_Tint;
  90: 
  91: void main() {
  92:     BlockFrag f;
  93:     f.texCoords = v2f_texCoords;
  94: f.color = v2f_color;
  95: f.diffuse = v2f_diffuse;
  96: f.light = v2f_light;
  97: 
  98: 
  99:     FLWMain(f);
 100: }

[12:29:43] [main/ERROR]: Shader compilation log for create:rotating.vert: No errors.

[12:29:43] [main/ERROR]: Source for shader 'create:rotating.vert':
   1: #version 110
   2: #define USE_FOG
   3: #define USE_FOG_EXP2
   4: 
   5: #define PI 3.1415926538
   6: 
   7: uniform float uTime;
   8: uniform mat4 uViewProjection;
   9: uniform vec3 uCameraPos;
  10: 
  11: #if defined(USE_FOG)
  12: varying float FragDistance;
  13: #endif
  14: 
  15: void FLWFinalizeWorldPos(inout vec4 worldPos) {
  16:     #if defined(USE_FOG)
  17:     FragDistance = length(worldPos.xyz - uCameraPos);
  18:     #endif
  19: 
  20:     gl_Position = uViewProjection * worldPos;
  21: }
  22: 
  23: void FLWFinalizeNormal(inout vec3 normal) {
  24:     // noop
  25: }
  26: 
  27: 
  28: mat4 rotate(vec3 axis, float angle) {
  29:     float s = sin(angle);
  30:     float c = cos(angle);
  31:     float oc = 1. - c;
  32: 
  33:     vec3 sa = axis * s;
  34: 
  35:     mat4 mr = mat4(1.);
  36:     mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
  37:     mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
  38:     mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);
  39: 
  40:     return mr;
  41: }
  42: 
  43: mat4 rotation(vec3 rot) {
  44:     return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
  45: }
  46: 
  47: mat3 modelToNormal(mat4 mat) {
  48:     // Discard the edges. This won't be accurate for scaled or skewed matrices,
  49:     // but we don't have to work with those often.
  50:     mat3 m;
  51:     m[0] = mat[0].xyz;
  52:     m[1] = mat[1].xyz;
  53:     m[2] = mat[2].xyz;
  54:     return m;
  55: }
  56: 
  57: float diffuse(vec3 normal) {
  58:     vec3 n2 = normal * normal * vec3(.6, .25, .8);
  59:     return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
  60: }
  61: 
  62: 
  63: struct Rotating {
  64:     vec2 light;
  65:     vec4 color;
  66:     vec3 pos;
  67:     float speed;
  68:     float offset;
  69:     vec3 axis;
  70: };
  71: 
  72: 
  73: struct Vertex {
  74:     vec3 pos;
  75:     vec3 normal;
  76:     vec2 texCoords;
  77: };
  78: 
  79: struct BlockFrag {
  80:     vec2 texCoords;
  81:     vec4 color;
  82:     float diffuse;
  83:     vec2 light;
  84: };
  85: 
  86: mat4 kineticRotation(float offset, float speed, vec3 axis) {
  87:     float degrees = offset + uTime * speed * 3./10.;
  88:     float angle = fract(degrees / 360.) * PI * 2.;
  89: 
  90:     return rotate(axis, angle);
  91: }
  92: 
  93: BlockFrag FLWMain(Vertex v, Rotating instance) {
  94:     mat4 spin = kineticRotation(instance.offset, instance.speed, instance.axis);
  95: 
  96:     vec4 worldPos = spin * vec4(v.pos - .5, 1.);
  97:     worldPos += vec4(instance.pos + .5, 0.);
  98: 
  99:     vec3 norm = modelToNormal(spin) * v.normal;
 100: 
 101:     FLWFinalizeWorldPos(worldPos);
 102:     FLWFinalizeNormal(norm);
 103: 
 104:     BlockFrag b;
 105:     b.diffuse = diffuse(norm);
 106:     b.texCoords = v.texCoords;
 107:     b.light = instance.light;
 108: 
 109:     #if defined(DEBUG_RAINBOW)
 110:     b.color = instance.color;
 111:     #elif defined(DEBUG_NORMAL)
 112:     b.color = vec4(norm, 1.);
 113:     #else
 114:     b.color = vec4(1.);
 115:     #endif
 116: 
 117:     return b;
 118: }
 119: attribute vec3 a_v_pos;
 120: attribute vec3 a_v_normal;
 121: attribute vec2 a_v_texCoords;
 122: 
 123: attribute vec2 a_i_light;
 124: attribute vec4 a_i_color;
 125: attribute vec3 a_i_pos;
 126: attribute float a_i_speed;
 127: attribute float a_i_offset;
 128: attribute vec3 a_i_axis;
 129: 
 130: 
 131: varying vec2 v2f_texCoords;
 132: varying vec4 v2f_color;
 133: varying float v2f_diffuse;
 134: varying vec2 v2f_light;
 135: 
 136: 
 137: void main() {
 138:     Vertex v;
 139:     v.pos = a_v_pos;
 140: v.normal = a_v_normal;
 141: v.texCoords = a_v_texCoords;
 142: 
 143: 
 144:     Rotating i;
 145:     i.light = a_i_light;
 146: i.color = a_i_color;
 147: i.pos = a_i_pos;
 148: i.speed = a_i_speed;
 149: i.offset = a_i_offset;
 150: i.axis = a_i_axis;
 151: 
 152: 
 153:     BlockFrag o = FLWMain(v, i);
 154: 
 155:     v2f_texCoords = o.texCoords;
 156: v2f_color = o.color;
 157: v2f_diffuse = o.diffuse;
 158: v2f_light = o.light;
 159: 
 160: }

[12:29:43] [main/ERROR]: Shader compilation log for flywheel:block.frag: No errors.

[12:29:43] [main/ERROR]: Source for shader 'flywheel:block.frag':
   1: #version 110
   2: #define USE_FOG
   3: #define USE_FOG_EXP2
   4: 
   5: #if defined(USE_FOG)
   6: varying float FragDistance;
   7: uniform vec4 uFogColor;
   8: #endif
   9: 
  10: #if defined(USE_FOG_LINEAR)
  11: uniform vec2 uFogRange;
  12: 
  13: float FLWFogFactor() {
  14:     return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
  15: }
  16:     #endif
  17: 
  18:     #if defined(USE_FOG_EXP2)
  19: uniform float uFogDensity;
  20: 
  21: float FLWFogFactor() {
  22:     float dist = FragDistance * uFogDensity;
  23:     return 1. / exp2(dist * dist);
  24: }
  25:     #endif
  26: 
  27: uniform vec2 uTextureScale;
  28: uniform sampler2D uBlockAtlas;
  29: uniform sampler2D uLightMap;
  30: uniform sampler2D uCrumbling;
  31: 
  32: vec4 FLWBlockTexture(vec2 texCoords) {
  33:     vec4 cr = texture2D(uCrumbling, texCoords * uTextureScale);
  34:     float diffuseAlpha = texture2D(uBlockAtlas, texCoords).a;
  35:     cr.a = cr.a * diffuseAlpha;
  36:     return cr;
  37: }
  38: 
  39: void FLWFinalizeColor(vec4 color) {
  40:     #if defined(USE_FOG)
  41:     float a = color.a;
  42:     float fog = clamp(FLWFogFactor(), 0., 1.);
  43: 
  44:     color = mix(uFogColor, color, fog);
  45:     color.a = a;
  46:     #endif
  47: 
  48:     gl_FragColor = color;
  49: }
  50: 
  51: vec4 FLWLight(vec2 lightCoords) {
  52:     return vec4(1.);
  53: }
  54: 
  55: 
  56: 
  57: struct BlockFrag {
  58:     vec2 texCoords;
  59:     vec4 color;
  60:     float diffuse;
  61:     vec2 light;
  62: };
  63: 
  64: void FLWMain(BlockFrag r) {
  65:     vec4 tex = FLWBlockTexture(r.texCoords);
  66: 
  67:     vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;
  68: 
  69: //    flw_WorldPos = ;
  70: //    flw_Normal = ;
  71: //    flw_Albedo = tex.rgb;
  72: //    flw_Alpha = tex.a;
  73: //    flw_LightMap = r.light;
  74: //    flw_Tint = r.color;
  75:     FLWFinalizeColor(color);
  76: }
  77: 
  78: varying vec2 v2f_texCoords;
  79: varying vec4 v2f_color;
  80: varying float v2f_diffuse;
  81: varying vec2 v2f_light;
  82: 
  83: 
  84: //vec3 flw_WorldPos;
  85: //vec3 flw_Normal;
  86: //vec3 flw_Albedo;
  87: //float flw_Alpha;
  88: //vec2 flw_LightMap;
  89: //vec4 flw_Tint;
  90: 
  91: void main() {
  92:     BlockFrag f;
  93:     f.texCoords = v2f_texCoords;
  94: f.color = v2f_color;
  95: f.diffuse = v2f_diffuse;
  96: f.light = v2f_light;
  97: 
  98: 
  99:     FLWMain(f);
 100: }

[12:29:43] [main/ERROR]: Shader compilation log for create:rotating.vert: No errors.

[12:29:43] [main/ERROR]: Source for shader 'create:rotating.vert':
   1: #version 110
   2: 
   3: #define PI 3.1415926538
   4: 
   5: uniform float uTime;
   6: uniform mat4 uViewProjection;
   7: uniform vec3 uCameraPos;
   8: 
   9: #if defined(USE_FOG)
  10: varying float FragDistance;
  11: #endif
  12: 
  13: void FLWFinalizeWorldPos(inout vec4 worldPos) {
  14:     #if defined(USE_FOG)
  15:     FragDistance = length(worldPos.xyz - uCameraPos);
  16:     #endif
  17: 
  18:     gl_Position = uViewProjection * worldPos;
  19: }
  20: 
  21: void FLWFinalizeNormal(inout vec3 normal) {
  22:     // noop
  23: }
  24: 
  25: 
  26: mat4 rotate(vec3 axis, float angle) {
  27:     float s = sin(angle);
  28:     float c = cos(angle);
  29:     float oc = 1. - c;
  30: 
  31:     vec3 sa = axis * s;
  32: 
  33:     mat4 mr = mat4(1.);
  34:     mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
  35:     mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
  36:     mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);
  37: 
  38:     return mr;
  39: }
  40: 
  41: mat4 rotation(vec3 rot) {
  42:     return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
  43: }
  44: 
  45: mat3 modelToNormal(mat4 mat) {
  46:     // Discard the edges. This won't be accurate for scaled or skewed matrices,
  47:     // but we don't have to work with those often.
  48:     mat3 m;
  49:     m[0] = mat[0].xyz;
  50:     m[1] = mat[1].xyz;
  51:     m[2] = mat[2].xyz;
  52:     return m;
  53: }
  54: 
  55: float diffuse(vec3 normal) {
  56:     vec3 n2 = normal * normal * vec3(.6, .25, .8);
  57:     return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
  58: }
  59: 
  60: 
  61: struct Rotating {
  62:     vec2 light;
  63:     vec4 color;
  64:     vec3 pos;
  65:     float speed;
  66:     float offset;
  67:     vec3 axis;
  68: };
  69: 
  70: 
  71: struct Vertex {
  72:     vec3 pos;
  73:     vec3 normal;
  74:     vec2 texCoords;
  75: };
  76: 
  77: struct BlockFrag {
  78:     vec2 texCoords;
  79:     vec4 color;
  80:     float diffuse;
  81:     vec2 light;
  82: };
  83: 
  84: mat4 kineticRotation(float offset, float speed, vec3 axis) {
  85:     float degrees = offset + uTime * speed * 3./10.;
  86:     float angle = fract(degrees / 360.) * PI * 2.;
  87: 
  88:     return rotate(axis, angle);
  89: }
  90: 
  91: BlockFrag FLWMain(Vertex v, Rotating instance) {
  92:     mat4 spin = kineticRotation(instance.offset, instance.speed, instance.axis);
  93: 
  94:     vec4 worldPos = spin * vec4(v.pos - .5, 1.);
  95:     worldPos += vec4(instance.pos + .5, 0.);
  96: 
  97:     vec3 norm = modelToNormal(spin) * v.normal;
  98: 
  99:     FLWFinalizeWorldPos(worldPos);
 100:     FLWFinalizeNormal(norm);
 101: 
 102:     BlockFrag b;
 103:     b.diffuse = diffuse(norm);
 104:     b.texCoords = v.texCoords;
 105:     b.light = instance.light;
 106: 
 107:     #if defined(DEBUG_RAINBOW)
 108:     b.color = instance.color;
 109:     #elif defined(DEBUG_NORMAL)
 110:     b.color = vec4(norm, 1.);
 111:     #else
 112:     b.color = vec4(1.);
 113:     #endif
 114: 
 115:     return b;
 116: }
 117: attribute vec3 a_v_pos;
 118: attribute vec3 a_v_normal;
 119: attribute vec2 a_v_texCoords;
 120: 
 121: attribute vec2 a_i_light;
 122: attribute vec4 a_i_color;
 123: attribute vec3 a_i_pos;
 124: attribute float a_i_speed;
 125: attribute float a_i_offset;
 126: attribute vec3 a_i_axis;
 127: 
 128: 
 129: varying vec2 v2f_texCoords;
 130: varying vec4 v2f_color;
 131: varying float v2f_diffuse;
 132: varying vec2 v2f_light;
 133: 
 134: 
 135: void main() {
 136:     Vertex v;
 137:     v.pos = a_v_pos;
 138: v.normal = a_v_normal;
 139: v.texCoords = a_v_texCoords;
 140: 
 141: 
 142:     Rotating i;
 143:     i.light = a_i_light;
 144: i.color = a_i_color;
 145: i.pos = a_i_pos;
 146: i.speed = a_i_speed;
 147: i.offset = a_i_offset;
 148: i.axis = a_i_axis;
 149: 
 150: 
 151:     BlockFrag o = FLWMain(v, i);
 152: 
 153:     v2f_texCoords = o.texCoords;
 154: v2f_color = o.color;
 155: v2f_diffuse = o.diffuse;
 156: v2f_light = o.light;
 157: 
 158: }

[12:29:43] [main/ERROR]: Shader compilation log for flywheel:block.frag: No errors.

[12:29:43] [main/ERROR]: Source for shader 'flywheel:block.frag':
   1: #version 110
   2: 
   3: #if defined(USE_FOG)
   4: varying float FragDistance;
   5: uniform vec4 uFogColor;
   6: #endif
   7: 
   8: #if defined(USE_FOG_LINEAR)
   9: uniform vec2 uFogRange;
  10: 
  11: float FLWFogFactor() {
  12:     return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
  13: }
  14:     #endif
  15: 
  16:     #if defined(USE_FOG_EXP2)
  17: uniform float uFogDensity;
  18: 
  19: float FLWFogFactor() {
  20:     float dist = FragDistance * uFogDensity;
  21:     return 1. / exp2(dist * dist);
  22: }
  23:     #endif
  24: 
  25: uniform vec2 uTextureScale;
  26: uniform sampler2D uBlockAtlas;
  27: uniform sampler2D uLightMap;
  28: uniform sampler2D uCrumbling;
  29: 
  30: vec4 FLWBlockTexture(vec2 texCoords) {
  31:     vec4 cr = texture2D(uCrumbling, texCoords * uTextureScale);
  32:     float diffuseAlpha = texture2D(uBlockAtlas, texCoords).a;
  33:     cr.a = cr.a * diffuseAlpha;
  34:     return cr;
  35: }
  36: 
  37: void FLWFinalizeColor(vec4 color) {
  38:     #if defined(USE_FOG)
  39:     float a = color.a;
  40:     float fog = clamp(FLWFogFactor(), 0., 1.);
  41: 
  42:     color = mix(uFogColor, color, fog);
  43:     color.a = a;
  44:     #endif
  45: 
  46:     gl_FragColor = color;
  47: }
  48: 
  49: vec4 FLWLight(vec2 lightCoords) {
  50:     return vec4(1.);
  51: }
  52: 
  53: 
  54: 
  55: struct BlockFrag {
  56:     vec2 texCoords;
  57:     vec4 color;
  58:     float diffuse;
  59:     vec2 light;
  60: };
  61: 
  62: void FLWMain(BlockFrag r) {
  63:     vec4 tex = FLWBlockTexture(r.texCoords);
  64: 
  65:     vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;
  66: 
  67: //    flw_WorldPos = ;
  68: //    flw_Normal = ;
  69: //    flw_Albedo = tex.rgb;
  70: //    flw_Alpha = tex.a;
  71: //    flw_LightMap = r.light;
  72: //    flw_Tint = r.color;
  73:     FLWFinalizeColor(color);
  74: }
  75: 
  76: varying vec2 v2f_texCoords;
  77: varying vec4 v2f_color;
  78: varying float v2f_diffuse;
  79: varying vec2 v2f_light;
  80: 
  81: 
  82: //vec3 flw_WorldPos;
  83: //vec3 flw_Normal;
  84: //vec3 flw_Albedo;
  85: //float flw_Alpha;
  86: //vec2 flw_LightMap;
  87: //vec4 flw_Tint;
  88: 
  89: void main() {
  90:     BlockFrag f;
  91:     f.texCoords = v2f_texCoords;
  92: f.color = v2f_color;
  93: f.diffuse = v2f_diffuse;
  94: f.light = v2f_light;
  95: 
  96: 
  97:     FLWMain(f);
  98: }

[12:29:43] [main/ERROR]: Shader compilation log for create:contraption_actor.vert: No errors.

[12:29:43] [main/ERROR]: Source for shader 'create:contraption_actor.vert':
   1: #version 110
   2: #define DEBUG_NORMAL
   3: 
   4: #define PI 3.1415926538
   5: 
   6: uniform float uTime;
   7: uniform mat4 uViewProjection;
   8: uniform vec3 uCameraPos;
   9: 
  10: #if defined(USE_FOG)
  11: varying float FragDistance;
  12: #endif
  13: 
  14: void FLWFinalizeWorldPos(inout vec4 worldPos) {
  15:     #if defined(USE_FOG)
  16:     FragDistance = length(worldPos.xyz - uCameraPos);
  17:     #endif
  18: 
  19:     gl_Position = uViewProjection * worldPos;
  20: }
  21: 
  22: void FLWFinalizeNormal(inout vec3 normal) {
  23:     // noop
  24: }
  25: 
  26: 
  27: mat4 rotate(vec3 axis, float angle) {
  28:     float s = sin(angle);
  29:     float c = cos(angle);
  30:     float oc = 1. - c;
  31: 
  32:     vec3 sa = axis * s;
  33: 
  34:     mat4 mr = mat4(1.);
  35:     mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
  36:     mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
  37:     mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);
  38: 
  39:     return mr;
  40: }
  41: 
  42: mat4 rotation(vec3 rot) {
  43:     return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
  44: }
  45: 
  46: mat3 modelToNormal(mat4 mat) {
  47:     // Discard the edges. This won't be accurate for scaled or skewed matrices,
  48:     // but we don't have to work with those often.
  49:     mat3 m;
  50:     m[0] = mat[0].xyz;
  51:     m[1] = mat[1].xyz;
  52:     m[2] = mat[2].xyz;
  53:     return m;
  54: }
  55: 
  56: #define PIOVER2 1.5707963268
  57: 
  58: vec4 quat(vec3 axis, float angle) {
  59:     float halfAngle = angle * PIOVER2 / 180.0;
  60:     vec2 cs = sin(vec2(PIOVER2 - halfAngle, halfAngle)); // compute sin and cos in one instruction
  61:     return vec4(axis.xyz * cs.y,  cs.x);
  62: }
  63: 
  64: vec4 quatMult(vec4 q1, vec4 q2) {
  65:     // disgustingly vectorized quaternion multiplication
  66:     vec4 a = q1.w * q2.xyzw;
  67:     vec4 b = q1.x * q2.wzxy * vec4(1., -1., 1., -1.);
  68:     vec4 c = q1.y * q2.zwxy * vec4(1., 1., -1., -1.);
  69:     vec4 d = q1.z * q2.yxwz * vec4(-1., 1., 1., -1.);
  70: 
  71:     return a + b + c + d;
  72: }
  73: 
  74: vec3 rotateVertexByQuat(vec3 v, vec4 q) {
  75:     vec3 i = q.xyz;
  76:     return v + 2.0 * cross(i, cross(i, v) + q.w * v);
  77: }
  78: 
  79: vec3 rotateAbout(vec3 v, vec3 axis, float angle) {
  80:     return rotateVertexByQuat(v, quat(axis, angle));
  81: }
  82: 
  83: float diffuse(vec3 normal) {
  84:     vec3 n2 = normal * normal * vec3(.6, .25, .8);
  85:     return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
  86: }
  87: 
  88: 
  89: struct Actor {
  90:     vec3 pos;
  91:     vec2 light;
  92:     float offset;
  93:     vec3 axis;
  94:     vec4 rotation;
  95:     vec3 rotationCenter;
  96:     float speed;
  97: };
  98: 
  99: 
 100: struct Vertex {
 101:     vec3 pos;
 102:     vec3 normal;
 103:     vec2 texCoords;
 104: };
 105: 
 106: struct BlockFrag {
 107:     vec2 texCoords;
 108:     vec4 color;
 109:     float diffuse;
 110:     vec2 light;
 111: };
 112: 
 113: BlockFrag FLWMain(Vertex v, Actor instance) {
 114:     float degrees = instance.offset + uTime * instance.speed / 20.;
 115:     //float angle = fract(degrees / 360.) * PI * 2.;
 116: 
 117:     vec4 kineticRot = quat(instance.axis, degrees);
 118:     vec3 rotated = rotateVertexByQuat(v.pos - instance.rotationCenter, kineticRot) + instance.rotationCenter;
 119: 
 120:     vec4 worldPos = vec4(rotateVertexByQuat(rotated - .5, instance.rotation) + instance.pos + .5, 1.);
 121:     vec3 norm = rotateVertexByQuat(rotateVertexByQuat(v.normal, kineticRot), instance.rotation);
 122: 
 123:     FLWFinalizeWorldPos(worldPos);
 124:     FLWFinalizeNormal(norm);
 125: 
 126:     BlockFrag b;
 127:     b.diffuse = diffuse(norm);
 128:     b.texCoords = v.texCoords;
 129:     b.light = instance.light;
 130: 
 131:     #if defined(DEBUG_NORMAL)
 132:     b.color = vec4(norm, 1.);
 133:     #else
 134:     b.color = vec4(1.);
 135:     #endif
 136: 
 137:     return b;
 138: }
 139: attribute vec3 a_v_pos;
 140: attribute vec3 a_v_normal;
 141: attribute vec2 a_v_texCoords;
 142: 
 143: attribute vec3 a_i_pos;
 144: attribute vec2 a_i_light;
 145: attribute float a_i_offset;
 146: attribute vec3 a_i_axis;
 147: attribute vec4 a_i_rotation;
 148: attribute vec3 a_i_rotationCenter;
 149: attribute float a_i_speed;
 150: 
 151: 
 152: varying vec2 v2f_texCoords;
 153: varying vec4 v2f_color;
 154: varying float v2f_diffuse;
 155: varying vec2 v2f_light;
 156: 
 157: 
 158: void main() {
 159:     Vertex v;
 160:     v.pos = a_v_pos;
 161: v.normal = a_v_normal;
 162: v.texCoords = a_v_texCoords;
 163: 
 164: 
 165:     Actor i;
 166:     i.pos = a_i_pos;
 167: i.light = a_i_light;
 168: i.offset = a_i_offset;
 169: i.axis = a_i_axis;
 170: i.rotation = a_i_rotation;
 171: i.rotationCenter = a_i_rotationCenter;
 172: i.speed = a_i_speed;
 173: 
 174: 
 175:     BlockFrag o = FLWMain(v, i);
 176: 
 177:     v2f_texCoords = o.texCoords;
 178: v2f_color = o.color;
 179: v2f_diffuse = o.diffuse;
 180: v2f_light = o.light;
 181: 
 182: }

[12:29:43] [main/ERROR]: Shader compilation log for flywheel:block.frag: No errors.

[12:29:43] [main/ERROR]: Source for shader 'flywheel:block.frag':
   1: #version 110
   2: #define DEBUG_NORMAL
   3: 
   4: #if defined(USE_FOG)
   5: varying float FragDistance;
   6: uniform vec4 uFogColor;
   7: #endif
   8: 
   9: #if defined(USE_FOG_LINEAR)
  10: uniform vec2 uFogRange;
  11: 
  12: float FLWFogFactor() {
  13:     return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
  14: }
  15:     #endif
  16: 
  17:     #if defined(USE_FOG_EXP2)
  18: uniform float uFogDensity;
  19: 
  20: float FLWFogFactor() {
  21:     float dist = FragDistance * uFogDensity;
  22:     return 1. / exp2(dist * dist);
  23: }
  24:     #endif
  25: 
  26: uniform vec2 uTextureScale;
  27: uniform sampler2D uBlockAtlas;
  28: uniform sampler2D uLightMap;
  29: uniform sampler2D uCrumbling;
  30: 
  31: vec4 FLWBlockTexture(vec2 texCoords) {
  32:     vec4 cr = texture2D(uCrumbling, texCoords * uTextureScale);
  33:     float diffuseAlpha = texture2D(uBlockAtlas, texCoords).a;
  34:     cr.a = cr.a * diffuseAlpha;
  35:     return cr;
  36: }
  37: 
  38: void FLWFinalizeColor(vec4 color) {
  39:     #if defined(USE_FOG)
  40:     float a = color.a;
  41:     float fog = clamp(FLWFogFactor(), 0., 1.);
  42: 
  43:     color = mix(uFogColor, color, fog);
  44:     color.a = a;
  45:     #endif
  46: 
  47:     gl_FragColor = color;
  48: }
  49: 
  50: vec4 FLWLight(vec2 lightCoords) {
  51:     return vec4(1.);
  52: }
  53: 
  54: 
  55: 
  56: struct BlockFrag {
  57:     vec2 texCoords;
  58:     vec4 color;
  59:     float diffuse;
  60:     vec2 light;
  61: };
  62: 
  63: void FLWMain(BlockFrag r) {
  64:     vec4 tex = FLWBlockTexture(r.texCoords);
  65: 
  66:     vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;
  67: 
  68: //    flw_WorldPos = ;
  69: //    flw_Normal = ;
  70: //    flw_Albedo = tex.rgb;
  71: //    flw_Alpha = tex.a;
  72: //    flw_LightMap = r.light;
  73: //    flw_Tint = r.color;
  74:     FLWFinalizeColor(color);
  75: }
  76: 
  77: varying vec2 v2f_texCoords;
  78: varying vec4 v2f_color;
  79: varying float v2f_diffuse;
  80: varying vec2 v2f_light;
  81: 
  82: 
  83: //vec3 flw_WorldPos;
  84: //vec3 flw_Normal;
  85: //vec3 flw_Albedo;
  86: //float flw_Alpha;
  87: //vec2 flw_LightMap;
  88: //vec4 flw_Tint;
  89: 
  90: void main() {
  91:     BlockFrag f;
  92:     f.texCoords = v2f_texCoords;
  93: f.color = v2f_color;
  94: f.diffuse = v2f_diffuse;
  95: f.light = v2f_light;
  96: 
  97: 
  98:     FLWMain(f);
  99: }

[12:29:43] [main/ERROR]: Shader compilation log for create:contraption_actor.vert: No errors.

[12:29:43] [main/ERROR]: Source for shader 'create:contraption_actor.vert':
   1: #version 110
   2: #define USE_FOG
   3: #define USE_FOG_LINEAR
   4: 
   5: #define PI 3.1415926538
   6: 
   7: uniform float uTime;
   8: uniform mat4 uViewProjection;
   9: uniform vec3 uCameraPos;
  10: 
  11: #if defined(USE_FOG)
  12: varying float FragDistance;
  13: #endif
  14: 
  15: void FLWFinalizeWorldPos(inout vec4 worldPos) {
  16:     #if defined(USE_FOG)
  17:     FragDistance = length(worldPos.xyz - uCameraPos);
  18:     #endif
  19: 
  20:     gl_Position = uViewProjection * worldPos;
  21: }
  22: 
  23: void FLWFinalizeNormal(inout vec3 normal) {
  24:     // noop
  25: }
  26: 
  27: 
  28: mat4 rotate(vec3 axis, float angle) {
  29:     float s = sin(angle);
  30:     float c = cos(angle);
  31:     float oc = 1. - c;
  32: 
  33:     vec3 sa = axis * s;
  34: 
  35:     mat4 mr = mat4(1.);
  36:     mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
  37:     mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
  38:     mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);
  39: 
  40:     return mr;
  41: }
  42: 
  43: mat4 rotation(vec3 rot) {
  44:     return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
  45: }
  46: 
  47: mat3 modelToNormal(mat4 mat) {
  48:     // Discard the edges. This won't be accurate for scaled or skewed matrices,
  49:     // but we don't have to work with those often.
  50:     mat3 m;
  51:     m[0] = mat[0].xyz;
  52:     m[1] = mat[1].xyz;
  53:     m[2] = mat[2].xyz;
  54:     return m;
  55: }
  56: 
  57: #define PIOVER2 1.5707963268
  58: 
  59: vec4 quat(vec3 axis, float angle) {
  60:     float halfAngle = angle * PIOVER2 / 180.0;
  61:     vec2 cs = sin(vec2(PIOVER2 - halfAngle, halfAngle)); // compute sin and cos in one instruction
  62:     return vec4(axis.xyz * cs.y,  cs.x);
  63: }
  64: 
  65: vec4 quatMult(vec4 q1, vec4 q2) {
  66:     // disgustingly vectorized quaternion multiplication
  67:     vec4 a = q1.w * q2.xyzw;
  68:     vec4 b = q1.x * q2.wzxy * vec4(1., -1., 1., -1.);
  69:     vec4 c = q1.y * q2.zwxy * vec4(1., 1., -1., -1.);
  70:     vec4 d = q1.z * q2.yxwz * vec4(-1., 1., 1., -1.);
  71: 
  72:     return a + b + c + d;
  73: }
  74: 
  75: vec3 rotateVertexByQuat(vec3 v, vec4 q) {
  76:     vec3 i = q.xyz;
  77:     return v + 2.0 * cross(i, cross(i, v) + q.w * v);
  78: }
  79: 
  80: vec3 rotateAbout(vec3 v, vec3 axis, float angle) {
  81:     return rotateVertexByQuat(v, quat(axis, angle));
  82: }
  83: 
  84: float diffuse(vec3 normal) {
  85:     vec3 n2 = normal * normal * vec3(.6, .25, .8);
  86:     return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
  87: }
  88: 
  89: 
  90: struct Actor {
  91:     vec3 pos;
  92:     vec2 light;
  93:     float offset;
  94:     vec3 axis;
  95:     vec4 rotation;
  96:     vec3 rotationCenter;
  97:     float speed;
  98: };
  99: 
 100: 
 101: struct Vertex {
 102:     vec3 pos;
 103:     vec3 normal;
 104:     vec2 texCoords;
 105: };
 106: 
 107: struct BlockFrag {
 108:     vec2 texCoords;
 109:     vec4 color;
 110:     float diffuse;
 111:     vec2 light;
 112: };
 113: 
 114: BlockFrag FLWMain(Vertex v, Actor instance) {
 115:     float degrees = instance.offset + uTime * instance.speed / 20.;
 116:     //float angle = fract(degrees / 360.) * PI * 2.;
 117: 
 118:     vec4 kineticRot = quat(instance.axis, degrees);
 119:     vec3 rotated = rotateVertexByQuat(v.pos - instance.rotationCenter, kineticRot) + instance.rotationCenter;
 120: 
 121:     vec4 worldPos = vec4(rotateVertexByQuat(rotated - .5, instance.rotation) + instance.pos + .5, 1.);
 122:     vec3 norm = rotateVertexByQuat(rotateVertexByQuat(v.normal, kineticRot), instance.rotation);
 123: 
 124:     FLWFinalizeWorldPos(worldPos);
 125:     FLWFinalizeNormal(norm);
 126: 
 127:     BlockFrag b;
 128:     b.diffuse = diffuse(norm);
 129:     b.texCoords = v.texCoords;
 130:     b.light = instance.light;
 131: 
 132:     #if defined(DEBUG_NORMAL)
 133:     b.color = vec4(norm, 1.);
 134:     #else
 135:     b.color = vec4(1.);
 136:     #endif
 137: 
 138:     return b;
 139: }
 140: attribute vec3 a_v_pos;
 141: attribute vec3 a_v_normal;
 142: attribute vec2 a_v_texCoords;
 143: 
 144: attribute vec3 a_i_pos;
 145: attribute vec2 a_i_light;
 146: attribute float a_i_offset;
 147: attribute vec3 a_i_axis;
 148: attribute vec4 a_i_rotation;
 149: attribute vec3 a_i_rotationCenter;
 150: attribute float a_i_speed;
 151: 
 152: 
 153: varying vec2 v2f_texCoords;
 154: varying vec4 v2f_color;
 155: varying float v2f_diffuse;
 156: varying vec2 v2f_light;
 157: 
 158: 
 159: void main() {
 160:     Vertex v;
 161:     v.pos = a_v_pos;
 162: v.normal = a_v_normal;
 163: v.texCoords = a_v_texCoords;
 164: 
 165: 
 166:     Actor i;
 167:     i.pos = a_i_pos;
 168: i.light = a_i_light;
 169: i.offset = a_i_offset;
 170: i.axis = a_i_axis;
 171: i.rotation = a_i_rotation;
 172: i.rotationCenter = a_i_rotationCenter;
 173: i.speed = a_i_speed;
 174: 
 175: 
 176:     BlockFrag o = FLWMain(v, i);
 177: 
 178:     v2f_texCoords = o.texCoords;
 179: v2f_color = o.color;
 180: v2f_diffuse = o.diffuse;
 181: v2f_light = o.light;
 182: 
 183: }

[12:29:43] [main/ERROR]: Shader compilation log for flywheel:block.frag: No errors.

[12:29:43] [main/ERROR]: Source for shader 'flywheel:block.frag':
   1: #version 110
   2: #define USE_FOG
   3: #define USE_FOG_LINEAR
   4: 
   5: #if defined(USE_FOG)
   6: varying float FragDistance;
   7: uniform vec4 uFogColor;
   8: #endif
   9: 
  10: #if defined(USE_FOG_LINEAR)
  11: uniform vec2 uFogRange;
  12: 
  13: float FLWFogFactor() {
  14:     return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
  15: }
  16:     #endif
  17: 
  18:     #if defined(USE_FOG_EXP2)
  19: uniform float uFogDensity;
  20: 
  21: float FLWFogFactor() {
  22:     float dist = FragDistance * uFogDensity;
  23:     return 1. / exp2(dist * dist);
  24: }
  25:     #endif
  26: 
  27: uniform vec2 uTextureScale;
  28: uniform sampler2D uBlockAtlas;
  29: uniform sampler2D uLightMap;
  30: uniform sampler2D uCrumbling;
  31: 
  32: vec4 FLWBlockTexture(vec2 texCoords) {
  33:     vec4 cr = texture2D(uCrumbling, texCoords * uTextureScale);
  34:     float diffuseAlpha = texture2D(uBlockAtlas, texCoords).a;
  35:     cr.a = cr.a * diffuseAlpha;
  36:     return cr;
  37: }
  38: 
  39: void FLWFinalizeColor(vec4 color) {
  40:     #if defined(USE_FOG)
  41:     float a = color.a;
  42:     float fog = clamp(FLWFogFactor(), 0., 1.);
  43: 
  44:     color = mix(uFogColor, color, fog);
  45:     color.a = a;
  46:     #endif
  47: 
  48:     gl_FragColor = color;
  49: }
  50: 
  51: vec4 FLWLight(vec2 lightCoords) {
  52:     return vec4(1.);
  53: }
  54: 
  55: 
  56: 
  57: struct BlockFrag {
  58:     vec2 texCoords;
  59:     vec4 color;
  60:     float diffuse;
  61:     vec2 light;
  62: };
  63: 
  64: void FLWMain(BlockFrag r) {
  65:     vec4 tex = FLWBlockTexture(r.texCoords);
  66: 
  67:     vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;
  68: 
  69: //    flw_WorldPos = ;
  70: //    flw_Normal = ;
  71: //    flw_Albedo = tex.rgb;
  72: //    flw_Alpha = tex.a;
  73: //    flw_LightMap = r.light;
  74: //    flw_Tint = r.color;
  75:     FLWFinalizeColor(color);
  76: }
  77: 
  78: varying vec2 v2f_texCoords;
  79: varying vec4 v2f_color;
  80: varying float v2f_diffuse;
  81: varying vec2 v2f_light;
  82: 
  83: 
  84: //vec3 flw_WorldPos;
  85: //vec3 flw_Normal;
  86: //vec3 flw_Albedo;
  87: //float flw_Alpha;
  88: //vec2 flw_LightMap;
  89: //vec4 flw_Tint;
  90: 
  91: void main() {
  92:     BlockFrag f;
  93:     f.texCoords = v2f_texCoords;
  94: f.color = v2f_color;
  95: f.diffuse = v2f_diffuse;
  96: f.light = v2f_light;
  97: 
  98: 
  99:     FLWMain(f);
 100: }

[12:29:43] [main/ERROR]: Shader compilation log for create:contraption_actor.vert: No errors.

[12:29:43] [main/ERROR]: Source for shader 'create:contraption_actor.vert':
   1: #version 110
   2: #define USE_FOG
   3: #define USE_FOG_EXP2
   4: 
   5: #define PI 3.1415926538
   6: 
   7: uniform float uTime;
   8: uniform mat4 uViewProjection;
   9: uniform vec3 uCameraPos;
  10: 
  11: #if defined(USE_FOG)
  12: varying float FragDistance;
  13: #endif
  14: 
  15: void FLWFinalizeWorldPos(inout vec4 worldPos) {
  16:     #if defined(USE_FOG)
  17:     FragDistance = length(worldPos.xyz - uCameraPos);
  18:     #endif
  19: 
  20:     gl_Position = uViewProjection * worldPos;
  21: }
  22: 
  23: void FLWFinalizeNormal(inout vec3 normal) {
  24:     // noop
  25: }
  26: 
  27: 
  28: mat4 rotate(vec3 axis, float angle) {
  29:     float s = sin(angle);
  30:     float c = cos(angle);
  31:     float oc = 1. - c;
  32: 
  33:     vec3 sa = axis * s;
  34: 
  35:     mat4 mr = mat4(1.);
  36:     mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
  37:     mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
  38:     mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);
  39: 
  40:     return mr;
  41: }
  42: 
  43: mat4 rotation(vec3 rot) {
  44:     return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
  45: }
  46: 
  47: mat3 modelToNormal(mat4 mat) {
  48:     // Discard the edges. This won't be accurate for scaled or skewed matrices,
  49:     // but we don't have to work with those often.
  50:     mat3 m;
  51:     m[0] = mat[0].xyz;
  52:     m[1] = mat[1].xyz;
  53:     m[2] = mat[2].xyz;
  54:     return m;
  55: }
  56: 
  57: #define PIOVER2 1.5707963268
  58: 
  59: vec4 quat(vec3 axis, float angle) {
  60:     float halfAngle = angle * PIOVER2 / 180.0;
  61:     vec2 cs = sin(vec2(PIOVER2 - halfAngle, halfAngle)); // compute sin and cos in one instruction
  62:     return vec4(axis.xyz * cs.y,  cs.x);
  63: }
  64: 
  65: vec4 quatMult(vec4 q1, vec4 q2) {
  66:     // disgustingly vectorized quaternion multiplication
  67:     vec4 a = q1.w * q2.xyzw;
  68:     vec4 b = q1.x * q2.wzxy * vec4(1., -1., 1., -1.);
  69:     vec4 c = q1.y * q2.zwxy * vec4(1., 1., -1., -1.);
  70:     vec4 d = q1.z * q2.yxwz * vec4(-1., 1., 1., -1.);
  71: 
  72:     return a + b + c + d;
  73: }
  74: 
  75: vec3 rotateVertexByQuat(vec3 v, vec4 q) {
  76:     vec3 i = q.xyz;
  77:     return v + 2.0 * cross(i, cross(i, v) + q.w * v);
  78: }
  79: 
  80: vec3 rotateAbout(vec3 v, vec3 axis, float angle) {
  81:     return rotateVertexByQuat(v, quat(axis, angle));
  82: }
  83: 
  84: float diffuse(vec3 normal) {
  85:     vec3 n2 = normal * normal * vec3(.6, .25, .8);
  86:     return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
  87: }
  88: 
  89: 
  90: struct Actor {
  91:     vec3 pos;
  92:     vec2 light;
  93:     float offset;
  94:     vec3 axis;
  95:     vec4 rotation;
  96:     vec3 rotationCenter;
  97:     float speed;
  98: };
  99: 
 100: 
 101: struct Vertex {
 102:     vec3 pos;
 103:     vec3 normal;
 104:     vec2 texCoords;
 105: };
 106: 
 107: struct BlockFrag {
 108:     vec2 texCoords;
 109:     vec4 color;
 110:     float diffuse;
 111:     vec2 light;
 112: };
 113: 
 114: BlockFrag FLWMain(Vertex v, Actor instance) {
 115:     float degrees = instance.offset + uTime * instance.speed / 20.;
 116:     //float angle = fract(degrees / 360.) * PI * 2.;
 117: 
 118:     vec4 kineticRot = quat(instance.axis, degrees);
 119:     vec3 rotated = rotateVertexByQuat(v.pos - instance.rotationCenter, kineticRot) + instance.rotationCenter;
 120: 
 121:     vec4 worldPos = vec4(rotateVertexByQuat(rotated - .5, instance.rotation) + instance.pos + .5, 1.);
 122:     vec3 norm = rotateVertexByQuat(rotateVertexByQuat(v.normal, kineticRot), instance.rotation);
 123: 
 124:     FLWFinalizeWorldPos(worldPos);
 125:     FLWFinalizeNormal(norm);
 126: 
 127:     BlockFrag b;
 128:     b.diffuse = diffuse(norm);
 129:     b.texCoords = v.texCoords;
 130:     b.light = instance.light;
 131: 
 132:     #if defined(DEBUG_NORMAL)
 133:     b.color = vec4(norm, 1.);
 134:     #else
 135:     b.color = vec4(1.);
 136:     #endif
 137: 
 138:     return b;
 139: }
 140: attribute vec3 a_v_pos;
 141: attribute vec3 a_v_normal;
 142: attribute vec2 a_v_texCoords;
 143: 
 144: attribute vec3 a_i_pos;
 145: attribute vec2 a_i_light;
 146: attribute float a_i_offset;
 147: attribute vec3 a_i_axis;
 148: attribute vec4 a_i_rotation;
 149: attribute vec3 a_i_rotationCenter;
 150: attribute float a_i_speed;
 151: 
 152: 
 153: varying vec2 v2f_texCoords;
 154: varying vec4 v2f_color;
 155: varying float v2f_diffuse;
 156: varying vec2 v2f_light;
 157: 
 158: 
 159: void main() {
 160:     Vertex v;
 161:     v.pos = a_v_pos;
 162: v.normal = a_v_normal;
 163: v.texCoords = a_v_texCoords;
 164: 
 165: 
 166:     Actor i;
 167:     i.pos = a_i_pos;
 168: i.light = a_i_light;
 169: i.offset = a_i_offset;
 170: i.axis = a_i_axis;
 171: i.rotation = a_i_rotation;
 172: i.rotationCenter = a_i_rotationCenter;
 173: i.speed = a_i_speed;
 174: 
 175: 
 176:     BlockFrag o = FLWMain(v, i);
 177: 
 178:     v2f_texCoords = o.texCoords;
 179: v2f_color = o.color;
 180: v2f_diffuse = o.diffuse;
 181: v2f_light = o.light;
 182: 
 183: }

[12:29:43] [main/ERROR]: Shader compilation log for flywheel:block.frag: No errors.

[12:29:43] [main/ERROR]: Source for shader 'flywheel:block.frag':
   1: #version 110
   2: #define USE_FOG
   3: #define USE_FOG_EXP2
   4: 
   5: #if defined(USE_FOG)
   6: varying float FragDistance;
   7: uniform vec4 uFogColor;
   8: #endif
   9: 
  10: #if defined(USE_FOG_LINEAR)
  11: uniform vec2 uFogRange;
  12: 
  13: float FLWFogFactor() {
  14:     return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
  15: }
  16:     #endif
  17: 
  18:     #if defined(USE_FOG_EXP2)
  19: uniform float uFogDensity;
  20: 
  21: float FLWFogFactor() {
  22:     float dist = FragDistance * uFogDensity;
  23:     return 1. / exp2(dist * dist);
  24: }
  25:     #endif
  26: 
  27: uniform vec2 uTextureScale;
  28: uniform sampler2D uBlockAtlas;
  29: uniform sampler2D uLightMap;
  30: uniform sampler2D uCrumbling;
  31: 
  32: vec4 FLWBlockTexture(vec2 texCoords) {
  33:     vec4 cr = texture2D(uCrumbling, texCoords * uTextureScale);
  34:     float diffuseAlpha = texture2D(uBlockAtlas, texCoords).a;
  35:     cr.a = cr.a * diffuseAlpha;
  36:     return cr;
  37: }
  38: 
  39: void FLWFinalizeColor(vec4 color) {
  40:     #if defined(USE_FOG)
  41:     float a = color.a;
  42:     float fog = clamp(FLWFogFactor(), 0., 1.);
  43: 
  44:     color = mix(uFogColor, color, fog);
  45:     color.a = a;
  46:     #endif
  47: 
  48:     gl_FragColor = color;
  49: }
  50: 
  51: vec4 FLWLight(vec2 lightCoords) {
  52:     return vec4(1.);
  53: }
  54: 
  55: 
  56: 
  57: struct BlockFrag {
  58:     vec2 texCoords;
  59:     vec4 color;
  60:     float diffuse;
  61:     vec2 light;
  62: };
  63: 
  64: void FLWMain(BlockFrag r) {
  65:     vec4 tex = FLWBlockTexture(r.texCoords);
  66: 
  67:     vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;
  68: 
  69: //    flw_WorldPos = ;
  70: //    flw_Normal = ;
  71: //    flw_Albedo = tex.rgb;
  72: //    flw_Alpha = tex.a;
  73: //    flw_LightMap = r.light;
  74: //    flw_Tint = r.color;
  75:     FLWFinalizeColor(color);
  76: }
  77: 
  78: varying vec2 v2f_texCoords;
  79: varying vec4 v2f_color;
  80: varying float v2f_diffuse;
  81: varying vec2 v2f_light;
  82: 
  83: 
  84: //vec3 flw_WorldPos;
  85: //vec3 flw_Normal;
  86: //vec3 flw_Albedo;
  87: //float flw_Alpha;
  88: //vec2 flw_LightMap;
  89: //vec4 flw_Tint;
  90: 
  91: void main() {
  92:     BlockFrag f;
  93:     f.texCoords = v2f_texCoords;
  94: f.color = v2f_color;
  95: f.diffuse = v2f_diffuse;
  96: f.light = v2f_light;
  97: 
  98: 
  99:     FLWMain(f);
 100: }

[12:29:43] [main/ERROR]: Shader compilation log for create:contraption_actor.vert: No errors.

[12:29:43] [main/ERROR]: Source for shader 'create:contraption_actor.vert':
   1: #version 110
   2: 
   3: #define PI 3.1415926538
   4: 
   5: uniform float uTime;
   6: uniform mat4 uViewProjection;
   7: uniform vec3 uCameraPos;
   8: 
   9: #if defined(USE_FOG)
  10: varying float FragDistance;
  11: #endif
  12: 
  13: void FLWFinalizeWorldPos(inout vec4 worldPos) {
  14:     #if defined(USE_FOG)
  15:     FragDistance = length(worldPos.xyz - uCameraPos);
  16:     #endif
  17: 
  18:     gl_Position = uViewProjection * worldPos;
  19: }
  20: 
  21: void FLWFinalizeNormal(inout vec3 normal) {
  22:     // noop
  23: }
  24: 
  25: 
  26: mat4 rotate(vec3 axis, float angle) {
  27:     float s = sin(angle);
  28:     float c = cos(angle);
  29:     float oc = 1. - c;
  30: 
  31:     vec3 sa = axis * s;
  32: 
  33:     mat4 mr = mat4(1.);
  34:     mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
  35:     mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
  36:     mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);
  37: 
  38:     return mr;
  39: }
  40: 
  41: mat4 rotation(vec3 rot) {
  42:     return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
  43: }
  44: 
  45: mat3 modelToNormal(mat4 mat) {
  46:     // Discard the edges. This won't be accurate for scaled or skewed matrices,
  47:     // but we don't have to work with those often.
  48:     mat3 m;
  49:     m[0] = mat[0].xyz;
  50:     m[1] = mat[1].xyz;
  51:     m[2] = mat[2].xyz;
  52:     return m;
  53: }
  54: 
  55: #define PIOVER2 1.5707963268
  56: 
  57: vec4 quat(vec3 axis, float angle) {
  58:     float halfAngle = angle * PIOVER2 / 180.0;
  59:     vec2 cs = sin(vec2(PIOVER2 - halfAngle, halfAngle)); // compute sin and cos in one instruction
  60:     return vec4(axis.xyz * cs.y,  cs.x);
  61: }
  62: 
  63: vec4 quatMult(vec4 q1, vec4 q2) {
  64:     // disgustingly vectorized quaternion multiplication
  65:     vec4 a = q1.w * q2.xyzw;
  66:     vec4 b = q1.x * q2.wzxy * vec4(1., -1., 1., -1.);
  67:     vec4 c = q1.y * q2.zwxy * vec4(1., 1., -1., -1.);
  68:     vec4 d = q1.z * q2.yxwz * vec4(-1., 1., 1., -1.);
  69: 
  70:     return a + b + c + d;
  71: }
  72: 
  73: vec3 rotateVertexByQuat(vec3 v, vec4 q) {
  74:     vec3 i = q.xyz;
  75:     return v + 2.0 * cross(i, cross(i, v) + q.w * v);
  76: }
  77: 
  78: vec3 rotateAbout(vec3 v, vec3 axis, float angle) {
  79:     return rotateVertexByQuat(v, quat(axis, angle));
  80: }
  81: 
  82: float diffuse(vec3 normal) {
  83:     vec3 n2 = normal * normal * vec3(.6, .25, .8);
  84:     return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
  85: }
  86: 
  87: 
  88: struct Actor {
  89:     vec3 pos;
  90:     vec2 light;
  91:     float offset;
  92:     vec3 axis;
  93:     vec4 rotation;
  94:     vec3 rotationCenter;
  95:     float speed;
  96: };
  97: 
  98: 
  99: struct Vertex {
 100:     vec3 pos;
 101:     vec3 normal;
 102:     vec2 texCoords;
 103: };
 104: 
 105: struct BlockFrag {
 106:     vec2 texCoords;
 107:     vec4 color;
 108:     float diffuse;
 109:     vec2 light;
 110: };
 111: 
 112: BlockFrag FLWMain(Vertex v, Actor instance) {
 113:     float degrees = instance.offset + uTime * instance.speed / 20.;
 114:     //float angle = fract(degrees / 360.) * PI * 2.;
 115: 
 116:     vec4 kineticRot = quat(instance.axis, degrees);
 117:     vec3 rotated = rotateVertexByQuat(v.pos - instance.rotationCenter, kineticRot) + instance.rotationCenter;
 118: 
 119:     vec4 worldPos = vec4(rotateVertexByQuat(rotated - .5, instance.rotation) + instance.pos + .5, 1.);
 120:     vec3 norm = rotateVertexByQuat(rotateVertexByQuat(v.normal, kineticRot), instance.rotation);
 121: 
 122:     FLWFinalizeWorldPos(worldPos);
 123:     FLWFinalizeNormal(norm);
 124: 
 125:     BlockFrag b;
 126:     b.diffuse = diffuse(norm);
 127:     b.texCoords = v.texCoords;
 128:     b.light = instance.light;
 129: 
 130:     #if defined(DEBUG_NORMAL)
 131:     b.color = vec4(norm, 1.);
 132:     #else
 133:     b.color = vec4(1.);
 134:     #endif
 135: 
 136:     return b;
 137: }
 138: attribute vec3 a_v_pos;
 139: attribute vec3 a_v_normal;
 140: attribute vec2 a_v_texCoords;
 141: 
 142: attribute vec3 a_i_pos;
 143: attribute vec2 a_i_light;
 144: attribute float a_i_offset;
 145: attribute vec3 a_i_axis;
 146: attribute vec4 a_i_rotation;
 147: attribute vec3 a_i_rotationCenter;
 148: attribute float a_i_speed;
 149: 
 150: 
 151: varying vec2 v2f_texCoords;
 152: varying vec4 v2f_color;
 153: varying float v2f_diffuse;
 154: varying vec2 v2f_light;
 155: 
 156: 
 157: void main() {
 158:     Vertex v;
 159:     v.pos = a_v_pos;
 160: v.normal = a_v_normal;
 161: v.texCoords = a_v_texCoords;
 162: 
 163: 
 164:     Actor i;
 165:     i.pos = a_i_pos;
 166: i.light = a_i_light;
 167: i.offset = a_i_offset;
 168: i.axis = a_i_axis;
 169: i.rotation = a_i_rotation;
 170: i.rotationCenter = a_i_rotationCenter;
 171: i.speed = a_i_speed;
 172: 
 173: 
 174:     BlockFrag o = FLWMain(v, i);
 175: 
 176:     v2f_texCoords = o.texCoords;
 177: v2f_color = o.color;
 178: v2f_diffuse = o.diffuse;
 179: v2f_light = o.light;
 180: 
 181: }

[12:29:43] [main/ERROR]: Shader compilation log for flywheel:block.frag: No errors.

[12:29:43] [main/ERROR]: Source for shader 'flywheel:block.frag':
   1: #version 110
   2: 
   3: #if defined(USE_FOG)
   4: varying float FragDistance;
   5: uniform vec4 uFogColor;
   6: #endif
   7: 
   8: #if defined(USE_FOG_LINEAR)
   9: uniform vec2 uFogRange;
  10: 
  11: float FLWFogFactor() {
  12:     return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
  13: }
  14:     #endif
  15: 
  16:     #if defined(USE_FOG_EXP2)
  17: uniform float uFogDensity;
  18: 
  19: float FLWFogFactor() {
  20:     float dist = FragDistance * uFogDensity;
  21:     return 1. / exp2(dist * dist);
  22: }
  23:     #endif
  24: 
  25: uniform vec2 uTextureScale;
  26: uniform sampler2D uBlockAtlas;
  27: uniform sampler2D uLightMap;
  28: uniform sampler2D uCrumbling;
  29: 
  30: vec4 FLWBlockTexture(vec2 texCoords) {
  31:     vec4 cr = texture2D(uCrumbling, texCoords * uTextureScale);
  32:     float diffuseAlpha = texture2D(uBlockAtlas, texCoords).a;
  33:     cr.a = cr.a * diffuseAlpha;
  34:     return cr;
  35: }
  36: 
  37: void FLWFinalizeColor(vec4 color) {
  38:     #if defined(USE_FOG)
  39:     float a = color.a;
  40:     float fog = clamp(FLWFogFactor(), 0., 1.);
  41: 
  42:     color = mix(uFogColor, color, fog);
  43:     color.a = a;
  44:     #endif
  45: 
  46:     gl_FragColor = color;
  47: }
  48: 
  49: vec4 FLWLight(vec2 lightCoords) {
  50:     return vec4(1.);
  51: }
  52: 
  53: 
  54: 
  55: struct BlockFrag {
  56:     vec2 texCoords;
  57:     vec4 color;
  58:     float diffuse;
  59:     vec2 light;
  60: };
  61: 
  62: void FLWMain(BlockFrag r) {
  63:     vec4 tex = FLWBlockTexture(r.texCoords);
  64: 
  65:     vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;
  66: 
  67: //    flw_WorldPos = ;
  68: //    flw_Normal = ;
  69: //    flw_Albedo = tex.rgb;
  70: //    flw_Alpha = tex.a;
  71: //    flw_LightMap = r.light;
  72: //    flw_Tint = r.color;
  73:     FLWFinalizeColor(color);
  74: }
  75: 
  76: varying vec2 v2f_texCoords;
  77: varying vec4 v2f_color;
  78: varying float v2f_diffuse;
  79: varying vec2 v2f_light;
  80: 
  81: 
  82: //vec3 flw_WorldPos;
  83: //vec3 flw_Normal;
  84: //vec3 flw_Albedo;
  85: //float flw_Alpha;
  86: //vec2 flw_LightMap;
  87: //vec4 flw_Tint;
  88: 
  89: void main() {
  90:     BlockFrag f;
  91:     f.texCoords = v2f_texCoords;
  92: f.color = v2f_color;
  93: f.diffuse = v2f_diffuse;
  94: f.light = v2f_light;
  95: 
  96: 
  97:     FLWMain(f);
  98: }

[12:29:43] [main/ERROR]: Shader compilation log for create:flap.vert: No errors.

[12:29:43] [main/ERROR]: Source for shader 'create:flap.vert':
   1: #version 110
   2: #define DEBUG_NORMAL
   3: 
   4: #define PI 3.1415926538
   5: 
   6: uniform float uTime;
   7: uniform mat4 uViewProjection;
   8: uniform vec3 uCameraPos;
   9: 
  10: #if defined(USE_FOG)
  11: varying float FragDistance;
  12: #endif
  13: 
  14: void FLWFinalizeWorldPos(inout vec4 worldPos) {
  15:     #if defined(USE_FOG)
  16:     FragDistance = length(worldPos.xyz - uCameraPos);
  17:     #endif
  18: 
  19:     gl_Position = uViewProjection * worldPos;
  20: }
  21: 
  22: void FLWFinalizeNormal(inout vec3 normal) {
  23:     // noop
  24: }
  25: 
  26: 
  27: mat4 rotate(vec3 axis, float angle) {
  28:     float s = sin(angle);
  29:     float c = cos(angle);
  30:     float oc = 1. - c;
  31: 
  32:     vec3 sa = axis * s;
  33: 
  34:     mat4 mr = mat4(1.);
  35:     mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
  36:     mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
  37:     mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);
  38: 
  39:     return mr;
  40: }
  41: 
  42: mat4 rotation(vec3 rot) {
  43:     return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
  44: }
  45: 
  46: mat3 modelToNormal(mat4 mat) {
  47:     // Discard the edges. This won't be accurate for scaled or skewed matrices,
  48:     // but we don't have to work with those often.
  49:     mat3 m;
  50:     m[0] = mat[0].xyz;
  51:     m[1] = mat[1].xyz;
  52:     m[2] = mat[2].xyz;
  53:     return m;
  54: }
  55: 
  56: #define PIOVER2 1.5707963268
  57: 
  58: vec4 quat(vec3 axis, float angle) {
  59:     float halfAngle = angle * PIOVER2 / 180.0;
  60:     vec2 cs = sin(vec2(PIOVER2 - halfAngle, halfAngle)); // compute sin and cos in one instruction
  61:     return vec4(axis.xyz * cs.y,  cs.x);
  62: }
  63: 
  64: vec4 quatMult(vec4 q1, vec4 q2) {
  65:     // disgustingly vectorized quaternion multiplication
  66:     vec4 a = q1.w * q2.xyzw;
  67:     vec4 b = q1.x * q2.wzxy * vec4(1., -1., 1., -1.);
  68:     vec4 c = q1.y * q2.zwxy * vec4(1., 1., -1., -1.);
  69:     vec4 d = q1.z * q2.yxwz * vec4(-1., 1., 1., -1.);
  70: 
  71:     return a + b + c + d;
  72: }
  73: 
  74: vec3 rotateVertexByQuat(vec3 v, vec4 q) {
  75:     vec3 i = q.xyz;
  76:     return v + 2.0 * cross(i, cross(i, v) + q.w * v);
  77: }
  78: 
  79: vec3 rotateAbout(vec3 v, vec3 axis, float angle) {
  80:     return rotateVertexByQuat(v, quat(axis, angle));
  81: }
  82: 
  83: float diffuse(vec3 normal) {
  84:     vec3 n2 = normal * normal * vec3(.6, .25, .8);
  85:     return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
  86: }
  87: 
  88: 
  89: struct Flap {
  90:     vec3 instancePos;
  91:     vec2 light;
  92:     vec3 segmentOffset;
  93:     vec3 pivot;
  94:     float horizontalAngle;
  95:     float intensity;
  96:     float flapScale;
  97:     float flapness;
  98: };
  99: 
 100: 
 101: struct Vertex {
 102:     vec3 pos;
 103:     vec3 normal;
 104:     vec2 texCoords;
 105: };
 106: 
 107: struct BlockFrag {
 108:     vec2 texCoords;
 109:     vec4 color;
 110:     float diffuse;
 111:     vec2 light;
 112: };
 113: 
 114: 
 115: float toRad(float degrees) {
 116:     return fract(degrees / 360.) * PI * 2.;
 117: }
 118: 
 119: float getFlapAngle(float flapness, float intensity, float scale) {
 120:     float absFlap = abs(flapness);
 121: 
 122:     float angle = sin((1. - absFlap) * PI * intensity) * 30. * flapness * scale;
 123: 
 124:     float halfAngle = angle * 0.5;
 125: 
 126:     float which = step(0., flapness);// 0 if negative, 1 if positive
 127:     float degrees = which * halfAngle + (1. - which) * angle;// branchless conditional multiply
 128: 
 129:     return degrees;
 130: }
 131: 
 132: BlockFrag FLWMain(Vertex v, Flap flap) {
 133:     float flapAngle = getFlapAngle(flap.flapness, flap.intensity, flap.flapScale);
 134: 
 135:     vec4 orientation = quat(vec3(0., 1., 0.), -flap.horizontalAngle);
 136:     vec4 flapRotation = quat(vec3(1., 0., 0.), flapAngle);
 137: 
 138:     vec3 rotated = rotateVertexByQuat(v.pos - flap.pivot, flapRotation) + flap.pivot + flap.segmentOffset;
 139:     rotated = rotateVertexByQuat(rotated - .5, orientation) + flap.instancePos + .5;
 140: 
 141:     vec4 worldPos = vec4(rotated, 1.);
 142:     vec3 norm = rotateVertexByQuat(rotateVertexByQuat(v.normal, flapRotation), orientation);
 143: 
 144:     FLWFinalizeWorldPos(worldPos);
 145:     FLWFinalizeNormal(norm);
 146: 
 147:     BlockFrag b;
 148:     b.diffuse = diffuse(norm);
 149:     b.texCoords = v.texCoords;
 150:     b.light = flap.light;
 151:     #if defined(DEBUG_NORMAL)
 152:     b.color = vec4(norm, 1.);
 153:     #else
 154:     b.color = vec4(1.);
 155:     #endif
 156:     return b;
 157: }
 158: attribute vec3 a_v_pos;
 159: attribute vec3 a_v_normal;
 160: attribute vec2 a_v_texCoords;
 161: 
 162: attribute vec3 a_i_instancePos;
 163: attribute vec2 a_i_light;
 164: attribute vec3 a_i_segmentOffset;
 165: attribute vec3 a_i_pivot;
 166: attribute float a_i_horizontalAngle;
 167: attribute float a_i_intensity;
 168: attribute float a_i_flapScale;
 169: attribute float a_i_flapness;
 170: 
 171: 
 172: varying vec2 v2f_texCoords;
 173: varying vec4 v2f_color;
 174: varying float v2f_diffuse;
 175: varying vec2 v2f_light;
 176: 
 177: 
 178: void main() {
 179:     Vertex v;
 180:     v.pos = a_v_pos;
 181: v.normal = a_v_normal;
 182: v.texCoords = a_v_texCoords;
 183: 
 184: 
 185:     Flap i;
 186:     i.instancePos = a_i_instancePos;
 187: i.light = a_i_light;
 188: i.segmentOffset = a_i_segmentOffset;
 189: i.pivot = a_i_pivot;
 190: i.horizontalAngle = a_i_horizontalAngle;
 191: i.intensity = a_i_intensity;
 192: i.flapScale = a_i_flapScale;
 193: i.flapness = a_i_flapness;
 194: 
 195: 
 196:     BlockFrag o = FLWMain(v, i);
 197: 
 198:     v2f_texCoords = o.texCoords;
 199: v2f_color = o.color;
 200: v2f_diffuse = o.diffuse;
 201: v2f_light = o.light;
 202: 
 203: }

[12:29:43] [main/ERROR]: Shader compilation log for flywheel:block.frag: No errors.

[12:29:43] [main/ERROR]: Source for shader 'flywheel:block.frag':
   1: #version 110
   2: #define DEBUG_NORMAL
   3: 
   4: #if defined(USE_FOG)
   5: varying float FragDistance;
   6: uniform vec4 uFogColor;
   7: #endif
   8: 
   9: #if defined(USE_FOG_LINEAR)
  10: uniform vec2 uFogRange;
  11: 
  12: float FLWFogFactor() {
  13:     return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
  14: }
  15:     #endif
  16: 
  17:     #if defined(USE_FOG_EXP2)
  18: uniform float uFogDensity;
  19: 
  20: float FLWFogFactor() {
  21:     float dist = FragDistance * uFogDensity;
  22:     return 1. / exp2(dist * dist);
  23: }
  24:     #endif
  25: 
  26: uniform vec2 uTextureScale;
  27: uniform sampler2D uBlockAtlas;
  28: uniform sampler2D uLightMap;
  29: uniform sampler2D uCrumbling;
  30: 
  31: vec4 FLWBlockTexture(vec2 texCoords) {
  32:     vec4 cr = texture2D(uCrumbling, texCoords * uTextureScale);
  33:     float diffuseAlpha = texture2D(uBlockAtlas, texCoords).a;
  34:     cr.a = cr.a * diffuseAlpha;
  35:     return cr;
  36: }
  37: 
  38: void FLWFinalizeColor(vec4 color) {
  39:     #if defined(USE_FOG)
  40:     float a = color.a;
  41:     float fog = clamp(FLWFogFactor(), 0., 1.);
  42: 
  43:     color = mix(uFogColor, color, fog);
  44:     color.a = a;
  45:     #endif
  46: 
  47:     gl_FragColor = color;
  48: }
  49: 
  50: vec4 FLWLight(vec2 lightCoords) {
  51:     return vec4(1.);
  52: }
  53: 
  54: 
  55: 
  56: struct BlockFrag {
  57:     vec2 texCoords;
  58:     vec4 color;
  59:     float diffuse;
  60:     vec2 light;
  61: };
  62: 
  63: void FLWMain(BlockFrag r) {
  64:     vec4 tex = FLWBlockTexture(r.texCoords);
  65: 
  66:     vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;
  67: 
  68: //    flw_WorldPos = ;
  69: //    flw_Normal = ;
  70: //    flw_Albedo = tex.rgb;
  71: //    flw_Alpha = tex.a;
  72: //    flw_LightMap = r.light;
  73: //    flw_Tint = r.color;
  74:     FLWFinalizeColor(color);
  75: }
  76: 
  77: varying vec2 v2f_texCoords;
  78: varying vec4 v2f_color;
  79: varying float v2f_diffuse;
  80: varying vec2 v2f_light;
  81: 
  82: 
  83: //vec3 flw_WorldPos;
  84: //vec3 flw_Normal;
  85: //vec3 flw_Albedo;
  86: //float flw_Alpha;
  87: //vec2 flw_LightMap;
  88: //vec4 flw_Tint;
  89: 
  90: void main() {
  91:     BlockFrag f;
  92:     f.texCoords = v2f_texCoords;
  93: f.color = v2f_color;
  94: f.diffuse = v2f_diffuse;
  95: f.light = v2f_light;
  96: 
  97: 
  98:     FLWMain(f);
  99: }

[12:29:43] [main/ERROR]: Shader compilation log for create:flap.vert: No errors.

[12:29:43] [main/ERROR]: Source for shader 'create:flap.vert':
   1: #version 110
   2: #define USE_FOG
   3: #define USE_FOG_LINEAR
   4: 
   5: #define PI 3.1415926538
   6: 
   7: uniform float uTime;
   8: uniform mat4 uViewProjection;
   9: uniform vec3 uCameraPos;
  10: 
  11: #if defined(USE_FOG)
  12: varying float FragDistance;
  13: #endif
  14: 
  15: void FLWFinalizeWorldPos(inout vec4 worldPos) {
  16:     #if defined(USE_FOG)
  17:     FragDistance = length(worldPos.xyz - uCameraPos);
  18:     #endif
  19: 
  20:     gl_Position = uViewProjection * worldPos;
  21: }
  22: 
  23: void FLWFinalizeNormal(inout vec3 normal) {
  24:     // noop
  25: }
  26: 
  27: 
  28: mat4 rotate(vec3 axis, float angle) {
  29:     float s = sin(angle);
  30:     float c = cos(angle);
  31:     float oc = 1. - c;
  32: 
  33:     vec3 sa = axis * s;
  34: 
  35:     mat4 mr = mat4(1.);
  36:     mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
  37:     mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
  38:     mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);
  39: 
  40:     return mr;
  41: }
  42: 
  43: mat4 rotation(vec3 rot) {
  44:     return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
  45: }
  46: 
  47: mat3 modelToNormal(mat4 mat) {
  48:     // Discard the edges. This won't be accurate for scaled or skewed matrices,
  49:     // but we don't have to work with those often.
  50:     mat3 m;
  51:     m[0] = mat[0].xyz;
  52:     m[1] = mat[1].xyz;
  53:     m[2] = mat[2].xyz;
  54:     return m;
  55: }
  56: 
  57: #define PIOVER2 1.5707963268
  58: 
  59: vec4 quat(vec3 axis, float angle) {
  60:     float halfAngle = angle * PIOVER2 / 180.0;
  61:     vec2 cs = sin(vec2(PIOVER2 - halfAngle, halfAngle)); // compute sin and cos in one instruction
  62:     return vec4(axis.xyz * cs.y,  cs.x);
  63: }
  64: 
  65: vec4 quatMult(vec4 q1, vec4 q2) {
  66:     // disgustingly vectorized quaternion multiplication
  67:     vec4 a = q1.w * q2.xyzw;
  68:     vec4 b = q1.x * q2.wzxy * vec4(1., -1., 1., -1.);
  69:     vec4 c = q1.y * q2.zwxy * vec4(1., 1., -1., -1.);
  70:     vec4 d = q1.z * q2.yxwz * vec4(-1., 1., 1., -1.);
  71: 
  72:     return a + b + c + d;
  73: }
  74: 
  75: vec3 rotateVertexByQuat(vec3 v, vec4 q) {
  76:     vec3 i = q.xyz;
  77:     return v + 2.0 * cross(i, cross(i, v) + q.w * v);
  78: }
  79: 
  80: vec3 rotateAbout(vec3 v, vec3 axis, float angle) {
  81:     return rotateVertexByQuat(v, quat(axis, angle));
  82: }
  83: 
  84: float diffuse(vec3 normal) {
  85:     vec3 n2 = normal * normal * vec3(.6, .25, .8);
  86:     return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
  87: }
  88: 
  89: 
  90: struct Flap {
  91:     vec3 instancePos;
  92:     vec2 light;
  93:     vec3 segmentOffset;
  94:     vec3 pivot;
  95:     float horizontalAngle;
  96:     float intensity;
  97:     float flapScale;
  98:     float flapness;
  99: };
 100: 
 101: 
 102: struct Vertex {
 103:     vec3 pos;
 104:     vec3 normal;
 105:     vec2 texCoords;
 106: };
 107: 
 108: struct BlockFrag {
 109:     vec2 texCoords;
 110:     vec4 color;
 111:     float diffuse;
 112:     vec2 light;
 113: };
 114: 
 115: 
 116: float toRad(float degrees) {
 117:     return fract(degrees / 360.) * PI * 2.;
 118: }
 119: 
 120: float getFlapAngle(float flapness, float intensity, float scale) {
 121:     float absFlap = abs(flapness);
 122: 
 123:     float angle = sin((1. - absFlap) * PI * intensity) * 30. * flapness * scale;
 124: 
 125:     float halfAngle = angle * 0.5;
 126: 
 127:     float which = step(0., flapness);// 0 if negative, 1 if positive
 128:     float degrees = which * halfAngle + (1. - which) * angle;// branchless conditional multiply
 129: 
 130:     return degrees;
 131: }
 132: 
 133: BlockFrag FLWMain(Vertex v, Flap flap) {
 134:     float flapAngle = getFlapAngle(flap.flapness, flap.intensity, flap.flapScale);
 135: 
 136:     vec4 orientation = quat(vec3(0., 1., 0.), -flap.horizontalAngle);
 137:     vec4 flapRotation = quat(vec3(1., 0., 0.), flapAngle);
 138: 
 139:     vec3 rotated = rotateVertexByQuat(v.pos - flap.pivot, flapRotation) + flap.pivot + flap.segmentOffset;
 140:     rotated = rotateVertexByQuat(rotated - .5, orientation) + flap.instancePos + .5;
 141: 
 142:     vec4 worldPos = vec4(rotated, 1.);
 143:     vec3 norm = rotateVertexByQuat(rotateVertexByQuat(v.normal, flapRotation), orientation);
 144: 
 145:     FLWFinalizeWorldPos(worldPos);
 146:     FLWFinalizeNormal(norm);
 147: 
 148:     BlockFrag b;
 149:     b.diffuse = diffuse(norm);
 150:     b.texCoords = v.texCoords;
 151:     b.light = flap.light;
 152:     #if defined(DEBUG_NORMAL)
 153:     b.color = vec4(norm, 1.);
 154:     #else
 155:     b.color = vec4(1.);
 156:     #endif
 157:     return b;
 158: }
 159: attribute vec3 a_v_pos;
 160: attribute vec3 a_v_normal;
 161: attribute vec2 a_v_texCoords;
 162: 
 163: attribute vec3 a_i_instancePos;
 164: attribute vec2 a_i_light;
 165: attribute vec3 a_i_segmentOffset;
 166: attribute vec3 a_i_pivot;
 167: attribute float a_i_horizontalAngle;
 168: attribute float a_i_intensity;
 169: attribute float a_i_flapScale;
 170: attribute float a_i_flapness;
 171: 
 172: 
 173: varying vec2 v2f_texCoords;
 174: varying vec4 v2f_color;
 175: varying float v2f_diffuse;
 176: varying vec2 v2f_light;
 177: 
 178: 
 179: void main() {
 180:     Vertex v;
 181:     v.pos = a_v_pos;
 182: v.normal = a_v_normal;
 183: v.texCoords = a_v_texCoords;
 184: 
 185: 
 186:     Flap i;
 187:     i.instancePos = a_i_instancePos;
 188: i.light = a_i_light;
 189: i.segmentOffset = a_i_segmentOffset;
 190: i.pivot = a_i_pivot;
 191: i.horizontalAngle = a_i_horizontalAngle;
 192: i.intensity = a_i_intensity;
 193: i.flapScale = a_i_flapScale;
 194: i.flapness = a_i_flapness;
 195: 
 196: 
 197:     BlockFrag o = FLWMain(v, i);
 198: 
 199:     v2f_texCoords = o.texCoords;
 200: v2f_color = o.color;
 201: v2f_diffuse = o.diffuse;
 202: v2f_light = o.light;
 203: 
 204: }

[12:29:43] [main/ERROR]: Shader compilation log for flywheel:block.frag: No errors.

[12:29:43] [Forge Version Check/INFO]: [codechickenlib] Found status: UP_TO_DATE Current: 4.0.7.445 Target: null
[12:29:43] [Forge Version Check/INFO]: [enderstorage] Starting version check at https://version-check.covers1624.net/check/?mod=EnderStorage&mc=1.16.5
[12:29:43] [main/ERROR]: Source for shader 'flywheel:block.frag':
   1: #version 110
   2: #define USE_FOG
   3: #define USE_FOG_LINEAR
   4: 
   5: #if defined(USE_FOG)
   6: varying float FragDistance;
   7: uniform vec4 uFogColor;
   8: #endif
   9: 
  10: #if defined(USE_FOG_LINEAR)
  11: uniform vec2 uFogRange;
  12: 
  13: float FLWFogFactor() {
  14:     return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
  15: }
  16:     #endif
  17: 
  18:     #if defined(USE_FOG_EXP2)
  19: uniform float uFogDensity;
  20: 
  21: float FLWFogFactor() {
  22:     float dist = FragDistance * uFogDensity;
  23:     return 1. / exp2(dist * dist);
  24: }
  25:     #endif
  26: 
  27: uniform vec2 uTextureScale;
  28: uniform sampler2D uBlockAtlas;
  29: uniform sampler2D uLightMap;
  30: uniform sampler2D uCrumbling;
  31: 
  32: vec4 FLWBlockTexture(vec2 texCoords) {
  33:     vec4 cr = texture2D(uCrumbling, texCoords * uTextureScale);
  34:     float diffuseAlpha = texture2D(uBlockAtlas, texCoords).a;
  35:     cr.a = cr.a * diffuseAlpha;
  36:     return cr;
  37: }
  38: 
  39: void FLWFinalizeColor(vec4 color) {
  40:     #if defined(USE_FOG)
  41:     float a = color.a;
  42:     float fog = clamp(FLWFogFactor(), 0., 1.);
  43: 
  44:     color = mix(uFogColor, color, fog);
  45:     color.a = a;
  46:     #endif
  47: 
  48:     gl_FragColor = color;
  49: }
  50: 
  51: vec4 FLWLight(vec2 lightCoords) {
  52:     return vec4(1.);
  53: }
  54: 
  55: 
  56: 
  57: struct BlockFrag {
  58:     vec2 texCoords;
  59:     vec4 color;
  60:     float diffuse;
  61:     vec2 light;
  62: };
  63: 
  64: void FLWMain(BlockFrag r) {
  65:     vec4 tex = FLWBlockTexture(r.texCoords);
  66: 
  67:     vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;
  68: 
  69: //    flw_WorldPos = ;
  70: //    flw_Normal = ;
  71: //    flw_Albedo = tex.rgb;
  72: //    flw_Alpha = tex.a;
  73: //    flw_LightMap = r.light;
  74: //    flw_Tint = r.color;
  75:     FLWFinalizeColor(color);
  76: }
  77: 
  78: varying vec2 v2f_texCoords;
  79: varying vec4 v2f_color;
  80: varying float v2f_diffuse;
  81: varying vec2 v2f_light;
  82: 
  83: 
  84: //vec3 flw_WorldPos;
  85: //vec3 flw_Normal;
  86: //vec3 flw_Albedo;
  87: //float flw_Alpha;
  88: //vec2 flw_LightMap;
  89: //vec4 flw_Tint;
  90: 
  91: void main() {
  92:     BlockFrag f;
  93:     f.texCoords = v2f_texCoords;
  94: f.color = v2f_color;
  95: f.diffuse = v2f_diffuse;
  96: f.light = v2f_light;
  97: 
  98: 
  99:     FLWMain(f);
 100: }

[12:29:43] [main/ERROR]: Shader compilation log for create:flap.vert: No errors.

[12:29:43] [main/ERROR]: Source for shader 'create:flap.vert':
   1: #version 110
   2: #define USE_FOG
   3: #define USE_FOG_EXP2
   4: 
   5: #define PI 3.1415926538
   6: 
   7: uniform float uTime;
   8: uniform mat4 uViewProjection;
   9: uniform vec3 uCameraPos;
  10: 
  11: #if defined(USE_FOG)
  12: varying float FragDistance;
  13: #endif
  14: 
  15: void FLWFinalizeWorldPos(inout vec4 worldPos) {
  16:     #if defined(USE_FOG)
  17:     FragDistance = length(worldPos.xyz - uCameraPos);
  18:     #endif
  19: 
  20:     gl_Position = uViewProjection * worldPos;
  21: }
  22: 
  23: void FLWFinalizeNormal(inout vec3 normal) {
  24:     // noop
  25: }
  26: 
  27: 
  28: mat4 rotate(vec3 axis, float angle) {
  29:     float s = sin(angle);
  30:     float c = cos(angle);
  31:     float oc = 1. - c;
  32: 
  33:     vec3 sa = axis * s;
  34: 
  35:     mat4 mr = mat4(1.);
  36:     mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
  37:     mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
  38:     mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);
  39: 
  40:     return mr;
  41: }
  42: 
  43: mat4 rotation(vec3 rot) {
  44:     return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
  45: }
  46: 
  47: mat3 modelToNormal(mat4 mat) {
  48:     // Discard the edges. This won't be accurate for scaled or skewed matrices,
  49:     // but we don't have to work with those often.
  50:     mat3 m;
  51:     m[0] = mat[0].xyz;
  52:     m[1] = mat[1].xyz;
  53:     m[2] = mat[2].xyz;
  54:     return m;
  55: }
  56: 
  57: #define PIOVER2 1.5707963268
  58: 
  59: vec4 quat(vec3 axis, float angle) {
  60:     float halfAngle = angle * PIOVER2 / 180.0;
  61:     vec2 cs = sin(vec2(PIOVER2 - halfAngle, halfAngle)); // compute sin and cos in one instruction
  62:     return vec4(axis.xyz * cs.y,  cs.x);
  63: }
  64: 
  65: vec4 quatMult(vec4 q1, vec4 q2) {
  66:     // disgustingly vectorized quaternion multiplication
  67:     vec4 a = q1.w * q2.xyzw;
  68:     vec4 b = q1.x * q2.wzxy * vec4(1., -1., 1., -1.);
  69:     vec4 c = q1.y * q2.zwxy * vec4(1., 1., -1., -1.);
  70:     vec4 d = q1.z * q2.yxwz * vec4(-1., 1., 1., -1.);
  71: 
  72:     return a + b + c + d;
  73: }
  74: 
  75: vec3 rotateVertexByQuat(vec3 v, vec4 q) {
  76:     vec3 i = q.xyz;
  77:     return v + 2.0 * cross(i, cross(i, v) + q.w * v);
  78: }
  79: 
  80: vec3 rotateAbout(vec3 v, vec3 axis, float angle) {
  81:     return rotateVertexByQuat(v, quat(axis, angle));
  82: }
  83: 
  84: float diffuse(vec3 normal) {
  85:     vec3 n2 = normal * normal * vec3(.6, .25, .8);
  86:     return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
  87: }
  88: 
  89: 
  90: struct Flap {
  91:     vec3 instancePos;
  92:     vec2 light;
  93:     vec3 segmentOffset;
  94:     vec3 pivot;
  95:     float horizontalAngle;
  96:     float intensity;
  97:     float flapScale;
  98:     float flapness;
  99: };
 100: 
 101: 
 102: struct Vertex {
 103:     vec3 pos;
 104:     vec3 normal;
 105:     vec2 texCoords;
 106: };
 107: 
 108: struct BlockFrag {
 109:     vec2 texCoords;
 110:     vec4 color;
 111:     float diffuse;
 112:     vec2 light;
 113: };
 114: 
 115: 
 116: float toRad(float degrees) {
 117:     return fract(degrees / 360.) * PI * 2.;
 118: }
 119: 
 120: float getFlapAngle(float flapness, float intensity, float scale) {
 121:     float absFlap = abs(flapness);
 122: 
 123:     float angle = sin((1. - absFlap) * PI * intensity) * 30. * flapness * scale;
 124: 
 125:     float halfAngle = angle * 0.5;
 126: 
 127:     float which = step(0., flapness);// 0 if negative, 1 if positive
 128:     float degrees = which * halfAngle + (1. - which) * angle;// branchless conditional multiply
 129: 
 130:     return degrees;
 131: }
 132: 
 133: BlockFrag FLWMain(Vertex v, Flap flap) {
 134:     float flapAngle = getFlapAngle(flap.flapness, flap.intensity, flap.flapScale);
 135: 
 136:     vec4 orientation = quat(vec3(0., 1., 0.), -flap.horizontalAngle);
 137:     vec4 flapRotation = quat(vec3(1., 0., 0.), flapAngle);
 138: 
 139:     vec3 rotated = rotateVertexByQuat(v.pos - flap.pivot, flapRotation) + flap.pivot + flap.segmentOffset;
 140:     rotated = rotateVertexByQuat(rotated - .5, orientation) + flap.instancePos + .5;
 141: 
 142:     vec4 worldPos = vec4(rotated, 1.);
 143:     vec3 norm = rotateVertexByQuat(rotateVertexByQuat(v.normal, flapRotation), orientation);
 144: 
 145:     FLWFinalizeWorldPos(worldPos);
 146:     FLWFinalizeNormal(norm);
 147: 
 148:     BlockFrag b;
 149:     b.diffuse = diffuse(norm);
 150:     b.texCoords = v.texCoords;
 151:     b.light = flap.light;
 152:     #if defined(DEBUG_NORMAL)
 153:     b.color = vec4(norm, 1.);
 154:     #else
 155:     b.color = vec4(1.);
 156:     #endif
 157:     return b;
 158: }
 159: attribute vec3 a_v_pos;
 160: attribute vec3 a_v_normal;
 161: attribute vec2 a_v_texCoords;
 162: 
 163: attribute vec3 a_i_instancePos;
 164: attribute vec2 a_i_light;
 165: attribute vec3 a_i_segmentOffset;
 166: attribute vec3 a_i_pivot;
 167: attribute float a_i_horizontalAngle;
 168: attribute float a_i_intensity;
 169: attribute float a_i_flapScale;
 170: attribute float a_i_flapness;
 171: 
 172: 
 173: varying vec2 v2f_texCoords;
 174: varying vec4 v2f_color;
 175: varying float v2f_diffuse;
 176: varying vec2 v2f_light;
 177: 
 178: 
 179: void main() {
 180:     Vertex v;
 181:     v.pos = a_v_pos;
 182: v.normal = a_v_normal;
 183: v.texCoords = a_v_texCoords;
 184: 
 185: 
 186:     Flap i;
 187:     i.instancePos = a_i_instancePos;
 188: i.light = a_i_light;
 189: i.segmentOffset = a_i_segmentOffset;
 190: i.pivot = a_i_pivot;
 191: i.horizontalAngle = a_i_horizontalAngle;
 192: i.intensity = a_i_intensity;
 193: i.flapScale = a_i_flapScale;
 194: i.flapness = a_i_flapness;
 195: 
 196: 
 197:     BlockFrag o = FLWMain(v, i);
 198: 
 199:     v2f_texCoords = o.texCoords;
 200: v2f_color = o.color;
 201: v2f_diffuse = o.diffuse;
 202: v2f_light = o.light;
 203: 
 204: }

[12:29:43] [main/ERROR]: Shader compilation log for flywheel:block.frag: No errors.

[12:29:43] [main/ERROR]: Source for shader 'flywheel:block.frag':
   1: #version 110
   2: #define USE_FOG
   3: #define USE_FOG_EXP2
   4: 
   5: #if defined(USE_FOG)
   6: varying float FragDistance;
   7: uniform vec4 uFogColor;
   8: #endif
   9: 
  10: #if defined(USE_FOG_LINEAR)
  11: uniform vec2 uFogRange;
  12: 
  13: float FLWFogFactor() {
  14:     return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
  15: }
  16:     #endif
  17: 
  18:     #if defined(USE_FOG_EXP2)
  19: uniform float uFogDensity;
  20: 
  21: float FLWFogFactor() {
  22:     float dist = FragDistance * uFogDensity;
  23:     return 1. / exp2(dist * dist);
  24: }
  25:     #endif
  26: 
  27: uniform vec2 uTextureScale;
  28: uniform sampler2D uBlockAtlas;
  29: uniform sampler2D uLightMap;
  30: uniform sampler2D uCrumbling;
  31: 
  32: vec4 FLWBlockTexture(vec2 texCoords) {
  33:     vec4 cr = texture2D(uCrumbling, texCoords * uTextureScale);
  34:     float diffuseAlpha = texture2D(uBlockAtlas, texCoords).a;
  35:     cr.a = cr.a * diffuseAlpha;
  36:     return cr;
  37: }
  38: 
  39: void FLWFinalizeColor(vec4 color) {
  40:     #if defined(USE_FOG)
  41:     float a = color.a;
  42:     float fog = clamp(FLWFogFactor(), 0., 1.);
  43: 
  44:     color = mix(uFogColor, color, fog);
  45:     color.a = a;
  46:     #endif
  47: 
  48:     gl_FragColor = color;
  49: }
  50: 
  51: vec4 FLWLight(vec2 lightCoords) {
  52:     return vec4(1.);
  53: }
  54: 
  55: 
  56: 
  57: struct BlockFrag {
  58:     vec2 texCoords;
  59:     vec4 color;
  60:     float diffuse;
  61:     vec2 light;
  62: };
  63: 
  64: void FLWMain(BlockFrag r) {
  65:     vec4 tex = FLWBlockTexture(r.texCoords);
  66: 
  67:     vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;
  68: 
  69: //    flw_WorldPos = ;
  70: //    flw_Normal = ;
  71: //    flw_Albedo = tex.rgb;
  72: //    flw_Alpha = tex.a;
  73: //    flw_LightMap = r.light;
  74: //    flw_Tint = r.color;
  75:     FLWFinalizeColor(color);
  76: }
  77: 
  78: varying vec2 v2f_texCoords;
  79: varying vec4 v2f_color;
  80: varying float v2f_diffuse;
  81: varying vec2 v2f_light;
  82: 
  83: 
  84: //vec3 flw_WorldPos;
  85: //vec3 flw_Normal;
  86: //vec3 flw_Albedo;
  87: //float flw_Alpha;
  88: //vec2 flw_LightMap;
  89: //vec4 flw_Tint;
  90: 
  91: void main() {
  92:     BlockFrag f;
  93:     f.texCoords = v2f_texCoords;
  94: f.color = v2f_color;
  95: f.diffuse = v2f_diffuse;
  96: f.light = v2f_light;
  97: 
  98: 
  99:     FLWMain(f);
 100: }

[12:29:43] [main/ERROR]: Shader compilation log for create:flap.vert: No errors.

[12:29:43] [main/ERROR]: Source for shader 'create:flap.vert':
   1: #version 110
   2: 
   3: #define PI 3.1415926538
   4: 
   5: uniform float uTime;
   6: uniform mat4 uViewProjection;
   7: uniform vec3 uCameraPos;
   8: 
   9: #if defined(USE_FOG)
  10: varying float FragDistance;
  11: #endif
  12: 
  13: void FLWFinalizeWorldPos(inout vec4 worldPos) {
  14:     #if defined(USE_FOG)
  15:     FragDistance = length(worldPos.xyz - uCameraPos);
  16:     #endif
  17: 
  18:     gl_Position = uViewProjection * worldPos;
  19: }
  20: 
  21: void FLWFinalizeNormal(inout vec3 normal) {
  22:     // noop
  23: }
  24: 
  25: 
  26: mat4 rotate(vec3 axis, float angle) {
  27:     float s = sin(angle);
  28:     float c = cos(angle);
  29:     float oc = 1. - c;
  30: 
  31:     vec3 sa = axis * s;
  32: 
  33:     mat4 mr = mat4(1.);
  34:     mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
  35:     mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
  36:     mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);
  37: 
  38:     return mr;
  39: }
  40: 
  41: mat4 rotation(vec3 rot) {
  42:     return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
  43: }
  44: 
  45: mat3 modelToNormal(mat4 mat) {
  46:     // Discard the edges. This won't be accurate for scaled or skewed matrices,
  47:     // but we don't have to work with those often.
  48:     mat3 m;
  49:     m[0] = mat[0].xyz;
  50:     m[1] = mat[1].xyz;
  51:     m[2] = mat[2].xyz;
  52:     return m;
  53: }
  54: 
  55: #define PIOVER2 1.5707963268
  56: 
  57: vec4 quat(vec3 axis, float angle) {
  58:     float halfAngle = angle * PIOVER2 / 180.0;
  59:     vec2 cs = sin(vec2(PIOVER2 - halfAngle, halfAngle)); // compute sin and cos in one instruction
  60:     return vec4(axis.xyz * cs.y,  cs.x);
  61: }
  62: 
  63: vec4 quatMult(vec4 q1, vec4 q2) {
  64:     // disgustingly vectorized quaternion multiplication
  65:     vec4 a = q1.w * q2.xyzw;
  66:     vec4 b = q1.x * q2.wzxy * vec4(1., -1., 1., -1.);
  67:     vec4 c = q1.y * q2.zwxy * vec4(1., 1., -1., -1.);
  68:     vec4 d = q1.z * q2.yxwz * vec4(-1., 1., 1., -1.);
  69: 
  70:     return a + b + c + d;
  71: }
  72: 
  73: vec3 rotateVertexByQuat(vec3 v, vec4 q) {
  74:     vec3 i = q.xyz;
  75:     return v + 2.0 * cross(i, cross(i, v) + q.w * v);
  76: }
  77: 
  78: vec3 rotateAbout(vec3 v, vec3 axis, float angle) {
  79:     return rotateVertexByQuat(v, quat(axis, angle));
  80: }
  81: 
  82: float diffuse(vec3 normal) {
  83:     vec3 n2 = normal * normal * vec3(.6, .25, .8);
  84:     return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
  85: }
  86: 
  87: 
  88: struct Flap {
  89:     vec3 instancePos;
  90:     vec2 light;
  91:     vec3 segmentOffset;
  92:     vec3 pivot;
  93:     float horizontalAngle;
  94:     float intensity;
  95:     float flapScale;
  96:     float flapness;
  97: };
  98: 
  99: 
 100: struct Vertex {
 101:     vec3 pos;
 102:     vec3 normal;
 103:     vec2 texCoords;
 104: };
 105: 
 106: struct BlockFrag {
 107:     vec2 texCoords;
 108:     vec4 color;
 109:     float diffuse;
 110:     vec2 light;
 111: };
 112: 
 113: 
 114: float toRad(float degrees) {
 115:     return fract(degrees / 360.) * PI * 2.;
 116: }
 117: 
 118: float getFlapAngle(float flapness, float intensity, float scale) {
 119:     float absFlap = abs(flapness);
 120: 
 121:     float angle = sin((1. - absFlap) * PI * intensity) * 30. * flapness * scale;
 122: 
 123:     float halfAngle = angle * 0.5;
 124: 
 125:     float which = step(0., flapness);// 0 if negative, 1 if positive
 126:     float degrees = which * halfAngle + (1. - which) * angle;// branchless conditional multiply
 127: 
 128:     return degrees;
 129: }
 130: 
 131: BlockFrag FLWMain(Vertex v, Flap flap) {
 132:     float flapAngle = getFlapAngle(flap.flapness, flap.intensity, flap.flapScale);
 133: 
 134:     vec4 orientation = quat(vec3(0., 1., 0.), -flap.horizontalAngle);
 135:     vec4 flapRotation = quat(vec3(1., 0., 0.), flapAngle);
 136: 
 137:     vec3 rotated = rotateVertexByQuat(v.pos - flap.pivot, flapRotation) + flap.pivot + flap.segmentOffset;
 138:     rotated = rotateVertexByQuat(rotated - .5, orientation) + flap.instancePos + .5;
 139: 
 140:     vec4 worldPos = vec4(rotated, 1.);
 141:     vec3 norm = rotateVertexByQuat(rotateVertexByQuat(v.normal, flapRotation), orientation);
 142: 
 143:     FLWFinalizeWorldPos(worldPos);
 144:     FLWFinalizeNormal(norm);
 145: 
 146:     BlockFrag b;
 147:     b.diffuse = diffuse(norm);
 148:     b.texCoords = v.texCoords;
 149:     b.light = flap.light;
 150:     #if defined(DEBUG_NORMAL)
 151:     b.color = vec4(norm, 1.);
 152:     #else
 153:     b.color = vec4(1.);
 154:     #endif
 155:     return b;
 156: }
 157: attribute vec3 a_v_pos;
 158: attribute vec3 a_v_normal;
 159: attribute vec2 a_v_texCoords;
 160: 
 161: attribute vec3 a_i_instancePos;
 162: attribute vec2 a_i_light;
 163: attribute vec3 a_i_segmentOffset;
 164: attribute vec3 a_i_pivot;
 165: attribute float a_i_horizontalAngle;
 166: attribute float a_i_intensity;
 167: attribute float a_i_flapScale;
 168: attribute float a_i_flapness;
 169: 
 170: 
 171: varying vec2 v2f_texCoords;
 172: varying vec4 v2f_color;
 173: varying float v2f_diffuse;
 174: varying vec2 v2f_light;
 175: 
 176: 
 177: void main() {
 178:     Vertex v;
 179:     v.pos = a_v_pos;
 180: v.normal = a_v_normal;
 181: v.texCoords = a_v_texCoords;
 182: 
 183: 
 184:     Flap i;
 185:     i.instancePos = a_i_instancePos;
 186: i.light = a_i_light;
 187: i.segmentOffset = a_i_segmentOffset;
 188: i.pivot = a_i_pivot;
 189: i.horizontalAngle = a_i_horizontalAngle;
 190: i.intensity = a_i_intensity;
 191: i.flapScale = a_i_flapScale;
 192: i.flapness = a_i_flapness;
 193: 
 194: 
 195:     BlockFrag o = FLWMain(v, i);
 196: 
 197:     v2f_texCoords = o.texCoords;
 198: v2f_color = o.color;
 199: v2f_diffuse = o.diffuse;
 200: v2f_light = o.light;
 201: 
 202: }

[12:29:43] [main/ERROR]: Shader compilation log for flywheel:block.frag: No errors.

[12:29:43] [main/ERROR]: Source for shader 'flywheel:block.frag':
   1: #version 110
   2: 
   3: #if defined(USE_FOG)
   4: varying float FragDistance;
   5: uniform vec4 uFogColor;
   6: #endif
   7: 
   8: #if defined(USE_FOG_LINEAR)
   9: uniform vec2 uFogRange;
  10: 
  11: float FLWFogFactor() {
  12:     return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
  13: }
  14:     #endif
  15: 
  16:     #if defined(USE_FOG_EXP2)
  17: uniform float uFogDensity;
  18: 
  19: float FLWFogFactor() {
  20:     float dist = FragDistance * uFogDensity;
  21:     return 1. / exp2(dist * dist);
  22: }
  23:     #endif
  24: 
  25: uniform vec2 uTextureScale;
  26: uniform sampler2D uBlockAtlas;
  27: uniform sampler2D uLightMap;
  28: uniform sampler2D uCrumbling;
  29: 
  30: vec4 FLWBlockTexture(vec2 texCoords) {
  31:     vec4 cr = texture2D(uCrumbling, texCoords * uTextureScale);
  32:     float diffuseAlpha = texture2D(uBlockAtlas, texCoords).a;
  33:     cr.a = cr.a * diffuseAlpha;
  34:     return cr;
  35: }
  36: 
  37: void FLWFinalizeColor(vec4 color) {
  38:     #if defined(USE_FOG)
  39:     float a = color.a;
  40:     float fog = clamp(FLWFogFactor(), 0., 1.);
  41: 
  42:     color = mix(uFogColor, color, fog);
  43:     color.a = a;
  44:     #endif
  45: 
  46:     gl_FragColor = color;
  47: }
  48: 
  49: vec4 FLWLight(vec2 lightCoords) {
  50:     return vec4(1.);
  51: }
  52: 
  53: 
  54: 
  55: struct BlockFrag {
  56:     vec2 texCoords;
  57:     vec4 color;
  58:     float diffuse;
  59:     vec2 light;
  60: };
  61: 
  62: void FLWMain(BlockFrag r) {
  63:     vec4 tex = FLWBlockTexture(r.texCoords);
  64: 
  65:     vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;
  66: 
  67: //    flw_WorldPos = ;
  68: //    flw_Normal = ;
  69: //    flw_Albedo = tex.rgb;
  70: //    flw_Alpha = tex.a;
  71: //    flw_LightMap = r.light;
  72: //    flw_Tint = r.color;
  73:     FLWFinalizeColor(color);
  74: }
  75: 
  76: varying vec2 v2f_texCoords;
  77: varying vec4 v2f_color;
  78: varying float v2f_diffuse;
  79: varying vec2 v2f_light;
  80: 
  81: 
  82: //vec3 flw_WorldPos;
  83: //vec3 flw_Normal;
  84: //vec3 flw_Albedo;
  85: //float flw_Alpha;
  86: //vec2 flw_LightMap;
  87: //vec4 flw_Tint;
  88: 
  89: void main() {
  90:     BlockFrag f;
  91:     f.texCoords = v2f_texCoords;
  92: f.color = v2f_color;
  93: f.diffuse = v2f_diffuse;
  94: f.light = v2f_light;
  95: 
  96: 
  97:     FLWMain(f);
  98: }

[12:29:43] [main/ERROR]: Shader compilation log for create:belt.vert: No errors.

[12:29:43] [main/ERROR]: Source for shader 'create:belt.vert':
   1: #version 110
   2: #define DEBUG_RAINBOW
   3: 
   4: #define PI 3.1415926538
   5: 
   6: uniform float uTime;
   7: uniform mat4 uViewProjection;
   8: uniform vec3 uCameraPos;
   9: 
  10: #if defined(USE_FOG)
  11: varying float FragDistance;
  12: #endif
  13: 
  14: void FLWFinalizeWorldPos(inout vec4 worldPos) {
  15:     #if defined(USE_FOG)
  16:     FragDistance = length(worldPos.xyz - uCameraPos);
  17:     #endif
  18: 
  19:     gl_Position = uViewProjection * worldPos;
  20: }
  21: 
  22: void FLWFinalizeNormal(inout vec3 normal) {
  23:     // noop
  24: }
  25: 
  26: 
  27: #define PIOVER2 1.5707963268
  28: 
  29: vec4 quat(vec3 axis, float angle) {
  30:     float halfAngle = angle * PIOVER2 / 180.0;
  31:     vec2 cs = sin(vec2(PIOVER2 - halfAngle, halfAngle)); // compute sin and cos in one instruction
  32:     return vec4(axis.xyz * cs.y,  cs.x);
  33: }
  34: 
  35: vec4 quatMult(vec4 q1, vec4 q2) {
  36:     // disgustingly vectorized quaternion multiplication
  37:     vec4 a = q1.w * q2.xyzw;
  38:     vec4 b = q1.x * q2.wzxy * vec4(1., -1., 1., -1.);
  39:     vec4 c = q1.y * q2.zwxy * vec4(1., 1., -1., -1.);
  40:     vec4 d = q1.z * q2.yxwz * vec4(-1., 1., 1., -1.);
  41: 
  42:     return a + b + c + d;
  43: }
  44: 
  45: vec3 rotateVertexByQuat(vec3 v, vec4 q) {
  46:     vec3 i = q.xyz;
  47:     return v + 2.0 * cross(i, cross(i, v) + q.w * v);
  48: }
  49: 
  50: vec3 rotateAbout(vec3 v, vec3 axis, float angle) {
  51:     return rotateVertexByQuat(v, quat(axis, angle));
  52: }
  53: 
  54: mat4 rotate(vec3 axis, float angle) {
  55:     float s = sin(angle);
  56:     float c = cos(angle);
  57:     float oc = 1. - c;
  58: 
  59:     vec3 sa = axis * s;
  60: 
  61:     mat4 mr = mat4(1.);
  62:     mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
  63:     mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
  64:     mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);
  65: 
  66:     return mr;
  67: }
  68: 
  69: mat4 rotation(vec3 rot) {
  70:     return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
  71: }
  72: 
  73: mat3 modelToNormal(mat4 mat) {
  74:     // Discard the edges. This won't be accurate for scaled or skewed matrices,
  75:     // but we don't have to work with those often.
  76:     mat3 m;
  77:     m[0] = mat[0].xyz;
  78:     m[1] = mat[1].xyz;
  79:     m[2] = mat[2].xyz;
  80:     return m;
  81: }
  82: 
  83: float diffuse(vec3 normal) {
  84:     vec3 n2 = normal * normal * vec3(.6, .25, .8);
  85:     return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
  86: }
  87: 
  88: 
  89: struct Belt {
  90:     vec2 light;
  91:     vec4 color;
  92:     vec3 pos;
  93:     float speed;
  94:     float offset;
  95:     vec4 rotation;
  96:     vec2 sourceTexture;
  97:     vec4 scrollTexture;
  98:     float scrollMult;
  99: };
 100: 
 101: 
 102: struct Vertex {
 103:     vec3 pos;
 104:     vec3 normal;
 105:     vec2 texCoords;
 106: };
 107: 
 108: struct BlockFrag {
 109:     vec2 texCoords;
 110:     vec4 color;
 111:     float diffuse;
 112:     vec2 light;
 113: };
 114: 
 115: BlockFrag FLWMain(Vertex v, Belt instance) {
 116:     vec3 rotated = rotateVertexByQuat(v.pos - .5, instance.rotation) + instance.pos + .5;
 117: 
 118:     vec4 worldPos = vec4(rotated, 1.);
 119: 
 120:     vec3 norm = rotateVertexByQuat(v.normal, instance.rotation);
 121: 
 122:     FLWFinalizeWorldPos(worldPos);
 123:     FLWFinalizeNormal(norm);
 124: 
 125:     float scrollSize = instance.scrollTexture.w - instance.scrollTexture.y;
 126:     float scroll = fract(instance.speed * uTime / (31.5 * 16.) + instance.offset) * scrollSize * instance.scrollMult;
 127: 
 128:     BlockFrag b;
 129:     b.diffuse = diffuse(norm);
 130:     b.texCoords = v.texCoords - instance.sourceTexture + instance.scrollTexture.xy + vec2(0, scroll);
 131:     b.light = instance.light;
 132: 
 133:     #if defined(DEBUG_RAINBOW)
 134:     b.color = instance.color;
 135:     #elif defined(DEBUG_NORMAL)
 136:     b.color = vec4(norm, 1.);
 137:     #else
 138:     b.color = vec4(1.);
 139:     #endif
 140: 
 141:     return b;
 142: }
 143: attribute vec3 a_v_pos;
 144: attribute vec3 a_v_normal;
 145: attribute vec2 a_v_texCoords;
 146: 
 147: attribute vec2 a_i_light;
 148: attribute vec4 a_i_color;
 149: attribute vec3 a_i_pos;
 150: attribute float a_i_speed;
 151: attribute float a_i_offset;
 152: attribute vec4 a_i_rotation;
 153: attribute vec2 a_i_sourceTexture;
 154: attribute vec4 a_i_scrollTexture;
 155: attribute float a_i_scrollMult;
 156: 
 157: 
 158: varying vec2 v2f_texCoords;
 159: varying vec4 v2f_color;
 160: varying float v2f_diffuse;
 161: varying vec2 v2f_light;
 162: 
 163: 
 164: void main() {
 165:     Vertex v;
 166:     v.pos = a_v_pos;
 167: v.normal = a_v_normal;
 168: v.texCoords = a_v_texCoords;
 169: 
 170: 
 171:     Belt i;
 172:     i.light = a_i_light;
 173: i.color = a_i_color;
 174: i.pos = a_i_pos;
 175: i.speed = a_i_speed;
 176: i.offset = a_i_offset;
 177: i.rotation = a_i_rotation;
 178: i.sourceTexture = a_i_sourceTexture;
 179: i.scrollTexture = a_i_scrollTexture;
 180: i.scrollMult = a_i_scrollMult;
 181: 
 182: 
 183:     BlockFrag o = FLWMain(v, i);
 184: 
 185:     v2f_texCoords = o.texCoords;
 186: v2f_color = o.color;
 187: v2f_diffuse = o.diffuse;
 188: v2f_light = o.light;
 189: 
 190: }

[12:29:43] [main/ERROR]: Shader compilation log for flywheel:block.frag: No errors.

[12:29:43] [main/ERROR]: Source for shader 'flywheel:block.frag':
   1: #version 110
   2: #define DEBUG_RAINBOW
   3: 
   4: #if defined(USE_FOG)
   5: varying float FragDistance;
   6: uniform vec4 uFogColor;
   7: #endif
   8: 
   9: #if defined(USE_FOG_LINEAR)
  10: uniform vec2 uFogRange;
  11: 
  12: float FLWFogFactor() {
  13:     return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
  14: }
  15:     #endif
  16: 
  17:     #if defined(USE_FOG_EXP2)
  18: uniform float uFogDensity;
  19: 
  20: float FLWFogFactor() {
  21:     float dist = FragDistance * uFogDensity;
  22:     return 1. / exp2(dist * dist);
  23: }
  24:     #endif
  25: 
  26: uniform vec2 uTextureScale;
  27: uniform sampler2D uBlockAtlas;
  28: uniform sampler2D uLightMap;
  29: uniform sampler2D uCrumbling;
  30: 
  31: vec4 FLWBlockTexture(vec2 texCoords) {
  32:     vec4 cr = texture2D(uCrumbling, texCoords * uTextureScale);
  33:     float diffuseAlpha = texture2D(uBlockAtlas, texCoords).a;
  34:     cr.a = cr.a * diffuseAlpha;
  35:     return cr;
  36: }
  37: 
  38: void FLWFinalizeColor(vec4 color) {
  39:     #if defined(USE_FOG)
  40:     float a = color.a;
  41:     float fog = clamp(FLWFogFactor(), 0., 1.);
  42: 
  43:     color = mix(uFogColor, color, fog);
  44:     color.a = a;
  45:     #endif
  46: 
  47:     gl_FragColor = color;
  48: }
  49: 
  50: vec4 FLWLight(vec2 lightCoords) {
  51:     return vec4(1.);
  52: }
  53: 
  54: 
  55: 
  56: struct BlockFrag {
  57:     vec2 texCoords;
  58:     vec4 color;
  59:     float diffuse;
  60:     vec2 light;
  61: };
  62: 
  63: void FLWMain(BlockFrag r) {
  64:     vec4 tex = FLWBlockTexture(r.texCoords);
  65: 
  66:     vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;
  67: 
  68: //    flw_WorldPos = ;
  69: //    flw_Normal = ;
  70: //    flw_Albedo = tex.rgb;
  71: //    flw_Alpha = tex.a;
  72: //    flw_LightMap = r.light;
  73: //    flw_Tint = r.color;
  74:     FLWFinalizeColor(color);
  75: }
  76: 
  77: varying vec2 v2f_texCoords;
  78: varying vec4 v2f_color;
  79: varying float v2f_diffuse;
  80: varying vec2 v2f_light;
  81: 
  82: 
  83: //vec3 flw_WorldPos;
  84: //vec3 flw_Normal;
  85: //vec3 flw_Albedo;
  86: //float flw_Alpha;
  87: //vec2 flw_LightMap;
  88: //vec4 flw_Tint;
  89: 
  90: void main() {
  91:     BlockFrag f;
  92:     f.texCoords = v2f_texCoords;
  93: f.color = v2f_color;
  94: f.diffuse = v2f_diffuse;
  95: f.light = v2f_light;
  96: 
  97: 
  98:     FLWMain(f);
  99: }

[12:29:43] [main/ERROR]: Shader compilation log for create:belt.vert: No errors.

[12:29:43] [main/ERROR]: Source for shader 'create:belt.vert':
   1: #version 110
   2: #define DEBUG_NORMAL
   3: 
   4: #define PI 3.1415926538
   5: 
   6: uniform float uTime;
   7: uniform mat4 uViewProjection;
   8: uniform vec3 uCameraPos;
   9: 
  10: #if defined(USE_FOG)
  11: varying float FragDistance;
  12: #endif
  13: 
  14: void FLWFinalizeWorldPos(inout vec4 worldPos) {
  15:     #if defined(USE_FOG)
  16:     FragDistance = length(worldPos.xyz - uCameraPos);
  17:     #endif
  18: 
  19:     gl_Position = uViewProjection * worldPos;
  20: }
  21: 
  22: void FLWFinalizeNormal(inout vec3 normal) {
  23:     // noop
  24: }
  25: 
  26: 
  27: #define PIOVER2 1.5707963268
  28: 
  29: vec4 quat(vec3 axis, float angle) {
  30:     float halfAngle = angle * PIOVER2 / 180.0;
  31:     vec2 cs = sin(vec2(PIOVER2 - halfAngle, halfAngle)); // compute sin and cos in one instruction
  32:     return vec4(axis.xyz * cs.y,  cs.x);
  33: }
  34: 
  35: vec4 quatMult(vec4 q1, vec4 q2) {
  36:     // disgustingly vectorized quaternion multiplication
  37:     vec4 a = q1.w * q2.xyzw;
  38:     vec4 b = q1.x * q2.wzxy * vec4(1., -1., 1., -1.);
  39:     vec4 c = q1.y * q2.zwxy * vec4(1., 1., -1., -1.);
  40:     vec4 d = q1.z * q2.yxwz * vec4(-1., 1., 1., -1.);
  41: 
  42:     return a + b + c + d;
  43: }
  44: 
  45: vec3 rotateVertexByQuat(vec3 v, vec4 q) {
  46:     vec3 i = q.xyz;
  47:     return v + 2.0 * cross(i, cross(i, v) + q.w * v);
  48: }
  49: 
  50: vec3 rotateAbout(vec3 v, vec3 axis, float angle) {
  51:     return rotateVertexByQuat(v, quat(axis, angle));
  52: }
  53: 
  54: mat4 rotate(vec3 axis, float angle) {
  55:     float s = sin(angle);
  56:     float c = cos(angle);
  57:     float oc = 1. - c;
  58: 
  59:     vec3 sa = axis * s;
  60: 
  61:     mat4 mr = mat4(1.);
  62:     mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
  63:     mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
  64:     mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);
  65: 
  66:     return mr;
  67: }
  68: 
  69: mat4 rotation(vec3 rot) {
  70:     return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
  71: }
  72: 
  73: mat3 modelToNormal(mat4 mat) {
  74:     // Discard the edges. This won't be accurate for scaled or skewed matrices,
  75:     // but we don't have to work with those often.
  76:     mat3 m;
  77:     m[0] = mat[0].xyz;
  78:     m[1] = mat[1].xyz;
  79:     m[2] = mat[2].xyz;
  80:     return m;
  81: }
  82: 
  83: float diffuse(vec3 normal) {
  84:     vec3 n2 = normal * normal * vec3(.6, .25, .8);
  85:     return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
  86: }
  87: 
  88: 
  89: struct Belt {
  90:     vec2 light;
  91:     vec4 color;
  92:     vec3 pos;
  93:     float speed;
  94:     float offset;
  95:     vec4 rotation;
  96:     vec2 sourceTexture;
  97:     vec4 scrollTexture;
  98:     float scrollMult;
  99: };
 100: 
 101: 
 102: struct Vertex {
 103:     vec3 pos;
 104:     vec3 normal;
 105:     vec2 texCoords;
 106: };
 107: 
 108: struct BlockFrag {
 109:     vec2 texCoords;
 110:     vec4 color;
 111:     float diffuse;
 112:     vec2 light;
 113: };
 114: 
 115: BlockFrag FLWMain(Vertex v, Belt instance) {
 116:     vec3 rotated = rotateVertexByQuat(v.pos - .5, instance.rotation) + instance.pos + .5;
 117: 
 118:     vec4 worldPos = vec4(rotated, 1.);
 119: 
 120:     vec3 norm = rotateVertexByQuat(v.normal, instance.rotation);
 121: 
 122:     FLWFinalizeWorldPos(worldPos);
 123:     FLWFinalizeNormal(norm);
 124: 
 125:     float scrollSize = instance.scrollTexture.w - instance.scrollTexture.y;
 126:     float scroll = fract(instance.speed * uTime / (31.5 * 16.) + instance.offset) * scrollSize * instance.scrollMult;
 127: 
 128:     BlockFrag b;
 129:     b.diffuse = diffuse(norm);
 130:     b.texCoords = v.texCoords - instance.sourceTexture + instance.scrollTexture.xy + vec2(0, scroll);
 131:     b.light = instance.light;
 132: 
 133:     #if defined(DEBUG_RAINBOW)
 134:     b.color = instance.color;
 135:     #elif defined(DEBUG_NORMAL)
 136:     b.color = vec4(norm, 1.);
 137:     #else
 138:     b.color = vec4(1.);
 139:     #endif
 140: 
 141:     return b;
 142: }
 143: attribute vec3 a_v_pos;
 144: attribute vec3 a_v_normal;
 145: attribute vec2 a_v_texCoords;
 146: 
 147: attribute vec2 a_i_light;
 148: attribute vec4 a_i_color;
 149: attribute vec3 a_i_pos;
 150: attribute float a_i_speed;
 151: attribute float a_i_offset;
 152: attribute vec4 a_i_rotation;
 153: attribute vec2 a_i_sourceTexture;
 154: attribute vec4 a_i_scrollTexture;
 155: attribute float a_i_scrollMult;
 156: 
 157: 
 158: varying vec2 v2f_texCoords;
 159: varying vec4 v2f_color;
 160: varying float v2f_diffuse;
 161: varying vec2 v2f_light;
 162: 
 163: 
 164: void main() {
 165:     Vertex v;
 166:     v.pos = a_v_pos;
 167: v.normal = a_v_normal;
 168: v.texCoords = a_v_texCoords;
 169: 
 170: 
 171:     Belt i;
 172:     i.light = a_i_light;
 173: i.color = a_i_color;
 174: i.pos = a_i_pos;
 175: i.speed = a_i_speed;
 176: i.offset = a_i_offset;
 177: i.rotation = a_i_rotation;
 178: i.sourceTexture = a_i_sourceTexture;
 179: i.scrollTexture = a_i_scrollTexture;
 180: i.scrollMult = a_i_scrollMult;
 181: 
 182: 
 183:     BlockFrag o = FLWMain(v, i);
 184: 
 185:     v2f_texCoords = o.texCoords;
 186: v2f_color = o.color;
 187: v2f_diffuse = o.diffuse;
 188: v2f_light = o.light;
 189: 
 190: }

[12:29:43] [main/ERROR]: Shader compilation log for flywheel:block.frag: No errors.

[12:29:43] [main/ERROR]: Source for shader 'flywheel:block.frag':
   1: #version 110
   2: #define DEBUG_NORMAL
   3: 
   4: #if defined(USE_FOG)
   5: varying float FragDistance;
   6: uniform vec4 uFogColor;
   7: #endif
   8: 
   9: #if defined(USE_FOG_LINEAR)
  10: uniform vec2 uFogRange;
  11: 
  12: float FLWFogFactor() {
  13:     return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
  14: }
  15:     #endif
  16: 
  17:     #if defined(USE_FOG_EXP2)
  18: uniform float uFogDensity;
  19: 
  20: float FLWFogFactor() {
  21:     float dist = FragDistance * uFogDensity;
  22:     return 1. / exp2(dist * dist);
  23: }
  24:     #endif
  25: 
  26: uniform vec2 uTextureScale;
  27: uniform sampler2D uBlockAtlas;
  28: uniform sampler2D uLightMap;
  29: uniform sampler2D uCrumbling;
  30: 
  31: vec4 FLWBlockTexture(vec2 texCoords) {
  32:     vec4 cr = texture2D(uCrumbling, texCoords * uTextureScale);
  33:     float diffuseAlpha = texture2D(uBlockAtlas, texCoords).a;
  34:     cr.a = cr.a * diffuseAlpha;
  35:     return cr;
  36: }
  37: 
  38: void FLWFinalizeColor(vec4 color) {
  39:     #if defined(USE_FOG)
  40:     float a = color.a;
  41:     float fog = clamp(FLWFogFactor(), 0., 1.);
  42: 
  43:     color = mix(uFogColor, color, fog);
  44:     color.a = a;
  45:     #endif
  46: 
  47:     gl_FragColor = color;
  48: }
  49: 
  50: vec4 FLWLight(vec2 lightCoords) {
  51:     return vec4(1.);
  52: }
  53: 
  54: 
  55: 
  56: struct BlockFrag {
  57:     vec2 texCoords;
  58:     vec4 color;
  59:     float diffuse;
  60:     vec2 light;
  61: };
  62: 
  63: void FLWMain(BlockFrag r) {
  64:     vec4 tex = FLWBlockTexture(r.texCoords);
  65: 
  66:     vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;
  67: 
  68: //    flw_WorldPos = ;
  69: //    flw_Normal = ;
  70: //    flw_Albedo = tex.rgb;
  71: //    flw_Alpha = tex.a;
  72: //    flw_LightMap = r.light;
  73: //    flw_Tint = r.color;
  74:     FLWFinalizeColor(color);
  75: }
  76: 
  77: varying vec2 v2f_texCoords;
  78: varying vec4 v2f_color;
  79: varying float v2f_diffuse;
  80: varying vec2 v2f_light;
  81: 
  82: 
  83: //vec3 flw_WorldPos;
  84: //vec3 flw_Normal;
  85: //vec3 flw_Albedo;
  86: //float flw_Alpha;
  87: //vec2 flw_LightMap;
  88: //vec4 flw_Tint;
  89: 
  90: void main() {
  91:     BlockFrag f;
  92:     f.texCoords = v2f_texCoords;
  93: f.color = v2f_color;
  94: f.diffuse = v2f_diffuse;
  95: f.light = v2f_light;
  96: 
  97: 
  98:     FLWMain(f);
  99: }

[12:29:43] [Forge Version Check/INFO]: [enderstorage] Found status: UP_TO_DATE Current: 2.8.0.168 Target: null
[12:29:44] [main/ERROR]: Shader compilation log for create:belt.vert: No errors.

[12:29:44] [main/ERROR]: Source for shader 'create:belt.vert':
   1: #version 110
   2: #define USE_FOG
   3: #define USE_FOG_LINEAR
   4: 
   5: #define PI 3.1415926538
   6: 
   7: uniform float uTime;
   8: uniform mat4 uViewProjection;
   9: uniform vec3 uCameraPos;
  10: 
  11: #if defined(USE_FOG)
  12: varying float FragDistance;
  13: #endif
  14: 
  15: void FLWFinalizeWorldPos(inout vec4 worldPos) {
  16:     #if defined(USE_FOG)
  17:     FragDistance = length(worldPos.xyz - uCameraPos);
  18:     #endif
  19: 
  20:     gl_Position = uViewProjection * worldPos;
  21: }
  22: 
  23: void FLWFinalizeNormal(inout vec3 normal) {
  24:     // noop
  25: }
  26: 
  27: 
  28: #define PIOVER2 1.5707963268
  29: 
  30: vec4 quat(vec3 axis, float angle) {
  31:     float halfAngle = angle * PIOVER2 / 180.0;
  32:     vec2 cs = sin(vec2(PIOVER2 - halfAngle, halfAngle)); // compute sin and cos in one instruction
  33:     return vec4(axis.xyz * cs.y,  cs.x);
  34: }
  35: 
  36: vec4 quatMult(vec4 q1, vec4 q2) {
  37:     // disgustingly vectorized quaternion multiplication
  38:     vec4 a = q1.w * q2.xyzw;
  39:     vec4 b = q1.x * q2.wzxy * vec4(1., -1., 1., -1.);
  40:     vec4 c = q1.y * q2.zwxy * vec4(1., 1., -1., -1.);
  41:     vec4 d = q1.z * q2.yxwz * vec4(-1., 1., 1., -1.);
  42: 
  43:     return a + b + c + d;
  44: }
  45: 
  46: vec3 rotateVertexByQuat(vec3 v, vec4 q) {
  47:     vec3 i = q.xyz;
  48:     return v + 2.0 * cross(i, cross(i, v) + q.w * v);
  49: }
  50: 
  51: vec3 rotateAbout(vec3 v, vec3 axis, float angle) {
  52:     return rotateVertexByQuat(v, quat(axis, angle));
  53: }
  54: 
  55: mat4 rotate(vec3 axis, float angle) {
  56:     float s = sin(angle);
  57:     float c = cos(angle);
  58:     float oc = 1. - c;
  59: 
  60:     vec3 sa = axis * s;
  61: 
  62:     mat4 mr = mat4(1.);
  63:     mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
  64:     mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
  65:     mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);
  66: 
  67:     return mr;
  68: }
  69: 
  70: mat4 rotation(vec3 rot) {
  71:     return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
  72: }
  73: 
  74: mat3 modelToNormal(mat4 mat) {
  75:     // Discard the edges. This won't be accurate for scaled or skewed matrices,
  76:     // but we don't have to work with those often.
  77:     mat3 m;
  78:     m[0] = mat[0].xyz;
  79:     m[1] = mat[1].xyz;
  80:     m[2] = mat[2].xyz;
  81:     return m;
  82: }
  83: 
  84: float diffuse(vec3 normal) {
  85:     vec3 n2 = normal * normal * vec3(.6, .25, .8);
  86:     return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
  87: }
  88: 
  89: 
  90: struct Belt {
  91:     vec2 light;
  92:     vec4 color;
  93:     vec3 pos;
  94:     float speed;
  95:     float offset;
  96:     vec4 rotation;
  97:     vec2 sourceTexture;
  98:     vec4 scrollTexture;
  99:     float scrollMult;
 100: };
 101: 
 102: 
 103: struct Vertex {
 104:     vec3 pos;
 105:     vec3 normal;
 106:     vec2 texCoords;
 107: };
 108: 
 109: struct BlockFrag {
 110:     vec2 texCoords;
 111:     vec4 color;
 112:     float diffuse;
 113:     vec2 light;
 114: };
 115: 
 116: BlockFrag FLWMain(Vertex v, Belt instance) {
 117:     vec3 rotated = rotateVertexByQuat(v.pos - .5, instance.rotation) + instance.pos + .5;
 118: 
 119:     vec4 worldPos = vec4(rotated, 1.);
 120: 
 121:     vec3 norm = rotateVertexByQuat(v.normal, instance.rotation);
 122: 
 123:     FLWFinalizeWorldPos(worldPos);
 124:     FLWFinalizeNormal(norm);
 125: 
 126:     float scrollSize = instance.scrollTexture.w - instance.scrollTexture.y;
 127:     float scroll = fract(instance.speed * uTime / (31.5 * 16.) + instance.offset) * scrollSize * instance.scrollMult;
 128: 
 129:     BlockFrag b;
 130:     b.diffuse = diffuse(norm);
 131:     b.texCoords = v.texCoords - instance.sourceTexture + instance.scrollTexture.xy + vec2(0, scroll);
 132:     b.light = instance.light;
 133: 
 134:     #if defined(DEBUG_RAINBOW)
 135:     b.color = instance.color;
 136:     #elif defined(DEBUG_NORMAL)
 137:     b.color = vec4(norm, 1.);
 138:     #else
 139:     b.color = vec4(1.);
 140:     #endif
 141: 
 142:     return b;
 143: }
 144: attribute vec3 a_v_pos;
 145: attribute vec3 a_v_normal;
 146: attribute vec2 a_v_texCoords;
 147: 
 148: attribute vec2 a_i_light;
 149: attribute vec4 a_i_color;
 150: attribute vec3 a_i_pos;
 151: attribute float a_i_speed;
 152: attribute float a_i_offset;
 153: attribute vec4 a_i_rotation;
 154: attribute vec2 a_i_sourceTexture;
 155: attribute vec4 a_i_scrollTexture;
 156: attribute float a_i_scrollMult;
 157: 
 158: 
 159: varying vec2 v2f_texCoords;
 160: varying vec4 v2f_color;
 161: varying float v2f_diffuse;
 162: varying vec2 v2f_light;
 163: 
 164: 
 165: void main() {
 166:     Vertex v;
 167:     v.pos = a_v_pos;
 168: v.normal = a_v_normal;
 169: v.texCoords = a_v_texCoords;
 170: 
 171: 
 172:     Belt i;
 173:     i.light = a_i_light;
 174: i.color = a_i_color;
 175: i.pos = a_i_pos;
 176: i.speed = a_i_speed;
 177: i.offset = a_i_offset;
 178: i.rotation = a_i_rotation;
 179: i.sourceTexture = a_i_sourceTexture;
 180: i.scrollTexture = a_i_scrollTexture;
 181: i.scrollMult = a_i_scrollMult;
 182: 
 183: 
 184:     BlockFrag o = FLWMain(v, i);
 185: 
 186:     v2f_texCoords = o.texCoords;
 187: v2f_color = o.color;
 188: v2f_diffuse = o.diffuse;
 189: v2f_light = o.light;
 190: 
 191: }

[12:29:44] [main/ERROR]: Shader compilation log for flywheel:block.frag: No errors.

[12:29:44] [main/ERROR]: Source for shader 'flywheel:block.frag':
   1: #version 110
   2: #define USE_FOG
   3: #define USE_FOG_LINEAR
   4: 
   5: #if defined(USE_FOG)
   6: varying float FragDistance;
   7: uniform vec4 uFogColor;
   8: #endif
   9: 
  10: #if defined(USE_FOG_LINEAR)
  11: uniform vec2 uFogRange;
  12: 
  13: float FLWFogFactor() {
  14:     return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
  15: }
  16:     #endif
  17: 
  18:     #if defined(USE_FOG_EXP2)
  19: uniform float uFogDensity;
  20: 
  21: float FLWFogFactor() {
  22:     float dist = FragDistance * uFogDensity;
  23:     return 1. / exp2(dist * dist);
  24: }
  25:     #endif
  26: 
  27: uniform vec2 uTextureScale;
  28: uniform sampler2D uBlockAtlas;
  29: uniform sampler2D uLightMap;
  30: uniform sampler2D uCrumbling;
  31: 
  32: vec4 FLWBlockTexture(vec2 texCoords) {
  33:     vec4 cr = texture2D(uCrumbling, texCoords * uTextureScale);
  34:     float diffuseAlpha = texture2D(uBlockAtlas, texCoords).a;
  35:     cr.a = cr.a * diffuseAlpha;
  36:     return cr;
  37: }
  38: 
  39: void FLWFinalizeColor(vec4 color) {
  40:     #if defined(USE_FOG)
  41:     float a = color.a;
  42:     float fog = clamp(FLWFogFactor(), 0., 1.);
  43: 
  44:     color = mix(uFogColor, color, fog);
  45:     color.a = a;
  46:     #endif
  47: 
  48:     gl_FragColor = color;
  49: }
  50: 
  51: vec4 FLWLight(vec2 lightCoords) {
  52:     return vec4(1.);
  53: }
  54: 
  55: 
  56: 
  57: struct BlockFrag {
  58:     vec2 texCoords;
  59:     vec4 color;
  60:     float diffuse;
  61:     vec2 light;
  62: };
  63: 
  64: void FLWMain(BlockFrag r) {
  65:     vec4 tex = FLWBlockTexture(r.texCoords);
  66: 
  67:     vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;
  68: 
  69: //    flw_WorldPos = ;
  70: //    flw_Normal = ;
  71: //    flw_Albedo = tex.rgb;
  72: //    flw_Alpha = tex.a;
  73: //    flw_LightMap = r.light;
  74: //    flw_Tint = r.color;
  75:     FLWFinalizeColor(color);
  76: }
  77: 
  78: varying vec2 v2f_texCoords;
  79: varying vec4 v2f_color;
  80: varying float v2f_diffuse;
  81: varying vec2 v2f_light;
  82: 
  83: 
  84: //vec3 flw_WorldPos;
  85: //vec3 flw_Normal;
  86: //vec3 flw_Albedo;
  87: //float flw_Alpha;
  88: //vec2 flw_LightMap;
  89: //vec4 flw_Tint;
  90: 
  91: void main() {
  92:     BlockFrag f;
  93:     f.texCoords = v2f_texCoords;
  94: f.color = v2f_color;
  95: f.diffuse = v2f_diffuse;
  96: f.light = v2f_light;
  97: 
  98: 
  99:     FLWMain(f);
 100: }

[12:29:44] [main/ERROR]: Shader compilation log for create:belt.vert: No errors.

[12:29:44] [main/ERROR]: Source for shader 'create:belt.vert':
   1: #version 110
   2: #define USE_FOG
   3: #define USE_FOG_EXP2
   4: 
   5: #define PI 3.1415926538
   6: 
   7: uniform float uTime;
   8: uniform mat4 uViewProjection;
   9: uniform vec3 uCameraPos;
  10: 
  11: #if defined(USE_FOG)
  12: varying float FragDistance;
  13: #endif
  14: 
  15: void FLWFinalizeWorldPos(inout vec4 worldPos) {
  16:     #if defined(USE_FOG)
  17:     FragDistance = length(worldPos.xyz - uCameraPos);
  18:     #endif
  19: 
  20:     gl_Position = uViewProjection * worldPos;
  21: }
  22: 
  23: void FLWFinalizeNormal(inout vec3 normal) {
  24:     // noop
  25: }
  26: 
  27: 
  28: #define PIOVER2 1.5707963268
  29: 
  30: vec4 quat(vec3 axis, float angle) {
  31:     float halfAngle = angle * PIOVER2 / 180.0;
  32:     vec2 cs = sin(vec2(PIOVER2 - halfAngle, halfAngle)); // compute sin and cos in one instruction
  33:     return vec4(axis.xyz * cs.y,  cs.x);
  34: }
  35: 
  36: vec4 quatMult(vec4 q1, vec4 q2) {
  37:     // disgustingly vectorized quaternion multiplication
  38:     vec4 a = q1.w * q2.xyzw;
  39:     vec4 b = q1.x * q2.wzxy * vec4(1., -1., 1., -1.);
  40:     vec4 c = q1.y * q2.zwxy * vec4(1., 1., -1., -1.);
  41:     vec4 d = q1.z * q2.yxwz * vec4(-1., 1., 1., -1.);
  42: 
  43:     return a + b + c + d;
  44: }
  45: 
  46: vec3 rotateVertexByQuat(vec3 v, vec4 q) {
  47:     vec3 i = q.xyz;
  48:     return v + 2.0 * cross(i, cross(i, v) + q.w * v);
  49: }
  50: 
  51: vec3 rotateAbout(vec3 v, vec3 axis, float angle) {
  52:     return rotateVertexByQuat(v, quat(axis, angle));
  53: }
  54: 
  55: mat4 rotate(vec3 axis, float angle) {
  56:     float s = sin(angle);
  57:     float c = cos(angle);
  58:     float oc = 1. - c;
  59: 
  60:     vec3 sa = axis * s;
  61: 
  62:     mat4 mr = mat4(1.);
  63:     mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
  64:     mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
  65:     mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);
  66: 
  67:     return mr;
  68: }
  69: 
  70: mat4 rotation(vec3 rot) {
  71:     return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
  72: }
  73: 
  74: mat3 modelToNormal(mat4 mat) {
  75:     // Discard the edges. This won't be accurate for scaled or skewed matrices,
  76:     // but we don't have to work with those often.
  77:     mat3 m;
  78:     m[0] = mat[0].xyz;
  79:     m[1] = mat[1].xyz;
  80:     m[2] = mat[2].xyz;
  81:     return m;
  82: }
  83: 
  84: float diffuse(vec3 normal) {
  85:     vec3 n2 = normal * normal * vec3(.6, .25, .8);
  86:     return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
  87: }
  88: 
  89: 
  90: struct Belt {
  91:     vec2 light;
  92:     vec4 color;
  93:     vec3 pos;
  94:     float speed;
  95:     float offset;
  96:     vec4 rotation;
  97:     vec2 sourceTexture;
  98:     vec4 scrollTexture;
  99:     float scrollMult;
 100: };
 101: 
 102: 
 103: struct Vertex {
 104:     vec3 pos;
 105:     vec3 normal;
 106:     vec2 texCoords;
 107: };
 108: 
 109: struct BlockFrag {
 110:     vec2 texCoords;
 111:     vec4 color;
 112:     float diffuse;
 113:     vec2 light;
 114: };
 115: 
 116: BlockFrag FLWMain(Vertex v, Belt instance) {
 117:     vec3 rotated = rotateVertexByQuat(v.pos - .5, instance.rotation) + instance.pos + .5;
 118: 
 119:     vec4 worldPos = vec4(rotated, 1.);
 120: 
 121:     vec3 norm = rotateVertexByQuat(v.normal, instance.rotation);
 122: 
 123:     FLWFinalizeWorldPos(worldPos);
 124:     FLWFinalizeNormal(norm);
 125: 
 126:     float scrollSize = instance.scrollTexture.w - instance.scrollTexture.y;
 127:     float scroll = fract(instance.speed * uTime / (31.5 * 16.) + instance.offset) * scrollSize * instance.scrollMult;
 128: 
 129:     BlockFrag b;
 130:     b.diffuse = diffuse(norm);
 131:     b.texCoords = v.texCoords - instance.sourceTexture + instance.scrollTexture.xy + vec2(0, scroll);
 132:     b.light = instance.light;
 133: 
 134:     #if defined(DEBUG_RAINBOW)
 135:     b.color = instance.color;
 136:     #elif defined(DEBUG_NORMAL)
 137:     b.color = vec4(norm, 1.);
 138:     #else
 139:     b.color = vec4(1.);
 140:     #endif
 141: 
 142:     return b;
 143: }
 144: attribute vec3 a_v_pos;
 145: attribute vec3 a_v_normal;
 146: attribute vec2 a_v_texCoords;
 147: 
 148: attribute vec2 a_i_light;
 149: attribute vec4 a_i_color;
 150: attribute vec3 a_i_pos;
 151: attribute float a_i_speed;
 152: attribute float a_i_offset;
 153: attribute vec4 a_i_rotation;
 154: attribute vec2 a_i_sourceTexture;
 155: attribute vec4 a_i_scrollTexture;
 156: attribute float a_i_scrollMult;
 157: 
 158: 
 159: varying vec2 v2f_texCoords;
 160: varying vec4 v2f_color;
 161: varying float v2f_diffuse;
 162: varying vec2 v2f_light;
 163: 
 164: 
 165: void main() {
 166:     Vertex v;
 167:     v.pos = a_v_pos;
 168: v.normal = a_v_normal;
 169: v.texCoords = a_v_texCoords;
 170: 
 171: 
 172:     Belt i;
 173:     i.light = a_i_light;
 174: i.color = a_i_color;
 175: i.pos = a_i_pos;
 176: i.speed = a_i_speed;
 177: i.offset = a_i_offset;
 178: i.rotation = a_i_rotation;
 179: i.sourceTexture = a_i_sourceTexture;
 180: i.scrollTexture = a_i_scrollTexture;
 181: i.scrollMult = a_i_scrollMult;
 182: 
 183: 
 184:     BlockFrag o = FLWMain(v, i);
 185: 
 186:     v2f_texCoords = o.texCoords;
 187: v2f_color = o.color;
 188: v2f_diffuse = o.diffuse;
 189: v2f_light = o.light;
 190: 
 191: }

[12:29:44] [main/ERROR]: Shader compilation log for flywheel:block.frag: No errors.

[12:29:44] [main/ERROR]: Source for shader 'flywheel:block.frag':
   1: #version 110
   2: #define USE_FOG
   3: #define USE_FOG_EXP2
   4: 
   5: #if defined(USE_FOG)
   6: varying float FragDistance;
   7: uniform vec4 uFogColor;
   8: #endif
   9: 
  10: #if defined(USE_FOG_LINEAR)
  11: uniform vec2 uFogRange;
  12: 
  13: float FLWFogFactor() {
  14:     return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
  15: }
  16:     #endif
  17: 
  18:     #if defined(USE_FOG_EXP2)
  19: uniform float uFogDensity;
  20: 
  21: float FLWFogFactor() {
  22:     float dist = FragDistance * uFogDensity;
  23:     return 1. / exp2(dist * dist);
  24: }
  25:     #endif
  26: 
  27: uniform vec2 uTextureScale;
  28: uniform sampler2D uBlockAtlas;
  29: uniform sampler2D uLightMap;
  30: uniform sampler2D uCrumbling;
  31: 
  32: vec4 FLWBlockTexture(vec2 texCoords) {
  33:     vec4 cr = texture2D(uCrumbling, texCoords * uTextureScale);
  34:     float diffuseAlpha = texture2D(uBlockAtlas, texCoords).a;
  35:     cr.a = cr.a * diffuseAlpha;
  36:     return cr;
  37: }
  38: 
  39: void FLWFinalizeColor(vec4 color) {
  40:     #if defined(USE_FOG)
  41:     float a = color.a;
  42:     float fog = clamp(FLWFogFactor(), 0., 1.);
  43: 
  44:     color = mix(uFogColor, color, fog);
  45:     color.a = a;
  46:     #endif
  47: 
  48:     gl_FragColor = color;
  49: }
  50: 
  51: vec4 FLWLight(vec2 lightCoords) {
  52:     return vec4(1.);
  53: }
  54: 
  55: 
  56: 
  57: struct BlockFrag {
  58:     vec2 texCoords;
  59:     vec4 color;
  60:     float diffuse;
  61:     vec2 light;
  62: };
  63: 
  64: void FLWMain(BlockFrag r) {
  65:     vec4 tex = FLWBlockTexture(r.texCoords);
  66: 
  67:     vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;
  68: 
  69: //    flw_WorldPos = ;
  70: //    flw_Normal = ;
  71: //    flw_Albedo = tex.rgb;
  72: //    flw_Alpha = tex.a;
  73: //    flw_LightMap = r.light;
  74: //    flw_Tint = r.color;
  75:     FLWFinalizeColor(color);
  76: }
  77: 
  78: varying vec2 v2f_texCoords;
  79: varying vec4 v2f_color;
  80: varying float v2f_diffuse;
  81: varying vec2 v2f_light;
  82: 
  83: 
  84: //vec3 flw_WorldPos;
  85: //vec3 flw_Normal;
  86: //vec3 flw_Albedo;
  87: //float flw_Alpha;
  88: //vec2 flw_LightMap;
  89: //vec4 flw_Tint;
  90: 
  91: void main() {
  92:     BlockFrag f;
  93:     f.texCoords = v2f_texCoords;
  94: f.color = v2f_color;
  95: f.diffuse = v2f_diffuse;
  96: f.light = v2f_light;
  97: 
  98: 
  99:     FLWMain(f);
 100: }

[12:29:44] [main/ERROR]: Shader compilation log for create:belt.vert: No errors.

[12:29:44] [main/ERROR]: Source for shader 'create:belt.vert':
   1: #version 110
   2: 
   3: #define PI 3.1415926538
   4: 
   5: uniform float uTime;
   6: uniform mat4 uViewProjection;
   7: uniform vec3 uCameraPos;
   8: 
   9: #if defined(USE_FOG)
  10: varying float FragDistance;
  11: #endif
  12: 
  13: void FLWFinalizeWorldPos(inout vec4 worldPos) {
  14:     #if defined(USE_FOG)
  15:     FragDistance = length(worldPos.xyz - uCameraPos);
  16:     #endif
  17: 
  18:     gl_Position = uViewProjection * worldPos;
  19: }
  20: 
  21: void FLWFinalizeNormal(inout vec3 normal) {
  22:     // noop
  23: }
  24: 
  25: 
  26: #define PIOVER2 1.5707963268
  27: 
  28: vec4 quat(vec3 axis, float angle) {
  29:     float halfAngle = angle * PIOVER2 / 180.0;
  30:     vec2 cs = sin(vec2(PIOVER2 - halfAngle, halfAngle)); // compute sin and cos in one instruction
  31:     return vec4(axis.xyz * cs.y,  cs.x);
  32: }
  33: 
  34: vec4 quatMult(vec4 q1, vec4 q2) {
  35:     // disgustingly vectorized quaternion multiplication
  36:     vec4 a = q1.w * q2.xyzw;
  37:     vec4 b = q1.x * q2.wzxy * vec4(1., -1., 1., -1.);
  38:     vec4 c = q1.y * q2.zwxy * vec4(1., 1., -1., -1.);
  39:     vec4 d = q1.z * q2.yxwz * vec4(-1., 1., 1., -1.);
  40: 
  41:     return a + b + c + d;
  42: }
  43: 
  44: vec3 rotateVertexByQuat(vec3 v, vec4 q) {
  45:     vec3 i = q.xyz;
  46:     return v + 2.0 * cross(i, cross(i, v) + q.w * v);
  47: }
  48: 
  49: vec3 rotateAbout(vec3 v, vec3 axis, float angle) {
  50:     return rotateVertexByQuat(v, quat(axis, angle));
  51: }
  52: 
  53: mat4 rotate(vec3 axis, float angle) {
  54:     float s = sin(angle);
  55:     float c = cos(angle);
  56:     float oc = 1. - c;
  57: 
  58:     vec3 sa = axis * s;
  59: 
  60:     mat4 mr = mat4(1.);
  61:     mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
  62:     mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
  63:     mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);
  64: 
  65:     return mr;
  66: }
  67: 
  68: mat4 rotation(vec3 rot) {
  69:     return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
  70: }
  71: 
  72: mat3 modelToNormal(mat4 mat) {
  73:     // Discard the edges. This won't be accurate for scaled or skewed matrices,
  74:     // but we don't have to work with those often.
  75:     mat3 m;
  76:     m[0] = mat[0].xyz;
  77:     m[1] = mat[1].xyz;
  78:     m[2] = mat[2].xyz;
  79:     return m;
  80: }
  81: 
  82: float diffuse(vec3 normal) {
  83:     vec3 n2 = normal * normal * vec3(.6, .25, .8);
  84:     return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
  85: }
  86: 
  87: 
  88: struct Belt {
  89:     vec2 light;
  90:     vec4 color;
  91:     vec3 pos;
  92:     float speed;
  93:     float offset;
  94:     vec4 rotation;
  95:     vec2 sourceTexture;
  96:     vec4 scrollTexture;
  97:     float scrollMult;
  98: };
  99: 
 100: 
 101: struct Vertex {
 102:     vec3 pos;
 103:     vec3 normal;
 104:     vec2 texCoords;
 105: };
 106: 
 107: struct BlockFrag {
 108:     vec2 texCoords;
 109:     vec4 color;
 110:     float diffuse;
 111:     vec2 light;
 112: };
 113: 
 114: BlockFrag FLWMain(Vertex v, Belt instance) {
 115:     vec3 rotated = rotateVertexByQuat(v.pos - .5, instance.rotation) + instance.pos + .5;
 116: 
 117:     vec4 worldPos = vec4(rotated, 1.);
 118: 
 119:     vec3 norm = rotateVertexByQuat(v.normal, instance.rotation);
 120: 
 121:     FLWFinalizeWorldPos(worldPos);
 122:     FLWFinalizeNormal(norm);
 123: 
 124:     float scrollSize = instance.scrollTexture.w - instance.scrollTexture.y;
 125:     float scroll = fract(instance.speed * uTime / (31.5 * 16.) + instance.offset) * scrollSize * instance.scrollMult;
 126: 
 127:     BlockFrag b;
 128:     b.diffuse = diffuse(norm);
 129:     b.texCoords = v.texCoords - instance.sourceTexture + instance.scrollTexture.xy + vec2(0, scroll);
 130:     b.light = instance.light;
 131: 
 132:     #if defined(DEBUG_RAINBOW)
 133:     b.color = instance.color;
 134:     #elif defined(DEBUG_NORMAL)
 135:     b.color = vec4(norm, 1.);
 136:     #else
 137:     b.color = vec4(1.);
 138:     #endif
 139: 
 140:     return b;
 141: }
 142: attribute vec3 a_v_pos;
 143: attribute vec3 a_v_normal;
 144: attribute vec2 a_v_texCoords;
 145: 
 146: attribute vec2 a_i_light;
 147: attribute vec4 a_i_color;
 148: attribute vec3 a_i_pos;
 149: attribute float a_i_speed;
 150: attribute float a_i_offset;
 151: attribute vec4 a_i_rotation;
 152: attribute vec2 a_i_sourceTexture;
 153: attribute vec4 a_i_scrollTexture;
 154: attribute float a_i_scrollMult;
 155: 
 156: 
 157: varying vec2 v2f_texCoords;
 158: varying vec4 v2f_color;
 159: varying float v2f_diffuse;
 160: varying vec2 v2f_light;
 161: 
 162: 
 163: void main() {
 164:     Vertex v;
 165:     v.pos = a_v_pos;
 166: v.normal = a_v_normal;
 167: v.texCoords = a_v_texCoords;
 168: 
 169: 
 170:     Belt i;
 171:     i.light = a_i_light;
 172: i.color = a_i_color;
 173: i.pos = a_i_pos;
 174: i.speed = a_i_speed;
 175: i.offset = a_i_offset;
 176: i.rotation = a_i_rotation;
 177: i.sourceTexture = a_i_sourceTexture;
 178: i.scrollTexture = a_i_scrollTexture;
 179: i.scrollMult = a_i_scrollMult;
 180: 
 181: 
 182:     BlockFrag o = FLWMain(v, i);
 183: 
 184:     v2f_texCoords = o.texCoords;
 185: v2f_color = o.color;
 186: v2f_diffuse = o.diffuse;
 187: v2f_light = o.light;
 188: 
 189: }

[12:29:44] [main/ERROR]: Shader compilation log for flywheel:block.frag: No errors.

[12:29:44] [main/ERROR]: Source for shader 'flywheel:block.frag':
   1: #version 110
   2: 
   3: #if defined(USE_FOG)
   4: varying float FragDistance;
   5: uniform vec4 uFogColor;
   6: #endif
   7: 
   8: #if defined(USE_FOG_LINEAR)
   9: uniform vec2 uFogRange;
  10: 
  11: float FLWFogFactor() {
  12:     return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
  13: }
  14:     #endif
  15: 
  16:     #if defined(USE_FOG_EXP2)
  17: uniform float uFogDensity;
  18: 
  19: float FLWFogFactor() {
  20:     float dist = FragDistance * uFogDensity;
  21:     return 1. / exp2(dist * dist);
  22: }
  23:     #endif
  24: 
  25: uniform vec2 uTextureScale;
  26: uniform sampler2D uBlockAtlas;
  27: uniform sampler2D uLightMap;
  28: uniform sampler2D uCrumbling;
  29: 
  30: vec4 FLWBlockTexture(vec2 texCoords) {
  31:     vec4 cr = texture2D(uCrumbling, texCoords * uTextureScale);
  32:     float diffuseAlpha = texture2D(uBlockAtlas, texCoords).a;
  33:     cr.a = cr.a * diffuseAlpha;
  34:     return cr;
  35: }
  36: 
  37: void FLWFinalizeColor(vec4 color) {
  38:     #if defined(USE_FOG)
  39:     float a = color.a;
  40:     float fog = clamp(FLWFogFactor(), 0., 1.);
  41: 
  42:     color = mix(uFogColor, color, fog);
  43:     color.a = a;
  44:     #endif
  45: 
  46:     gl_FragColor = color;
  47: }
  48: 
  49: vec4 FLWLight(vec2 lightCoords) {
  50:     return vec4(1.);
  51: }
  52: 
  53: 
  54: 
  55: struct BlockFrag {
  56:     vec2 texCoords;
  57:     vec4 color;
  58:     float diffuse;
  59:     vec2 light;
  60: };
  61: 
  62: void FLWMain(BlockFrag r) {
  63:     vec4 tex = FLWBlockTexture(r.texCoords);
  64: 
  65:     vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;
  66: 
  67: //    flw_WorldPos = ;
  68: //    flw_Normal = ;
  69: //    flw_Albedo = tex.rgb;
  70: //    flw_Alpha = tex.a;
  71: //    flw_LightMap = r.light;
  72: //    flw_Tint = r.color;
  73:     FLWFinalizeColor(color);
  74: }
  75: 
  76: varying vec2 v2f_texCoords;
  77: varying vec4 v2f_color;
  78: varying float v2f_diffuse;
  79: varying vec2 v2f_light;
  80: 
  81: 
  82: //vec3 flw_WorldPos;
  83: //vec3 flw_Normal;
  84: //vec3 flw_Albedo;
  85: //float flw_Alpha;
  86: //vec2 flw_LightMap;
  87: //vec4 flw_Tint;
  88: 
  89: void main() {
  90:     BlockFrag f;
  91:     f.texCoords = v2f_texCoords;
  92: f.color = v2f_color;
  93: f.diffuse = v2f_diffuse;
  94: f.light = v2f_light;
  95: 
  96: 
  97:     FLWMain(f);
  98: }

[12:29:44] [main/ERROR]: Shader compilation log for flywheel:oriented.vert: No errors.

[12:29:44] [main/ERROR]: Source for shader 'flywheel:oriented.vert':
   1: #version 110
   2: #define DEBUG_NORMAL
   3: 
   4: uniform float uTime;
   5: uniform mat4 uViewProjection;
   6: uniform vec3 uCameraPos;
   7: 
   8: #if defined(USE_FOG)
   9: varying float FragDistance;
  10: #endif
  11: 
  12: void FLWFinalizeWorldPos(inout vec4 worldPos) {
  13:     #if defined(USE_FOG)
  14:     FragDistance = length(worldPos.xyz - uCameraPos);
  15:     #endif
  16: 
  17:     gl_Position = uViewProjection * worldPos;
  18: }
  19: 
  20: void FLWFinalizeNormal(inout vec3 normal) {
  21:     // noop
  22: }
  23: 
  24: 
  25: mat4 rotate(vec3 axis, float angle) {
  26:     float s = sin(angle);
  27:     float c = cos(angle);
  28:     float oc = 1. - c;
  29: 
  30:     vec3 sa = axis * s;
  31: 
  32:     mat4 mr = mat4(1.);
  33:     mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
  34:     mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
  35:     mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);
  36: 
  37:     return mr;
  38: }
  39: 
  40: mat4 rotation(vec3 rot) {
  41:     return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
  42: }
  43: 
  44: mat3 modelToNormal(mat4 mat) {
  45:     // Discard the edges. This won't be accurate for scaled or skewed matrices,
  46:     // but we don't have to work with those often.
  47:     mat3 m;
  48:     m[0] = mat[0].xyz;
  49:     m[1] = mat[1].xyz;
  50:     m[2] = mat[2].xyz;
  51:     return m;
  52: }
  53: 
  54: #define PIOVER2 1.5707963268
  55: 
  56: vec4 quat(vec3 axis, float angle) {
  57:     float halfAngle = angle * PIOVER2 / 180.0;
  58:     vec2 cs = sin(vec2(PIOVER2 - halfAngle, halfAngle)); // compute sin and cos in one instruction
  59:     return vec4(axis.xyz * cs.y,  cs.x);
  60: }
  61: 
  62: vec4 quatMult(vec4 q1, vec4 q2) {
  63:     // disgustingly vectorized quaternion multiplication
  64:     vec4 a = q1.w * q2.xyzw;
  65:     vec4 b = q1.x * q2.wzxy * vec4(1., -1., 1., -1.);
  66:     vec4 c = q1.y * q2.zwxy * vec4(1., 1., -1., -1.);
  67:     vec4 d = q1.z * q2.yxwz * vec4(-1., 1., 1., -1.);
  68: 
  69:     return a + b + c + d;
  70: }
  71: 
  72: vec3 rotateVertexByQuat(vec3 v, vec4 q) {
  73:     vec3 i = q.xyz;
  74:     return v + 2.0 * cross(i, cross(i, v) + q.w * v);
  75: }
  76: 
  77: vec3 rotateAbout(vec3 v, vec3 axis, float angle) {
  78:     return rotateVertexByQuat(v, quat(axis, angle));
  79: }
  80: 
  81: float diffuse(vec3 normal) {
  82:     vec3 n2 = normal * normal * vec3(.6, .25, .8);
  83:     return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
  84: }
  85: 
  86: 
  87: struct Oriented {
  88:     vec2 light;
  89:     vec4 color;
  90:     vec3 pos;
  91:     vec3 pivot;
  92:     vec4 rotation;
  93: };
  94: 
  95: 
  96: struct Vertex {
  97:     vec3 pos;
  98:     vec3 normal;
  99:     vec2 texCoords;
 100: };
 101: 
 102: struct BlockFrag {
 103:     vec2 texCoords;
 104:     vec4 color;
 105:     float diffuse;
 106:     vec2 light;
 107: };
 108: 
 109: BlockFrag FLWMain(Vertex v, Oriented o) {
 110:     vec4 worldPos = vec4(rotateVertexByQuat(v.pos - o.pivot, o.rotation) + o.pivot + o.pos, 1.);
 111: 
 112:     vec3 norm = rotateVertexByQuat(v.normal, o.rotation);
 113: 
 114:     FLWFinalizeWorldPos(worldPos);
 115:     FLWFinalizeNormal(norm);
 116: 
 117:     BlockFrag b;
 118:     b.diffuse = diffuse(norm);
 119:     b.texCoords = v.texCoords;
 120:     b.light = o.light;
 121:     #if defined(DEBUG_NORMAL)
 122:     b.color = vec4(norm, 1.);
 123:     #else
 124:     b.color = o.color;
 125:     #endif
 126:     return b;
 127: }
 128: attribute vec3 a_v_pos;
 129: attribute vec3 a_v_normal;
 130: attribute vec2 a_v_texCoords;
 131: 
 132: attribute vec2 a_i_light;
 133: attribute vec4 a_i_color;
 134: attribute vec3 a_i_pos;
 135: attribute vec3 a_i_pivot;
 136: attribute vec4 a_i_rotation;
 137: 
 138: 
 139: varying vec2 v2f_texCoords;
 140: varying vec4 v2f_color;
 141: varying float v2f_diffuse;
 142: varying vec2 v2f_light;
 143: 
 144: 
 145: void main() {
 146:     Vertex v;
 147:     v.pos = a_v_pos;
 148: v.normal = a_v_normal;
 149: v.texCoords = a_v_texCoords;
 150: 
 151: 
 152:     Oriented i;
 153:     i.light = a_i_light;
 154: i.color = a_i_color;
 155: i.pos = a_i_pos;
 156: i.pivot = a_i_pivot;
 157: i.rotation = a_i_rotation;
 158: 
 159: 
 160:     BlockFrag o = FLWMain(v, i);
 161: 
 162:     v2f_texCoords = o.texCoords;
 163: v2f_color = o.color;
 164: v2f_diffuse = o.diffuse;
 165: v2f_light = o.light;
 166: 
 167: }

[12:29:44] [main/ERROR]: Shader compilation log for flywheel:block.frag: No errors.

[12:29:44] [main/ERROR]: Source for shader 'flywheel:block.frag':
   1: #version 110
   2: #define DEBUG_NORMAL
   3: 
   4: #if defined(USE_FOG)
   5: varying float FragDistance;
   6: uniform vec4 uFogColor;
   7: #endif
   8: 
   9: #if defined(USE_FOG_LINEAR)
  10: uniform vec2 uFogRange;
  11: 
  12: float FLWFogFactor() {
  13:     return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
  14: }
  15:     #endif
  16: 
  17:     #if defined(USE_FOG_EXP2)
  18: uniform float uFogDensity;
  19: 
  20: float FLWFogFactor() {
  21:     float dist = FragDistance * uFogDensity;
  22:     return 1. / exp2(dist * dist);
  23: }
  24:     #endif
  25: 
  26: uniform vec2 uTextureScale;
  27: uniform sampler2D uBlockAtlas;
  28: uniform sampler2D uLightMap;
  29: uniform sampler2D uCrumbling;
  30: 
  31: vec4 FLWBlockTexture(vec2 texCoords) {
  32:     vec4 cr = texture2D(uCrumbling, texCoords * uTextureScale);
  33:     float diffuseAlpha = texture2D(uBlockAtlas, texCoords).a;
  34:     cr.a = cr.a * diffuseAlpha;
  35:     return cr;
  36: }
  37: 
  38: void FLWFinalizeColor(vec4 color) {
  39:     #if defined(USE_FOG)
  40:     float a = color.a;
  41:     float fog = clamp(FLWFogFactor(), 0., 1.);
  42: 
  43:     color = mix(uFogColor, color, fog);
  44:     color.a = a;
  45:     #endif
  46: 
  47:     gl_FragColor = color;
  48: }
  49: 
  50: vec4 FLWLight(vec2 lightCoords) {
  51:     return vec4(1.);
  52: }
  53: 
  54: 
  55: 
  56: struct BlockFrag {
  57:     vec2 texCoords;
  58:     vec4 color;
  59:     float diffuse;
  60:     vec2 light;
  61: };
  62: 
  63: void FLWMain(BlockFrag r) {
  64:     vec4 tex = FLWBlockTexture(r.texCoords);
  65: 
  66:     vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;
  67: 
  68: //    flw_WorldPos = ;
  69: //    flw_Normal = ;
  70: //    flw_Albedo = tex.rgb;
  71: //    flw_Alpha = tex.a;
  72: //    flw_LightMap = r.light;
  73: //    flw_Tint = r.color;
  74:     FLWFinalizeColor(color);
  75: }
  76: 
  77: varying vec2 v2f_texCoords;
  78: varying vec4 v2f_color;
  79: varying float v2f_diffuse;
  80: varying vec2 v2f_light;
  81: 
  82: 
  83: //vec3 flw_WorldPos;
  84: //vec3 flw_Normal;
  85: //vec3 flw_Albedo;
  86: //float flw_Alpha;
  87: //vec2 flw_LightMap;
  88: //vec4 flw_Tint;
  89: 
  90: void main() {
  91:     BlockFrag f;
  92:     f.texCoords = v2f_texCoords;
  93: f.color = v2f_color;
  94: f.diffuse = v2f_diffuse;
  95: f.light = v2f_light;
  96: 
  97: 
  98:     FLWMain(f);
  99: }

[12:29:44] [main/ERROR]: Shader compilation log for flywheel:oriented.vert: No errors.

[12:29:44] [main/ERROR]: Source for shader 'flywheel:oriented.vert':
   1: #version 110
   2: #define USE_FOG
   3: #define USE_FOG_LINEAR
   4: 
   5: uniform float uTime;
   6: uniform mat4 uViewProjection;
   7: uniform vec3 uCameraPos;
   8: 
   9: #if defined(USE_FOG)
  10: varying float FragDistance;
  11: #endif
  12: 
  13: void FLWFinalizeWorldPos(inout vec4 worldPos) {
  14:     #if defined(USE_FOG)
  15:     FragDistance = length(worldPos.xyz - uCameraPos);
  16:     #endif
  17: 
  18:     gl_Position = uViewProjection * worldPos;
  19: }
  20: 
  21: void FLWFinalizeNormal(inout vec3 normal) {
  22:     // noop
  23: }
  24: 
  25: 
  26: mat4 rotate(vec3 axis, float angle) {
  27:     float s = sin(angle);
  28:     float c = cos(angle);
  29:     float oc = 1. - c;
  30: 
  31:     vec3 sa = axis * s;
  32: 
  33:     mat4 mr = mat4(1.);
  34:     mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
  35:     mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
  36:     mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);
  37: 
  38:     return mr;
  39: }
  40: 
  41: mat4 rotation(vec3 rot) {
  42:     return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
  43: }
  44: 
  45: mat3 modelToNormal(mat4 mat) {
  46:     // Discard the edges. This won't be accurate for scaled or skewed matrices,
  47:     // but we don't have to work with those often.
  48:     mat3 m;
  49:     m[0] = mat[0].xyz;
  50:     m[1] = mat[1].xyz;
  51:     m[2] = mat[2].xyz;
  52:     return m;
  53: }
  54: 
  55: #define PIOVER2 1.5707963268
  56: 
  57: vec4 quat(vec3 axis, float angle) {
  58:     float halfAngle = angle * PIOVER2 / 180.0;
  59:     vec2 cs = sin(vec2(PIOVER2 - halfAngle, halfAngle)); // compute sin and cos in one instruction
  60:     return vec4(axis.xyz * cs.y,  cs.x);
  61: }
  62: 
  63: vec4 quatMult(vec4 q1, vec4 q2) {
  64:     // disgustingly vectorized quaternion multiplication
  65:     vec4 a = q1.w * q2.xyzw;
  66:     vec4 b = q1.x * q2.wzxy * vec4(1., -1., 1., -1.);
  67:     vec4 c = q1.y * q2.zwxy * vec4(1., 1., -1., -1.);
  68:     vec4 d = q1.z * q2.yxwz * vec4(-1., 1., 1., -1.);
  69: 
  70:     return a + b + c + d;
  71: }
  72: 
  73: vec3 rotateVertexByQuat(vec3 v, vec4 q) {
  74:     vec3 i = q.xyz;
  75:     return v + 2.0 * cross(i, cross(i, v) + q.w * v);
  76: }
  77: 
  78: vec3 rotateAbout(vec3 v, vec3 axis, float angle) {
  79:     return rotateVertexByQuat(v, quat(axis, angle));
  80: }
  81: 
  82: float diffuse(vec3 normal) {
  83:     vec3 n2 = normal * normal * vec3(.6, .25, .8);
  84:     return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
  85: }
  86: 
  87: 
  88: struct Oriented {
  89:     vec2 light;
  90:     vec4 color;
  91:     vec3 pos;
  92:     vec3 pivot;
  93:     vec4 rotation;
  94: };
  95: 
  96: 
  97: struct Vertex {
  98:     vec3 pos;
  99:     vec3 normal;
 100:     vec2 texCoords;
 101: };
 102: 
 103: struct BlockFrag {
 104:     vec2 texCoords;
 105:     vec4 color;
 106:     float diffuse;
 107:     vec2 light;
 108: };
 109: 
 110: BlockFrag FLWMain(Vertex v, Oriented o) {
 111:     vec4 worldPos = vec4(rotateVertexByQuat(v.pos - o.pivot, o.rotation) + o.pivot + o.pos, 1.);
 112: 
 113:     vec3 norm = rotateVertexByQuat(v.normal, o.rotation);
 114: 
 115:     FLWFinalizeWorldPos(worldPos);
 116:     FLWFinalizeNormal(norm);
 117: 
 118:     BlockFrag b;
 119:     b.diffuse = diffuse(norm);
 120:     b.texCoords = v.texCoords;
 121:     b.light = o.light;
 122:     #if defined(DEBUG_NORMAL)
 123:     b.color = vec4(norm, 1.);
 124:     #else
 125:     b.color = o.color;
 126:     #endif
 127:     return b;
 128: }
 129: attribute vec3 a_v_pos;
 130: attribute vec3 a_v_normal;
 131: attribute vec2 a_v_texCoords;
 132: 
 133: attribute vec2 a_i_light;
 134: attribute vec4 a_i_color;
 135: attribute vec3 a_i_pos;
 136: attribute vec3 a_i_pivot;
 137: attribute vec4 a_i_rotation;
 138: 
 139: 
 140: varying vec2 v2f_texCoords;
 141: varying vec4 v2f_color;
 142: varying float v2f_diffuse;
 143: varying vec2 v2f_light;
 144: 
 145: 
 146: void main() {
 147:     Vertex v;
 148:     v.pos = a_v_pos;
 149: v.normal = a_v_normal;
 150: v.texCoords = a_v_texCoords;
 151: 
 152: 
 153:     Oriented i;
 154:     i.light = a_i_light;
 155: i.color = a_i_color;
 156: i.pos = a_i_pos;
 157: i.pivot = a_i_pivot;
 158: i.rotation = a_i_rotation;
 159: 
 160: 
 161:     BlockFrag o = FLWMain(v, i);
 162: 
 163:     v2f_texCoords = o.texCoords;
 164: v2f_color = o.color;
 165: v2f_diffuse = o.diffuse;
 166: v2f_light = o.light;
 167: 
 168: }

[12:29:44] [main/ERROR]: Shader compilation log for flywheel:block.frag: No errors.

[12:29:44] [main/ERROR]: Source for shader 'flywheel:block.frag':
   1: #version 110
   2: #define USE_FOG
   3: #define USE_FOG_LINEAR
   4: 
   5: #if defined(USE_FOG)
   6: varying float FragDistance;
   7: uniform vec4 uFogColor;
   8: #endif
   9: 
  10: #if defined(USE_FOG_LINEAR)
  11: uniform vec2 uFogRange;
  12: 
  13: float FLWFogFactor() {
  14:     return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
  15: }
  16:     #endif
  17: 
  18:     #if defined(USE_FOG_EXP2)
  19: uniform float uFogDensity;
  20: 
  21: float FLWFogFactor() {
  22:     float dist = FragDistance * uFogDensity;
  23:     return 1. / exp2(dist * dist);
  24: }
  25:     #endif
  26: 
  27: uniform vec2 uTextureScale;
  28: uniform sampler2D uBlockAtlas;
  29: uniform sampler2D uLightMap;
  30: uniform sampler2D uCrumbling;
  31: 
  32: vec4 FLWBlockTexture(vec2 texCoords) {
  33:     vec4 cr = texture2D(uCrumbling, texCoords * uTextureScale);
  34:     float diffuseAlpha = texture2D(uBlockAtlas, texCoords).a;
  35:     cr.a = cr.a * diffuseAlpha;
  36:     return cr;
  37: }
  38: 
  39: void FLWFinalizeColor(vec4 color) {
  40:     #if defined(USE_FOG)
  41:     float a = color.a;
  42:     float fog = clamp(FLWFogFactor(), 0., 1.);
  43: 
  44:     color = mix(uFogColor, color, fog);
  45:     color.a = a;
  46:     #endif
  47: 
  48:     gl_FragColor = color;
  49: }
  50: 
  51: vec4 FLWLight(vec2 lightCoords) {
  52:     return vec4(1.);
  53: }
  54: 
  55: 
  56: 
  57: struct BlockFrag {
  58:     vec2 texCoords;
  59:     vec4 color;
  60:     float diffuse;
  61:     vec2 light;
  62: };
  63: 
  64: void FLWMain(BlockFrag r) {
  65:     vec4 tex = FLWBlockTexture(r.texCoords);
  66: 
  67:     vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;
  68: 
  69: //    flw_WorldPos = ;
  70: //    flw_Normal = ;
  71: //    flw_Albedo = tex.rgb;
  72: //    flw_Alpha = tex.a;
  73: //    flw_LightMap = r.light;
  74: //    flw_Tint = r.color;
  75:     FLWFinalizeColor(color);
  76: }
  77: 
  78: varying vec2 v2f_texCoords;
  79: varying vec4 v2f_color;
  80: varying float v2f_diffuse;
  81: varying vec2 v2f_light;
  82: 
  83: 
  84: //vec3 flw_WorldPos;
  85: //vec3 flw_Normal;
  86: //vec3 flw_Albedo;
  87: //float flw_Alpha;
  88: //vec2 flw_LightMap;
  89: //vec4 flw_Tint;
  90: 
  91: void main() {
  92:     BlockFrag f;
  93:     f.texCoords = v2f_texCoords;
  94: f.color = v2f_color;
  95: f.diffuse = v2f_diffuse;
  96: f.light = v2f_light;
  97: 
  98: 
  99:     FLWMain(f);
 100: }

[12:29:44] [main/ERROR]: Shader compilation log for flywheel:oriented.vert: No errors.

[12:29:44] [main/ERROR]: Source for shader 'flywheel:oriented.vert':
   1: #version 110
   2: #define USE_FOG
   3: #define USE_FOG_EXP2
   4: 
   5: uniform float uTime;
   6: uniform mat4 uViewProjection;
   7: uniform vec3 uCameraPos;
   8: 
   9: #if defined(USE_FOG)
  10: varying float FragDistance;
  11: #endif
  12: 
  13: void FLWFinalizeWorldPos(inout vec4 worldPos) {
  14:     #if defined(USE_FOG)
  15:     FragDistance = length(worldPos.xyz - uCameraPos);
  16:     #endif
  17: 
  18:     gl_Position = uViewProjection * worldPos;
  19: }
  20: 
  21: void FLWFinalizeNormal(inout vec3 normal) {
  22:     // noop
  23: }
  24: 
  25: 
  26: mat4 rotate(vec3 axis, float angle) {
  27:     float s = sin(angle);
  28:     float c = cos(angle);
  29:     float oc = 1. - c;
  30: 
  31:     vec3 sa = axis * s;
  32: 
  33:     mat4 mr = mat4(1.);
  34:     mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
  35:     mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
  36:     mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);
  37: 
  38:     return mr;
  39: }
  40: 
  41: mat4 rotation(vec3 rot) {
  42:     return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
  43: }
  44: 
  45: mat3 modelToNormal(mat4 mat) {
  46:     // Discard the edges. This won't be accurate for scaled or skewed matrices,
  47:     // but we don't have to work with those often.
  48:     mat3 m;
  49:     m[0] = mat[0].xyz;
  50:     m[1] = mat[1].xyz;
  51:     m[2] = mat[2].xyz;
  52:     return m;
  53: }
  54: 
  55: #define PIOVER2 1.5707963268
  56: 
  57: vec4 quat(vec3 axis, float angle) {
  58:     float halfAngle = angle * PIOVER2 / 180.0;
  59:     vec2 cs = sin(vec2(PIOVER2 - halfAngle, halfAngle)); // compute sin and cos in one instruction
  60:     return vec4(axis.xyz * cs.y,  cs.x);
  61: }
  62: 
  63: vec4 quatMult(vec4 q1, vec4 q2) {
  64:     // disgustingly vectorized quaternion multiplication
  65:     vec4 a = q1.w * q2.xyzw;
  66:     vec4 b = q1.x * q2.wzxy * vec4(1., -1., 1., -1.);
  67:     vec4 c = q1.y * q2.zwxy * vec4(1., 1., -1., -1.);
  68:     vec4 d = q1.z * q2.yxwz * vec4(-1., 1., 1., -1.);
  69: 
  70:     return a + b + c + d;
  71: }
  72: 
  73: vec3 rotateVertexByQuat(vec3 v, vec4 q) {
  74:     vec3 i = q.xyz;
  75:     return v + 2.0 * cross(i, cross(i, v) + q.w * v);
  76: }
  77: 
  78: vec3 rotateAbout(vec3 v, vec3 axis, float angle) {
  79:     return rotateVertexByQuat(v, quat(axis, angle));
  80: }
  81: 
  82: float diffuse(vec3 normal) {
  83:     vec3 n2 = normal * normal * vec3(.6, .25, .8);
  84:     return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
  85: }
  86: 
  87: 
  88: struct Oriented {
  89:     vec2 light;
  90:     vec4 color;
  91:     vec3 pos;
  92:     vec3 pivot;
  93:     vec4 rotation;
  94: };
  95: 
  96: 
  97: struct Vertex {
  98:     vec3 pos;
  99:     vec3 normal;
 100:     vec2 texCoords;
 101: };
 102: 
 103: struct BlockFrag {
 104:     vec2 texCoords;
 105:     vec4 color;
 106:     float diffuse;
 107:     vec2 light;
 108: };
 109: 
 110: BlockFrag FLWMain(Vertex v, Oriented o) {
 111:     vec4 worldPos = vec4(rotateVertexByQuat(v.pos - o.pivot, o.rotation) + o.pivot + o.pos, 1.);
 112: 
 113:     vec3 norm = rotateVertexByQuat(v.normal, o.rotation);
 114: 
 115:     FLWFinalizeWorldPos(worldPos);
 116:     FLWFinalizeNormal(norm);
 117: 
 118:     BlockFrag b;
 119:     b.diffuse = diffuse(norm);
 120:     b.texCoords = v.texCoords;
 121:     b.light = o.light;
 122:     #if defined(DEBUG_NORMAL)
 123:     b.color = vec4(norm, 1.);
 124:     #else
 125:     b.color = o.color;
 126:     #endif
 127:     return b;
 128: }
 129: attribute vec3 a_v_pos;
 130: attribute vec3 a_v_normal;
 131: attribute vec2 a_v_texCoords;
 132: 
 133: attribute vec2 a_i_light;
 134: attribute vec4 a_i_color;
 135: attribute vec3 a_i_pos;
 136: attribute vec3 a_i_pivot;
 137: attribute vec4 a_i_rotation;
 138: 
 139: 
 140: varying vec2 v2f_texCoords;
 141: varying vec4 v2f_color;
 142: varying float v2f_diffuse;
 143: varying vec2 v2f_light;
 144: 
 145: 
 146: void main() {
 147:     Vertex v;
 148:     v.pos = a_v_pos;
 149: v.normal = a_v_normal;
 150: v.texCoords = a_v_texCoords;
 151: 
 152: 
 153:     Oriented i;
 154:     i.light = a_i_light;
 155: i.color = a_i_color;
 156: i.pos = a_i_pos;
 157: i.pivot = a_i_pivot;
 158: i.rotation = a_i_rotation;
 159: 
 160: 
 161:     BlockFrag o = FLWMain(v, i);
 162: 
 163:     v2f_texCoords = o.texCoords;
 164: v2f_color = o.color;
 165: v2f_diffuse = o.diffuse;
 166: v2f_light = o.light;
 167: 
 168: }

[12:29:44] [main/ERROR]: Shader compilation log for flywheel:block.frag: No errors.

[12:29:44] [main/ERROR]: Source for shader 'flywheel:block.frag':
   1: #version 110
   2: #define USE_FOG
   3: #define USE_FOG_EXP2
   4: 
   5: #if defined(USE_FOG)
   6: varying float FragDistance;
   7: uniform vec4 uFogColor;
   8: #endif
   9: 
  10: #if defined(USE_FOG_LINEAR)
  11: uniform vec2 uFogRange;
  12: 
  13: float FLWFogFactor() {
  14:     return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
  15: }
  16:     #endif
  17: 
  18:     #if defined(USE_FOG_EXP2)
  19: uniform float uFogDensity;
  20: 
  21: float FLWFogFactor() {
  22:     float dist = FragDistance * uFogDensity;
  23:     return 1. / exp2(dist * dist);
  24: }
  25:     #endif
  26: 
  27: uniform vec2 uTextureScale;
  28: uniform sampler2D uBlockAtlas;
  29: uniform sampler2D uLightMap;
  30: uniform sampler2D uCrumbling;
  31: 
  32: vec4 FLWBlockTexture(vec2 texCoords) {
  33:     vec4 cr = texture2D(uCrumbling, texCoords * uTextureScale);
  34:     float diffuseAlpha = texture2D(uBlockAtlas, texCoords).a;
  35:     cr.a = cr.a * diffuseAlpha;
  36:     return cr;
  37: }
  38: 
  39: void FLWFinalizeColor(vec4 color) {
  40:     #if defined(USE_FOG)
  41:     float a = color.a;
  42:     float fog = clamp(FLWFogFactor(), 0., 1.);
  43: 
  44:     color = mix(uFogColor, color, fog);
  45:     color.a = a;
  46:     #endif
  47: 
  48:     gl_FragColor = color;
  49: }
  50: 
  51: vec4 FLWLight(vec2 lightCoords) {
  52:     return vec4(1.);
  53: }
  54: 
  55: 
  56: 
  57: struct BlockFrag {
  58:     vec2 texCoords;
  59:     vec4 color;
  60:     float diffuse;
  61:     vec2 light;
  62: };
  63: 
  64: void FLWMain(BlockFrag r) {
  65:     vec4 tex = FLWBlockTexture(r.texCoords);
  66: 
  67:     vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;
  68: 
  69: //    flw_WorldPos = ;
  70: //    flw_Normal = ;
  71: //    flw_Albedo = tex.rgb;
  72: //    flw_Alpha = tex.a;
  73: //    flw_LightMap = r.light;
  74: //    flw_Tint = r.color;
  75:     FLWFinalizeColor(color);
  76: }
  77: 
  78: varying vec2 v2f_texCoords;
  79: varying vec4 v2f_color;
  80: varying float v2f_diffuse;
  81: varying vec2 v2f_light;
  82: 
  83: 
  84: //vec3 flw_WorldPos;
  85: //vec3 flw_Normal;
  86: //vec3 flw_Albedo;
  87: //float flw_Alpha;
  88: //vec2 flw_LightMap;
  89: //vec4 flw_Tint;
  90: 
  91: void main() {
  92:     BlockFrag f;
  93:     f.texCoords = v2f_texCoords;
  94: f.color = v2f_color;
  95: f.diffuse = v2f_diffuse;
  96: f.light = v2f_light;
  97: 
  98: 
  99:     FLWMain(f);
 100: }

[12:29:44] [main/ERROR]: Shader compilation log for flywheel:oriented.vert: No errors.

[12:29:44] [main/ERROR]: Source for shader 'flywheel:oriented.vert':
   1: #version 110
   2: 
   3: uniform float uTime;
   4: uniform mat4 uViewProjection;
   5: uniform vec3 uCameraPos;
   6: 
   7: #if defined(USE_FOG)
   8: varying float FragDistance;
   9: #endif
  10: 
  11: void FLWFinalizeWorldPos(inout vec4 worldPos) {
  12:     #if defined(USE_FOG)
  13:     FragDistance = length(worldPos.xyz - uCameraPos);
  14:     #endif
  15: 
  16:     gl_Position = uViewProjection * worldPos;
  17: }
  18: 
  19: void FLWFinalizeNormal(inout vec3 normal) {
  20:     // noop
  21: }
  22: 
  23: 
  24: mat4 rotate(vec3 axis, float angle) {
  25:     float s = sin(angle);
  26:     float c = cos(angle);
  27:     float oc = 1. - c;
  28: 
  29:     vec3 sa = axis * s;
  30: 
  31:     mat4 mr = mat4(1.);
  32:     mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
  33:     mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
  34:     mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);
  35: 
  36:     return mr;
  37: }
  38: 
  39: mat4 rotation(vec3 rot) {
  40:     return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
  41: }
  42: 
  43: mat3 modelToNormal(mat4 mat) {
  44:     // Discard the edges. This won't be accurate for scaled or skewed matrices,
  45:     // but we don't have to work with those often.
  46:     mat3 m;
  47:     m[0] = mat[0].xyz;
  48:     m[1] = mat[1].xyz;
  49:     m[2] = mat[2].xyz;
  50:     return m;
  51: }
  52: 
  53: #define PIOVER2 1.5707963268
  54: 
  55: vec4 quat(vec3 axis, float angle) {
  56:     float halfAngle = angle * PIOVER2 / 180.0;
  57:     vec2 cs = sin(vec2(PIOVER2 - halfAngle, halfAngle)); // compute sin and cos in one instruction
  58:     return vec4(axis.xyz * cs.y,  cs.x);
  59: }
  60: 
  61: vec4 quatMult(vec4 q1, vec4 q2) {
  62:     // disgustingly vectorized quaternion multiplication
  63:     vec4 a = q1.w * q2.xyzw;
  64:     vec4 b = q1.x * q2.wzxy * vec4(1., -1., 1., -1.);
  65:     vec4 c = q1.y * q2.zwxy * vec4(1., 1., -1., -1.);
  66:     vec4 d = q1.z * q2.yxwz * vec4(-1., 1., 1., -1.);
  67: 
  68:     return a + b + c + d;
  69: }
  70: 
  71: vec3 rotateVertexByQuat(vec3 v, vec4 q) {
  72:     vec3 i = q.xyz;
  73:     return v + 2.0 * cross(i, cross(i, v) + q.w * v);
  74: }
  75: 
  76: vec3 rotateAbout(vec3 v, vec3 axis, float angle) {
  77:     return rotateVertexByQuat(v, quat(axis, angle));
  78: }
  79: 
  80: float diffuse(vec3 normal) {
  81:     vec3 n2 = normal * normal * vec3(.6, .25, .8);
  82:     return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
  83: }
  84: 
  85: 
  86: struct Oriented {
  87:     vec2 light;
  88:     vec4 color;
  89:     vec3 pos;
  90:     vec3 pivot;
  91:     vec4 rotation;
  92: };
  93: 
  94: 
  95: struct Vertex {
  96:     vec3 pos;
  97:     vec3 normal;
  98:     vec2 texCoords;
  99: };
 100: 
 101: struct BlockFrag {
 102:     vec2 texCoords;
 103:     vec4 color;
 104:     float diffuse;
 105:     vec2 light;
 106: };
 107: 
 108: BlockFrag FLWMain(Vertex v, Oriented o) {
 109:     vec4 worldPos = vec4(rotateVertexByQuat(v.pos - o.pivot, o.rotation) + o.pivot + o.pos, 1.);
 110: 
 111:     vec3 norm = rotateVertexByQuat(v.normal, o.rotation);
 112: 
 113:     FLWFinalizeWorldPos(worldPos);
 114:     FLWFinalizeNormal(norm);
 115: 
 116:     BlockFrag b;
 117:     b.diffuse = diffuse(norm);
 118:     b.texCoords = v.texCoords;
 119:     b.light = o.light;
 120:     #if defined(DEBUG_NORMAL)
 121:     b.color = vec4(norm, 1.);
 122:     #else
 123:     b.color = o.color;
 124:     #endif
 125:     return b;
 126: }
 127: attribute vec3 a_v_pos;
 128: attribute vec3 a_v_normal;
 129: attribute vec2 a_v_texCoords;
 130: 
 131: attribute vec2 a_i_light;
 132: attribute vec4 a_i_color;
 133: attribute vec3 a_i_pos;
 134: attribute vec3 a_i_pivot;
 135: attribute vec4 a_i_rotation;
 136: 
 137: 
 138: varying vec2 v2f_texCoords;
 139: varying vec4 v2f_color;
 140: varying float v2f_diffuse;
 141: varying vec2 v2f_light;
 142: 
 143: 
 144: void main() {
 145:     Vertex v;
 146:     v.pos = a_v_pos;
 147: v.normal = a_v_normal;
 148: v.texCoords = a_v_texCoords;
 149: 
 150: 
 151:     Oriented i;
 152:     i.light = a_i_light;
 153: i.color = a_i_color;
 154: i.pos = a_i_pos;
 155: i.pivot = a_i_pivot;
 156: i.rotation = a_i_rotation;
 157: 
 158: 
 159:     BlockFrag o = FLWMain(v, i);
 160: 
 161:     v2f_texCoords = o.texCoords;
 162: v2f_color = o.color;
 163: v2f_diffuse = o.diffuse;
 164: v2f_light = o.light;
 165: 
 166: }

[12:29:44] [main/ERROR]: Shader compilation log for flywheel:block.frag: No errors.

[12:29:44] [main/ERROR]: Source for shader 'flywheel:block.frag':
   1: #version 110
   2: 
   3: #if defined(USE_FOG)
   4: varying float FragDistance;
   5: uniform vec4 uFogColor;
   6: #endif
   7: 
   8: #if defined(USE_FOG_LINEAR)
   9: uniform vec2 uFogRange;
  10: 
  11: float FLWFogFactor() {
  12:     return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
  13: }
  14:     #endif
  15: 
  16:     #if defined(USE_FOG_EXP2)
  17: uniform float uFogDensity;
  18: 
  19: float FLWFogFactor() {
  20:     float dist = FragDistance * uFogDensity;
  21:     return 1. / exp2(dist * dist);
  22: }
  23:     #endif
  24: 
  25: uniform vec2 uTextureScale;
  26: uniform sampler2D uBlockAtlas;
  27: uniform sampler2D uLightMap;
  28: uniform sampler2D uCrumbling;
  29: 
  30: vec4 FLWBlockTexture(vec2 texCoords) {
  31:     vec4 cr = texture2D(uCrumbling, texCoords * uTextureScale);
  32:     float diffuseAlpha = texture2D(uBlockAtlas, texCoords).a;
  33:     cr.a = cr.a * diffuseAlpha;
  34:     return cr;
  35: }
  36: 
  37: void FLWFinalizeColor(vec4 color) {
  38:     #if defined(USE_FOG)
  39:     float a = color.a;
  40:     float fog = clamp(FLWFogFactor(), 0., 1.);
  41: 
  42:     color = mix(uFogColor, color, fog);
  43:     color.a = a;
  44:     #endif
  45: 
  46:     gl_FragColor = color;
  47: }
  48: 
  49: vec4 FLWLight(vec2 lightCoords) {
  50:     return vec4(1.);
  51: }
  52: 
  53: 
  54: 
  55: struct BlockFrag {
  56:     vec2 texCoords;
  57:     vec4 color;
  58:     float diffuse;
  59:     vec2 light;
  60: };
  61: 
  62: void FLWMain(BlockFrag r) {
  63:     vec4 tex = FLWBlockTexture(r.texCoords);
  64: 
  65:     vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;
  66: 
  67: //    flw_WorldPos = ;
  68: //    flw_Normal = ;
  69: //    flw_Albedo = tex.rgb;
  70: //    flw_Alpha = tex.a;
  71: //    flw_LightMap = r.light;
  72: //    flw_Tint = r.color;
  73:     FLWFinalizeColor(color);
  74: }
  75: 
  76: varying vec2 v2f_texCoords;
  77: varying vec4 v2f_color;
  78: varying float v2f_diffuse;
  79: varying vec2 v2f_light;
  80: 
  81: 
  82: //vec3 flw_WorldPos;
  83: //vec3 flw_Normal;
  84: //vec3 flw_Albedo;
  85: //float flw_Alpha;
  86: //vec2 flw_LightMap;
  87: //vec4 flw_Tint;
  88: 
  89: void main() {
  90:     BlockFrag f;
  91:     f.texCoords = v2f_texCoords;
  92: f.color = v2f_color;
  93: f.diffuse = v2f_diffuse;
  94: f.light = v2f_light;
  95: 
  96: 
  97:     FLWMain(f);
  98: }

[12:29:44] [main/ERROR]: Shader compilation log for flywheel:model.vert: No errors.

[12:29:44] [main/ERROR]: Source for shader 'flywheel:model.vert':
   1: #version 110
   2: #define DEBUG_NORMAL
   3: 
   4: uniform float uTime;
   5: uniform mat4 uViewProjection;
   6: uniform vec3 uCameraPos;
   7: 
   8: #if defined(USE_FOG)
   9: varying float FragDistance;
  10: #endif
  11: 
  12: void FLWFinalizeWorldPos(inout vec4 worldPos) {
  13:     #if defined(USE_FOG)
  14:     FragDistance = length(worldPos.xyz - uCameraPos);
  15:     #endif
  16: 
  17:     gl_Position = uViewProjection * worldPos;
  18: }
  19: 
  20: void FLWFinalizeNormal(inout vec3 normal) {
  21:     // noop
  22: }
  23: 
  24: 
  25: float diffuse(vec3 normal) {
  26:     vec3 n2 = normal * normal * vec3(.6, .25, .8);
  27:     return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
  28: }
  29: 
  30: 
  31: struct Vertex {
  32:     vec3 pos;
  33:     vec3 normal;
  34:     vec2 texCoords;
  35: };
  36: 
  37: struct BlockFrag {
  38:     vec2 texCoords;
  39:     vec4 color;
  40:     float diffuse;
  41:     vec2 light;
  42: };
  43: 
  44: 
  45: struct Instance {
  46:     vec2 light;
  47:     vec4 color;
  48:     mat4 transform;
  49:     mat3 normalMat;
  50: };
  51: 
  52: BlockFrag FLWMain(Vertex v, Instance i) {
  53:     vec4 worldPos = i.transform * vec4(v.pos, 1.);
  54: 
  55:     vec3 norm = i.normalMat * v.normal;
  56: 
  57:     FLWFinalizeWorldPos(worldPos);
  58:     FLWFinalizeNormal(norm);
  59: 
  60:     norm = normalize(norm);
  61: 
  62:     BlockFrag b;
  63:     b.diffuse = diffuse(norm);
  64:     b.texCoords = v.texCoords;
  65:     b.light = i.light;
  66:     #if defined(DEBUG_NORMAL)
  67:     b.color = vec4(norm, 1.);
  68:     #else
  69:     b.color = i.color;
  70:     #endif
  71:     return b;
  72: }
  73: attribute vec3 a_v_pos;
  74: attribute vec3 a_v_normal;
  75: attribute vec2 a_v_texCoords;
  76: 
  77: attribute vec2 a_i_light;
  78: attribute vec4 a_i_color;
  79: attribute mat4 a_i_transform;
  80: attribute mat3 a_i_normalMat;
  81: 
  82: 
  83: varying vec2 v2f_texCoords;
  84: varying vec4 v2f_color;
  85: varying float v2f_diffuse;
  86: varying vec2 v2f_light;
  87: 
  88: 
  89: void main() {
  90:     Vertex v;
  91:     v.pos = a_v_pos;
  92: v.normal = a_v_normal;
  93: v.texCoords = a_v_texCoords;
  94: 
  95: 
  96:     Instance i;
  97:     i.light = a_i_light;
  98: i.color = a_i_color;
  99: i.transform = a_i_transform;
 100: i.normalMat = a_i_normalMat;
 101: 
 102: 
 103:     BlockFrag o = FLWMain(v, i);
 104: 
 105:     v2f_texCoords = o.texCoords;
 106: v2f_color = o.color;
 107: v2f_diffuse = o.diffuse;
 108: v2f_light = o.light;
 109: 
 110: }

[12:29:44] [main/ERROR]: Shader compilation log for flywheel:block.frag: No errors.

[12:29:44] [main/ERROR]: Source for shader 'flywheel:block.frag':
   1: #version 110
   2: #define DEBUG_NORMAL
   3: 
   4: #if defined(USE_FOG)
   5: varying float FragDistance;
   6: uniform vec4 uFogColor;
   7: #endif
   8: 
   9: #if defined(USE_FOG_LINEAR)
  10: uniform vec2 uFogRange;
  11: 
  12: float FLWFogFactor() {
  13:     return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
  14: }
  15:     #endif
  16: 
  17:     #if defined(USE_FOG_EXP2)
  18: uniform float uFogDensity;
  19: 
  20: float FLWFogFactor() {
  21:     float dist = FragDistance * uFogDensity;
  22:     return 1. / exp2(dist * dist);
  23: }
  24:     #endif
  25: 
  26: uniform vec2 uTextureScale;
  27: uniform sampler2D uBlockAtlas;
  28: uniform sampler2D uLightMap;
  29: uniform sampler2D uCrumbling;
  30: 
  31: vec4 FLWBlockTexture(vec2 texCoords) {
  32:     vec4 cr = texture2D(uCrumbling, texCoords * uTextureScale);
  33:     float diffuseAlpha = texture2D(uBlockAtlas, texCoords).a;
  34:     cr.a = cr.a * diffuseAlpha;
  35:     return cr;
  36: }
  37: 
  38: void FLWFinalizeColor(vec4 color) {
  39:     #if defined(USE_FOG)
  40:     float a = color.a;
  41:     float fog = clamp(FLWFogFactor(), 0., 1.);
  42: 
  43:     color = mix(uFogColor, color, fog);
  44:     color.a = a;
  45:     #endif
  46: 
  47:     gl_FragColor = color;
  48: }
  49: 
  50: vec4 FLWLight(vec2 lightCoords) {
  51:     return vec4(1.);
  52: }
  53: 
  54: 
  55: 
  56: struct BlockFrag {
  57:     vec2 texCoords;
  58:     vec4 color;
  59:     float diffuse;
  60:     vec2 light;
  61: };
  62: 
  63: void FLWMain(BlockFrag r) {
  64:     vec4 tex = FLWBlockTexture(r.texCoords);
  65: 
  66:     vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;
  67: 
  68: //    flw_WorldPos = ;
  69: //    flw_Normal = ;
  70: //    flw_Albedo = tex.rgb;
  71: //    flw_Alpha = tex.a;
  72: //    flw_LightMap = r.light;
  73: //    flw_Tint = r.color;
  74:     FLWFinalizeColor(color);
  75: }
  76: 
  77: varying vec2 v2f_texCoords;
  78: varying vec4 v2f_color;
  79: varying float v2f_diffuse;
  80: varying vec2 v2f_light;
  81: 
  82: 
  83: //vec3 flw_WorldPos;
  84: //vec3 flw_Normal;
  85: //vec3 flw_Albedo;
  86: //float flw_Alpha;
  87: //vec2 flw_LightMap;
  88: //vec4 flw_Tint;
  89: 
  90: void main() {
  91:     BlockFrag f;
  92:     f.texCoords = v2f_texCoords;
  93: f.color = v2f_color;
  94: f.diffuse = v2f_diffuse;
  95: f.light = v2f_light;
  96: 
  97: 
  98:     FLWMain(f);
  99: }

[12:29:44] [main/ERROR]: Shader compilation log for flywheel:model.vert: No errors.

[12:29:44] [main/ERROR]: Source for shader 'flywheel:model.vert':
   1: #version 110
   2: #define USE_FOG
   3: #define USE_FOG_LINEAR
   4: 
   5: uniform float uTime;
   6: uniform mat4 uViewProjection;
   7: uniform vec3 uCameraPos;
   8: 
   9: #if defined(USE_FOG)
  10: varying float FragDistance;
  11: #endif
  12: 
  13: void FLWFinalizeWorldPos(inout vec4 worldPos) {
  14:     #if defined(USE_FOG)
  15:     FragDistance = length(worldPos.xyz - uCameraPos);
  16:     #endif
  17: 
  18:     gl_Position = uViewProjection * worldPos;
  19: }
  20: 
  21: void FLWFinalizeNormal(inout vec3 normal) {
  22:     // noop
  23: }
  24: 
  25: 
  26: float diffuse(vec3 normal) {
  27:     vec3 n2 = normal * normal * vec3(.6, .25, .8);
  28:     return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
  29: }
  30: 
  31: 
  32: struct Vertex {
  33:     vec3 pos;
  34:     vec3 normal;
  35:     vec2 texCoords;
  36: };
  37: 
  38: struct BlockFrag {
  39:     vec2 texCoords;
  40:     vec4 color;
  41:     float diffuse;
  42:     vec2 light;
  43: };
  44: 
  45: 
  46: struct Instance {
  47:     vec2 light;
  48:     vec4 color;
  49:     mat4 transform;
  50:     mat3 normalMat;
  51: };
  52: 
  53: BlockFrag FLWMain(Vertex v, Instance i) {
  54:     vec4 worldPos = i.transform * vec4(v.pos, 1.);
  55: 
  56:     vec3 norm = i.normalMat * v.normal;
  57: 
  58:     FLWFinalizeWorldPos(worldPos);
  59:     FLWFinalizeNormal(norm);
  60: 
  61:     norm = normalize(norm);
  62: 
  63:     BlockFrag b;
  64:     b.diffuse = diffuse(norm);
  65:     b.texCoords = v.texCoords;
  66:     b.light = i.light;
  67:     #if defined(DEBUG_NORMAL)
  68:     b.color = vec4(norm, 1.);
  69:     #else
  70:     b.color = i.color;
  71:     #endif
  72:     return b;
  73: }
  74: attribute vec3 a_v_pos;
  75: attribute vec3 a_v_normal;
  76: attribute vec2 a_v_texCoords;
  77: 
  78: attribute vec2 a_i_light;
  79: attribute vec4 a_i_color;
  80: attribute mat4 a_i_transform;
  81: attribute mat3 a_i_normalMat;
  82: 
  83: 
  84: varying vec2 v2f_texCoords;
  85: varying vec4 v2f_color;
  86: varying float v2f_diffuse;
  87: varying vec2 v2f_light;
  88: 
  89: 
  90: void main() {
  91:     Vertex v;
  92:     v.pos = a_v_pos;
  93: v.normal = a_v_normal;
  94: v.texCoords = a_v_texCoords;
  95: 
  96: 
  97:     Instance i;
  98:     i.light = a_i_light;
  99: i.color = a_i_color;
 100: i.transform = a_i_transform;
 101: i.normalMat = a_i_normalMat;
 102: 
 103: 
 104:     BlockFrag o = FLWMain(v, i);
 105: 
 106:     v2f_texCoords = o.texCoords;
 107: v2f_color = o.color;
 108: v2f_diffuse = o.diffuse;
 109: v2f_light = o.light;
 110: 
 111: }

[12:29:44] [main/ERROR]: Shader compilation log for flywheel:block.frag: No errors.

[12:29:44] [main/ERROR]: Source for shader 'flywheel:block.frag':
   1: #version 110
   2: #define USE_FOG
   3: #define USE_FOG_LINEAR
   4: 
   5: #if defined(USE_FOG)
   6: varying float FragDistance;
   7: uniform vec4 uFogColor;
   8: #endif
   9: 
  10: #if defined(USE_FOG_LINEAR)
  11: uniform vec2 uFogRange;
  12: 
  13: float FLWFogFactor() {
  14:     return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
  15: }
  16:     #endif
  17: 
  18:     #if defined(USE_FOG_EXP2)
  19: uniform float uFogDensity;
  20: 
  21: float FLWFogFactor() {
  22:     float dist = FragDistance * uFogDensity;
  23:     return 1. / exp2(dist * dist);
  24: }
  25:     #endif
  26: 
  27: uniform vec2 uTextureScale;
  28: uniform sampler2D uBlockAtlas;
  29: uniform sampler2D uLightMap;
  30: uniform sampler2D uCrumbling;
  31: 
  32: vec4 FLWBlockTexture(vec2 texCoords) {
  33:     vec4 cr = texture2D(uCrumbling, texCoords * uTextureScale);
  34:     float diffuseAlpha = texture2D(uBlockAtlas, texCoords).a;
  35:     cr.a = cr.a * diffuseAlpha;
  36:     return cr;
  37: }
  38: 
  39: void FLWFinalizeColor(vec4 color) {
  40:     #if defined(USE_FOG)
  41:     float a = color.a;
  42:     float fog = clamp(FLWFogFactor(), 0., 1.);
  43: 
  44:     color = mix(uFogColor, color, fog);
  45:     color.a = a;
  46:     #endif
  47: 
  48:     gl_FragColor = color;
  49: }
  50: 
  51: vec4 FLWLight(vec2 lightCoords) {
  52:     return vec4(1.);
  53: }
  54: 
  55: 
  56: 
  57: struct BlockFrag {
  58:     vec2 texCoords;
  59:     vec4 color;
  60:     float diffuse;
  61:     vec2 light;
  62: };
  63: 
  64: void FLWMain(BlockFrag r) {
  65:     vec4 tex = FLWBlockTexture(r.texCoords);
  66: 
  67:     vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;
  68: 
  69: //    flw_WorldPos = ;
  70: //    flw_Normal = ;
  71: //    flw_Albedo = tex.rgb;
  72: //    flw_Alpha = tex.a;
  73: //    flw_LightMap = r.light;
  74: //    flw_Tint = r.color;
  75:     FLWFinalizeColor(color);
  76: }
  77: 
  78: varying vec2 v2f_texCoords;
  79: varying vec4 v2f_color;
  80: varying float v2f_diffuse;
  81: varying vec2 v2f_light;
  82: 
  83: 
  84: //vec3 flw_WorldPos;
  85: //vec3 flw_Normal;
  86: //vec3 flw_Albedo;
  87: //float flw_Alpha;
  88: //vec2 flw_LightMap;
  89: //vec4 flw_Tint;
  90: 
  91: void main() {
  92:     BlockFrag f;
  93:     f.texCoords = v2f_texCoords;
  94: f.color = v2f_color;
  95: f.diffuse = v2f_diffuse;
  96: f.light = v2f_light;
  97: 
  98: 
  99:     FLWMain(f);
 100: }

[12:29:44] [main/ERROR]: Shader compilation log for flywheel:model.vert: No errors.

[12:29:44] [main/ERROR]: Source for shader 'flywheel:model.vert':
   1: #version 110
   2: #define USE_FOG
   3: #define USE_FOG_EXP2
   4: 
   5: uniform float uTime;
   6: uniform mat4 uViewProjection;
   7: uniform vec3 uCameraPos;
   8: 
   9: #if defined(USE_FOG)
  10: varying float FragDistance;
  11: #endif
  12: 
  13: void FLWFinalizeWorldPos(inout vec4 worldPos) {
  14:     #if defined(USE_FOG)
  15:     FragDistance = length(worldPos.xyz - uCameraPos);
  16:     #endif
  17: 
  18:     gl_Position = uViewProjection * worldPos;
  19: }
  20: 
  21: void FLWFinalizeNormal(inout vec3 normal) {
  22:     // noop
  23: }
  24: 
  25: 
  26: float diffuse(vec3 normal) {
  27:     vec3 n2 = normal * normal * vec3(.6, .25, .8);
  28:     return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
  29: }
  30: 
  31: 
  32: struct Vertex {
  33:     vec3 pos;
  34:     vec3 normal;
  35:     vec2 texCoords;
  36: };
  37: 
  38: struct BlockFrag {
  39:     vec2 texCoords;
  40:     vec4 color;
  41:     float diffuse;
  42:     vec2 light;
  43: };
  44: 
  45: 
  46: struct Instance {
  47:     vec2 light;
  48:     vec4 color;
  49:     mat4 transform;
  50:     mat3 normalMat;
  51: };
  52: 
  53: BlockFrag FLWMain(Vertex v, Instance i) {
  54:     vec4 worldPos = i.transform * vec4(v.pos, 1.);
  55: 
  56:     vec3 norm = i.normalMat * v.normal;
  57: 
  58:     FLWFinalizeWorldPos(worldPos);
  59:     FLWFinalizeNormal(norm);
  60: 
  61:     norm = normalize(norm);
  62: 
  63:     BlockFrag b;
  64:     b.diffuse = diffuse(norm);
  65:     b.texCoords = v.texCoords;
  66:     b.light = i.light;
  67:     #if defined(DEBUG_NORMAL)
  68:     b.color = vec4(norm, 1.);
  69:     #else
  70:     b.color = i.color;
  71:     #endif
  72:     return b;
  73: }
  74: attribute vec3 a_v_pos;
  75: attribute vec3 a_v_normal;
  76: attribute vec2 a_v_texCoords;
  77: 
  78: attribute vec2 a_i_light;
  79: attribute vec4 a_i_color;
  80: attribute mat4 a_i_transform;
  81: attribute mat3 a_i_normalMat;
  82: 
  83: 
  84: varying vec2 v2f_texCoords;
  85: varying vec4 v2f_color;
  86: varying float v2f_diffuse;
  87: varying vec2 v2f_light;
  88: 
  89: 
  90: void main() {
  91:     Vertex v;
  92:     v.pos = a_v_pos;
  93: v.normal = a_v_normal;
  94: v.texCoords = a_v_texCoords;
  95: 
  96: 
  97:     Instance i;
  98:     i.light = a_i_light;
  99: i.color = a_i_color;
 100: i.transform = a_i_transform;
 101: i.normalMat = a_i_normalMat;
 102: 
 103: 
 104:     BlockFrag o = FLWMain(v, i);
 105: 
 106:     v2f_texCoords = o.texCoords;
 107: v2f_color = o.color;
 108: v2f_diffuse = o.diffuse;
 109: v2f_light = o.light;
 110: 
 111: }

[12:29:44] [main/ERROR]: Shader compilation log for flywheel:block.frag: No errors.

[12:29:44] [main/ERROR]: Source for shader 'flywheel:block.frag':
   1: #version 110
   2: #define USE_FOG
   3: #define USE_FOG_EXP2
   4: 
   5: #if defined(USE_FOG)
   6: varying float FragDistance;
   7: uniform vec4 uFogColor;
   8: #endif
   9: 
  10: #if defined(USE_FOG_LINEAR)
  11: uniform vec2 uFogRange;
  12: 
  13: float FLWFogFactor() {
  14:     return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
  15: }
  16:     #endif
  17: 
  18:     #if defined(USE_FOG_EXP2)
  19: uniform float uFogDensity;
  20: 
  21: float FLWFogFactor() {
  22:     float dist = FragDistance * uFogDensity;
  23:     return 1. / exp2(dist * dist);
  24: }
  25:     #endif
  26: 
  27: uniform vec2 uTextureScale;
  28: uniform sampler2D uBlockAtlas;
  29: uniform sampler2D uLightMap;
  30: uniform sampler2D uCrumbling;
  31: 
  32: vec4 FLWBlockTexture(vec2 texCoords) {
  33:     vec4 cr = texture2D(uCrumbling, texCoords * uTextureScale);
  34:     float diffuseAlpha = texture2D(uBlockAtlas, texCoords).a;
  35:     cr.a = cr.a * diffuseAlpha;
  36:     return cr;
  37: }
  38: 
  39: void FLWFinalizeColor(vec4 color) {
  40:     #if defined(USE_FOG)
  41:     float a = color.a;
  42:     float fog = clamp(FLWFogFactor(), 0., 1.);
  43: 
  44:     color = mix(uFogColor, color, fog);
  45:     color.a = a;
  46:     #endif
  47: 
  48:     gl_FragColor = color;
  49: }
  50: 
  51: vec4 FLWLight(vec2 lightCoords) {
  52:     return vec4(1.);
  53: }
  54: 
  55: 
  56: 
  57: struct BlockFrag {
  58:     vec2 texCoords;
  59:     vec4 color;
  60:     float diffuse;
  61:     vec2 light;
  62: };
  63: 
  64: void FLWMain(BlockFrag r) {
  65:     vec4 tex = FLWBlockTexture(r.texCoords);
  66: 
  67:     vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;
  68: 
  69: //    flw_WorldPos = ;
  70: //    flw_Normal = ;
  71: //    flw_Albedo = tex.rgb;
  72: //    flw_Alpha = tex.a;
  73: //    flw_LightMap = r.light;
  74: //    flw_Tint = r.color;
  75:     FLWFinalizeColor(color);
  76: }
  77: 
  78: varying vec2 v2f_texCoords;
  79: varying vec4 v2f_color;
  80: varying float v2f_diffuse;
  81: varying vec2 v2f_light;
  82: 
  83: 
  84: //vec3 flw_WorldPos;
  85: //vec3 flw_Normal;
  86: //vec3 flw_Albedo;
  87: //float flw_Alpha;
  88: //vec2 flw_LightMap;
  89: //vec4 flw_Tint;
  90: 
  91: void main() {
  92:     BlockFrag f;
  93:     f.texCoords = v2f_texCoords;
  94: f.color = v2f_color;
  95: f.diffuse = v2f_diffuse;
  96: f.light = v2f_light;
  97: 
  98: 
  99:     FLWMain(f);
 100: }

[12:29:44] [main/ERROR]: Shader compilation log for flywheel:model.vert: No errors.

[12:29:44] [main/ERROR]: Source for shader 'flywheel:model.vert':
   1: #version 110
   2: 
   3: uniform float uTime;
   4: uniform mat4 uViewProjection;
   5: uniform vec3 uCameraPos;
   6: 
   7: #if defined(USE_FOG)
   8: varying float FragDistance;
   9: #endif
  10: 
  11: void FLWFinalizeWorldPos(inout vec4 worldPos) {
  12:     #if defined(USE_FOG)
  13:     FragDistance = length(worldPos.xyz - uCameraPos);
  14:     #endif
  15: 
  16:     gl_Position = uViewProjection * worldPos;
  17: }
  18: 
  19: void FLWFinalizeNormal(inout vec3 normal) {
  20:     // noop
  21: }
  22: 
  23: 
  24: float diffuse(vec3 normal) {
  25:     vec3 n2 = normal * normal * vec3(.6, .25, .8);
  26:     return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
  27: }
  28: 
  29: 
  30: struct Vertex {
  31:     vec3 pos;
  32:     vec3 normal;
  33:     vec2 texCoords;
  34: };
  35: 
  36: struct BlockFrag {
  37:     vec2 texCoords;
  38:     vec4 color;
  39:     float diffuse;
  40:     vec2 light;
  41: };
  42: 
  43: 
  44: struct Instance {
  45:     vec2 light;
  46:     vec4 color;
  47:     mat4 transform;
  48:     mat3 normalMat;
  49: };
  50: 
  51: BlockFrag FLWMain(Vertex v, Instance i) {
  52:     vec4 worldPos = i.transform * vec4(v.pos, 1.);
  53: 
  54:     vec3 norm = i.normalMat * v.normal;
  55: 
  56:     FLWFinalizeWorldPos(worldPos);
  57:     FLWFinalizeNormal(norm);
  58: 
  59:     norm = normalize(norm);
  60: 
  61:     BlockFrag b;
  62:     b.diffuse = diffuse(norm);
  63:     b.texCoords = v.texCoords;
  64:     b.light = i.light;
  65:     #if defined(DEBUG_NORMAL)
  66:     b.color = vec4(norm, 1.);
  67:     #else
  68:     b.color = i.color;
  69:     #endif
  70:     return b;
  71: }
  72: attribute vec3 a_v_pos;
  73: attribute vec3 a_v_normal;
  74: attribute vec2 a_v_texCoords;
  75: 
  76: attribute vec2 a_i_light;
  77: attribute vec4 a_i_color;
  78: attribute mat4 a_i_transform;
  79: attribute mat3 a_i_normalMat;
  80: 
  81: 
  82: varying vec2 v2f_texCoords;
  83: varying vec4 v2f_color;
  84: varying float v2f_diffuse;
  85: varying vec2 v2f_light;
  86: 
  87: 
  88: void main() {
  89:     Vertex v;
  90:     v.pos = a_v_pos;
  91: v.normal = a_v_normal;
  92: v.texCoords = a_v_texCoords;
  93: 
  94: 
  95:     Instance i;
  96:     i.light = a_i_light;
  97: i.color = a_i_color;
  98: i.transform = a_i_transform;
  99: i.normalMat = a_i_normalMat;
 100: 
 101: 
 102:     BlockFrag o = FLWMain(v, i);
 103: 
 104:     v2f_texCoords = o.texCoords;
 105: v2f_color = o.color;
 106: v2f_diffuse = o.diffuse;
 107: v2f_light = o.light;
 108: 
 109: }

[12:29:44] [main/ERROR]: Shader compilation log for flywheel:block.frag: No errors.

[12:29:44] [main/ERROR]: Source for shader 'flywheel:block.frag':
   1: #version 110
   2: 
   3: #if defined(USE_FOG)
   4: varying float FragDistance;
   5: uniform vec4 uFogColor;
   6: #endif
   7: 
   8: #if defined(USE_FOG_LINEAR)
   9: uniform vec2 uFogRange;
  10: 
  11: float FLWFogFactor() {
  12:     return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
  13: }
  14:     #endif
  15: 
  16:     #if defined(USE_FOG_EXP2)
  17: uniform float uFogDensity;
  18: 
  19: float FLWFogFactor() {
  20:     float dist = FragDistance * uFogDensity;
  21:     return 1. / exp2(dist * dist);
  22: }
  23:     #endif
  24: 
  25: uniform vec2 uTextureScale;
  26: uniform sampler2D uBlockAtlas;
  27: uniform sampler2D uLightMap;
  28: uniform sampler2D uCrumbling;
  29: 
  30: vec4 FLWBlockTexture(vec2 texCoords) {
  31:     vec4 cr = texture2D(uCrumbling, texCoords * uTextureScale);
  32:     float diffuseAlpha = texture2D(uBlockAtlas, texCoords).a;
  33:     cr.a = cr.a * diffuseAlpha;
  34:     return cr;
  35: }
  36: 
  37: void FLWFinalizeColor(vec4 color) {
  38:     #if defined(USE_FOG)
  39:     float a = color.a;
  40:     float fog = clamp(FLWFogFactor(), 0., 1.);
  41: 
  42:     color = mix(uFogColor, color, fog);
  43:     color.a = a;
  44:     #endif
  45: 
  46:     gl_FragColor = color;
  47: }
  48: 
  49: vec4 FLWLight(vec2 lightCoords) {
  50:     return vec4(1.);
  51: }
  52: 
  53: 
  54: 
  55: struct BlockFrag {
  56:     vec2 texCoords;
  57:     vec4 color;
  58:     float diffuse;
  59:     vec2 light;
  60: };
  61: 
  62: void FLWMain(BlockFrag r) {
  63:     vec4 tex = FLWBlockTexture(r.texCoords);
  64: 
  65:     vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;
  66: 
  67: //    flw_WorldPos = ;
  68: //    flw_Normal = ;
  69: //    flw_Albedo = tex.rgb;
  70: //    flw_Alpha = tex.a;
  71: //    flw_LightMap = r.light;
  72: //    flw_Tint = r.color;
  73:     FLWFinalizeColor(color);
  74: }
  75: 
  76: varying vec2 v2f_texCoords;
  77: varying vec4 v2f_color;
  78: varying float v2f_diffuse;
  79: varying vec2 v2f_light;
  80: 
  81: 
  82: //vec3 flw_WorldPos;
  83: //vec3 flw_Normal;
  84: //vec3 flw_Albedo;
  85: //float flw_Alpha;
  86: //vec2 flw_LightMap;
  87: //vec4 flw_Tint;
  88: 
  89: void main() {
  90:     BlockFrag f;
  91:     f.texCoords = v2f_texCoords;
  92: f.color = v2f_color;
  93: f.diffuse = v2f_diffuse;
  94: f.light = v2f_light;
  95: 
  96: 
  97:     FLWMain(f);
  98: }

[12:29:44] [main/INFO]: Loading context 'flywheel:context/world'
[12:29:44] [main/ERROR]: Shader compilation log for create:rotating.vert: No errors.

[12:29:44] [main/ERROR]: Source for shader 'create:rotating.vert':
   1: #version 110
   2: #define DEBUG_RAINBOW
   3: 
   4: #define PI 3.1415926538
   5: 
   6: uniform float uTime;
   7: uniform mat4 uViewProjection;
   8: uniform vec3 uCameraPos;
   9: 
  10: #if defined(USE_FOG)
  11: varying float FragDistance;
  12: #endif
  13: 
  14: void FLWFinalizeWorldPos(inout vec4 worldPos) {
  15:     #if defined(USE_FOG)
  16:     FragDistance = length(worldPos.xyz - uCameraPos);
  17:     #endif
  18: 
  19:     gl_Position = uViewProjection * worldPos;
  20: }
  21: 
  22: void FLWFinalizeNormal(inout vec3 normal) {
  23:     // noop
  24: }
  25: 
  26: 
  27: mat4 rotate(vec3 axis, float angle) {
  28:     float s = sin(angle);
  29:     float c = cos(angle);
  30:     float oc = 1. - c;
  31: 
  32:     vec3 sa = axis * s;
  33: 
  34:     mat4 mr = mat4(1.);
  35:     mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
  36:     mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
  37:     mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);
  38: 
  39:     return mr;
  40: }
  41: 
  42: mat4 rotation(vec3 rot) {
  43:     return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
  44: }
  45: 
  46: mat3 modelToNormal(mat4 mat) {
  47:     // Discard the edges. This won't be accurate for scaled or skewed matrices,
  48:     // but we don't have to work with those often.
  49:     mat3 m;
  50:     m[0] = mat[0].xyz;
  51:     m[1] = mat[1].xyz;
  52:     m[2] = mat[2].xyz;
  53:     return m;
  54: }
  55: 
  56: float diffuse(vec3 normal) {
  57:     vec3 n2 = normal * normal * vec3(.6, .25, .8);
  58:     return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
  59: }
  60: 
  61: 
  62: struct Rotating {
  63:     vec2 light;
  64:     vec4 color;
  65:     vec3 pos;
  66:     float speed;
  67:     float offset;
  68:     vec3 axis;
  69: };
  70: 
  71: 
  72: struct Vertex {
  73:     vec3 pos;
  74:     vec3 normal;
  75:     vec2 texCoords;
  76: };
  77: 
  78: struct BlockFrag {
  79:     vec2 texCoords;
  80:     vec4 color;
  81:     float diffuse;
  82:     vec2 light;
  83: };
  84: 
  85: mat4 kineticRotation(float offset, float speed, vec3 axis) {
  86:     float degrees = offset + uTime * speed * 3./10.;
  87:     float angle = fract(degrees / 360.) * PI * 2.;
  88: 
  89:     return rotate(axis, angle);
  90: }
  91: 
  92: BlockFrag FLWMain(Vertex v, Rotating instance) {
  93:     mat4 spin = kineticRotation(instance.offset, instance.speed, instance.axis);
  94: 
  95:     vec4 worldPos = spin * vec4(v.pos - .5, 1.);
  96:     worldPos += vec4(instance.pos + .5, 0.);
  97: 
  98:     vec3 norm = modelToNormal(spin) * v.normal;
  99: 
 100:     FLWFinalizeWorldPos(worldPos);
 101:     FLWFinalizeNormal(norm);
 102: 
 103:     BlockFrag b;
 104:     b.diffuse = diffuse(norm);
 105:     b.texCoords = v.texCoords;
 106:     b.light = instance.light;
 107: 
 108:     #if defined(DEBUG_RAINBOW)
 109:     b.color = instance.color;
 110:     #elif defined(DEBUG_NORMAL)
 111:     b.color = vec4(norm, 1.);
 112:     #else
 113:     b.color = vec4(1.);
 114:     #endif
 115: 
 116:     return b;
 117: }
 118: attribute vec3 a_v_pos;
 119: attribute vec3 a_v_normal;
 120: attribute vec2 a_v_texCoords;
 121: 
 122: attribute vec2 a_i_light;
 123: attribute vec4 a_i_color;
 124: attribute vec3 a_i_pos;
 125: attribute float a_i_speed;
 126: attribute float a_i_offset;
 127: attribute vec3 a_i_axis;
 128: 
 129: 
 130: varying vec2 v2f_texCoords;
 131: varying vec4 v2f_color;
 132: varying float v2f_diffuse;
 133: varying vec2 v2f_light;
 134: 
 135: 
 136: void main() {
 137:     Vertex v;
 138:     v.pos = a_v_pos;
 139: v.normal = a_v_normal;
 140: v.texCoords = a_v_texCoords;
 141: 
 142: 
 143:     Rotating i;
 144:     i.light = a_i_light;
 145: i.color = a_i_color;
 146: i.pos = a_i_pos;
 147: i.speed = a_i_speed;
 148: i.offset = a_i_offset;
 149: i.axis = a_i_axis;
 150: 
 151: 
 152:     BlockFrag o = FLWMain(v, i);
 153: 
 154:     v2f_texCoords = o.texCoords;
 155: v2f_color = o.color;
 156: v2f_diffuse = o.diffuse;
 157: v2f_light = o.light;
 158: 
 159: }

[12:29:44] [main/ERROR]: Shader compilation log for flywheel:block.frag: No errors.

[12:29:44] [main/ERROR]: Source for shader 'flywheel:block.frag':
   1: #version 110
   2: #define DEBUG_RAINBOW
   3: 
   4: #if defined(USE_FOG)
   5: varying float FragDistance;
   6: uniform vec4 uFogColor;
   7: #endif
   8: 
   9: #if defined(USE_FOG_LINEAR)
  10: uniform vec2 uFogRange;
  11: 
  12: float FLWFogFactor() {
  13:     return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
  14: }
  15:     #endif
  16: 
  17:     #if defined(USE_FOG_EXP2)
  18: uniform float uFogDensity;
  19: 
  20: float FLWFogFactor() {
  21:     float dist = FragDistance * uFogDensity;
  22:     return 1. / exp2(dist * dist);
  23: }
  24:     #endif
  25: // Adjust the [0,1] normalized lightmap value based on the texture matrix from LightTexture#enableLightmap
  26: vec2 shiftLight(vec2 lm) {
  27:     return lm * 0.99609375 + 0.03125;// * 255/256 + 1/32
  28: }
  29: 
  30: uniform sampler2D uBlockAtlas;
  31: uniform sampler2D uLightMap;
  32: 
  33: vec4 FLWBlockTexture(vec2 texCoords) {
  34:     return texture2D(uBlockAtlas, texCoords);
  35: }
  36: 
  37: void FLWFinalizeColor(vec4 color) {
  38:     #if defined(USE_FOG)
  39:     float a = color.a;
  40:     float fog = clamp(FLWFogFactor(), 0., 1.);
  41: 
  42:     color = mix(uFogColor, color, fog);
  43:     color.a = a;
  44:     #endif
  45: 
  46:     gl_FragColor = color;
  47: }
  48: 
  49: vec4 FLWLight(vec2 lightCoords) {
  50:     return texture2D(uLightMap, shiftLight(lightCoords));
  51: }
  52: 
  53: 
  54: 
  55: struct BlockFrag {
  56:     vec2 texCoords;
  57:     vec4 color;
  58:     float diffuse;
  59:     vec2 light;
  60: };
  61: 
  62: void FLWMain(BlockFrag r) {
  63:     vec4 tex = FLWBlockTexture(r.texCoords);
  64: 
  65:     vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;
  66: 
  67: //    flw_WorldPos = ;
  68: //    flw_Normal = ;
  69: //    flw_Albedo = tex.rgb;
  70: //    flw_Alpha = tex.a;
  71: //    flw_LightMap = r.light;
  72: //    flw_Tint = r.color;
  73:     FLWFinalizeColor(color);
  74: }
  75: 
  76: varying vec2 v2f_texCoords;
  77: varying vec4 v2f_color;
  78: varying float v2f_diffuse;
  79: varying vec2 v2f_light;
  80: 
  81: 
  82: //vec3 flw_WorldPos;
  83: //vec3 flw_Normal;
  84: //vec3 flw_Albedo;
  85: //float flw_Alpha;
  86: //vec2 flw_LightMap;
  87: //vec4 flw_Tint;
  88: 
  89: void main() {
  90:     BlockFrag f;
  91:     f.texCoords = v2f_texCoords;
  92: f.color = v2f_color;
  93: f.diffuse = v2f_diffuse;
  94: f.light = v2f_light;
  95: 
  96: 
  97:     FLWMain(f);
  98: }

[12:29:44] [main/ERROR]: Shader compilation log for create:rotating.vert: No errors.

[12:29:44] [main/ERROR]: Source for shader 'create:rotating.vert':
   1: #version 110
   2: #define DEBUG_NORMAL
   3: 
   4: #define PI 3.1415926538
   5: 
   6: uniform float uTime;
   7: uniform mat4 uViewProjection;
   8: uniform vec3 uCameraPos;
   9: 
  10: #if defined(USE_FOG)
  11: varying float FragDistance;
  12: #endif
  13: 
  14: void FLWFinalizeWorldPos(inout vec4 worldPos) {
  15:     #if defined(USE_FOG)
  16:     FragDistance = length(worldPos.xyz - uCameraPos);
  17:     #endif
  18: 
  19:     gl_Position = uViewProjection * worldPos;
  20: }
  21: 
  22: void FLWFinalizeNormal(inout vec3 normal) {
  23:     // noop
  24: }
  25: 
  26: 
  27: mat4 rotate(vec3 axis, float angle) {
  28:     float s = sin(angle);
  29:     float c = cos(angle);
  30:     float oc = 1. - c;
  31: 
  32:     vec3 sa = axis * s;
  33: 
  34:     mat4 mr = mat4(1.);
  35:     mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
  36:     mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
  37:     mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);
  38: 
  39:     return mr;
  40: }
  41: 
  42: mat4 rotation(vec3 rot) {
  43:     return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
  44: }
  45: 
  46: mat3 modelToNormal(mat4 mat) {
  47:     // Discard the edges. This won't be accurate for scaled or skewed matrices,
  48:     // but we don't have to work with those often.
  49:     mat3 m;
  50:     m[0] = mat[0].xyz;
  51:     m[1] = mat[1].xyz;
  52:     m[2] = mat[2].xyz;
  53:     return m;
  54: }
  55: 
  56: float diffuse(vec3 normal) {
  57:     vec3 n2 = normal * normal * vec3(.6, .25, .8);
  58:     return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
  59: }
  60: 
  61: 
  62: struct Rotating {
  63:     vec2 light;
  64:     vec4 color;
  65:     vec3 pos;
  66:     float speed;
  67:     float offset;
  68:     vec3 axis;
  69: };
  70: 
  71: 
  72: struct Vertex {
  73:     vec3 pos;
  74:     vec3 normal;
  75:     vec2 texCoords;
  76: };
  77: 
  78: struct BlockFrag {
  79:     vec2 texCoords;
  80:     vec4 color;
  81:     float diffuse;
  82:     vec2 light;
  83: };
  84: 
  85: mat4 kineticRotation(float offset, float speed, vec3 axis) {
  86:     float degrees = offset + uTime * speed * 3./10.;
  87:     float angle = fract(degrees / 360.) * PI * 2.;
  88: 
  89:     return rotate(axis, angle);
  90: }
  91: 
  92: BlockFrag FLWMain(Vertex v, Rotating instance) {
  93:     mat4 spin = kineticRotation(instance.offset, instance.speed, instance.axis);
  94: 
  95:     vec4 worldPos = spin * vec4(v.pos - .5, 1.);
  96:     worldPos += vec4(instance.pos + .5, 0.);
  97: 
  98:     vec3 norm = modelToNormal(spin) * v.normal;
  99: 
 100:     FLWFinalizeWorldPos(worldPos);
 101:     FLWFinalizeNormal(norm);
 102: 
 103:     BlockFrag b;
 104:     b.diffuse = diffuse(norm);
 105:     b.texCoords = v.texCoords;
 106:     b.light = instance.light;
 107: 
 108:     #if defined(DEBUG_RAINBOW)
 109:     b.color = instance.color;
 110:     #elif defined(DEBUG_NORMAL)
 111:     b.color = vec4(norm, 1.);
 112:     #else
 113:     b.color = vec4(1.);
 114:     #endif
 115: 
 116:     return b;
 117: }
 118: attribute vec3 a_v_pos;
 119: attribute vec3 a_v_normal;
 120: attribute vec2 a_v_texCoords;
 121: 
 122: attribute vec2 a_i_light;
 123: attribute vec4 a_i_color;
 124: attribute vec3 a_i_pos;
 125: attribute float a_i_speed;
 126: attribute float a_i_offset;
 127: attribute vec3 a_i_axis;
 128: 
 129: 
 130: varying vec2 v2f_texCoords;
 131: varying vec4 v2f_color;
 132: varying float v2f_diffuse;
 133: varying vec2 v2f_light;
 134: 
 135: 
 136: void main() {
 137:     Vertex v;
 138:     v.pos = a_v_pos;
 139: v.normal = a_v_normal;
 140: v.texCoords = a_v_texCoords;
 141: 
 142: 
 143:     Rotating i;
 144:     i.light = a_i_light;
 145: i.color = a_i_color;
 146: i.pos = a_i_pos;
 147: i.speed = a_i_speed;
 148: i.offset = a_i_offset;
 149: i.axis = a_i_axis;
 150: 
 151: 
 152:     BlockFrag o = FLWMain(v, i);
 153: 
 154:     v2f_texCoords = o.texCoords;
 155: v2f_color = o.color;
 156: v2f_diffuse = o.diffuse;
 157: v2f_light = o.light;
 158: 
 159: }

[12:29:44] [main/ERROR]: Shader compilation log for flywheel:block.frag: No errors.

[12:29:44] [main/ERROR]: Source for shader 'flywheel:block.frag':
   1: #version 110
   2: #define DEBUG_NORMAL
   3: 
   4: #if defined(USE_FOG)
   5: varying float FragDistance;
   6: uniform vec4 uFogColor;
   7: #endif
   8: 
   9: #if defined(USE_FOG_LINEAR)
  10: uniform vec2 uFogRange;
  11: 
  12: float FLWFogFactor() {
  13:     return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
  14: }
  15:     #endif
  16: 
  17:     #if defined(USE_FOG_EXP2)
  18: uniform float uFogDensity;
  19: 
  20: float FLWFogFactor() {
  21:     float dist = FragDistance * uFogDensity;
  22:     return 1. / exp2(dist * dist);
  23: }
  24:     #endif
  25: // Adjust the [0,1] normalized lightmap value based on the texture matrix from LightTexture#enableLightmap
  26: vec2 shiftLight(vec2 lm) {
  27:     return lm * 0.99609375 + 0.03125;// * 255/256 + 1/32
  28: }
  29: 
  30: uniform sampler2D uBlockAtlas;
  31: uniform sampler2D uLightMap;
  32: 
  33: vec4 FLWBlockTexture(vec2 texCoords) {
  34:     return texture2D(uBlockAtlas, texCoords);
  35: }
  36: 
  37: void FLWFinalizeColor(vec4 color) {
  38:     #if defined(USE_FOG)
  39:     float a = color.a;
  40:     float fog = clamp(FLWFogFactor(), 0., 1.);
  41: 
  42:     color = mix(uFogColor, color, fog);
  43:     color.a = a;
  44:     #endif
  45: 
  46:     gl_FragColor = color;
  47: }
  48: 
  49: vec4 FLWLight(vec2 lightCoords) {
  50:     return texture2D(uLightMap, shiftLight(lightCoords));
  51: }
  52: 
  53: 
  54: 
  55: struct BlockFrag {
  56:     vec2 texCoords;
  57:     vec4 color;
  58:     float diffuse;
  59:     vec2 light;
  60: };
  61: 
  62: void FLWMain(BlockFrag r) {
  63:     vec4 tex = FLWBlockTexture(r.texCoords);
  64: 
  65:     vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;
  66: 
  67: //    flw_WorldPos = ;
  68: //    flw_Normal = ;
  69: //    flw_Albedo = tex.rgb;
  70: //    flw_Alpha = tex.a;
  71: //    flw_LightMap = r.light;
  72: //    flw_Tint = r.color;
  73:     FLWFinalizeColor(color);
  74: }
  75: 
  76: varying vec2 v2f_texCoords;
  77: varying vec4 v2f_color;
  78: varying float v2f_diffuse;
  79: varying vec2 v2f_light;
  80: 
  81: 
  82: //vec3 flw_WorldPos;
  83: //vec3 flw_Normal;
  84: //vec3 flw_Albedo;
  85: //float flw_Alpha;
  86: //vec2 flw_LightMap;
  87: //vec4 flw_Tint;
  88: 
  89: void main() {
  90:     BlockFrag f;
  91:     f.texCoords = v2f_texCoords;
  92: f.color = v2f_color;
  93: f.diffuse = v2f_diffuse;
  94: f.light = v2f_light;
  95: 
  96: 
  97:     FLWMain(f);
  98: }

[12:29:44] [main/ERROR]: Shader compilation log for create:rotating.vert: No errors.

[12:29:44] [main/ERROR]: Source for shader 'create:rotating.vert':
   1: #version 110
   2: #define USE_FOG
   3: #define USE_FOG_LINEAR
   4: 
   5: #define PI 3.1415926538
   6: 
   7: uniform float uTime;
   8: uniform mat4 uViewProjection;
   9: uniform vec3 uCameraPos;
  10: 
  11: #if defined(USE_FOG)
  12: varying float FragDistance;
  13: #endif
  14: 
  15: void FLWFinalizeWorldPos(inout vec4 worldPos) {
  16:     #if defined(USE_FOG)
  17:     FragDistance = length(worldPos.xyz - uCameraPos);
  18:     #endif
  19: 
  20:     gl_Position = uViewProjection * worldPos;
  21: }
  22: 
  23: void FLWFinalizeNormal(inout vec3 normal) {
  24:     // noop
  25: }
  26: 
  27: 
  28: mat4 rotate(vec3 axis, float angle) {
  29:     float s = sin(angle);
  30:     float c = cos(angle);
  31:     float oc = 1. - c;
  32: 
  33:     vec3 sa = axis * s;
  34: 
  35:     mat4 mr = mat4(1.);
  36:     mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
  37:     mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
  38:     mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);
  39: 
  40:     return mr;
  41: }
  42: 
  43: mat4 rotation(vec3 rot) {
  44:     return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
  45: }
  46: 
  47: mat3 modelToNormal(mat4 mat) {
  48:     // Discard the edges. This won't be accurate for scaled or skewed matrices,
  49:     // but we don't have to work with those often.
  50:     mat3 m;
  51:     m[0] = mat[0].xyz;
  52:     m[1] = mat[1].xyz;
  53:     m[2] = mat[2].xyz;
  54:     return m;
  55: }
  56: 
  57: float diffuse(vec3 normal) {
  58:     vec3 n2 = normal * normal * vec3(.6, .25, .8);
  59:     return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
  60: }
  61: 
  62: 
  63: struct Rotating {
  64:     vec2 light;
  65:     vec4 color;
  66:     vec3 pos;
  67:     float speed;
  68:     float offset;
  69:     vec3 axis;
  70: };
  71: 
  72: 
  73: struct Vertex {
  74:     vec3 pos;
  75:     vec3 normal;
  76:     vec2 texCoords;
  77: };
  78: 
  79: struct BlockFrag {
  80:     vec2 texCoords;
  81:     vec4 color;
  82:     float diffuse;
  83:     vec2 light;
  84: };
  85: 
  86: mat4 kineticRotation(float offset, float speed, vec3 axis) {
  87:     float degrees = offset + uTime * speed * 3./10.;
  88:     float angle = fract(degrees / 360.) * PI * 2.;
  89: 
  90:     return rotate(axis, angle);
  91: }
  92: 
  93: BlockFrag FLWMain(Vertex v, Rotating instance) {
  94:     mat4 spin = kineticRotation(instance.offset, instance.speed, instance.axis);
  95: 
  96:     vec4 worldPos = spin * vec4(v.pos - .5, 1.);
  97:     worldPos += vec4(instance.pos + .5, 0.);
  98: 
  99:     vec3 norm = modelToNormal(spin) * v.normal;
 100: 
 101:     FLWFinalizeWorldPos(worldPos);
 102:     FLWFinalizeNormal(norm);
 103: 
 104:     BlockFrag b;
 105:     b.diffuse = diffuse(norm);
 106:     b.texCoords = v.texCoords;
 107:     b.light = instance.light;
 108: 
 109:     #if defined(DEBUG_RAINBOW)
 110:     b.color = instance.color;
 111:     #elif defined(DEBUG_NORMAL)
 112:     b.color = vec4(norm, 1.);
 113:     #else
 114:     b.color = vec4(1.);
 115:     #endif
 116: 
 117:     return b;
 118: }
 119: attribute vec3 a_v_pos;
 120: attribute vec3 a_v_normal;
 121: attribute vec2 a_v_texCoords;
 122: 
 123: attribute vec2 a_i_light;
 124: attribute vec4 a_i_color;
 125: attribute vec3 a_i_pos;
 126: attribute float a_i_speed;
 127: attribute float a_i_offset;
 128: attribute vec3 a_i_axis;
 129: 
 130: 
 131: varying vec2 v2f_texCoords;
 132: varying vec4 v2f_color;
 133: varying float v2f_diffuse;
 134: varying vec2 v2f_light;
 135: 
 136: 
 137: void main() {
 138:     Vertex v;
 139:     v.pos = a_v_pos;
 140: v.normal = a_v_normal;
 141: v.texCoords = a_v_texCoords;
 142: 
 143: 
 144:     Rotating i;
 145:     i.light = a_i_light;
 146: i.color = a_i_color;
 147: i.pos = a_i_pos;
 148: i.speed = a_i_speed;
 149: i.offset = a_i_offset;
 150: i.axis = a_i_axis;
 151: 
 152: 
 153:     BlockFrag o = FLWMain(v, i);
 154: 
 155:     v2f_texCoords = o.texCoords;
 156: v2f_color = o.color;
 157: v2f_diffuse = o.diffuse;
 158: v2f_light = o.light;
 159: 
 160: }

[12:29:44] [main/ERROR]: Shader compilation log for flywheel:block.frag: No errors.

[12:29:44] [main/ERROR]: Source for shader 'flywheel:block.frag':
   1: #version 110
   2: #define USE_FOG
   3: #define USE_FOG_LINEAR
   4: 
   5: #if defined(USE_FOG)
   6: varying float FragDistance;
   7: uniform vec4 uFogColor;
   8: #endif
   9: 
  10: #if defined(USE_FOG_LINEAR)
  11: uniform vec2 uFogRange;
  12: 
  13: float FLWFogFactor() {
  14:     return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
  15: }
  16:     #endif
  17: 
  18:     #if defined(USE_FOG_EXP2)
  19: uniform float uFogDensity;
  20: 
  21: float FLWFogFactor() {
  22:     float dist = FragDistance * uFogDensity;
  23:     return 1. / exp2(dist * dist);
  24: }
  25:     #endif
  26: // Adjust the [0,1] normalized lightmap value based on the texture matrix from LightTexture#enableLightmap
  27: vec2 shiftLight(vec2 lm) {
  28:     return lm * 0.99609375 + 0.03125;// * 255/256 + 1/32
  29: }
  30: 
  31: uniform sampler2D uBlockAtlas;
  32: uniform sampler2D uLightMap;
  33: 
  34: vec4 FLWBlockTexture(vec2 texCoords) {
  35:     return texture2D(uBlockAtlas, texCoords);
  36: }
  37: 
  38: void FLWFinalizeColor(vec4 color) {
  39:     #if defined(USE_FOG)
  40:     float a = color.a;
  41:     float fog = clamp(FLWFogFactor(), 0., 1.);
  42: 
  43:     color = mix(uFogColor, color, fog);
  44:     color.a = a;
  45:     #endif
  46: 
  47:     gl_FragColor = color;
  48: }
  49: 
  50: vec4 FLWLight(vec2 lightCoords) {
  51:     return texture2D(uLightMap, shiftLight(lightCoords));
  52: }
  53: 
  54: 
  55: 
  56: struct BlockFrag {
  57:     vec2 texCoords;
  58:     vec4 color;
  59:     float diffuse;
  60:     vec2 light;
  61: };
  62: 
  63: void FLWMain(BlockFrag r) {
  64:     vec4 tex = FLWBlockTexture(r.texCoords);
  65: 
  66:     vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;
  67: 
  68: //    flw_WorldPos = ;
  69: //    flw_Normal = ;
  70: //    flw_Albedo = tex.rgb;
  71: //    flw_Alpha = tex.a;
  72: //    flw_LightMap = r.light;
  73: //    flw_Tint = r.color;
  74:     FLWFinalizeColor(color);
  75: }
  76: 
  77: varying vec2 v2f_texCoords;
  78: varying vec4 v2f_color;
  79: varying float v2f_diffuse;
  80: varying vec2 v2f_light;
  81: 
  82: 
  83: //vec3 flw_WorldPos;
  84: //vec3 flw_Normal;
  85: //vec3 flw_Albedo;
  86: //float flw_Alpha;
  87: //vec2 flw_LightMap;
  88: //vec4 flw_Tint;
  89: 
  90: void main() {
  91:     BlockFrag f;
  92:     f.texCoords = v2f_texCoords;
  93: f.color = v2f_color;
  94: f.diffuse = v2f_diffuse;
  95: f.light = v2f_light;
  96: 
  97: 
  98:     FLWMain(f);
  99: }

[12:29:44] [main/ERROR]: Shader compilation log for create:rotating.vert: No errors.

[12:29:44] [main/ERROR]: Source for shader 'create:rotating.vert':
   1: #version 110
   2: #define USE_FOG
   3: #define USE_FOG_EXP2
   4: 
   5: #define PI 3.1415926538
   6: 
   7: uniform float uTime;
   8: uniform mat4 uViewProjection;
   9: uniform vec3 uCameraPos;
  10: 
  11: #if defined(USE_FOG)
  12: varying float FragDistance;
  13: #endif
  14: 
  15: void FLWFinalizeWorldPos(inout vec4 worldPos) {
  16:     #if defined(USE_FOG)
  17:     FragDistance = length(worldPos.xyz - uCameraPos);
  18:     #endif
  19: 
  20:     gl_Position = uViewProjection * worldPos;
  21: }
  22: 
  23: void FLWFinalizeNormal(inout vec3 normal) {
  24:     // noop
  25: }
  26: 
  27: 
  28: mat4 rotate(vec3 axis, float angle) {
  29:     float s = sin(angle);
  30:     float c = cos(angle);
  31:     float oc = 1. - c;
  32: 
  33:     vec3 sa = axis * s;
  34: 
  35:     mat4 mr = mat4(1.);
  36:     mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
  37:     mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
  38:     mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);
  39: 
  40:     return mr;
  41: }
  42: 
  43: mat4 rotation(vec3 rot) {
  44:     return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
  45: }
  46: 
  47: mat3 modelToNormal(mat4 mat) {
  48:     // Discard the edges. This won't be accurate for scaled or skewed matrices,
  49:     // but we don't have to work with those often.
  50:     mat3 m;
  51:     m[0] = mat[0].xyz;
  52:     m[1] = mat[1].xyz;
  53:     m[2] = mat[2].xyz;
  54:     return m;
  55: }
  56: 
  57: float diffuse(vec3 normal) {
  58:     vec3 n2 = normal * normal * vec3(.6, .25, .8);
  59:     return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
  60: }
  61: 
  62: 
  63: struct Rotating {
  64:     vec2 light;
  65:     vec4 color;
  66:     vec3 pos;
  67:     float speed;
  68:     float offset;
  69:     vec3 axis;
  70: };
  71: 
  72: 
  73: struct Vertex {
  74:     vec3 pos;
  75:     vec3 normal;
  76:     vec2 texCoords;
  77: };
  78: 
  79: struct BlockFrag {
  80:     vec2 texCoords;
  81:     vec4 color;
  82:     float diffuse;
  83:     vec2 light;
  84: };
  85: 
  86: mat4 kineticRotation(float offset, float speed, vec3 axis) {
  87:     float degrees = offset + uTime * speed * 3./10.;
  88:     float angle = fract(degrees / 360.) * PI * 2.;
  89: 
  90:     return rotate(axis, angle);
  91: }
  92: 
  93: BlockFrag FLWMain(Vertex v, Rotating instance) {
  94:     mat4 spin = kineticRotation(instance.offset, instance.speed, instance.axis);
  95: 
  96:     vec4 worldPos = spin * vec4(v.pos - .5, 1.);
  97:     worldPos += vec4(instance.pos + .5, 0.);
  98: 
  99:     vec3 norm = modelToNormal(spin) * v.normal;
 100: 
 101:     FLWFinalizeWorldPos(worldPos);
 102:     FLWFinalizeNormal(norm);
 103: 
 104:     BlockFrag b;
 105:     b.diffuse = diffuse(norm);
 106:     b.texCoords = v.texCoords;
 107:     b.light = instance.light;
 108: 
 109:     #if defined(DEBUG_RAINBOW)
 110:     b.color = instance.color;
 111:     #elif defined(DEBUG_NORMAL)
 112:     b.color = vec4(norm, 1.);
 113:     #else
 114:     b.color = vec4(1.);
 115:     #endif
 116: 
 117:     return b;
 118: }
 119: attribute vec3 a_v_pos;
 120: attribute vec3 a_v_normal;
 121: attribute vec2 a_v_texCoords;
 122: 
 123: attribute vec2 a_i_light;
 124: attribute vec4 a_i_color;
 125: attribute vec3 a_i_pos;
 126: attribute float a_i_speed;
 127: attribute float a_i_offset;
 128: attribute vec3 a_i_axis;
 129: 
 130: 
 131: varying vec2 v2f_texCoords;
 132: varying vec4 v2f_color;
 133: varying float v2f_diffuse;
 134: varying vec2 v2f_light;
 135: 
 136: 
 137: void main() {
 138:     Vertex v;
 139:     v.pos = a_v_pos;
 140: v.normal = a_v_normal;
 141: v.texCoords = a_v_texCoords;
 142: 
 143: 
 144:     Rotating i;
 145:     i.light = a_i_light;
 146: i.color = a_i_color;
 147: i.pos = a_i_pos;
 148: i.speed = a_i_speed;
 149: i.offset = a_i_offset;
 150: i.axis = a_i_axis;
 151: 
 152: 
 153:     BlockFrag o = FLWMain(v, i);
 154: 
 155:     v2f_texCoords = o.texCoords;
 156: v2f_color = o.color;
 157: v2f_diffuse = o.diffuse;
 158: v2f_light = o.light;
 159: 
 160: }

[12:29:44] [main/ERROR]: Shader compilation log for flywheel:block.frag: No errors.

[12:29:44] [main/ERROR]: Source for shader 'flywheel:block.frag':
   1: #version 110
   2: #define USE_FOG
   3: #define USE_FOG_EXP2
   4: 
   5: #if defined(USE_FOG)
   6: varying float FragDistance;
   7: uniform vec4 uFogColor;
   8: #endif
   9: 
  10: #if defined(USE_FOG_LINEAR)
  11: uniform vec2 uFogRange;
  12: 
  13: float FLWFogFactor() {
  14:     return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
  15: }
  16:     #endif
  17: 
  18:     #if defined(USE_FOG_EXP2)
  19: uniform float uFogDensity;
  20: 
  21: float FLWFogFactor() {
  22:     float dist = FragDistance * uFogDensity;
  23:     return 1. / exp2(dist * dist);
  24: }
  25:     #endif
  26: // Adjust the [0,1] normalized lightmap value based on the texture matrix from LightTexture#enableLightmap
  27: vec2 shiftLight(vec2 lm) {
  28:     return lm * 0.99609375 + 0.03125;// * 255/256 + 1/32
  29: }
  30: 
  31: uniform sampler2D uBlockAtlas;
  32: uniform sampler2D uLightMap;
  33: 
  34: vec4 FLWBlockTexture(vec2 texCoords) {
  35:     return texture2D(uBlockAtlas, texCoords);
  36: }
  37: 
  38: void FLWFinalizeColor(vec4 color) {
  39:     #if defined(USE_FOG)
  40:     float a = color.a;
  41:     float fog = clamp(FLWFogFactor(), 0., 1.);
  42: 
  43:     color = mix(uFogColor, color, fog);
  44:     color.a = a;
  45:     #endif
  46: 
  47:     gl_FragColor = color;
  48: }
  49: 
  50: vec4 FLWLight(vec2 lightCoords) {
  51:     return texture2D(uLightMap, shiftLight(lightCoords));
  52: }
  53: 
  54: 
  55: 
  56: struct BlockFrag {
  57:     vec2 texCoords;
  58:     vec4 color;
  59:     float diffuse;
  60:     vec2 light;
  61: };
  62: 
  63: void FLWMain(BlockFrag r) {
  64:     vec4 tex = FLWBlockTexture(r.texCoords);
  65: 
  66:     vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;
  67: 
  68: //    flw_WorldPos = ;
  69: //    flw_Normal = ;
  70: //    flw_Albedo = tex.rgb;
  71: //    flw_Alpha = tex.a;
  72: //    flw_LightMap = r.light;
  73: //    flw_Tint = r.color;
  74:     FLWFinalizeColor(color);
  75: }
  76: 
  77: varying vec2 v2f_texCoords;
  78: varying vec4 v2f_color;
  79: varying float v2f_diffuse;
  80: varying vec2 v2f_light;
  81: 
  82: 
  83: //vec3 flw_WorldPos;
  84: //vec3 flw_Normal;
  85: //vec3 flw_Albedo;
  86: //float flw_Alpha;
  87: //vec2 flw_LightMap;
  88: //vec4 flw_Tint;
  89: 
  90: void main() {
  91:     BlockFrag f;
  92:     f.texCoords = v2f_texCoords;
  93: f.color = v2f_color;
  94: f.diffuse = v2f_diffuse;
  95: f.light = v2f_light;
  96: 
  97: 
  98:     FLWMain(f);
  99: }

[12:29:44] [main/ERROR]: Shader compilation log for create:rotating.vert: No errors.

[12:29:44] [main/ERROR]: Source for shader 'create:rotating.vert':
   1: #version 110
   2: 
   3: #define PI 3.1415926538
   4: 
   5: uniform float uTime;
   6: uniform mat4 uViewProjection;
   7: uniform vec3 uCameraPos;
   8: 
   9: #if defined(USE_FOG)
  10: varying float FragDistance;
  11: #endif
  12: 
  13: void FLWFinalizeWorldPos(inout vec4 worldPos) {
  14:     #if defined(USE_FOG)
  15:     FragDistance = length(worldPos.xyz - uCameraPos);
  16:     #endif
  17: 
  18:     gl_Position = uViewProjection * worldPos;
  19: }
  20: 
  21: void FLWFinalizeNormal(inout vec3 normal) {
  22:     // noop
  23: }
  24: 
  25: 
  26: mat4 rotate(vec3 axis, float angle) {
  27:     float s = sin(angle);
  28:     float c = cos(angle);
  29:     float oc = 1. - c;
  30: 
  31:     vec3 sa = axis * s;
  32: 
  33:     mat4 mr = mat4(1.);
  34:     mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
  35:     mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
  36:     mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);
  37: 
  38:     return mr;
  39: }
  40: 
  41: mat4 rotation(vec3 rot) {
  42:     return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
  43: }
  44: 
  45: mat3 modelToNormal(mat4 mat) {
  46:     // Discard the edges. This won't be accurate for scaled or skewed matrices,
  47:     // but we don't have to work with those often.
  48:     mat3 m;
  49:     m[0] = mat[0].xyz;
  50:     m[1] = mat[1].xyz;
  51:     m[2] = mat[2].xyz;
  52:     return m;
  53: }
  54: 
  55: float diffuse(vec3 normal) {
  56:     vec3 n2 = normal * normal * vec3(.6, .25, .8);
  57:     return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
  58: }
  59: 
  60: 
  61: struct Rotating {
  62:     vec2 light;
  63:     vec4 color;
  64:     vec3 pos;
  65:     float speed;
  66:     float offset;
  67:     vec3 axis;
  68: };
  69: 
  70: 
  71: struct Vertex {
  72:     vec3 pos;
  73:     vec3 normal;
  74:     vec2 texCoords;
  75: };
  76: 
  77: struct BlockFrag {
  78:     vec2 texCoords;
  79:     vec4 color;
  80:     float diffuse;
  81:     vec2 light;
  82: };
  83: 
  84: mat4 kineticRotation(float offset, float speed, vec3 axis) {
  85:     float degrees = offset + uTime * speed * 3./10.;
  86:     float angle = fract(degrees / 360.) * PI * 2.;
  87: 
  88:     return rotate(axis, angle);
  89: }
  90: 
  91: BlockFrag FLWMain(Vertex v, Rotating instance) {
  92:     mat4 spin = kineticRotation(instance.offset, instance.speed, instance.axis);
  93: 
  94:     vec4 worldPos = spin * vec4(v.pos - .5, 1.);
  95:     worldPos += vec4(instance.pos + .5, 0.);
  96: 
  97:     vec3 norm = modelToNormal(spin) * v.normal;
  98: 
  99:     FLWFinalizeWorldPos(worldPos);
 100:     FLWFinalizeNormal(norm);
 101: 
 102:     BlockFrag b;
 103:     b.diffuse = diffuse(norm);
 104:     b.texCoords = v.texCoords;
 105:     b.light = instance.light;
 106: 
 107:     #if defined(DEBUG_RAINBOW)
 108:     b.color = instance.color;
 109:     #elif defined(DEBUG_NORMAL)
 110:     b.color = vec4(norm, 1.);
 111:     #else
 112:     b.color = vec4(1.);
 113:     #endif
 114: 
 115:     return b;
 116: }
 117: attribute vec3 a_v_pos;
 118: attribute vec3 a_v_normal;
 119: attribute vec2 a_v_texCoords;
 120: 
 121: attribute vec2 a_i_light;
 122: attribute vec4 a_i_color;
 123: attribute vec3 a_i_pos;
 124: attribute float a_i_speed;
 125: attribute float a_i_offset;
 126: attribute vec3 a_i_axis;
 127: 
 128: 
 129: varying vec2 v2f_texCoords;
 130: varying vec4 v2f_color;
 131: varying float v2f_diffuse;
 132: varying vec2 v2f_light;
 133: 
 134: 
 135: void main() {
 136:     Vertex v;
 137:     v.pos = a_v_pos;
 138: v.normal = a_v_normal;
 139: v.texCoords = a_v_texCoords;
 140: 
 141: 
 142:     Rotating i;
 143:     i.light = a_i_light;
 144: i.color = a_i_color;
 145: i.pos = a_i_pos;
 146: i.speed = a_i_speed;
 147: i.offset = a_i_offset;
 148: i.axis = a_i_axis;
 149: 
 150: 
 151:     BlockFrag o = FLWMain(v, i);
 152: 
 153:     v2f_texCoords = o.texCoords;
 154: v2f_color = o.color;
 155: v2f_diffuse = o.diffuse;
 156: v2f_light = o.light;
 157: 
 158: }

[12:29:44] [main/ERROR]: Shader compilation log for flywheel:block.frag: No errors.

[12:29:44] [main/ERROR]: Source for shader 'flywheel:block.frag':
   1: #version 110
   2: 
   3: #if defined(USE_FOG)
   4: varying float FragDistance;
   5: uniform vec4 uFogColor;
   6: #endif
   7: 
   8: #if defined(USE_FOG_LINEAR)
   9: uniform vec2 uFogRange;
  10: 
  11: float FLWFogFactor() {
  12:     return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
  13: }
  14:     #endif
  15: 
  16:     #if defined(USE_FOG_EXP2)
  17: uniform float uFogDensity;
  18: 
  19: float FLWFogFactor() {
  20:     float dist = FragDistance * uFogDensity;
  21:     return 1. / exp2(dist * dist);
  22: }
  23:     #endif
  24: // Adjust the [0,1] normalized lightmap value based on the texture matrix from LightTexture#enableLightmap
  25: vec2 shiftLight(vec2 lm) {
  26:     return lm * 0.99609375 + 0.03125;// * 255/256 + 1/32
  27: }
  28: 
  29: uniform sampler2D uBlockAtlas;
  30: uniform sampler2D uLightMap;
  31: 
  32: vec4 FLWBlockTexture(vec2 texCoords) {
  33:     return texture2D(uBlockAtlas, texCoords);
  34: }
  35: 
  36: void FLWFinalizeColor(vec4 color) {
  37:     #if defined(USE_FOG)
  38:     float a = color.a;
  39:     float fog = clamp(FLWFogFactor(), 0., 1.);
  40: 
  41:     color = mix(uFogColor, color, fog);
  42:     color.a = a;
  43:     #endif
  44: 
  45:     gl_FragColor = color;
  46: }
  47: 
  48: vec4 FLWLight(vec2 lightCoords) {
  49:     return texture2D(uLightMap, shiftLight(lightCoords));
  50: }
  51: 
  52: 
  53: 
  54: struct BlockFrag {
  55:     vec2 texCoords;
  56:     vec4 color;
  57:     float diffuse;
  58:     vec2 light;
  59: };
  60: 
  61: void FLWMain(BlockFrag r) {
  62:     vec4 tex = FLWBlockTexture(r.texCoords);
  63: 
  64:     vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;
  65: 
  66: //    flw_WorldPos = ;
  67: //    flw_Normal = ;
  68: //    flw_Albedo = tex.rgb;
  69: //    flw_Alpha = tex.a;
  70: //    flw_LightMap = r.light;
  71: //    flw_Tint = r.color;
  72:     FLWFinalizeColor(color);
  73: }
  74: 
  75: varying vec2 v2f_texCoords;
  76: varying vec4 v2f_color;
  77: varying float v2f_diffuse;
  78: varying vec2 v2f_light;
  79: 
  80: 
  81: //vec3 flw_WorldPos;
  82: //vec3 flw_Normal;
  83: //vec3 flw_Albedo;
  84: //float flw_Alpha;
  85: //vec2 flw_LightMap;
  86: //vec4 flw_Tint;
  87: 
  88: void main() {
  89:     BlockFrag f;
  90:     f.texCoords = v2f_texCoords;
  91: f.color = v2f_color;
  92: f.diffuse = v2f_diffuse;
  93: f.light = v2f_light;
  94: 
  95: 
  96:     FLWMain(f);
  97: }

[12:29:44] [main/ERROR]: Shader compilation log for create:contraption_actor.vert: No errors.

[12:29:44] [main/ERROR]: Source for shader 'create:contraption_actor.vert':
   1: #version 110
   2: #define DEBUG_NORMAL
   3: 
   4: #define PI 3.1415926538
   5: 
   6: uniform float uTime;
   7: uniform mat4 uViewProjection;
   8: uniform vec3 uCameraPos;
   9: 
  10: #if defined(USE_FOG)
  11: varying float FragDistance;
  12: #endif
  13: 
  14: void FLWFinalizeWorldPos(inout vec4 worldPos) {
  15:     #if defined(USE_FOG)
  16:     FragDistance = length(worldPos.xyz - uCameraPos);
  17:     #endif
  18: 
  19:     gl_Position = uViewProjection * worldPos;
  20: }
  21: 
  22: void FLWFinalizeNormal(inout vec3 normal) {
  23:     // noop
  24: }
  25: 
  26: 
  27: mat4 rotate(vec3 axis, float angle) {
  28:     float s = sin(angle);
  29:     float c = cos(angle);
  30:     float oc = 1. - c;
  31: 
  32:     vec3 sa = axis * s;
  33: 
  34:     mat4 mr = mat4(1.);
  35:     mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
  36:     mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
  37:     mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);
  38: 
  39:     return mr;
  40: }
  41: 
  42: mat4 rotation(vec3 rot) {
  43:     return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
  44: }
  45: 
  46: mat3 modelToNormal(mat4 mat) {
  47:     // Discard the edges. This won't be accurate for scaled or skewed matrices,
  48:     // but we don't have to work with those often.
  49:     mat3 m;
  50:     m[0] = mat[0].xyz;
  51:     m[1] = mat[1].xyz;
  52:     m[2] = mat[2].xyz;
  53:     return m;
  54: }
  55: 
  56: #define PIOVER2 1.5707963268
  57: 
  58: vec4 quat(vec3 axis, float angle) {
  59:     float halfAngle = angle * PIOVER2 / 180.0;
  60:     vec2 cs = sin(vec2(PIOVER2 - halfAngle, halfAngle)); // compute sin and cos in one instruction
  61:     return vec4(axis.xyz * cs.y,  cs.x);
  62: }
  63: 
  64: vec4 quatMult(vec4 q1, vec4 q2) {
  65:     // disgustingly vectorized quaternion multiplication
  66:     vec4 a = q1.w * q2.xyzw;
  67:     vec4 b = q1.x * q2.wzxy * vec4(1., -1., 1., -1.);
  68:     vec4 c = q1.y * q2.zwxy * vec4(1., 1., -1., -1.);
  69:     vec4 d = q1.z * q2.yxwz * vec4(-1., 1., 1., -1.);
  70: 
  71:     return a + b + c + d;
  72: }
  73: 
  74: vec3 rotateVertexByQuat(vec3 v, vec4 q) {
  75:     vec3 i = q.xyz;
  76:     return v + 2.0 * cross(i, cross(i, v) + q.w * v);
  77: }
  78: 
  79: vec3 rotateAbout(vec3 v, vec3 axis, float angle) {
  80:     return rotateVertexByQuat(v, quat(axis, angle));
  81: }
  82: 
  83: float diffuse(vec3 normal) {
  84:     vec3 n2 = normal * normal * vec3(.6, .25, .8);
  85:     return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
  86: }
  87: 
  88: 
  89: struct Actor {
  90:     vec3 pos;
  91:     vec2 light;
  92:     float offset;
  93:     vec3 axis;
  94:     vec4 rotation;
  95:     vec3 rotationCenter;
  96:     float speed;
  97: };
  98: 
  99: 
 100: struct Vertex {
 101:     vec3 pos;
 102:     vec3 normal;
 103:     vec2 texCoords;
 104: };
 105: 
 106: struct BlockFrag {
 107:     vec2 texCoords;
 108:     vec4 color;
 109:     float diffuse;
 110:     vec2 light;
 111: };
 112: 
 113: BlockFrag FLWMain(Vertex v, Actor instance) {
 114:     float degrees = instance.offset + uTime * instance.speed / 20.;
 115:     //float angle = fract(degrees / 360.) * PI * 2.;
 116: 
 117:     vec4 kineticRot = quat(instance.axis, degrees);
 118:     vec3 rotated = rotateVertexByQuat(v.pos - instance.rotationCenter, kineticRot) + instance.rotationCenter;
 119: 
 120:     vec4 worldPos = vec4(rotateVertexByQuat(rotated - .5, instance.rotation) + instance.pos + .5, 1.);
 121:     vec3 norm = rotateVertexByQuat(rotateVertexByQuat(v.normal, kineticRot), instance.rotation);
 122: 
 123:     FLWFinalizeWorldPos(worldPos);
 124:     FLWFinalizeNormal(norm);
 125: 
 126:     BlockFrag b;
 127:     b.diffuse = diffuse(norm);
 128:     b.texCoords = v.texCoords;
 129:     b.light = instance.light;
 130: 
 131:     #if defined(DEBUG_NORMAL)
 132:     b.color = vec4(norm, 1.);
 133:     #else
 134:     b.color = vec4(1.);
 135:     #endif
 136: 
 137:     return b;
 138: }
 139: attribute vec3 a_v_pos;
 140: attribute vec3 a_v_normal;
 141: attribute vec2 a_v_texCoords;
 142: 
 143: attribute vec3 a_i_pos;
 144: attribute vec2 a_i_light;
 145: attribute float a_i_offset;
 146: attribute vec3 a_i_axis;
 147: attribute vec4 a_i_rotation;
 148: attribute vec3 a_i_rotationCenter;
 149: attribute float a_i_speed;
 150: 
 151: 
 152: varying vec2 v2f_texCoords;
 153: varying vec4 v2f_color;
 154: varying float v2f_diffuse;
 155: varying vec2 v2f_light;
 156: 
 157: 
 158: void main() {
 159:     Vertex v;
 160:     v.pos = a_v_pos;
 161: v.normal = a_v_normal;
 162: v.texCoords = a_v_texCoords;
 163: 
 164: 
 165:     Actor i;
 166:     i.pos = a_i_pos;
 167: i.light = a_i_light;
 168: i.offset = a_i_offset;
 169: i.axis = a_i_axis;
 170: i.rotation = a_i_rotation;
 171: i.rotationCenter = a_i_rotationCenter;
 172: i.speed = a_i_speed;
 173: 
 174: 
 175:     BlockFrag o = FLWMain(v, i);
 176: 
 177:     v2f_texCoords = o.texCoords;
 178: v2f_color = o.color;
 179: v2f_diffuse = o.diffuse;
 180: v2f_light = o.light;
 181: 
 182: }

[12:29:44] [main/ERROR]: Shader compilation log for flywheel:block.frag: No errors.

[12:29:44] [main/ERROR]: Source for shader 'flywheel:block.frag':
   1: #version 110
   2: #define DEBUG_NORMAL
   3: 
   4: #if defined(USE_FOG)
   5: varying float FragDistance;
   6: uniform vec4 uFogColor;
   7: #endif
   8: 
   9: #if defined(USE_FOG_LINEAR)
  10: uniform vec2 uFogRange;
  11: 
  12: float FLWFogFactor() {
  13:     return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
  14: }
  15:     #endif
  16: 
  17:     #if defined(USE_FOG_EXP2)
  18: uniform float uFogDensity;
  19: 
  20: float FLWFogFactor() {
  21:     float dist = FragDistance * uFogDensity;
  22:     return 1. / exp2(dist * dist);
  23: }
  24:     #endif
  25: // Adjust the [0,1] normalized lightmap value based on the texture matrix from LightTexture#enableLightmap
  26: vec2 shiftLight(vec2 lm) {
  27:     return lm * 0.99609375 + 0.03125;// * 255/256 + 1/32
  28: }
  29: 
  30: uniform sampler2D uBlockAtlas;
  31: uniform sampler2D uLightMap;
  32: 
  33: vec4 FLWBlockTexture(vec2 texCoords) {
  34:     return texture2D(uBlockAtlas, texCoords);
  35: }
  36: 
  37: void FLWFinalizeColor(vec4 color) {
  38:     #if defined(USE_FOG)
  39:     float a = color.a;
  40:     float fog = clamp(FLWFogFactor(), 0., 1.);
  41: 
  42:     color = mix(uFogColor, color, fog);
  43:     color.a = a;
  44:     #endif
  45: 
  46:     gl_FragColor = color;
  47: }
  48: 
  49: vec4 FLWLight(vec2 lightCoords) {
  50:     return texture2D(uLightMap, shiftLight(lightCoords));
  51: }
  52: 
  53: 
  54: 
  55: struct BlockFrag {
  56:     vec2 texCoords;
  57:     vec4 color;
  58:     float diffuse;
  59:     vec2 light;
  60: };
  61: 
  62: void FLWMain(BlockFrag r) {
  63:     vec4 tex = FLWBlockTexture(r.texCoords);
  64: 
  65:     vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;
  66: 
  67: //    flw_WorldPos = ;
  68: //    flw_Normal = ;
  69: //    flw_Albedo = tex.rgb;
  70: //    flw_Alpha = tex.a;
  71: //    flw_LightMap = r.light;
  72: //    flw_Tint = r.color;
  73:     FLWFinalizeColor(color);
  74: }
  75: 
  76: varying vec2 v2f_texCoords;
  77: varying vec4 v2f_color;
  78: varying float v2f_diffuse;
  79: varying vec2 v2f_light;
  80: 
  81: 
  82: //vec3 flw_WorldPos;
  83: //vec3 flw_Normal;
  84: //vec3 flw_Albedo;
  85: //float flw_Alpha;
  86: //vec2 flw_LightMap;
  87: //vec4 flw_Tint;
  88: 
  89: void main() {
  90:     BlockFrag f;
  91:     f.texCoords = v2f_texCoords;
  92: f.color = v2f_color;
  93: f.diffuse = v2f_diffuse;
  94: f.light = v2f_light;
  95: 
  96: 
  97:     FLWMain(f);
  98: }

[12:29:44] [main/ERROR]: Shader compilation log for create:contraption_actor.vert: No errors.

[12:29:44] [main/ERROR]: Source for shader 'create:contraption_actor.vert':
   1: #version 110
   2: #define USE_FOG
   3: #define USE_FOG_LINEAR
   4: 
   5: #define PI 3.1415926538
   6: 
   7: uniform float uTime;
   8: uniform mat4 uViewProjection;
   9: uniform vec3 uCameraPos;
  10: 
  11: #if defined(USE_FOG)
  12: varying float FragDistance;
  13: #endif
  14: 
  15: void FLWFinalizeWorldPos(inout vec4 worldPos) {
  16:     #if defined(USE_FOG)
  17:     FragDistance = length(worldPos.xyz - uCameraPos);
  18:     #endif
  19: 
  20:     gl_Position = uViewProjection * worldPos;
  21: }
  22: 
  23: void FLWFinalizeNormal(inout vec3 normal) {
  24:     // noop
  25: }
  26: 
  27: 
  28: mat4 rotate(vec3 axis, float angle) {
  29:     float s = sin(angle);
  30:     float c = cos(angle);
  31:     float oc = 1. - c;
  32: 
  33:     vec3 sa = axis * s;
  34: 
  35:     mat4 mr = mat4(1.);
  36:     mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
  37:     mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
  38:     mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);
  39: 
  40:     return mr;
  41: }
  42: 
  43: mat4 rotation(vec3 rot) {
  44:     return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
  45: }
  46: 
  47: mat3 modelToNormal(mat4 mat) {
  48:     // Discard the edges. This won't be accurate for scaled or skewed matrices,
  49:     // but we don't have to work with those often.
  50:     mat3 m;
  51:     m[0] = mat[0].xyz;
  52:     m[1] = mat[1].xyz;
  53:     m[2] = mat[2].xyz;
  54:     return m;
  55: }
  56: 
  57: #define PIOVER2 1.5707963268
  58: 
  59: vec4 quat(vec3 axis, float angle) {
  60:     float halfAngle = angle * PIOVER2 / 180.0;
  61:     vec2 cs = sin(vec2(PIOVER2 - halfAngle, halfAngle)); // compute sin and cos in one instruction
  62:     return vec4(axis.xyz * cs.y,  cs.x);
  63: }
  64: 
  65: vec4 quatMult(vec4 q1, vec4 q2) {
  66:     // disgustingly vectorized quaternion multiplication
  67:     vec4 a = q1.w * q2.xyzw;
  68:     vec4 b = q1.x * q2.wzxy * vec4(1., -1., 1., -1.);
  69:     vec4 c = q1.y * q2.zwxy * vec4(1., 1., -1., -1.);
  70:     vec4 d = q1.z * q2.yxwz * vec4(-1., 1., 1., -1.);
  71: 
  72:     return a + b + c + d;
  73: }
  74: 
  75: vec3 rotateVertexByQuat(vec3 v, vec4 q) {
  76:     vec3 i = q.xyz;
  77:     return v + 2.0 * cross(i, cross(i, v) + q.w * v);
  78: }
  79: 
  80: vec3 rotateAbout(vec3 v, vec3 axis, float angle) {
  81:     return rotateVertexByQuat(v, quat(axis, angle));
  82: }
  83: 
  84: float diffuse(vec3 normal) {
  85:     vec3 n2 = normal * normal * vec3(.6, .25, .8);
  86:     return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
  87: }
  88: 
  89: 
  90: struct Actor {
  91:     vec3 pos;
  92:     vec2 light;
  93:     float offset;
  94:     vec3 axis;
  95:     vec4 rotation;
  96:     vec3 rotationCenter;
  97:     float speed;
  98: };
  99: 
 100: 
 101: struct Vertex {
 102:     vec3 pos;
 103:     vec3 normal;
 104:     vec2 texCoords;
 105: };
 106: 
 107: struct BlockFrag {
 108:     vec2 texCoords;
 109:     vec4 color;
 110:     float diffuse;
 111:     vec2 light;
 112: };
 113: 
 114: BlockFrag FLWMain(Vertex v, Actor instance) {
 115:     float degrees = instance.offset + uTime * instance.speed / 20.;
 116:     //float angle = fract(degrees / 360.) * PI * 2.;
 117: 
 118:     vec4 kineticRot = quat(instance.axis, degrees);
 119:     vec3 rotated = rotateVertexByQuat(v.pos - instance.rotationCenter, kineticRot) + instance.rotationCenter;
 120: 
 121:     vec4 worldPos = vec4(rotateVertexByQuat(rotated - .5, instance.rotation) + instance.pos + .5, 1.);
 122:     vec3 norm = rotateVertexByQuat(rotateVertexByQuat(v.normal, kineticRot), instance.rotation);
 123: 
 124:     FLWFinalizeWorldPos(worldPos);
 125:     FLWFinalizeNormal(norm);
 126: 
 127:     BlockFrag b;
 128:     b.diffuse = diffuse(norm);
 129:     b.texCoords = v.texCoords;
 130:     b.light = instance.light;
 131: 
 132:     #if defined(DEBUG_NORMAL)
 133:     b.color = vec4(norm, 1.);
 134:     #else
 135:     b.color = vec4(1.);
 136:     #endif
 137: 
 138:     return b;
 139: }
 140: attribute vec3 a_v_pos;
 141: attribute vec3 a_v_normal;
 142: attribute vec2 a_v_texCoords;
 143: 
 144: attribute vec3 a_i_pos;
 145: attribute vec2 a_i_light;
 146: attribute float a_i_offset;
 147: attribute vec3 a_i_axis;
 148: attribute vec4 a_i_rotation;
 149: attribute vec3 a_i_rotationCenter;
 150: attribute float a_i_speed;
 151: 
 152: 
 153: varying vec2 v2f_texCoords;
 154: varying vec4 v2f_color;
 155: varying float v2f_diffuse;
 156: varying vec2 v2f_light;
 157: 
 158: 
 159: void main() {
 160:     Vertex v;
 161:     v.pos = a_v_pos;
 162: v.normal = a_v_normal;
 163: v.texCoords = a_v_texCoords;
 164: 
 165: 
 166:     Actor i;
 167:     i.pos = a_i_pos;
 168: i.light = a_i_light;
 169: i.offset = a_i_offset;
 170: i.axis = a_i_axis;
 171: i.rotation = a_i_rotation;
 172: i.rotationCenter = a_i_rotationCenter;
 173: i.speed = a_i_speed;
 174: 
 175: 
 176:     BlockFrag o = FLWMain(v, i);
 177: 
 178:     v2f_texCoords = o.texCoords;
 179: v2f_color = o.color;
 180: v2f_diffuse = o.diffuse;
 181: v2f_light = o.light;
 182: 
 183: }

[12:29:44] [main/ERROR]: Shader compilation log for flywheel:block.frag: No errors.

[12:29:44] [main/ERROR]: Source for shader 'flywheel:block.frag':
   1: #version 110
   2: #define USE_FOG
   3: #define USE_FOG_LINEAR
   4: 
   5: #if defined(USE_FOG)
   6: varying float FragDistance;
   7: uniform vec4 uFogColor;
   8: #endif
   9: 
  10: #if defined(USE_FOG_LINEAR)
  11: uniform vec2 uFogRange;
  12: 
  13: float FLWFogFactor() {
  14:     return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
  15: }
  16:     #endif
  17: 
  18:     #if defined(USE_FOG_EXP2)
  19: uniform float uFogDensity;
  20: 
  21: float FLWFogFactor() {
  22:     float dist = FragDistance * uFogDensity;
  23:     return 1. / exp2(dist * dist);
  24: }
  25:     #endif
  26: // Adjust the [0,1] normalized lightmap value based on the texture matrix from LightTexture#enableLightmap
  27: vec2 shiftLight(vec2 lm) {
  28:     return lm * 0.99609375 + 0.03125;// * 255/256 + 1/32
  29: }
  30: 
  31: uniform sampler2D uBlockAtlas;
  32: uniform sampler2D uLightMap;
  33: 
  34: vec4 FLWBlockTexture(vec2 texCoords) {
  35:     return texture2D(uBlockAtlas, texCoords);
  36: }
  37: 
  38: void FLWFinalizeColor(vec4 color) {
  39:     #if defined(USE_FOG)
  40:     float a = color.a;
  41:     float fog = clamp(FLWFogFactor(), 0., 1.);
  42: 
  43:     color = mix(uFogColor, color, fog);
  44:     color.a = a;
  45:     #endif
  46: 
  47:     gl_FragColor = color;
  48: }
  49: 
  50: vec4 FLWLight(vec2 lightCoords) {
  51:     return texture2D(uLightMap, shiftLight(lightCoords));
  52: }
  53: 
  54: 
  55: 
  56: struct BlockFrag {
  57:     vec2 texCoords;
  58:     vec4 color;
  59:     float diffuse;
  60:     vec2 light;
  61: };
  62: 
  63: void FLWMain(BlockFrag r) {
  64:     vec4 tex = FLWBlockTexture(r.texCoords);
  65: 
  66:     vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;
  67: 
  68: //    flw_WorldPos = ;
  69: //    flw_Normal = ;
  70: //    flw_Albedo = tex.rgb;
  71: //    flw_Alpha = tex.a;
  72: //    flw_LightMap = r.light;
  73: //    flw_Tint = r.color;
  74:     FLWFinalizeColor(color);
  75: }
  76: 
  77: varying vec2 v2f_texCoords;
  78: varying vec4 v2f_color;
  79: varying float v2f_diffuse;
  80: varying vec2 v2f_light;
  81: 
  82: 
  83: //vec3 flw_WorldPos;
  84: //vec3 flw_Normal;
  85: //vec3 flw_Albedo;
  86: //float flw_Alpha;
  87: //vec2 flw_LightMap;
  88: //vec4 flw_Tint;
  89: 
  90: void main() {
  91:     BlockFrag f;
  92:     f.texCoords = v2f_texCoords;
  93: f.color = v2f_color;
  94: f.diffuse = v2f_diffuse;
  95: f.light = v2f_light;
  96: 
  97: 
  98:     FLWMain(f);
  99: }

[12:29:44] [main/ERROR]: Shader compilation log for create:contraption_actor.vert: No errors.

[12:29:44] [main/ERROR]: Source for shader 'create:contraption_actor.vert':
   1: #version 110
   2: #define USE_FOG
   3: #define USE_FOG_EXP2
   4: 
   5: #define PI 3.1415926538
   6: 
   7: uniform float uTime;
   8: uniform mat4 uViewProjection;
   9: uniform vec3 uCameraPos;
  10: 
  11: #if defined(USE_FOG)
  12: varying float FragDistance;
  13: #endif
  14: 
  15: void FLWFinalizeWorldPos(inout vec4 worldPos) {
  16:     #if defined(USE_FOG)
  17:     FragDistance = length(worldPos.xyz - uCameraPos);
  18:     #endif
  19: 
  20:     gl_Position = uViewProjection * worldPos;
  21: }
  22: 
  23: void FLWFinalizeNormal(inout vec3 normal) {
  24:     // noop
  25: }
  26: 
  27: 
  28: mat4 rotate(vec3 axis, float angle) {
  29:     float s = sin(angle);
  30:     float c = cos(angle);
  31:     float oc = 1. - c;
  32: 
  33:     vec3 sa = axis * s;
  34: 
  35:     mat4 mr = mat4(1.);
  36:     mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
  37:     mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
  38:     mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);
  39: 
  40:     return mr;
  41: }
  42: 
  43: mat4 rotation(vec3 rot) {
  44:     return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
  45: }
  46: 
  47: mat3 modelToNormal(mat4 mat) {
  48:     // Discard the edges. This won't be accurate for scaled or skewed matrices,
  49:     // but we don't have to work with those often.
  50:     mat3 m;
  51:     m[0] = mat[0].xyz;
  52:     m[1] = mat[1].xyz;
  53:     m[2] = mat[2].xyz;
  54:     return m;
  55: }
  56: 
  57: #define PIOVER2 1.5707963268
  58: 
  59: vec4 quat(vec3 axis, float angle) {
  60:     float halfAngle = angle * PIOVER2 / 180.0;
  61:     vec2 cs = sin(vec2(PIOVER2 - halfAngle, halfAngle)); // compute sin and cos in one instruction
  62:     return vec4(axis.xyz * cs.y,  cs.x);
  63: }
  64: 
  65: vec4 quatMult(vec4 q1, vec4 q2) {
  66:     // disgustingly vectorized quaternion multiplication
  67:     vec4 a = q1.w * q2.xyzw;
  68:     vec4 b = q1.x * q2.wzxy * vec4(1., -1., 1., -1.);
  69:     vec4 c = q1.y * q2.zwxy * vec4(1., 1., -1., -1.);
  70:     vec4 d = q1.z * q2.yxwz * vec4(-1., 1., 1., -1.);
  71: 
  72:     return a + b + c + d;
  73: }
  74: 
  75: vec3 rotateVertexByQuat(vec3 v, vec4 q) {
  76:     vec3 i = q.xyz;
  77:     return v + 2.0 * cross(i, cross(i, v) + q.w * v);
  78: }
  79: 
  80: vec3 rotateAbout(vec3 v, vec3 axis, float angle) {
  81:     return rotateVertexByQuat(v, quat(axis, angle));
  82: }
  83: 
  84: float diffuse(vec3 normal) {
  85:     vec3 n2 = normal * normal * vec3(.6, .25, .8);
  86:     return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
  87: }
  88: 
  89: 
  90: struct Actor {
  91:     vec3 pos;
  92:     vec2 light;
  93:     float offset;
  94:     vec3 axis;
  95:     vec4 rotation;
  96:     vec3 rotationCenter;
  97:     float speed;
  98: };
  99: 
 100: 
 101: struct Vertex {
 102:     vec3 pos;
 103:     vec3 normal;
 104:     vec2 texCoords;
 105: };
 106: 
 107: struct BlockFrag {
 108:     vec2 texCoords;
 109:     vec4 color;
 110:     float diffuse;
 111:     vec2 light;
 112: };
 113: 
 114: BlockFrag FLWMain(Vertex v, Actor instance) {
 115:     float degrees = instance.offset + uTime * instance.speed / 20.;
 116:     //float angle = fract(degrees / 360.) * PI * 2.;
 117: 
 118:     vec4 kineticRot = quat(instance.axis, degrees);
 119:     vec3 rotated = rotateVertexByQuat(v.pos - instance.rotationCenter, kineticRot) + instance.rotationCenter;
 120: 
 121:     vec4 worldPos = vec4(rotateVertexByQuat(rotated - .5, instance.rotation) + instance.pos + .5, 1.);
 122:     vec3 norm = rotateVertexByQuat(rotateVertexByQuat(v.normal, kineticRot), instance.rotation);
 123: 
 124:     FLWFinalizeWorldPos(worldPos);
 125:     FLWFinalizeNormal(norm);
 126: 
 127:     BlockFrag b;
 128:     b.diffuse = diffuse(norm);
 129:     b.texCoords = v.texCoords;
 130:     b.light = instance.light;
 131: 
 132:     #if defined(DEBUG_NORMAL)
 133:     b.color = vec4(norm, 1.);
 134:     #else
 135:     b.color = vec4(1.);
 136:     #endif
 137: 
 138:     return b;
 139: }
 140: attribute vec3 a_v_pos;
 141: attribute vec3 a_v_normal;
 142: attribute vec2 a_v_texCoords;
 143: 
 144: attribute vec3 a_i_pos;
 145: attribute vec2 a_i_light;
 146: attribute float a_i_offset;
 147: attribute vec3 a_i_axis;
 148: attribute vec4 a_i_rotation;
 149: attribute vec3 a_i_rotationCenter;
 150: attribute float a_i_speed;
 151: 
 152: 
 153: varying vec2 v2f_texCoords;
 154: varying vec4 v2f_color;
 155: varying float v2f_diffuse;
 156: varying vec2 v2f_light;
 157: 
 158: 
 159: void main() {
 160:     Vertex v;
 161:     v.pos = a_v_pos;
 162: v.normal = a_v_normal;
 163: v.texCoords = a_v_texCoords;
 164: 
 165: 
 166:     Actor i;
 167:     i.pos = a_i_pos;
 168: i.light = a_i_light;
 169: i.offset = a_i_offset;
 170: i.axis = a_i_axis;
 171: i.rotation = a_i_rotation;
 172: i.rotationCenter = a_i_rotationCenter;
 173: i.speed = a_i_speed;
 174: 
 175: 
 176:     BlockFrag o = FLWMain(v, i);
 177: 
 178:     v2f_texCoords = o.texCoords;
 179: v2f_color = o.color;
 180: v2f_diffuse = o.diffuse;
 181: v2f_light = o.light;
 182: 
 183: }

[12:29:45] [main/ERROR]: Shader compilation log for flywheel:block.frag: No errors.

[12:29:45] [main/ERROR]: Source for shader 'flywheel:block.frag':
   1: #version 110
   2: #define USE_FOG
   3: #define USE_FOG_EXP2
   4: 
   5: #if defined(USE_FOG)
   6: varying float FragDistance;
   7: uniform vec4 uFogColor;
   8: #endif
   9: 
  10: #if defined(USE_FOG_LINEAR)
  11: uniform vec2 uFogRange;
  12: 
  13: float FLWFogFactor() {
  14:     return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
  15: }
  16:     #endif
  17: 
  18:     #if defined(USE_FOG_EXP2)
  19: uniform float uFogDensity;
  20: 
  21: float FLWFogFactor() {
  22:     float dist = FragDistance * uFogDensity;
  23:     return 1. / exp2(dist * dist);
  24: }
  25:     #endif
  26: // Adjust the [0,1] normalized lightmap value based on the texture matrix from LightTexture#enableLightmap
  27: vec2 shiftLight(vec2 lm) {
  28:     return lm * 0.99609375 + 0.03125;// * 255/256 + 1/32
  29: }
  30: 
  31: uniform sampler2D uBlockAtlas;
  32: uniform sampler2D uLightMap;
  33: 
  34: vec4 FLWBlockTexture(vec2 texCoords) {
  35:     return texture2D(uBlockAtlas, texCoords);
  36: }
  37: 
  38: void FLWFinalizeColor(vec4 color) {
  39:     #if defined(USE_FOG)
  40:     float a = color.a;
  41:     float fog = clamp(FLWFogFactor(), 0., 1.);
  42: 
  43:     color = mix(uFogColor, color, fog);
  44:     color.a = a;
  45:     #endif
  46: 
  47:     gl_FragColor = color;
  48: }
  49: 
  50: vec4 FLWLight(vec2 lightCoords) {
  51:     return texture2D(uLightMap, shiftLight(lightCoords));
  52: }
  53: 
  54: 
  55: 
  56: struct BlockFrag {
  57:     vec2 texCoords;
  58:     vec4 color;
  59:     float diffuse;
  60:     vec2 light;
  61: };
  62: 
  63: void FLWMain(BlockFrag r) {
  64:     vec4 tex = FLWBlockTexture(r.texCoords);
  65: 
  66:     vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;
  67: 
  68: //    flw_WorldPos = ;
  69: //    flw_Normal = ;
  70: //    flw_Albedo = tex.rgb;
  71: //    flw_Alpha = tex.a;
  72: //    flw_LightMap = r.light;
  73: //    flw_Tint = r.color;
  74:     FLWFinalizeColor(color);
  75: }
  76: 
  77: varying vec2 v2f_texCoords;
  78: varying vec4 v2f_color;
  79: varying float v2f_diffuse;
  80: varying vec2 v2f_light;
  81: 
  82: 
  83: //vec3 flw_WorldPos;
  84: //vec3 flw_Normal;
  85: //vec3 flw_Albedo;
  86: //float flw_Alpha;
  87: //vec2 flw_LightMap;
  88: //vec4 flw_Tint;
  89: 
  90: void main() {
  91:     BlockFrag f;
  92:     f.texCoords = v2f_texCoords;
  93: f.color = v2f_color;
  94: f.diffuse = v2f_diffuse;
  95: f.light = v2f_light;
  96: 
  97: 
  98:     FLWMain(f);
  99: }

[12:29:45] [main/ERROR]: Shader compilation log for create:contraption_actor.vert: No errors.

[12:29:45] [main/ERROR]: Source for shader 'create:contraption_actor.vert':
   1: #version 110
   2: 
   3: #define PI 3.1415926538
   4: 
   5: uniform float uTime;
   6: uniform mat4 uViewProjection;
   7: uniform vec3 uCameraPos;
   8: 
   9: #if defined(USE_FOG)
  10: varying float FragDistance;
  11: #endif
  12: 
  13: void FLWFinalizeWorldPos(inout vec4 worldPos) {
  14:     #if defined(USE_FOG)
  15:     FragDistance = length(worldPos.xyz - uCameraPos);
  16:     #endif
  17: 
  18:     gl_Position = uViewProjection * worldPos;
  19: }
  20: 
  21: void FLWFinalizeNormal(inout vec3 normal) {
  22:     // noop
  23: }
  24: 
  25: 
  26: mat4 rotate(vec3 axis, float angle) {
  27:     float s = sin(angle);
  28:     float c = cos(angle);
  29:     float oc = 1. - c;
  30: 
  31:     vec3 sa = axis * s;
  32: 
  33:     mat4 mr = mat4(1.);
  34:     mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
  35:     mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
  36:     mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);
  37: 
  38:     return mr;
  39: }
  40: 
  41: mat4 rotation(vec3 rot) {
  42:     return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
  43: }
  44: 
  45: mat3 modelToNormal(mat4 mat) {
  46:     // Discard the edges. This won't be accurate for scaled or skewed matrices,
  47:     // but we don't have to work with those often.
  48:     mat3 m;
  49:     m[0] = mat[0].xyz;
  50:     m[1] = mat[1].xyz;
  51:     m[2] = mat[2].xyz;
  52:     return m;
  53: }
  54: 
  55: #define PIOVER2 1.5707963268
  56: 
  57: vec4 quat(vec3 axis, float angle) {
  58:     float halfAngle = angle * PIOVER2 / 180.0;
  59:     vec2 cs = sin(vec2(PIOVER2 - halfAngle, halfAngle)); // compute sin and cos in one instruction
  60:     return vec4(axis.xyz * cs.y,  cs.x);
  61: }
  62: 
  63: vec4 quatMult(vec4 q1, vec4 q2) {
  64:     // disgustingly vectorized quaternion multiplication
  65:     vec4 a = q1.w * q2.xyzw;
  66:     vec4 b = q1.x * q2.wzxy * vec4(1., -1., 1., -1.);
  67:     vec4 c = q1.y * q2.zwxy * vec4(1., 1., -1., -1.);
  68:     vec4 d = q1.z * q2.yxwz * vec4(-1., 1., 1., -1.);
  69: 
  70:     return a + b + c + d;
  71: }
  72: 
  73: vec3 rotateVertexByQuat(vec3 v, vec4 q) {
  74:     vec3 i = q.xyz;
  75:     return v + 2.0 * cross(i, cross(i, v) + q.w * v);
  76: }
  77: 
  78: vec3 rotateAbout(vec3 v, vec3 axis, float angle) {
  79:     return rotateVertexByQuat(v, quat(axis, angle));
  80: }
  81: 
  82: float diffuse(vec3 normal) {
  83:     vec3 n2 = normal * normal * vec3(.6, .25, .8);
  84:     return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
  85: }
  86: 
  87: 
  88: struct Actor {
  89:     vec3 pos;
  90:     vec2 light;
  91:     float offset;
  92:     vec3 axis;
  93:     vec4 rotation;
  94:     vec3 rotationCenter;
  95:     float speed;
  96: };
  97: 
  98: 
  99: struct Vertex {
 100:     vec3 pos;
 101:     vec3 normal;
 102:     vec2 texCoords;
 103: };
 104: 
 105: struct BlockFrag {
 106:     vec2 texCoords;
 107:     vec4 color;
 108:     float diffuse;
 109:     vec2 light;
 110: };
 111: 
 112: BlockFrag FLWMain(Vertex v, Actor instance) {
 113:     float degrees = instance.offset + uTime * instance.speed / 20.;
 114:     //float angle = fract(degrees / 360.) * PI * 2.;
 115: 
 116:     vec4 kineticRot = quat(instance.axis, degrees);
 117:     vec3 rotated = rotateVertexByQuat(v.pos - instance.rotationCenter, kineticRot) + instance.rotationCenter;
 118: 
 119:     vec4 worldPos = vec4(rotateVertexByQuat(rotated - .5, instance.rotation) + instance.pos + .5, 1.);
 120:     vec3 norm = rotateVertexByQuat(rotateVertexByQuat(v.normal, kineticRot), instance.rotation);
 121: 
 122:     FLWFinalizeWorldPos(worldPos);
 123:     FLWFinalizeNormal(norm);
 124: 
 125:     BlockFrag b;
 126:     b.diffuse = diffuse(norm);
 127:     b.texCoords = v.texCoords;
 128:     b.light = instance.light;
 129: 
 130:     #if defined(DEBUG_NORMAL)
 131:     b.color = vec4(norm, 1.);
 132:     #else
 133:     b.color = vec4(1.);
 134:     #endif
 135: 
 136:     return b;
 137: }
 138: attribute vec3 a_v_pos;
 139: attribute vec3 a_v_normal;
 140: attribute vec2 a_v_texCoords;
 141: 
 142: attribute vec3 a_i_pos;
 143: attribute vec2 a_i_light;
 144: attribute float a_i_offset;
 145: attribute vec3 a_i_axis;
 146: attribute vec4 a_i_rotation;
 147: attribute vec3 a_i_rotationCenter;
 148: attribute float a_i_speed;
 149: 
 150: 
 151: varying vec2 v2f_texCoords;
 152: varying vec4 v2f_color;
 153: varying float v2f_diffuse;
 154: varying vec2 v2f_light;
 155: 
 156: 
 157: void main() {
 158:     Vertex v;
 159:     v.pos = a_v_pos;
 160: v.normal = a_v_normal;
 161: v.texCoords = a_v_texCoords;
 162: 
 163: 
 164:     Actor i;
 165:     i.pos = a_i_pos;
 166: i.light = a_i_light;
 167: i.offset = a_i_offset;
 168: i.axis = a_i_axis;
 169: i.rotation = a_i_rotation;
 170: i.rotationCenter = a_i_rotationCenter;
 171: i.speed = a_i_speed;
 172: 
 173: 
 174:     BlockFrag o = FLWMain(v, i);
 175: 
 176:     v2f_texCoords = o.texCoords;
 177: v2f_color = o.color;
 178: v2f_diffuse = o.diffuse;
 179: v2f_light = o.light;
 180: 
 181: }

[12:29:45] [main/ERROR]: Shader compilation log for flywheel:block.frag: No errors.

[12:29:45] [main/ERROR]: Source for shader 'flywheel:block.frag':
   1: #version 110
   2: 
   3: #if defined(USE_FOG)
   4: varying float FragDistance;
   5: uniform vec4 uFogColor;
   6: #endif
   7: 
   8: #if defined(USE_FOG_LINEAR)
   9: uniform vec2 uFogRange;
  10: 
  11: float FLWFogFactor() {
  12:     return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
  13: }
  14:     #endif
  15: 
  16:     #if defined(USE_FOG_EXP2)
  17: uniform float uFogDensity;
  18: 
  19: float FLWFogFactor() {
  20:     float dist = FragDistance * uFogDensity;
  21:     return 1. / exp2(dist * dist);
  22: }
  23:     #endif
  24: // Adjust the [0,1] normalized lightmap value based on the texture matrix from LightTexture#enableLightmap
  25: vec2 shiftLight(vec2 lm) {
  26:     return lm * 0.99609375 + 0.03125;// * 255/256 + 1/32
  27: }
  28: 
  29: uniform sampler2D uBlockAtlas;
  30: uniform sampler2D uLightMap;
  31: 
  32: vec4 FLWBlockTexture(vec2 texCoords) {
  33:     return texture2D(uBlockAtlas, texCoords);
  34: }
  35: 
  36: void FLWFinalizeColor(vec4 color) {
  37:     #if defined(USE_FOG)
  38:     float a = color.a;
  39:     float fog = clamp(FLWFogFactor(), 0., 1.);
  40: 
  41:     color = mix(uFogColor, color, fog);
  42:     color.a = a;
  43:     #endif
  44: 
  45:     gl_FragColor = color;
  46: }
  47: 
  48: vec4 FLWLight(vec2 lightCoords) {
  49:     return texture2D(uLightMap, shiftLight(lightCoords));
  50: }
  51: 
  52: 
  53: 
  54: struct BlockFrag {
  55:     vec2 texCoords;
  56:     vec4 color;
  57:     float diffuse;
  58:     vec2 light;
  59: };
  60: 
  61: void FLWMain(BlockFrag r) {
  62:     vec4 tex = FLWBlockTexture(r.texCoords);
  63: 
  64:     vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;
  65: 
  66: //    flw_WorldPos = ;
  67: //    flw_Normal = ;
  68: //    flw_Albedo = tex.rgb;
  69: //    flw_Alpha = tex.a;
  70: //    flw_LightMap = r.light;
  71: //    flw_Tint = r.color;
  72:     FLWFinalizeColor(color);
  73: }
  74: 
  75: varying vec2 v2f_texCoords;
  76: varying vec4 v2f_color;
  77: varying float v2f_diffuse;
  78: varying vec2 v2f_light;
  79: 
  80: 
  81: //vec3 flw_WorldPos;
  82: //vec3 flw_Normal;
  83: //vec3 flw_Albedo;
  84: //float flw_Alpha;
  85: //vec2 flw_LightMap;
  86: //vec4 flw_Tint;
  87: 
  88: void main() {
  89:     BlockFrag f;
  90:     f.texCoords = v2f_texCoords;
  91: f.color = v2f_color;
  92: f.diffuse = v2f_diffuse;
  93: f.light = v2f_light;
  94: 
  95: 
  96:     FLWMain(f);
  97: }

[12:29:45] [main/ERROR]: Shader compilation log for create:flap.vert: No errors.

[12:29:45] [main/ERROR]: Source for shader 'create:flap.vert':
   1: #version 110
   2: #define DEBUG_NORMAL
   3: 
   4: #define PI 3.1415926538
   5: 
   6: uniform float uTime;
   7: uniform mat4 uViewProjection;
   8: uniform vec3 uCameraPos;
   9: 
  10: #if defined(USE_FOG)
  11: varying float FragDistance;
  12: #endif
  13: 
  14: void FLWFinalizeWorldPos(inout vec4 worldPos) {
  15:     #if defined(USE_FOG)
  16:     FragDistance = length(worldPos.xyz - uCameraPos);
  17:     #endif
  18: 
  19:     gl_Position = uViewProjection * worldPos;
  20: }
  21: 
  22: void FLWFinalizeNormal(inout vec3 normal) {
  23:     // noop
  24: }
  25: 
  26: 
  27: mat4 rotate(vec3 axis, float angle) {
  28:     float s = sin(angle);
  29:     float c = cos(angle);
  30:     float oc = 1. - c;
  31: 
  32:     vec3 sa = axis * s;
  33: 
  34:     mat4 mr = mat4(1.);
  35:     mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
  36:     mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
  37:     mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);
  38: 
  39:     return mr;
  40: }
  41: 
  42: mat4 rotation(vec3 rot) {
  43:     return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
  44: }
  45: 
  46: mat3 modelToNormal(mat4 mat) {
  47:     // Discard the edges. This won't be accurate for scaled or skewed matrices,
  48:     // but we don't have to work with those often.
  49:     mat3 m;
  50:     m[0] = mat[0].xyz;
  51:     m[1] = mat[1].xyz;
  52:     m[2] = mat[2].xyz;
  53:     return m;
  54: }
  55: 
  56: #define PIOVER2 1.5707963268
  57: 
  58: vec4 quat(vec3 axis, float angle) {
  59:     float halfAngle = angle * PIOVER2 / 180.0;
  60:     vec2 cs = sin(vec2(PIOVER2 - halfAngle, halfAngle)); // compute sin and cos in one instruction
  61:     return vec4(axis.xyz * cs.y,  cs.x);
  62: }
  63: 
  64: vec4 quatMult(vec4 q1, vec4 q2) {
  65:     // disgustingly vectorized quaternion multiplication
  66:     vec4 a = q1.w * q2.xyzw;
  67:     vec4 b = q1.x * q2.wzxy * vec4(1., -1., 1., -1.);
  68:     vec4 c = q1.y * q2.zwxy * vec4(1., 1., -1., -1.);
  69:     vec4 d = q1.z * q2.yxwz * vec4(-1., 1., 1., -1.);
  70: 
  71:     return a + b + c + d;
  72: }
  73: 
  74: vec3 rotateVertexByQuat(vec3 v, vec4 q) {
  75:     vec3 i = q.xyz;
  76:     return v + 2.0 * cross(i, cross(i, v) + q.w * v);
  77: }
  78: 
  79: vec3 rotateAbout(vec3 v, vec3 axis, float angle) {
  80:     return rotateVertexByQuat(v, quat(axis, angle));
  81: }
  82: 
  83: float diffuse(vec3 normal) {
  84:     vec3 n2 = normal * normal * vec3(.6, .25, .8);
  85:     return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
  86: }
  87: 
  88: 
  89: struct Flap {
  90:     vec3 instancePos;
  91:     vec2 light;
  92:     vec3 segmentOffset;
  93:     vec3 pivot;
  94:     float horizontalAngle;
  95:     float intensity;
  96:     float flapScale;
  97:     float flapness;
  98: };
  99: 
 100: 
 101: struct Vertex {
 102:     vec3 pos;
 103:     vec3 normal;
 104:     vec2 texCoords;
 105: };
 106: 
 107: struct BlockFrag {
 108:     vec2 texCoords;
 109:     vec4 color;
 110:     float diffuse;
 111:     vec2 light;
 112: };
 113: 
 114: 
 115: float toRad(float degrees) {
 116:     return fract(degrees / 360.) * PI * 2.;
 117: }
 118: 
 119: float getFlapAngle(float flapness, float intensity, float scale) {
 120:     float absFlap = abs(flapness);
 121: 
 122:     float angle = sin((1. - absFlap) * PI * intensity) * 30. * flapness * scale;
 123: 
 124:     float halfAngle = angle * 0.5;
 125: 
 126:     float which = step(0., flapness);// 0 if negative, 1 if positive
 127:     float degrees = which * halfAngle + (1. - which) * angle;// branchless conditional multiply
 128: 
 129:     return degrees;
 130: }
 131: 
 132: BlockFrag FLWMain(Vertex v, Flap flap) {
 133:     float flapAngle = getFlapAngle(flap.flapness, flap.intensity, flap.flapScale);
 134: 
 135:     vec4 orientation = quat(vec3(0., 1., 0.), -flap.horizontalAngle);
 136:     vec4 flapRotation = quat(vec3(1., 0., 0.), flapAngle);
 137: 
 138:     vec3 rotated = rotateVertexByQuat(v.pos - flap.pivot, flapRotation) + flap.pivot + flap.segmentOffset;
 139:     rotated = rotateVertexByQuat(rotated - .5, orientation) + flap.instancePos + .5;
 140: 
 141:     vec4 worldPos = vec4(rotated, 1.);
 142:     vec3 norm = rotateVertexByQuat(rotateVertexByQuat(v.normal, flapRotation), orientation);
 143: 
 144:     FLWFinalizeWorldPos(worldPos);
 145:     FLWFinalizeNormal(norm);
 146: 
 147:     BlockFrag b;
 148:     b.diffuse = diffuse(norm);
 149:     b.texCoords = v.texCoords;
 150:     b.light = flap.light;
 151:     #if defined(DEBUG_NORMAL)
 152:     b.color = vec4(norm, 1.);
 153:     #else
 154:     b.color = vec4(1.);
 155:     #endif
 156:     return b;
 157: }
 158: attribute vec3 a_v_pos;
 159: attribute vec3 a_v_normal;
 160: attribute vec2 a_v_texCoords;
 161: 
 162: attribute vec3 a_i_instancePos;
 163: attribute vec2 a_i_light;
 164: attribute vec3 a_i_segmentOffset;
 165: attribute vec3 a_i_pivot;
 166: attribute float a_i_horizontalAngle;
 167: attribute float a_i_intensity;
 168: attribute float a_i_flapScale;
 169: attribute float a_i_flapness;
 170: 
 171: 
 172: varying vec2 v2f_texCoords;
 173: varying vec4 v2f_color;
 174: varying float v2f_diffuse;
 175: varying vec2 v2f_light;
 176: 
 177: 
 178: void main() {
 179:     Vertex v;
 180:     v.pos = a_v_pos;
 181: v.normal = a_v_normal;
 182: v.texCoords = a_v_texCoords;
 183: 
 184: 
 185:     Flap i;
 186:     i.instancePos = a_i_instancePos;
 187: i.light = a_i_light;
 188: i.segmentOffset = a_i_segmentOffset;
 189: i.pivot = a_i_pivot;
 190: i.horizontalAngle = a_i_horizontalAngle;
 191: i.intensity = a_i_intensity;
 192: i.flapScale = a_i_flapScale;
 193: i.flapness = a_i_flapness;
 194: 
 195: 
 196:     BlockFrag o = FLWMain(v, i);
 197: 
 198:     v2f_texCoords = o.texCoords;
 199: v2f_color = o.color;
 200: v2f_diffuse = o.diffuse;
 201: v2f_light = o.light;
 202: 
 203: }

[12:29:45] [main/ERROR]: Shader compilation log for flywheel:block.frag: No errors.

[12:29:45] [main/ERROR]: Source for shader 'flywheel:block.frag':
   1: #version 110
   2: #define DEBUG_NORMAL
   3: 
   4: #if defined(USE_FOG)
   5: varying float FragDistance;
   6: uniform vec4 uFogColor;
   7: #endif
   8: 
   9: #if defined(USE_FOG_LINEAR)
  10: uniform vec2 uFogRange;
  11: 
  12: float FLWFogFactor() {
  13:     return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
  14: }
  15:     #endif
  16: 
  17:     #if defined(USE_FOG_EXP2)
  18: uniform float uFogDensity;
  19: 
  20: float FLWFogFactor() {
  21:     float dist = FragDistance * uFogDensity;
  22:     return 1. / exp2(dist * dist);
  23: }
  24:     #endif
  25: // Adjust the [0,1] normalized lightmap value based on the texture matrix from LightTexture#enableLightmap
  26: vec2 shiftLight(vec2 lm) {
  27:     return lm * 0.99609375 + 0.03125;// * 255/256 + 1/32
  28: }
  29: 
  30: uniform sampler2D uBlockAtlas;
  31: uniform sampler2D uLightMap;
  32: 
  33: vec4 FLWBlockTexture(vec2 texCoords) {
  34:     return texture2D(uBlockAtlas, texCoords);
  35: }
  36: 
  37: void FLWFinalizeColor(vec4 color) {
  38:     #if defined(USE_FOG)
  39:     float a = color.a;
  40:     float fog = clamp(FLWFogFactor(), 0., 1.);
  41: 
  42:     color = mix(uFogColor, color, fog);
  43:     color.a = a;
  44:     #endif
  45: 
  46:     gl_FragColor = color;
  47: }
  48: 
  49: vec4 FLWLight(vec2 lightCoords) {
  50:     return texture2D(uLightMap, shiftLight(lightCoords));
  51: }
  52: 
  53: 
  54: 
  55: struct BlockFrag {
  56:     vec2 texCoords;
  57:     vec4 color;
  58:     float diffuse;
  59:     vec2 light;
  60: };
  61: 
  62: void FLWMain(BlockFrag r) {
  63:     vec4 tex = FLWBlockTexture(r.texCoords);
  64: 
  65:     vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;
  66: 
  67: //    flw_WorldPos = ;
  68: //    flw_Normal = ;
  69: //    flw_Albedo = tex.rgb;
  70: //    flw_Alpha = tex.a;
  71: //    flw_LightMap = r.light;
  72: //    flw_Tint = r.color;
  73:     FLWFinalizeColor(color);
  74: }
  75: 
  76: varying vec2 v2f_texCoords;
  77: varying vec4 v2f_color;
  78: varying float v2f_diffuse;
  79: varying vec2 v2f_light;
  80: 
  81: 
  82: //vec3 flw_WorldPos;
  83: //vec3 flw_Normal;
  84: //vec3 flw_Albedo;
  85: //float flw_Alpha;
  86: //vec2 flw_LightMap;
  87: //vec4 flw_Tint;
  88: 
  89: void main() {
  90:     BlockFrag f;
  91:     f.texCoords = v2f_texCoords;
  92: f.color = v2f_color;
  93: f.diffuse = v2f_diffuse;
  94: f.light = v2f_light;
  95: 
  96: 
  97:     FLWMain(f);
  98: }

[12:29:45] [main/ERROR]: Shader compilation log for create:flap.vert: No errors.

[12:29:45] [main/ERROR]: Source for shader 'create:flap.vert':
   1: #version 110
   2: #define USE_FOG
   3: #define USE_FOG_LINEAR
   4: 
   5: #define PI 3.1415926538
   6: 
   7: uniform float uTime;
   8: uniform mat4 uViewProjection;
   9: uniform vec3 uCameraPos;
  10: 
  11: #if defined(USE_FOG)
  12: varying float FragDistance;
  13: #endif
  14: 
  15: void FLWFinalizeWorldPos(inout vec4 worldPos) {
  16:     #if defined(USE_FOG)
  17:     FragDistance = length(worldPos.xyz - uCameraPos);
  18:     #endif
  19: 
  20:     gl_Position = uViewProjection * worldPos;
  21: }
  22: 
  23: void FLWFinalizeNormal(inout vec3 normal) {
  24:     // noop
  25: }
  26: 
  27: 
  28: mat4 rotate(vec3 axis, float angle) {
  29:     float s = sin(angle);
  30:     float c = cos(angle);
  31:     float oc = 1. - c;
  32: 
  33:     vec3 sa = axis * s;
  34: 
  35:     mat4 mr = mat4(1.);
  36:     mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
  37:     mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
  38:     mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);
  39: 
  40:     return mr;
  41: }
  42: 
  43: mat4 rotation(vec3 rot) {
  44:     return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
  45: }
  46: 
  47: mat3 modelToNormal(mat4 mat) {
  48:     // Discard the edges. This won't be accurate for scaled or skewed matrices,
  49:     // but we don't have to work with those often.
  50:     mat3 m;
  51:     m[0] = mat[0].xyz;
  52:     m[1] = mat[1].xyz;
  53:     m[2] = mat[2].xyz;
  54:     return m;
  55: }
  56: 
  57: #define PIOVER2 1.5707963268
  58: 
  59: vec4 quat(vec3 axis, float angle) {
  60:     float halfAngle = angle * PIOVER2 / 180.0;
  61:     vec2 cs = sin(vec2(PIOVER2 - halfAngle, halfAngle)); // compute sin and cos in one instruction
  62:     return vec4(axis.xyz * cs.y,  cs.x);
  63: }
  64: 
  65: vec4 quatMult(vec4 q1, vec4 q2) {
  66:     // disgustingly vectorized quaternion multiplication
  67:     vec4 a = q1.w * q2.xyzw;
  68:     vec4 b = q1.x * q2.wzxy * vec4(1., -1., 1., -1.);
  69:     vec4 c = q1.y * q2.zwxy * vec4(1., 1., -1., -1.);
  70:     vec4 d = q1.z * q2.yxwz * vec4(-1., 1., 1., -1.);
  71: 
  72:     return a + b + c + d;
  73: }
  74: 
  75: vec3 rotateVertexByQuat(vec3 v, vec4 q) {
  76:     vec3 i = q.xyz;
  77:     return v + 2.0 * cross(i, cross(i, v) + q.w * v);
  78: }
  79: 
  80: vec3 rotateAbout(vec3 v, vec3 axis, float angle) {
  81:     return rotateVertexByQuat(v, quat(axis, angle));
  82: }
  83: 
  84: float diffuse(vec3 normal) {
  85:     vec3 n2 = normal * normal * vec3(.6, .25, .8);
  86:     return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
  87: }
  88: 
  89: 
  90: struct Flap {
  91:     vec3 instancePos;
  92:     vec2 light;
  93:     vec3 segmentOffset;
  94:     vec3 pivot;
  95:     float horizontalAngle;
  96:     float intensity;
  97:     float flapScale;
  98:     float flapness;
  99: };
 100: 
 101: 
 102: struct Vertex {
 103:     vec3 pos;
 104:     vec3 normal;
 105:     vec2 texCoords;
 106: };
 107: 
 108: struct BlockFrag {
 109:     vec2 texCoords;
 110:     vec4 color;
 111:     float diffuse;
 112:     vec2 light;
 113: };
 114: 
 115: 
 116: float toRad(float degrees) {
 117:     return fract(degrees / 360.) * PI * 2.;
 118: }
 119: 
 120: float getFlapAngle(float flapness, float intensity, float scale) {
 121:     float absFlap = abs(flapness);
 122: 
 123:     float angle = sin((1. - absFlap) * PI * intensity) * 30. * flapness * scale;
 124: 
 125:     float halfAngle = angle * 0.5;
 126: 
 127:     float which = step(0., flapness);// 0 if negative, 1 if positive
 128:     float degrees = which * halfAngle + (1. - which) * angle;// branchless conditional multiply
 129: 
 130:     return degrees;
 131: }
 132: 
 133: BlockFrag FLWMain(Vertex v, Flap flap) {
 134:     float flapAngle = getFlapAngle(flap.flapness, flap.intensity, flap.flapScale);
 135: 
 136:     vec4 orientation = quat(vec3(0., 1., 0.), -flap.horizontalAngle);
 137:     vec4 flapRotation = quat(vec3(1., 0., 0.), flapAngle);
 138: 
 139:     vec3 rotated = rotateVertexByQuat(v.pos - flap.pivot, flapRotation) + flap.pivot + flap.segmentOffset;
 140:     rotated = rotateVertexByQuat(rotated - .5, orientation) + flap.instancePos + .5;
 141: 
 142:     vec4 worldPos = vec4(rotated, 1.);
 143:     vec3 norm = rotateVertexByQuat(rotateVertexByQuat(v.normal, flapRotation), orientation);
 144: 
 145:     FLWFinalizeWorldPos(worldPos);
 146:     FLWFinalizeNormal(norm);
 147: 
 148:     BlockFrag b;
 149:     b.diffuse = diffuse(norm);
 150:     b.texCoords = v.texCoords;
 151:     b.light = flap.light;
 152:     #if defined(DEBUG_NORMAL)
 153:     b.color = vec4(norm, 1.);
 154:     #else
 155:     b.color = vec4(1.);
 156:     #endif
 157:     return b;
 158: }
 159: attribute vec3 a_v_pos;
 160: attribute vec3 a_v_normal;
 161: attribute vec2 a_v_texCoords;
 162: 
 163: attribute vec3 a_i_instancePos;
 164: attribute vec2 a_i_light;
 165: attribute vec3 a_i_segmentOffset;
 166: attribute vec3 a_i_pivot;
 167: attribute float a_i_horizontalAngle;
 168: attribute float a_i_intensity;
 169: attribute float a_i_flapScale;
 170: attribute float a_i_flapness;
 171: 
 172: 
 173: varying vec2 v2f_texCoords;
 174: varying vec4 v2f_color;
 175: varying float v2f_diffuse;
 176: varying vec2 v2f_light;
 177: 
 178: 
 179: void main() {
 180:     Vertex v;
 181:     v.pos = a_v_pos;
 182: v.normal = a_v_normal;
 183: v.texCoords = a_v_texCoords;
 184: 
 185: 
 186:     Flap i;
 187:     i.instancePos = a_i_instancePos;
 188: i.light = a_i_light;
 189: i.segmentOffset = a_i_segmentOffset;
 190: i.pivot = a_i_pivot;
 191: i.horizontalAngle = a_i_horizontalAngle;
 192: i.intensity = a_i_intensity;
 193: i.flapScale = a_i_flapScale;
 194: i.flapness = a_i_flapness;
 195: 
 196: 
 197:     BlockFrag o = FLWMain(v, i);
 198: 
 199:     v2f_texCoords = o.texCoords;
 200: v2f_color = o.color;
 201: v2f_diffuse = o.diffuse;
 202: v2f_light = o.light;
 203: 
 204: }

[12:29:45] [main/ERROR]: Shader compilation log for flywheel:block.frag: No errors.

[12:29:45] [main/ERROR]: Source for shader 'flywheel:block.frag':
   1: #version 110
   2: #define USE_FOG
   3: #define USE_FOG_LINEAR
   4: 
   5: #if defined(USE_FOG)
   6: varying float FragDistance;
   7: uniform vec4 uFogColor;
   8: #endif
   9: 
  10: #if defined(USE_FOG_LINEAR)
  11: uniform vec2 uFogRange;
  12: 
  13: float FLWFogFactor() {
  14:     return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
  15: }
  16:     #endif
  17: 
  18:     #if defined(USE_FOG_EXP2)
  19: uniform float uFogDensity;
  20: 
  21: float FLWFogFactor() {
  22:     float dist = FragDistance * uFogDensity;
  23:     return 1. / exp2(dist * dist);
  24: }
  25:     #endif
  26: // Adjust the [0,1] normalized lightmap value based on the texture matrix from LightTexture#enableLightmap
  27: vec2 shiftLight(vec2 lm) {
  28:     return lm * 0.99609375 + 0.03125;// * 255/256 + 1/32
  29: }
  30: 
  31: uniform sampler2D uBlockAtlas;
  32: uniform sampler2D uLightMap;
  33: 
  34: vec4 FLWBlockTexture(vec2 texCoords) {
  35:     return texture2D(uBlockAtlas, texCoords);
  36: }
  37: 
  38: void FLWFinalizeColor(vec4 color) {
  39:     #if defined(USE_FOG)
  40:     float a = color.a;
  41:     float fog = clamp(FLWFogFactor(), 0., 1.);
  42: 
  43:     color = mix(uFogColor, color, fog);
  44:     color.a = a;
  45:     #endif
  46: 
  47:     gl_FragColor = color;
  48: }
  49: 
  50: vec4 FLWLight(vec2 lightCoords) {
  51:     return texture2D(uLightMap, shiftLight(lightCoords));
  52: }
  53: 
  54: 
  55: 
  56: struct BlockFrag {
  57:     vec2 texCoords;
  58:     vec4 color;
  59:     float diffuse;
  60:     vec2 light;
  61: };
  62: 
  63: void FLWMain(BlockFrag r) {
  64:     vec4 tex = FLWBlockTexture(r.texCoords);
  65: 
  66:     vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;
  67: 
  68: //    flw_WorldPos = ;
  69: //    flw_Normal = ;
  70: //    flw_Albedo = tex.rgb;
  71: //    flw_Alpha = tex.a;
  72: //    flw_LightMap = r.light;
  73: //    flw_Tint = r.color;
  74:     FLWFinalizeColor(color);
  75: }
  76: 
  77: varying vec2 v2f_texCoords;
  78: varying vec4 v2f_color;
  79: varying float v2f_diffuse;
  80: varying vec2 v2f_light;
  81: 
  82: 
  83: //vec3 flw_WorldPos;
  84: //vec3 flw_Normal;
  85: //vec3 flw_Albedo;
  86: //float flw_Alpha;
  87: //vec2 flw_LightMap;
  88: //vec4 flw_Tint;
  89: 
  90: void main() {
  91:     BlockFrag f;
  92:     f.texCoords = v2f_texCoords;
  93: f.color = v2f_color;
  94: f.diffuse = v2f_diffuse;
  95: f.light = v2f_light;
  96: 
  97: 
  98:     FLWMain(f);
  99: }

[12:29:45] [main/ERROR]: Shader compilation log for create:flap.vert: No errors.

[12:29:45] [main/ERROR]: Source for shader 'create:flap.vert':
   1: #version 110
   2: #define USE_FOG
   3: #define USE_FOG_EXP2
   4: 
   5: #define PI 3.1415926538
   6: 
   7: uniform float uTime;
   8: uniform mat4 uViewProjection;
   9: uniform vec3 uCameraPos;
  10: 
  11: #if defined(USE_FOG)
  12: varying float FragDistance;
  13: #endif
  14: 
  15: void FLWFinalizeWorldPos(inout vec4 worldPos) {
  16:     #if defined(USE_FOG)
  17:     FragDistance = length(worldPos.xyz - uCameraPos);
  18:     #endif
  19: 
  20:     gl_Position = uViewProjection * worldPos;
  21: }
  22: 
  23: void FLWFinalizeNormal(inout vec3 normal) {
  24:     // noop
  25: }
  26: 
  27: 
  28: mat4 rotate(vec3 axis, float angle) {
  29:     float s = sin(angle);
  30:     float c = cos(angle);
  31:     float oc = 1. - c;
  32: 
  33:     vec3 sa = axis * s;
  34: 
  35:     mat4 mr = mat4(1.);
  36:     mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
  37:     mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
  38:     mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);
  39: 
  40:     return mr;
  41: }
  42: 
  43: mat4 rotation(vec3 rot) {
  44:     return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
  45: }
  46: 
  47: mat3 modelToNormal(mat4 mat) {
  48:     // Discard the edges. This won't be accurate for scaled or skewed matrices,
  49:     // but we don't have to work with those often.
  50:     mat3 m;
  51:     m[0] = mat[0].xyz;
  52:     m[1] = mat[1].xyz;
  53:     m[2] = mat[2].xyz;
  54:     return m;
  55: }
  56: 
  57: #define PIOVER2 1.5707963268
  58: 
  59: vec4 quat(vec3 axis, float angle) {
  60:     float halfAngle = angle * PIOVER2 / 180.0;
  61:     vec2 cs = sin(vec2(PIOVER2 - halfAngle, halfAngle)); // compute sin and cos in one instruction
  62:     return vec4(axis.xyz * cs.y,  cs.x);
  63: }
  64: 
  65: vec4 quatMult(vec4 q1, vec4 q2) {
  66:     // disgustingly vectorized quaternion multiplication
  67:     vec4 a = q1.w * q2.xyzw;
  68:     vec4 b = q1.x * q2.wzxy * vec4(1., -1., 1., -1.);
  69:     vec4 c = q1.y * q2.zwxy * vec4(1., 1., -1., -1.);
  70:     vec4 d = q1.z * q2.yxwz * vec4(-1., 1., 1., -1.);
  71: 
  72:     return a + b + c + d;
  73: }
  74: 
  75: vec3 rotateVertexByQuat(vec3 v, vec4 q) {
  76:     vec3 i = q.xyz;
  77:     return v + 2.0 * cross(i, cross(i, v) + q.w * v);
  78: }
  79: 
  80: vec3 rotateAbout(vec3 v, vec3 axis, float angle) {
  81:     return rotateVertexByQuat(v, quat(axis, angle));
  82: }
  83: 
  84: float diffuse(vec3 normal) {
  85:     vec3 n2 = normal * normal * vec3(.6, .25, .8);
  86:     return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
  87: }
  88: 
  89: 
  90: struct Flap {
  91:     vec3 instancePos;
  92:     vec2 light;
  93:     vec3 segmentOffset;
  94:     vec3 pivot;
  95:     float horizontalAngle;
  96:     float intensity;
  97:     float flapScale;
  98:     float flapness;
  99: };
 100: 
 101: 
 102: struct Vertex {
 103:     vec3 pos;
 104:     vec3 normal;
 105:     vec2 texCoords;
 106: };
 107: 
 108: struct BlockFrag {
 109:     vec2 texCoords;
 110:     vec4 color;
 111:     float diffuse;
 112:     vec2 light;
 113: };
 114: 
 115: 
 116: float toRad(float degrees) {
 117:     return fract(degrees / 360.) * PI * 2.;
 118: }
 119: 
 120: float getFlapAngle(float flapness, float intensity, float scale) {
 121:     float absFlap = abs(flapness);
 122: 
 123:     float angle = sin((1. - absFlap) * PI * intensity) * 30. * flapness * scale;
 124: 
 125:     float halfAngle = angle * 0.5;
 126: 
 127:     float which = step(0., flapness);// 0 if negative, 1 if positive
 128:     float degrees = which * halfAngle + (1. - which) * angle;// branchless conditional multiply
 129: 
 130:     return degrees;
 131: }
 132: 
 133: BlockFrag FLWMain(Vertex v, Flap flap) {
 134:     float flapAngle = getFlapAngle(flap.flapness, flap.intensity, flap.flapScale);
 135: 
 136:     vec4 orientation = quat(vec3(0., 1., 0.), -flap.horizontalAngle);
 137:     vec4 flapRotation = quat(vec3(1., 0., 0.), flapAngle);
 138: 
 139:     vec3 rotated = rotateVertexByQuat(v.pos - flap.pivot, flapRotation) + flap.pivot + flap.segmentOffset;
 140:     rotated = rotateVertexByQuat(rotated - .5, orientation) + flap.instancePos + .5;
 141: 
 142:     vec4 worldPos = vec4(rotated, 1.);
 143:     vec3 norm = rotateVertexByQuat(rotateVertexByQuat(v.normal, flapRotation), orientation);
 144: 
 145:     FLWFinalizeWorldPos(worldPos);
 146:     FLWFinalizeNormal(norm);
 147: 
 148:     BlockFrag b;
 149:     b.diffuse = diffuse(norm);
 150:     b.texCoords = v.texCoords;
 151:     b.light = flap.light;
 152:     #if defined(DEBUG_NORMAL)
 153:     b.color = vec4(norm, 1.);
 154:     #else
 155:     b.color = vec4(1.);
 156:     #endif
 157:     return b;
 158: }
 159: attribute vec3 a_v_pos;
 160: attribute vec3 a_v_normal;
 161: attribute vec2 a_v_texCoords;
 162: 
 163: attribute vec3 a_i_instancePos;
 164: attribute vec2 a_i_light;
 165: attribute vec3 a_i_segmentOffset;
 166: attribute vec3 a_i_pivot;
 167: attribute float a_i_horizontalAngle;
 168: attribute float a_i_intensity;
 169: attribute float a_i_flapScale;
 170: attribute float a_i_flapness;
 171: 
 172: 
 173: varying vec2 v2f_texCoords;
 174: varying vec4 v2f_color;
 175: varying float v2f_diffuse;
 176: varying vec2 v2f_light;
 177: 
 178: 
 179: void main() {
 180:     Vertex v;
 181:     v.pos = a_v_pos;
 182: v.normal = a_v_normal;
 183: v.texCoords = a_v_texCoords;
 184: 
 185: 
 186:     Flap i;
 187:     i.instancePos = a_i_instancePos;
 188: i.light = a_i_light;
 189: i.segmentOffset = a_i_segmentOffset;
 190: i.pivot = a_i_pivot;
 191: i.horizontalAngle = a_i_horizontalAngle;
 192: i.intensity = a_i_intensity;
 193: i.flapScale = a_i_flapScale;
 194: i.flapness = a_i_flapness;
 195: 
 196: 
 197:     BlockFrag o = FLWMain(v, i);
 198: 
 199:     v2f_texCoords = o.texCoords;
 200: v2f_color = o.color;
 201: v2f_diffuse = o.diffuse;
 202: v2f_light = o.light;
 203: 
 204: }

[12:29:45] [main/ERROR]: Shader compilation log for flywheel:block.frag: No errors.

[12:29:45] [main/ERROR]: Source for shader 'flywheel:block.frag':
   1: #version 110
   2: #define USE_FOG
   3: #define USE_FOG_EXP2
   4: 
   5: #if defined(USE_FOG)
   6: varying float FragDistance;
   7: uniform vec4 uFogColor;
   8: #endif
   9: 
  10: #if defined(USE_FOG_LINEAR)
  11: uniform vec2 uFogRange;
  12: 
  13: float FLWFogFactor() {
  14:     return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
  15: }
  16:     #endif
  17: 
  18:     #if defined(USE_FOG_EXP2)
  19: uniform float uFogDensity;
  20: 
  21: float FLWFogFactor() {
  22:     float dist = FragDistance * uFogDensity;
  23:     return 1. / exp2(dist * dist);
  24: }
  25:     #endif
  26: // Adjust the [0,1] normalized lightmap value based on the texture matrix from LightTexture#enableLightmap
  27: vec2 shiftLight(vec2 lm) {
  28:     return lm * 0.99609375 + 0.03125;// * 255/256 + 1/32
  29: }
  30: 
  31: uniform sampler2D uBlockAtlas;
  32: uniform sampler2D uLightMap;
  33: 
  34: vec4 FLWBlockTexture(vec2 texCoords) {
  35:     return texture2D(uBlockAtlas, texCoords);
  36: }
  37: 
  38: void FLWFinalizeColor(vec4 color) {
  39:     #if defined(USE_FOG)
  40:     float a = color.a;
  41:     float fog = clamp(FLWFogFactor(), 0., 1.);
  42: 
  43:     color = mix(uFogColor, color, fog);
  44:     color.a = a;
  45:     #endif
  46: 
  47:     gl_FragColor = color;
  48: }
  49: 
  50: vec4 FLWLight(vec2 lightCoords) {
  51:     return texture2D(uLightMap, shiftLight(lightCoords));
  52: }
  53: 
  54: 
  55: 
  56: struct BlockFrag {
  57:     vec2 texCoords;
  58:     vec4 color;
  59:     float diffuse;
  60:     vec2 light;
  61: };
  62: 
  63: void FLWMain(BlockFrag r) {
  64:     vec4 tex = FLWBlockTexture(r.texCoords);
  65: 
  66:     vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;
  67: 
  68: //    flw_WorldPos = ;
  69: //    flw_Normal = ;
  70: //    flw_Albedo = tex.rgb;
  71: //    flw_Alpha = tex.a;
  72: //    flw_LightMap = r.light;
  73: //    flw_Tint = r.color;
  74:     FLWFinalizeColor(color);
  75: }
  76: 
  77: varying vec2 v2f_texCoords;
  78: varying vec4 v2f_color;
  79: varying float v2f_diffuse;
  80: varying vec2 v2f_light;
  81: 
  82: 
  83: //vec3 flw_WorldPos;
  84: //vec3 flw_Normal;
  85: //vec3 flw_Albedo;
  86: //float flw_Alpha;
  87: //vec2 flw_LightMap;
  88: //vec4 flw_Tint;
  89: 
  90: void main() {
  91:     BlockFrag f;
  92:     f.texCoords = v2f_texCoords;
  93: f.color = v2f_color;
  94: f.diffuse = v2f_diffuse;
  95: f.light = v2f_light;
  96: 
  97: 
  98:     FLWMain(f);
  99: }

[12:29:45] [main/ERROR]: Shader compilation log for create:flap.vert: No errors.

[12:29:45] [main/ERROR]: Source for shader 'create:flap.vert':
   1: #version 110
   2: 
   3: #define PI 3.1415926538
   4: 
   5: uniform float uTime;
   6: uniform mat4 uViewProjection;
   7: uniform vec3 uCameraPos;
   8: 
   9: #if defined(USE_FOG)
  10: varying float FragDistance;
  11: #endif
  12: 
  13: void FLWFinalizeWorldPos(inout vec4 worldPos) {
  14:     #if defined(USE_FOG)
  15:     FragDistance = length(worldPos.xyz - uCameraPos);
  16:     #endif
  17: 
  18:     gl_Position = uViewProjection * worldPos;
  19: }
  20: 
  21: void FLWFinalizeNormal(inout vec3 normal) {
  22:     // noop
  23: }
  24: 
  25: 
  26: mat4 rotate(vec3 axis, float angle) {
  27:     float s = sin(angle);
  28:     float c = cos(angle);
  29:     float oc = 1. - c;
  30: 
  31:     vec3 sa = axis * s;
  32: 
  33:     mat4 mr = mat4(1.);
  34:     mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
  35:     mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
  36:     mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);
  37: 
  38:     return mr;
  39: }
  40: 
  41: mat4 rotation(vec3 rot) {
  42:     return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
  43: }
  44: 
  45: mat3 modelToNormal(mat4 mat) {
  46:     // Discard the edges. This won't be accurate for scaled or skewed matrices,
  47:     // but we don't have to work with those often.
  48:     mat3 m;
  49:     m[0] = mat[0].xyz;
  50:     m[1] = mat[1].xyz;
  51:     m[2] = mat[2].xyz;
  52:     return m;
  53: }
  54: 
  55: #define PIOVER2 1.5707963268
  56: 
  57: vec4 quat(vec3 axis, float angle) {
  58:     float halfAngle = angle * PIOVER2 / 180.0;
  59:     vec2 cs = sin(vec2(PIOVER2 - halfAngle, halfAngle)); // compute sin and cos in one instruction
  60:     return vec4(axis.xyz * cs.y,  cs.x);
  61: }
  62: 
  63: vec4 quatMult(vec4 q1, vec4 q2) {
  64:     // disgustingly vectorized quaternion multiplication
  65:     vec4 a = q1.w * q2.xyzw;
  66:     vec4 b = q1.x * q2.wzxy * vec4(1., -1., 1., -1.);
  67:     vec4 c = q1.y * q2.zwxy * vec4(1., 1., -1., -1.);
  68:     vec4 d = q1.z * q2.yxwz * vec4(-1., 1., 1., -1.);
  69: 
  70:     return a + b + c + d;
  71: }
  72: 
  73: vec3 rotateVertexByQuat(vec3 v, vec4 q) {
  74:     vec3 i = q.xyz;
  75:     return v + 2.0 * cross(i, cross(i, v) + q.w * v);
  76: }
  77: 
  78: vec3 rotateAbout(vec3 v, vec3 axis, float angle) {
  79:     return rotateVertexByQuat(v, quat(axis, angle));
  80: }
  81: 
  82: float diffuse(vec3 normal) {
  83:     vec3 n2 = normal * normal * vec3(.6, .25, .8);
  84:     return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
  85: }
  86: 
  87: 
  88: struct Flap {
  89:     vec3 instancePos;
  90:     vec2 light;
  91:     vec3 segmentOffset;
  92:     vec3 pivot;
  93:     float horizontalAngle;
  94:     float intensity;
  95:     float flapScale;
  96:     float flapness;
  97: };
  98: 
  99: 
 100: struct Vertex {
 101:     vec3 pos;
 102:     vec3 normal;
 103:     vec2 texCoords;
 104: };
 105: 
 106: struct BlockFrag {
 107:     vec2 texCoords;
 108:     vec4 color;
 109:     float diffuse;
 110:     vec2 light;
 111: };
 112: 
 113: 
 114: float toRad(float degrees) {
 115:     return fract(degrees / 360.) * PI * 2.;
 116: }
 117: 
 118: float getFlapAngle(float flapness, float intensity, float scale) {
 119:     float absFlap = abs(flapness);
 120: 
 121:     float angle = sin((1. - absFlap) * PI * intensity) * 30. * flapness * scale;
 122: 
 123:     float halfAngle = angle * 0.5;
 124: 
 125:     float which = step(0., flapness);// 0 if negative, 1 if positive
 126:     float degrees = which * halfAngle + (1. - which) * angle;// branchless conditional multiply
 127: 
 128:     return degrees;
 129: }
 130: 
 131: BlockFrag FLWMain(Vertex v, Flap flap) {
 132:     float flapAngle = getFlapAngle(flap.flapness, flap.intensity, flap.flapScale);
 133: 
 134:     vec4 orientation = quat(vec3(0., 1., 0.), -flap.horizontalAngle);
 135:     vec4 flapRotation = quat(vec3(1., 0., 0.), flapAngle);
 136: 
 137:     vec3 rotated = rotateVertexByQuat(v.pos - flap.pivot, flapRotation) + flap.pivot + flap.segmentOffset;
 138:     rotated = rotateVertexByQuat(rotated - .5, orientation) + flap.instancePos + .5;
 139: 
 140:     vec4 worldPos = vec4(rotated, 1.);
 141:     vec3 norm = rotateVertexByQuat(rotateVertexByQuat(v.normal, flapRotation), orientation);
 142: 
 143:     FLWFinalizeWorldPos(worldPos);
 144:     FLWFinalizeNormal(norm);
 145: 
 146:     BlockFrag b;
 147:     b.diffuse = diffuse(norm);
 148:     b.texCoords = v.texCoords;
 149:     b.light = flap.light;
 150:     #if defined(DEBUG_NORMAL)
 151:     b.color = vec4(norm, 1.);
 152:     #else
 153:     b.color = vec4(1.);
 154:     #endif
 155:     return b;
 156: }
 157: attribute vec3 a_v_pos;
 158: attribute vec3 a_v_normal;
 159: attribute vec2 a_v_texCoords;
 160: 
 161: attribute vec3 a_i_instancePos;
 162: attribute vec2 a_i_light;
 163: attribute vec3 a_i_segmentOffset;
 164: attribute vec3 a_i_pivot;
 165: attribute float a_i_horizontalAngle;
 166: attribute float a_i_intensity;
 167: attribute float a_i_flapScale;
 168: attribute float a_i_flapness;
 169: 
 170: 
 171: varying vec2 v2f_texCoords;
 172: varying vec4 v2f_color;
 173: varying float v2f_diffuse;
 174: varying vec2 v2f_light;
 175: 
 176: 
 177: void main() {
 178:     Vertex v;
 179:     v.pos = a_v_pos;
 180: v.normal = a_v_normal;
 181: v.texCoords = a_v_texCoords;
 182: 
 183: 
 184:     Flap i;
 185:     i.instancePos = a_i_instancePos;
 186: i.light = a_i_light;
 187: i.segmentOffset = a_i_segmentOffset;
 188: i.pivot = a_i_pivot;
 189: i.horizontalAngle = a_i_horizontalAngle;
 190: i.intensity = a_i_intensity;
 191: i.flapScale = a_i_flapScale;
 192: i.flapness = a_i_flapness;
 193: 
 194: 
 195:     BlockFrag o = FLWMain(v, i);
 196: 
 197:     v2f_texCoords = o.texCoords;
 198: v2f_color = o.color;
 199: v2f_diffuse = o.diffuse;
 200: v2f_light = o.light;
 201: 
 202: }

[12:29:45] [main/ERROR]: Shader compilation log for flywheel:block.frag: No errors.

[12:29:45] [main/ERROR]: Source for shader 'flywheel:block.frag':
   1: #version 110
   2: 
   3: #if defined(USE_FOG)
   4: varying float FragDistance;
   5: uniform vec4 uFogColor;
   6: #endif
   7: 
   8: #if defined(USE_FOG_LINEAR)
   9: uniform vec2 uFogRange;
  10: 
  11: float FLWFogFactor() {
  12:     return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
  13: }
  14:     #endif
  15: 
  16:     #if defined(USE_FOG_EXP2)
  17: uniform float uFogDensity;
  18: 
  19: float FLWFogFactor() {
  20:     float dist = FragDistance * uFogDensity;
  21:     return 1. / exp2(dist * dist);
  22: }
  23:     #endif
  24: // Adjust the [0,1] normalized lightmap value based on the texture matrix from LightTexture#enableLightmap
  25: vec2 shiftLight(vec2 lm) {
  26:     return lm * 0.99609375 + 0.03125;// * 255/256 + 1/32
  27: }
  28: 
  29: uniform sampler2D uBlockAtlas;
  30: uniform sampler2D uLightMap;
  31: 
  32: vec4 FLWBlockTexture(vec2 texCoords) {
  33:     return texture2D(uBlockAtlas, texCoords);
  34: }
  35: 
  36: void FLWFinalizeColor(vec4 color) {
  37:     #if defined(USE_FOG)
  38:     float a = color.a;
  39:     float fog = clamp(FLWFogFactor(), 0., 1.);
  40: 
  41:     color = mix(uFogColor, color, fog);
  42:     color.a = a;
  43:     #endif
  44: 
  45:     gl_FragColor = color;
  46: }
  47: 
  48: vec4 FLWLight(vec2 lightCoords) {
  49:     return texture2D(uLightMap, shiftLight(lightCoords));
  50: }
  51: 
  52: 
  53: 
  54: struct BlockFrag {
  55:     vec2 texCoords;
  56:     vec4 color;
  57:     float diffuse;
  58:     vec2 light;
  59: };
  60: 
  61: void FLWMain(BlockFrag r) {
  62:     vec4 tex = FLWBlockTexture(r.texCoords);
  63: 
  64:     vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;
  65: 
  66: //    flw_WorldPos = ;
  67: //    flw_Normal = ;
  68: //    flw_Albedo = tex.rgb;
  69: //    flw_Alpha = tex.a;
  70: //    flw_LightMap = r.light;
  71: //    flw_Tint = r.color;
  72:     FLWFinalizeColor(color);
  73: }
  74: 
  75: varying vec2 v2f_texCoords;
  76: varying vec4 v2f_color;
  77: varying float v2f_diffuse;
  78: varying vec2 v2f_light;
  79: 
  80: 
  81: //vec3 flw_WorldPos;
  82: //vec3 flw_Normal;
  83: //vec3 flw_Albedo;
  84: //float flw_Alpha;
  85: //vec2 flw_LightMap;
  86: //vec4 flw_Tint;
  87: 
  88: void main() {
  89:     BlockFrag f;
  90:     f.texCoords = v2f_texCoords;
  91: f.color = v2f_color;
  92: f.diffuse = v2f_diffuse;
  93: f.light = v2f_light;
  94: 
  95: 
  96:     FLWMain(f);
  97: }

[12:29:45] [main/ERROR]: Shader compilation log for create:belt.vert: No errors.

[12:29:45] [main/ERROR]: Source for shader 'create:belt.vert':
   1: #version 110
   2: #define DEBUG_RAINBOW
   3: 
   4: #define PI 3.1415926538
   5: 
   6: uniform float uTime;
   7: uniform mat4 uViewProjection;
   8: uniform vec3 uCameraPos;
   9: 
  10: #if defined(USE_FOG)
  11: varying float FragDistance;
  12: #endif
  13: 
  14: void FLWFinalizeWorldPos(inout vec4 worldPos) {
  15:     #if defined(USE_FOG)
  16:     FragDistance = length(worldPos.xyz - uCameraPos);
  17:     #endif
  18: 
  19:     gl_Position = uViewProjection * worldPos;
  20: }
  21: 
  22: void FLWFinalizeNormal(inout vec3 normal) {
  23:     // noop
  24: }
  25: 
  26: 
  27: #define PIOVER2 1.5707963268
  28: 
  29: vec4 quat(vec3 axis, float angle) {
  30:     float halfAngle = angle * PIOVER2 / 180.0;
  31:     vec2 cs = sin(vec2(PIOVER2 - halfAngle, halfAngle)); // compute sin and cos in one instruction
  32:     return vec4(axis.xyz * cs.y,  cs.x);
  33: }
  34: 
  35: vec4 quatMult(vec4 q1, vec4 q2) {
  36:     // disgustingly vectorized quaternion multiplication
  37:     vec4 a = q1.w * q2.xyzw;
  38:     vec4 b = q1.x * q2.wzxy * vec4(1., -1., 1., -1.);
  39:     vec4 c = q1.y * q2.zwxy * vec4(1., 1., -1., -1.);
  40:     vec4 d = q1.z * q2.yxwz * vec4(-1., 1., 1., -1.);
  41: 
  42:     return a + b + c + d;
  43: }
  44: 
  45: vec3 rotateVertexByQuat(vec3 v, vec4 q) {
  46:     vec3 i = q.xyz;
  47:     return v + 2.0 * cross(i, cross(i, v) + q.w * v);
  48: }
  49: 
  50: vec3 rotateAbout(vec3 v, vec3 axis, float angle) {
  51:     return rotateVertexByQuat(v, quat(axis, angle));
  52: }
  53: 
  54: mat4 rotate(vec3 axis, float angle) {
  55:     float s = sin(angle);
  56:     float c = cos(angle);
  57:     float oc = 1. - c;
  58: 
  59:     vec3 sa = axis * s;
  60: 
  61:     mat4 mr = mat4(1.);
  62:     mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
  63:     mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
  64:     mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);
  65: 
  66:     return mr;
  67: }
  68: 
  69: mat4 rotation(vec3 rot) {
  70:     return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
  71: }
  72: 
  73: mat3 modelToNormal(mat4 mat) {
  74:     // Discard the edges. This won't be accurate for scaled or skewed matrices,
  75:     // but we don't have to work with those often.
  76:     mat3 m;
  77:     m[0] = mat[0].xyz;
  78:     m[1] = mat[1].xyz;
  79:     m[2] = mat[2].xyz;
  80:     return m;
  81: }
  82: 
  83: float diffuse(vec3 normal) {
  84:     vec3 n2 = normal * normal * vec3(.6, .25, .8);
  85:     return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
  86: }
  87: 
  88: 
  89: struct Belt {
  90:     vec2 light;
  91:     vec4 color;
  92:     vec3 pos;
  93:     float speed;
  94:     float offset;
  95:     vec4 rotation;
  96:     vec2 sourceTexture;
  97:     vec4 scrollTexture;
  98:     float scrollMult;
  99: };
 100: 
 101: 
 102: struct Vertex {
 103:     vec3 pos;
 104:     vec3 normal;
 105:     vec2 texCoords;
 106: };
 107: 
 108: struct BlockFrag {
 109:     vec2 texCoords;
 110:     vec4 color;
 111:     float diffuse;
 112:     vec2 light;
 113: };
 114: 
 115: BlockFrag FLWMain(Vertex v, Belt instance) {
 116:     vec3 rotated = rotateVertexByQuat(v.pos - .5, instance.rotation) + instance.pos + .5;
 117: 
 118:     vec4 worldPos = vec4(rotated, 1.);
 119: 
 120:     vec3 norm = rotateVertexByQuat(v.normal, instance.rotation);
 121: 
 122:     FLWFinalizeWorldPos(worldPos);
 123:     FLWFinalizeNormal(norm);
 124: 
 125:     float scrollSize = instance.scrollTexture.w - instance.scrollTexture.y;
 126:     float scroll = fract(instance.speed * uTime / (31.5 * 16.) + instance.offset) * scrollSize * instance.scrollMult;
 127: 
 128:     BlockFrag b;
 129:     b.diffuse = diffuse(norm);
 130:     b.texCoords = v.texCoords - instance.sourceTexture + instance.scrollTexture.xy + vec2(0, scroll);
 131:     b.light = instance.light;
 132: 
 133:     #if defined(DEBUG_RAINBOW)
 134:     b.color = instance.color;
 135:     #elif defined(DEBUG_NORMAL)
 136:     b.color = vec4(norm, 1.);
 137:     #else
 138:     b.color = vec4(1.);
 139:     #endif
 140: 
 141:     return b;
 142: }
 143: attribute vec3 a_v_pos;
 144: attribute vec3 a_v_normal;
 145: attribute vec2 a_v_texCoords;
 146: 
 147: attribute vec2 a_i_light;
 148: attribute vec4 a_i_color;
 149: attribute vec3 a_i_pos;
 150: attribute float a_i_speed;
 151: attribute float a_i_offset;
 152: attribute vec4 a_i_rotation;
 153: attribute vec2 a_i_sourceTexture;
 154: attribute vec4 a_i_scrollTexture;
 155: attribute float a_i_scrollMult;
 156: 
 157: 
 158: varying vec2 v2f_texCoords;
 159: varying vec4 v2f_color;
 160: varying float v2f_diffuse;
 161: varying vec2 v2f_light;
 162: 
 163: 
 164: void main() {
 165:     Vertex v;
 166:     v.pos = a_v_pos;
 167: v.normal = a_v_normal;
 168: v.texCoords = a_v_texCoords;
 169: 
 170: 
 171:     Belt i;
 172:     i.light = a_i_light;
 173: i.color = a_i_color;
 174: i.pos = a_i_pos;
 175: i.speed = a_i_speed;
 176: i.offset = a_i_offset;
 177: i.rotation = a_i_rotation;
 178: i.sourceTexture = a_i_sourceTexture;
 179: i.scrollTexture = a_i_scrollTexture;
 180: i.scrollMult = a_i_scrollMult;
 181: 
 182: 
 183:     BlockFrag o = FLWMain(v, i);
 184: 
 185:     v2f_texCoords = o.texCoords;
 186: v2f_color = o.color;
 187: v2f_diffuse = o.diffuse;
 188: v2f_light = o.light;
 189: 
 190: }

[12:29:45] [main/ERROR]: Shader compilation log for flywheel:block.frag: No errors.

[12:29:45] [main/ERROR]: Source for shader 'flywheel:block.frag':
   1: #version 110
   2: #define DEBUG_RAINBOW
   3: 
   4: #if defined(USE_FOG)
   5: varying float FragDistance;
   6: uniform vec4 uFogColor;
   7: #endif
   8: 
   9: #if defined(USE_FOG_LINEAR)
  10: uniform vec2 uFogRange;
  11: 
  12: float FLWFogFactor() {
  13:     return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
  14: }
  15:     #endif
  16: 
  17:     #if defined(USE_FOG_EXP2)
  18: uniform float uFogDensity;
  19: 
  20: float FLWFogFactor() {
  21:     float dist = FragDistance * uFogDensity;
  22:     return 1. / exp2(dist * dist);
  23: }
  24:     #endif
  25: // Adjust the [0,1] normalized lightmap value based on the texture matrix from LightTexture#enableLightmap
  26: vec2 shiftLight(vec2 lm) {
  27:     return lm * 0.99609375 + 0.03125;// * 255/256 + 1/32
  28: }
  29: 
  30: uniform sampler2D uBlockAtlas;
  31: uniform sampler2D uLightMap;
  32: 
  33: vec4 FLWBlockTexture(vec2 texCoords) {
  34:     return texture2D(uBlockAtlas, texCoords);
  35: }
  36: 
  37: void FLWFinalizeColor(vec4 color) {
  38:     #if defined(USE_FOG)
  39:     float a = color.a;
  40:     float fog = clamp(FLWFogFactor(), 0., 1.);
  41: 
  42:     color = mix(uFogColor, color, fog);
  43:     color.a = a;
  44:     #endif
  45: 
  46:     gl_FragColor = color;
  47: }
  48: 
  49: vec4 FLWLight(vec2 lightCoords) {
  50:     return texture2D(uLightMap, shiftLight(lightCoords));
  51: }
  52: 
  53: 
  54: 
  55: struct BlockFrag {
  56:     vec2 texCoords;
  57:     vec4 color;
  58:     float diffuse;
  59:     vec2 light;
  60: };
  61: 
  62: void FLWMain(BlockFrag r) {
  63:     vec4 tex = FLWBlockTexture(r.texCoords);
  64: 
  65:     vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;
  66: 
  67: //    flw_WorldPos = ;
  68: //    flw_Normal = ;
  69: //    flw_Albedo = tex.rgb;
  70: //    flw_Alpha = tex.a;
  71: //    flw_LightMap = r.light;
  72: //    flw_Tint = r.color;
  73:     FLWFinalizeColor(color);
  74: }
  75: 
  76: varying vec2 v2f_texCoords;
  77: varying vec4 v2f_color;
  78: varying float v2f_diffuse;
  79: varying vec2 v2f_light;
  80: 
  81: 
  82: //vec3 flw_WorldPos;
  83: //vec3 flw_Normal;
  84: //vec3 flw_Albedo;
  85: //float flw_Alpha;
  86: //vec2 flw_LightMap;
  87: //vec4 flw_Tint;
  88: 
  89: void main() {
  90:     BlockFrag f;
  91:     f.texCoords = v2f_texCoords;
  92: f.color = v2f_color;
  93: f.diffuse = v2f_diffuse;
  94: f.light = v2f_light;
  95: 
  96: 
  97:     FLWMain(f);
  98: }

[12:29:45] [main/ERROR]: Shader compilation log for create:belt.vert: No errors.

[12:29:45] [main/ERROR]: Source for shader 'create:belt.vert':
   1: #version 110
   2: #define DEBUG_NORMAL
   3: 
   4: #define PI 3.1415926538
   5: 
   6: uniform float uTime;
   7: uniform mat4 uViewProjection;
   8: uniform vec3 uCameraPos;
   9: 
  10: #if defined(USE_FOG)
  11: varying float FragDistance;
  12: #endif
  13: 
  14: void FLWFinalizeWorldPos(inout vec4 worldPos) {
  15:     #if defined(USE_FOG)
  16:     FragDistance = length(worldPos.xyz - uCameraPos);
  17:     #endif
  18: 
  19:     gl_Position = uViewProjection * worldPos;
  20: }
  21: 
  22: void FLWFinalizeNormal(inout vec3 normal) {
  23:     // noop
  24: }
  25: 
  26: 
  27: #define PIOVER2 1.5707963268
  28: 
  29: vec4 quat(vec3 axis, float angle) {
  30:     float halfAngle = angle * PIOVER2 / 180.0;
  31:     vec2 cs = sin(vec2(PIOVER2 - halfAngle, halfAngle)); // compute sin and cos in one instruction
  32:     return vec4(axis.xyz * cs.y,  cs.x);
  33: }
  34: 
  35: vec4 quatMult(vec4 q1, vec4 q2) {
  36:     // disgustingly vectorized quaternion multiplication
  37:     vec4 a = q1.w * q2.xyzw;
  38:     vec4 b = q1.x * q2.wzxy * vec4(1., -1., 1., -1.);
  39:     vec4 c = q1.y * q2.zwxy * vec4(1., 1., -1., -1.);
  40:     vec4 d = q1.z * q2.yxwz * vec4(-1., 1., 1., -1.);
  41: 
  42:     return a + b + c + d;
  43: }
  44: 
  45: vec3 rotateVertexByQuat(vec3 v, vec4 q) {
  46:     vec3 i = q.xyz;
  47:     return v + 2.0 * cross(i, cross(i, v) + q.w * v);
  48: }
  49: 
  50: vec3 rotateAbout(vec3 v, vec3 axis, float angle) {
  51:     return rotateVertexByQuat(v, quat(axis, angle));
  52: }
  53: 
  54: mat4 rotate(vec3 axis, float angle) {
  55:     float s = sin(angle);
  56:     float c = cos(angle);
  57:     float oc = 1. - c;
  58: 
  59:     vec3 sa = axis * s;
  60: 
  61:     mat4 mr = mat4(1.);
  62:     mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
  63:     mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
  64:     mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);
  65: 
  66:     return mr;
  67: }
  68: 
  69: mat4 rotation(vec3 rot) {
  70:     return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
  71: }
  72: 
  73: mat3 modelToNormal(mat4 mat) {
  74:     // Discard the edges. This won't be accurate for scaled or skewed matrices,
  75:     // but we don't have to work with those often.
  76:     mat3 m;
  77:     m[0] = mat[0].xyz;
  78:     m[1] = mat[1].xyz;
  79:     m[2] = mat[2].xyz;
  80:     return m;
  81: }
  82: 
  83: float diffuse(vec3 normal) {
  84:     vec3 n2 = normal * normal * vec3(.6, .25, .8);
  85:     return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
  86: }
  87: 
  88: 
  89: struct Belt {
  90:     vec2 light;
  91:     vec4 color;
  92:     vec3 pos;
  93:     float speed;
  94:     float offset;
  95:     vec4 rotation;
  96:     vec2 sourceTexture;
  97:     vec4 scrollTexture;
  98:     float scrollMult;
  99: };
 100: 
 101: 
 102: struct Vertex {
 103:     vec3 pos;
 104:     vec3 normal;
 105:     vec2 texCoords;
 106: };
 107: 
 108: struct BlockFrag {
 109:     vec2 texCoords;
 110:     vec4 color;
 111:     float diffuse;
 112:     vec2 light;
 113: };
 114: 
 115: BlockFrag FLWMain(Vertex v, Belt instance) {
 116:     vec3 rotated = rotateVertexByQuat(v.pos - .5, instance.rotation) + instance.pos + .5;
 117: 
 118:     vec4 worldPos = vec4(rotated, 1.);
 119: 
 120:     vec3 norm = rotateVertexByQuat(v.normal, instance.rotation);
 121: 
 122:     FLWFinalizeWorldPos(worldPos);
 123:     FLWFinalizeNormal(norm);
 124: 
 125:     float scrollSize = instance.scrollTexture.w - instance.scrollTexture.y;
 126:     float scroll = fract(instance.speed * uTime / (31.5 * 16.) + instance.offset) * scrollSize * instance.scrollMult;
 127: 
 128:     BlockFrag b;
 129:     b.diffuse = diffuse(norm);
 130:     b.texCoords = v.texCoords - instance.sourceTexture + instance.scrollTexture.xy + vec2(0, scroll);
 131:     b.light = instance.light;
 132: 
 133:     #if defined(DEBUG_RAINBOW)
 134:     b.color = instance.color;
 135:     #elif defined(DEBUG_NORMAL)
 136:     b.color = vec4(norm, 1.);
 137:     #else
 138:     b.color = vec4(1.);
 139:     #endif
 140: 
 141:     return b;
 142: }
 143: attribute vec3 a_v_pos;
 144: attribute vec3 a_v_normal;
 145: attribute vec2 a_v_texCoords;
 146: 
 147: attribute vec2 a_i_light;
 148: attribute vec4 a_i_color;
 149: attribute vec3 a_i_pos;
 150: attribute float a_i_speed;
 151: attribute float a_i_offset;
 152: attribute vec4 a_i_rotation;
 153: attribute vec2 a_i_sourceTexture;
 154: attribute vec4 a_i_scrollTexture;
 155: attribute float a_i_scrollMult;
 156: 
 157: 
 158: varying vec2 v2f_texCoords;
 159: varying vec4 v2f_color;
 160: varying float v2f_diffuse;
 161: varying vec2 v2f_light;
 162: 
 163: 
 164: void main() {
 165:     Vertex v;
 166:     v.pos = a_v_pos;
 167: v.normal = a_v_normal;
 168: v.texCoords = a_v_texCoords;
 169: 
 170: 
 171:     Belt i;
 172:     i.light = a_i_light;
 173: i.color = a_i_color;
 174: i.pos = a_i_pos;
 175: i.speed = a_i_speed;
 176: i.offset = a_i_offset;
 177: i.rotation = a_i_rotation;
 178: i.sourceTexture = a_i_sourceTexture;
 179: i.scrollTexture = a_i_scrollTexture;
 180: i.scrollMult = a_i_scrollMult;
 181: 
 182: 
 183:     BlockFrag o = FLWMain(v, i);
 184: 
 185:     v2f_texCoords = o.texCoords;
 186: v2f_color = o.color;
 187: v2f_diffuse = o.diffuse;
 188: v2f_light = o.light;
 189: 
 190: }

[12:29:45] [main/ERROR]: Shader compilation log for flywheel:block.frag: No errors.

[12:29:45] [main/ERROR]: Source for shader 'flywheel:block.frag':
   1: #version 110
   2: #define DEBUG_NORMAL
   3: 
   4: #if defined(USE_FOG)
   5: varying float FragDistance;
   6: uniform vec4 uFogColor;
   7: #endif
   8: 
   9: #if defined(USE_FOG_LINEAR)
  10: uniform vec2 uFogRange;
  11: 
  12: float FLWFogFactor() {
  13:     return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
  14: }
  15:     #endif
  16: 
  17:     #if defined(USE_FOG_EXP2)
  18: uniform float uFogDensity;
  19: 
  20: float FLWFogFactor() {
  21:     float dist = FragDistance * uFogDensity;
  22:     return 1. / exp2(dist * dist);
  23: }
  24:     #endif
  25: // Adjust the [0,1] normalized lightmap value based on the texture matrix from LightTexture#enableLightmap
  26: vec2 shiftLight(vec2 lm) {
  27:     return lm * 0.99609375 + 0.03125;// * 255/256 + 1/32
  28: }
  29: 
  30: uniform sampler2D uBlockAtlas;
  31: uniform sampler2D uLightMap;
  32: 
  33: vec4 FLWBlockTexture(vec2 texCoords) {
  34:     return texture2D(uBlockAtlas, texCoords);
  35: }
  36: 
  37: void FLWFinalizeColor(vec4 color) {
  38:     #if defined(USE_FOG)
  39:     float a = color.a;
  40:     float fog = clamp(FLWFogFactor(), 0., 1.);
  41: 
  42:     color = mix(uFogColor, color, fog);
  43:     color.a = a;
  44:     #endif
  45: 
  46:     gl_FragColor = color;
  47: }
  48: 
  49: vec4 FLWLight(vec2 lightCoords) {
  50:     return texture2D(uLightMap, shiftLight(lightCoords));
  51: }
  52: 
  53: 
  54: 
  55: struct BlockFrag {
  56:     vec2 texCoords;
  57:     vec4 color;
  58:     float diffuse;
  59:     vec2 light;
  60: };
  61: 
  62: void FLWMain(BlockFrag r) {
  63:     vec4 tex = FLWBlockTexture(r.texCoords);
  64: 
  65:     vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;
  66: 
  67: //    flw_WorldPos = ;
  68: //    flw_Normal = ;
  69: //    flw_Albedo = tex.rgb;
  70: //    flw_Alpha = tex.a;
  71: //    flw_LightMap = r.light;
  72: //    flw_Tint = r.color;
  73:     FLWFinalizeColor(color);
  74: }
  75: 
  76: varying vec2 v2f_texCoords;
  77: varying vec4 v2f_color;
  78: varying float v2f_diffuse;
  79: varying vec2 v2f_light;
  80: 
  81: 
  82: //vec3 flw_WorldPos;
  83: //vec3 flw_Normal;
  84: //vec3 flw_Albedo;
  85: //float flw_Alpha;
  86: //vec2 flw_LightMap;
  87: //vec4 flw_Tint;
  88: 
  89: void main() {
  90:     BlockFrag f;
  91:     f.texCoords = v2f_texCoords;
  92: f.color = v2f_color;
  93: f.diffuse = v2f_diffuse;
  94: f.light = v2f_light;
  95: 
  96: 
  97:     FLWMain(f);
  98: }

[12:29:45] [main/ERROR]: Shader compilation log for create:belt.vert: No errors.

[12:29:45] [main/ERROR]: Source for shader 'create:belt.vert':
   1: #version 110
   2: #define USE_FOG
   3: #define USE_FOG_LINEAR
   4: 
   5: #define PI 3.1415926538
   6: 
   7: uniform float uTime;
   8: uniform mat4 uViewProjection;
   9: uniform vec3 uCameraPos;
  10: 
  11: #if defined(USE_FOG)
  12: varying float FragDistance;
  13: #endif
  14: 
  15: void FLWFinalizeWorldPos(inout vec4 worldPos) {
  16:     #if defined(USE_FOG)
  17:     FragDistance = length(worldPos.xyz - uCameraPos);
  18:     #endif
  19: 
  20:     gl_Position = uViewProjection * worldPos;
  21: }
  22: 
  23: void FLWFinalizeNormal(inout vec3 normal) {
  24:     // noop
  25: }
  26: 
  27: 
  28: #define PIOVER2 1.5707963268
  29: 
  30: vec4 quat(vec3 axis, float angle) {
  31:     float halfAngle = angle * PIOVER2 / 180.0;
  32:     vec2 cs = sin(vec2(PIOVER2 - halfAngle, halfAngle)); // compute sin and cos in one instruction
  33:     return vec4(axis.xyz * cs.y,  cs.x);
  34: }
  35: 
  36: vec4 quatMult(vec4 q1, vec4 q2) {
  37:     // disgustingly vectorized quaternion multiplication
  38:     vec4 a = q1.w * q2.xyzw;
  39:     vec4 b = q1.x * q2.wzxy * vec4(1., -1., 1., -1.);
  40:     vec4 c = q1.y * q2.zwxy * vec4(1., 1., -1., -1.);
  41:     vec4 d = q1.z * q2.yxwz * vec4(-1., 1., 1., -1.);
  42: 
  43:     return a + b + c + d;
  44: }
  45: 
  46: vec3 rotateVertexByQuat(vec3 v, vec4 q) {
  47:     vec3 i = q.xyz;
  48:     return v + 2.0 * cross(i, cross(i, v) + q.w * v);
  49: }
  50: 
  51: vec3 rotateAbout(vec3 v, vec3 axis, float angle) {
  52:     return rotateVertexByQuat(v, quat(axis, angle));
  53: }
  54: 
  55: mat4 rotate(vec3 axis, float angle) {
  56:     float s = sin(angle);
  57:     float c = cos(angle);
  58:     float oc = 1. - c;
  59: 
  60:     vec3 sa = axis * s;
  61: 
  62:     mat4 mr = mat4(1.);
  63:     mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
  64:     mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
  65:     mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);
  66: 
  67:     return mr;
  68: }
  69: 
  70: mat4 rotation(vec3 rot) {
  71:     return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
  72: }
  73: 
  74: mat3 modelToNormal(mat4 mat) {
  75:     // Discard the edges. This won't be accurate for scaled or skewed matrices,
  76:     // but we don't have to work with those often.
  77:     mat3 m;
  78:     m[0] = mat[0].xyz;
  79:     m[1] = mat[1].xyz;
  80:     m[2] = mat[2].xyz;
  81:     return m;
  82: }
  83: 
  84: float diffuse(vec3 normal) {
  85:     vec3 n2 = normal * normal * vec3(.6, .25, .8);
  86:     return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
  87: }
  88: 
  89: 
  90: struct Belt {
  91:     vec2 light;
  92:     vec4 color;
  93:     vec3 pos;
  94:     float speed;
  95:     float offset;
  96:     vec4 rotation;
  97:     vec2 sourceTexture;
  98:     vec4 scrollTexture;
  99:     float scrollMult;
 100: };
 101: 
 102: 
 103: struct Vertex {
 104:     vec3 pos;
 105:     vec3 normal;
 106:     vec2 texCoords;
 107: };
 108: 
 109: struct BlockFrag {
 110:     vec2 texCoords;
 111:     vec4 color;
 112:     float diffuse;
 113:     vec2 light;
 114: };
 115: 
 116: BlockFrag FLWMain(Vertex v, Belt instance) {
 117:     vec3 rotated = rotateVertexByQuat(v.pos - .5, instance.rotation) + instance.pos + .5;
 118: 
 119:     vec4 worldPos = vec4(rotated, 1.);
 120: 
 121:     vec3 norm = rotateVertexByQuat(v.normal, instance.rotation);
 122: 
 123:     FLWFinalizeWorldPos(worldPos);
 124:     FLWFinalizeNormal(norm);
 125: 
 126:     float scrollSize = instance.scrollTexture.w - instance.scrollTexture.y;
 127:     float scroll = fract(instance.speed * uTime / (31.5 * 16.) + instance.offset) * scrollSize * instance.scrollMult;
 128: 
 129:     BlockFrag b;
 130:     b.diffuse = diffuse(norm);
 131:     b.texCoords = v.texCoords - instance.sourceTexture + instance.scrollTexture.xy + vec2(0, scroll);
 132:     b.light = instance.light;
 133: 
 134:     #if defined(DEBUG_RAINBOW)
 135:     b.color = instance.color;
 136:     #elif defined(DEBUG_NORMAL)
 137:     b.color = vec4(norm, 1.);
 138:     #else
 139:     b.color = vec4(1.);
 140:     #endif
 141: 
 142:     return b;
 143: }
 144: attribute vec3 a_v_pos;
 145: attribute vec3 a_v_normal;
 146: attribute vec2 a_v_texCoords;
 147: 
 148: attribute vec2 a_i_light;
 149: attribute vec4 a_i_color;
 150: attribute vec3 a_i_pos;
 151: attribute float a_i_speed;
 152: attribute float a_i_offset;
 153: attribute vec4 a_i_rotation;
 154: attribute vec2 a_i_sourceTexture;
 155: attribute vec4 a_i_scrollTexture;
 156: attribute float a_i_scrollMult;
 157: 
 158: 
 159: varying vec2 v2f_texCoords;
 160: varying vec4 v2f_color;
 161: varying float v2f_diffuse;
 162: varying vec2 v2f_light;
 163: 
 164: 
 165: void main() {
 166:     Vertex v;
 167:     v.pos = a_v_pos;
 168: v.normal = a_v_normal;
 169: v.texCoords = a_v_texCoords;
 170: 
 171: 
 172:     Belt i;
 173:     i.light = a_i_light;
 174: i.color = a_i_color;
 175: i.pos = a_i_pos;
 176: i.speed = a_i_speed;
 177: i.offset = a_i_offset;
 178: i.rotation = a_i_rotation;
 179: i.sourceTexture = a_i_sourceTexture;
 180: i.scrollTexture = a_i_scrollTexture;
 181: i.scrollMult = a_i_scrollMult;
 182: 
 183: 
 184:     BlockFrag o = FLWMain(v, i);
 185: 
 186:     v2f_texCoords = o.texCoords;
 187: v2f_color = o.color;
 188: v2f_diffuse = o.diffuse;
 189: v2f_light = o.light;
 190: 
 191: }

[12:29:45] [main/ERROR]: Shader compilation log for flywheel:block.frag: No errors.

[12:29:45] [main/ERROR]: Source for shader 'flywheel:block.frag':
   1: #version 110
   2: #define USE_FOG
   3: #define USE_FOG_LINEAR
   4: 
   5: #if defined(USE_FOG)
   6: varying float FragDistance;
   7: uniform vec4 uFogColor;
   8: #endif
   9: 
  10: #if defined(USE_FOG_LINEAR)
  11: uniform vec2 uFogRange;
  12: 
  13: float FLWFogFactor() {
  14:     return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
  15: }
  16:     #endif
  17: 
  18:     #if defined(USE_FOG_EXP2)
  19: uniform float uFogDensity;
  20: 
  21: float FLWFogFactor() {
  22:     float dist = FragDistance * uFogDensity;
  23:     return 1. / exp2(dist * dist);
  24: }
  25:     #endif
  26: // Adjust the [0,1] normalized lightmap value based on the texture matrix from LightTexture#enableLightmap
  27: vec2 shiftLight(vec2 lm) {
  28:     return lm * 0.99609375 + 0.03125;// * 255/256 + 1/32
  29: }
  30: 
  31: uniform sampler2D uBlockAtlas;
  32: uniform sampler2D uLightMap;
  33: 
  34: vec4 FLWBlockTexture(vec2 texCoords) {
  35:     return texture2D(uBlockAtlas, texCoords);
  36: }
  37: 
  38: void FLWFinalizeColor(vec4 color) {
  39:     #if defined(USE_FOG)
  40:     float a = color.a;
  41:     float fog = clamp(FLWFogFactor(), 0., 1.);
  42: 
  43:     color = mix(uFogColor, color, fog);
  44:     color.a = a;
  45:     #endif
  46: 
  47:     gl_FragColor = color;
  48: }
  49: 
  50: vec4 FLWLight(vec2 lightCoords) {
  51:     return texture2D(uLightMap, shiftLight(lightCoords));
  52: }
  53: 
  54: 
  55: 
  56: struct BlockFrag {
  57:     vec2 texCoords;
  58:     vec4 color;
  59:     float diffuse;
  60:     vec2 light;
  61: };
  62: 
  63: void FLWMain(BlockFrag r) {
  64:     vec4 tex = FLWBlockTexture(r.texCoords);
  65: 
  66:     vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;
  67: 
  68: //    flw_WorldPos = ;
  69: //    flw_Normal = ;
  70: //    flw_Albedo = tex.rgb;
  71: //    flw_Alpha = tex.a;
  72: //    flw_LightMap = r.light;
  73: //    flw_Tint = r.color;
  74:     FLWFinalizeColor(color);
  75: }
  76: 
  77: varying vec2 v2f_texCoords;
  78: varying vec4 v2f_color;
  79: varying float v2f_diffuse;
  80: varying vec2 v2f_light;
  81: 
  82: 
  83: //vec3 flw_WorldPos;
  84: //vec3 flw_Normal;
  85: //vec3 flw_Albedo;
  86: //float flw_Alpha;
  87: //vec2 flw_LightMap;
  88: //vec4 flw_Tint;
  89: 
  90: void main() {
  91:     BlockFrag f;
  92:     f.texCoords = v2f_texCoords;
  93: f.color = v2f_color;
  94: f.diffuse = v2f_diffuse;
  95: f.light = v2f_light;
  96: 
  97: 
  98:     FLWMain(f);
  99: }

[12:29:45] [main/ERROR]: Shader compilation log for create:belt.vert: No errors.

[12:29:45] [main/ERROR]: Source for shader 'create:belt.vert':
   1: #version 110
   2: #define USE_FOG
   3: #define USE_FOG_EXP2
   4: 
   5: #define PI 3.1415926538
   6: 
   7: uniform float uTime;
   8: uniform mat4 uViewProjection;
   9: uniform vec3 uCameraPos;
  10: 
  11: #if defined(USE_FOG)
  12: varying float FragDistance;
  13: #endif
  14: 
  15: void FLWFinalizeWorldPos(inout vec4 worldPos) {
  16:     #if defined(USE_FOG)
  17:     FragDistance = length(worldPos.xyz - uCameraPos);
  18:     #endif
  19: 
  20:     gl_Position = uViewProjection * worldPos;
  21: }
  22: 
  23: void FLWFinalizeNormal(inout vec3 normal) {
  24:     // noop
  25: }
  26: 
  27: 
  28: #define PIOVER2 1.5707963268
  29: 
  30: vec4 quat(vec3 axis, float angle) {
  31:     float halfAngle = angle * PIOVER2 / 180.0;
  32:     vec2 cs = sin(vec2(PIOVER2 - halfAngle, halfAngle)); // compute sin and cos in one instruction
  33:     return vec4(axis.xyz * cs.y,  cs.x);
  34: }
  35: 
  36: vec4 quatMult(vec4 q1, vec4 q2) {
  37:     // disgustingly vectorized quaternion multiplication
  38:     vec4 a = q1.w * q2.xyzw;
  39:     vec4 b = q1.x * q2.wzxy * vec4(1., -1., 1., -1.);
  40:     vec4 c = q1.y * q2.zwxy * vec4(1., 1., -1., -1.);
  41:     vec4 d = q1.z * q2.yxwz * vec4(-1., 1., 1., -1.);
  42: 
  43:     return a + b + c + d;
  44: }
  45: 
  46: vec3 rotateVertexByQuat(vec3 v, vec4 q) {
  47:     vec3 i = q.xyz;
  48:     return v + 2.0 * cross(i, cross(i, v) + q.w * v);
  49: }
  50: 
  51: vec3 rotateAbout(vec3 v, vec3 axis, float angle) {
  52:     return rotateVertexByQuat(v, quat(axis, angle));
  53: }
  54: 
  55: mat4 rotate(vec3 axis, float angle) {
  56:     float s = sin(angle);
  57:     float c = cos(angle);
  58:     float oc = 1. - c;
  59: 
  60:     vec3 sa = axis * s;
  61: 
  62:     mat4 mr = mat4(1.);
  63:     mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
  64:     mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
  65:     mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);
  66: 
  67:     return mr;
  68: }
  69: 
  70: mat4 rotation(vec3 rot) {
  71:     return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
  72: }
  73: 
  74: mat3 modelToNormal(mat4 mat) {
  75:     // Discard the edges. This won't be accurate for scaled or skewed matrices,
  76:     // but we don't have to work with those often.
  77:     mat3 m;
  78:     m[0] = mat[0].xyz;
  79:     m[1] = mat[1].xyz;
  80:     m[2] = mat[2].xyz;
  81:     return m;
  82: }
  83: 
  84: float diffuse(vec3 normal) {
  85:     vec3 n2 = normal * normal * vec3(.6, .25, .8);
  86:     return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
  87: }
  88: 
  89: 
  90: struct Belt {
  91:     vec2 light;
  92:     vec4 color;
  93:     vec3 pos;
  94:     float speed;
  95:     float offset;
  96:     vec4 rotation;
  97:     vec2 sourceTexture;
  98:     vec4 scrollTexture;
  99:     float scrollMult;
 100: };
 101: 
 102: 
 103: struct Vertex {
 104:     vec3 pos;
 105:     vec3 normal;
 106:     vec2 texCoords;
 107: };
 108: 
 109: struct BlockFrag {
 110:     vec2 texCoords;
 111:     vec4 color;
 112:     float diffuse;
 113:     vec2 light;
 114: };
 115: 
 116: BlockFrag FLWMain(Vertex v, Belt instance) {
 117:     vec3 rotated = rotateVertexByQuat(v.pos - .5, instance.rotation) + instance.pos + .5;
 118: 
 119:     vec4 worldPos = vec4(rotated, 1.);
 120: 
 121:     vec3 norm = rotateVertexByQuat(v.normal, instance.rotation);
 122: 
 123:     FLWFinalizeWorldPos(worldPos);
 124:     FLWFinalizeNormal(norm);
 125: 
 126:     float scrollSize = instance.scrollTexture.w - instance.scrollTexture.y;
 127:     float scroll = fract(instance.speed * uTime / (31.5 * 16.) + instance.offset) * scrollSize * instance.scrollMult;
 128: 
 129:     BlockFrag b;
 130:     b.diffuse = diffuse(norm);
 131:     b.texCoords = v.texCoords - instance.sourceTexture + instance.scrollTexture.xy + vec2(0, scroll);
 132:     b.light = instance.light;
 133: 
 134:     #if defined(DEBUG_RAINBOW)
 135:     b.color = instance.color;
 136:     #elif defined(DEBUG_NORMAL)
 137:     b.color = vec4(norm, 1.);
 138:     #else
 139:     b.color = vec4(1.);
 140:     #endif
 141: 
 142:     return b;
 143: }
 144: attribute vec3 a_v_pos;
 145: attribute vec3 a_v_normal;
 146: attribute vec2 a_v_texCoords;
 147: 
 148: attribute vec2 a_i_light;
 149: attribute vec4 a_i_color;
 150: attribute vec3 a_i_pos;
 151: attribute float a_i_speed;
 152: attribute float a_i_offset;
 153: attribute vec4 a_i_rotation;
 154: attribute vec2 a_i_sourceTexture;
 155: attribute vec4 a_i_scrollTexture;
 156: attribute float a_i_scrollMult;
 157: 
 158: 
 159: varying vec2 v2f_texCoords;
 160: varying vec4 v2f_color;
 161: varying float v2f_diffuse;
 162: varying vec2 v2f_light;
 163: 
 164: 
 165: void main() {
 166:     Vertex v;
 167:     v.pos = a_v_pos;
 168: v.normal = a_v_normal;
 169: v.texCoords = a_v_texCoords;
 170: 
 171: 
 172:     Belt i;
 173:     i.light = a_i_light;
 174: i.color = a_i_color;
 175: i.pos = a_i_pos;
 176: i.speed = a_i_speed;
 177: i.offset = a_i_offset;
 178: i.rotation = a_i_rotation;
 179: i.sourceTexture = a_i_sourceTexture;
 180: i.scrollTexture = a_i_scrollTexture;
 181: i.scrollMult = a_i_scrollMult;
 182: 
 183: 
 184:     BlockFrag o = FLWMain(v, i);
 185: 
 186:     v2f_texCoords = o.texCoords;
 187: v2f_color = o.color;
 188: v2f_diffuse = o.diffuse;
 189: v2f_light = o.light;
 190: 
 191: }

[12:29:45] [main/ERROR]: Shader compilation log for flywheel:block.frag: No errors.

[12:29:45] [main/ERROR]: Source for shader 'flywheel:block.frag':
   1: #version 110
   2: #define USE_FOG
   3: #define USE_FOG_EXP2
   4: 
   5: #if defined(USE_FOG)
   6: varying float FragDistance;
   7: uniform vec4 uFogColor;
   8: #endif
   9: 
  10: #if defined(USE_FOG_LINEAR)
  11: uniform vec2 uFogRange;
  12: 
  13: float FLWFogFactor() {
  14:     return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
  15: }
  16:     #endif
  17: 
  18:     #if defined(USE_FOG_EXP2)
  19: uniform float uFogDensity;
  20: 
  21: float FLWFogFactor() {
  22:     float dist = FragDistance * uFogDensity;
  23:     return 1. / exp2(dist * dist);
  24: }
  25:     #endif
  26: // Adjust the [0,1] normalized lightmap value based on the texture matrix from LightTexture#enableLightmap
  27: vec2 shiftLight(vec2 lm) {
  28:     return lm * 0.99609375 + 0.03125;// * 255/256 + 1/32
  29: }
  30: 
  31: uniform sampler2D uBlockAtlas;
  32: uniform sampler2D uLightMap;
  33: 
  34: vec4 FLWBlockTexture(vec2 texCoords) {
  35:     return texture2D(uBlockAtlas, texCoords);
  36: }
  37: 
  38: void FLWFinalizeColor(vec4 color) {
  39:     #if defined(USE_FOG)
  40:     float a = color.a;
  41:     float fog = clamp(FLWFogFactor(), 0., 1.);
  42: 
  43:     color = mix(uFogColor, color, fog);
  44:     color.a = a;
  45:     #endif
  46: 
  47:     gl_FragColor = color;
  48: }
  49: 
  50: vec4 FLWLight(vec2 lightCoords) {
  51:     return texture2D(uLightMap, shiftLight(lightCoords));
  52: }
  53: 
  54: 
  55: 
  56: struct BlockFrag {
  57:     vec2 texCoords;
  58:     vec4 color;
  59:     float diffuse;
  60:     vec2 light;
  61: };
  62: 
  63: void FLWMain(BlockFrag r) {
  64:     vec4 tex = FLWBlockTexture(r.texCoords);
  65: 
  66:     vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;
  67: 
  68: //    flw_WorldPos = ;
  69: //    flw_Normal = ;
  70: //    flw_Albedo = tex.rgb;
  71: //    flw_Alpha = tex.a;
  72: //    flw_LightMap = r.light;
  73: //    flw_Tint = r.color;
  74:     FLWFinalizeColor(color);
  75: }
  76: 
  77: varying vec2 v2f_texCoords;
  78: varying vec4 v2f_color;
  79: varying float v2f_diffuse;
  80: varying vec2 v2f_light;
  81: 
  82: 
  83: //vec3 flw_WorldPos;
  84: //vec3 flw_Normal;
  85: //vec3 flw_Albedo;
  86: //float flw_Alpha;
  87: //vec2 flw_LightMap;
  88: //vec4 flw_Tint;
  89: 
  90: void main() {
  91:     BlockFrag f;
  92:     f.texCoords = v2f_texCoords;
  93: f.color = v2f_color;
  94: f.diffuse = v2f_diffuse;
  95: f.light = v2f_light;
  96: 
  97: 
  98:     FLWMain(f);
  99: }

[12:29:45] [main/ERROR]: Shader compilation log for create:belt.vert: No errors.

[12:29:45] [main/ERROR]: Source for shader 'create:belt.vert':
   1: #version 110
   2: 
   3: #define PI 3.1415926538
   4: 
   5: uniform float uTime;
   6: uniform mat4 uViewProjection;
   7: uniform vec3 uCameraPos;
   8: 
   9: #if defined(USE_FOG)
  10: varying float FragDistance;
  11: #endif
  12: 
  13: void FLWFinalizeWorldPos(inout vec4 worldPos) {
  14:     #if defined(USE_FOG)
  15:     FragDistance = length(worldPos.xyz - uCameraPos);
  16:     #endif
  17: 
  18:     gl_Position = uViewProjection * worldPos;
  19: }
  20: 
  21: void FLWFinalizeNormal(inout vec3 normal) {
  22:     // noop
  23: }
  24: 
  25: 
  26: #define PIOVER2 1.5707963268
  27: 
  28: vec4 quat(vec3 axis, float angle) {
  29:     float halfAngle = angle * PIOVER2 / 180.0;
  30:     vec2 cs = sin(vec2(PIOVER2 - halfAngle, halfAngle)); // compute sin and cos in one instruction
  31:     return vec4(axis.xyz * cs.y,  cs.x);
  32: }
  33: 
  34: vec4 quatMult(vec4 q1, vec4 q2) {
  35:     // disgustingly vectorized quaternion multiplication
  36:     vec4 a = q1.w * q2.xyzw;
  37:     vec4 b = q1.x * q2.wzxy * vec4(1., -1., 1., -1.);
  38:     vec4 c = q1.y * q2.zwxy * vec4(1., 1., -1., -1.);
  39:     vec4 d = q1.z * q2.yxwz * vec4(-1., 1., 1., -1.);
  40: 
  41:     return a + b + c + d;
  42: }
  43: 
  44: vec3 rotateVertexByQuat(vec3 v, vec4 q) {
  45:     vec3 i = q.xyz;
  46:     return v + 2.0 * cross(i, cross(i, v) + q.w * v);
  47: }
  48: 
  49: vec3 rotateAbout(vec3 v, vec3 axis, float angle) {
  50:     return rotateVertexByQuat(v, quat(axis, angle));
  51: }
  52: 
  53: mat4 rotate(vec3 axis, float angle) {
  54:     float s = sin(angle);
  55:     float c = cos(angle);
  56:     float oc = 1. - c;
  57: 
  58:     vec3 sa = axis * s;
  59: 
  60:     mat4 mr = mat4(1.);
  61:     mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
  62:     mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
  63:     mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);
  64: 
  65:     return mr;
  66: }
  67: 
  68: mat4 rotation(vec3 rot) {
  69:     return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
  70: }
  71: 
  72: mat3 modelToNormal(mat4 mat) {
  73:     // Discard the edges. This won't be accurate for scaled or skewed matrices,
  74:     // but we don't have to work with those often.
  75:     mat3 m;
  76:     m[0] = mat[0].xyz;
  77:     m[1] = mat[1].xyz;
  78:     m[2] = mat[2].xyz;
  79:     return m;
  80: }
  81: 
  82: float diffuse(vec3 normal) {
  83:     vec3 n2 = normal * normal * vec3(.6, .25, .8);
  84:     return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
  85: }
  86: 
  87: 
  88: struct Belt {
  89:     vec2 light;
  90:     vec4 color;
  91:     vec3 pos;
  92:     float speed;
  93:     float offset;
  94:     vec4 rotation;
  95:     vec2 sourceTexture;
  96:     vec4 scrollTexture;
  97:     float scrollMult;
  98: };
  99: 
 100: 
 101: struct Vertex {
 102:     vec3 pos;
 103:     vec3 normal;
 104:     vec2 texCoords;
 105: };
 106: 
 107: struct BlockFrag {
 108:     vec2 texCoords;
 109:     vec4 color;
 110:     float diffuse;
 111:     vec2 light;
 112: };
 113: 
 114: BlockFrag FLWMain(Vertex v, Belt instance) {
 115:     vec3 rotated = rotateVertexByQuat(v.pos - .5, instance.rotation) + instance.pos + .5;
 116: 
 117:     vec4 worldPos = vec4(rotated, 1.);
 118: 
 119:     vec3 norm = rotateVertexByQuat(v.normal, instance.rotation);
 120: 
 121:     FLWFinalizeWorldPos(worldPos);
 122:     FLWFinalizeNormal(norm);
 123: 
 124:     float scrollSize = instance.scrollTexture.w - instance.scrollTexture.y;
 125:     float scroll = fract(instance.speed * uTime / (31.5 * 16.) + instance.offset) * scrollSize * instance.scrollMult;
 126: 
 127:     BlockFrag b;
 128:     b.diffuse = diffuse(norm);
 129:     b.texCoords = v.texCoords - instance.sourceTexture + instance.scrollTexture.xy + vec2(0, scroll);
 130:     b.light = instance.light;
 131: 
 132:     #if defined(DEBUG_RAINBOW)
 133:     b.color = instance.color;
 134:     #elif defined(DEBUG_NORMAL)
 135:     b.color = vec4(norm, 1.);
 136:     #else
 137:     b.color = vec4(1.);
 138:     #endif
 139: 
 140:     return b;
 141: }
 142: attribute vec3 a_v_pos;
 143: attribute vec3 a_v_normal;
 144: attribute vec2 a_v_texCoords;
 145: 
 146: attribute vec2 a_i_light;
 147: attribute vec4 a_i_color;
 148: attribute vec3 a_i_pos;
 149: attribute float a_i_speed;
 150: attribute float a_i_offset;
 151: attribute vec4 a_i_rotation;
 152: attribute vec2 a_i_sourceTexture;
 153: attribute vec4 a_i_scrollTexture;
 154: attribute float a_i_scrollMult;
 155: 
 156: 
 157: varying vec2 v2f_texCoords;
 158: varying vec4 v2f_color;
 159: varying float v2f_diffuse;
 160: varying vec2 v2f_light;
 161: 
 162: 
 163: void main() {
 164:     Vertex v;
 165:     v.pos = a_v_pos;
 166: v.normal = a_v_normal;
 167: v.texCoords = a_v_texCoords;
 168: 
 169: 
 170:     Belt i;
 171:     i.light = a_i_light;
 172: i.color = a_i_color;
 173: i.pos = a_i_pos;
 174: i.speed = a_i_speed;
 175: i.offset = a_i_offset;
 176: i.rotation = a_i_rotation;
 177: i.sourceTexture = a_i_sourceTexture;
 178: i.scrollTexture = a_i_scrollTexture;
 179: i.scrollMult = a_i_scrollMult;
 180: 
 181: 
 182:     BlockFrag o = FLWMain(v, i);
 183: 
 184:     v2f_texCoords = o.texCoords;
 185: v2f_color = o.color;
 186: v2f_diffuse = o.diffuse;
 187: v2f_light = o.light;
 188: 
 189: }

[12:29:45] [main/ERROR]: Shader compilation log for flywheel:block.frag: No errors.

[12:29:45] [main/ERROR]: Source for shader 'flywheel:block.frag':
   1: #version 110
   2: 
   3: #if defined(USE_FOG)
   4: varying float FragDistance;
   5: uniform vec4 uFogColor;
   6: #endif
   7: 
   8: #if defined(USE_FOG_LINEAR)
   9: uniform vec2 uFogRange;
  10: 
  11: float FLWFogFactor() {
  12:     return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
  13: }
  14:     #endif
  15: 
  16:     #if defined(USE_FOG_EXP2)
  17: uniform float uFogDensity;
  18: 
  19: float FLWFogFactor() {
  20:     float dist = FragDistance * uFogDensity;
  21:     return 1. / exp2(dist * dist);
  22: }
  23:     #endif
  24: // Adjust the [0,1] normalized lightmap value based on the texture matrix from LightTexture#enableLightmap
  25: vec2 shiftLight(vec2 lm) {
  26:     return lm * 0.99609375 + 0.03125;// * 255/256 + 1/32
  27: }
  28: 
  29: uniform sampler2D uBlockAtlas;
  30: uniform sampler2D uLightMap;
  31: 
  32: vec4 FLWBlockTexture(vec2 texCoords) {
  33:     return texture2D(uBlockAtlas, texCoords);
  34: }
  35: 
  36: void FLWFinalizeColor(vec4 color) {
  37:     #if defined(USE_FOG)
  38:     float a = color.a;
  39:     float fog = clamp(FLWFogFactor(), 0., 1.);
  40: 
  41:     color = mix(uFogColor, color, fog);
  42:     color.a = a;
  43:     #endif
  44: 
  45:     gl_FragColor = color;
  46: }
  47: 
  48: vec4 FLWLight(vec2 lightCoords) {
  49:     return texture2D(uLightMap, shiftLight(lightCoords));
  50: }
  51: 
  52: 
  53: 
  54: struct BlockFrag {
  55:     vec2 texCoords;
  56:     vec4 color;
  57:     float diffuse;
  58:     vec2 light;
  59: };
  60: 
  61: void FLWMain(BlockFrag r) {
  62:     vec4 tex = FLWBlockTexture(r.texCoords);
  63: 
  64:     vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;
  65: 
  66: //    flw_WorldPos = ;
  67: //    flw_Normal = ;
  68: //    flw_Albedo = tex.rgb;
  69: //    flw_Alpha = tex.a;
  70: //    flw_LightMap = r.light;
  71: //    flw_Tint = r.color;
  72:     FLWFinalizeColor(color);
  73: }
  74: 
  75: varying vec2 v2f_texCoords;
  76: varying vec4 v2f_color;
  77: varying float v2f_diffuse;
  78: varying vec2 v2f_light;
  79: 
  80: 
  81: //vec3 flw_WorldPos;
  82: //vec3 flw_Normal;
  83: //vec3 flw_Albedo;
  84: //float flw_Alpha;
  85: //vec2 flw_LightMap;
  86: //vec4 flw_Tint;
  87: 
  88: void main() {
  89:     BlockFrag f;
  90:     f.texCoords = v2f_texCoords;
  91: f.color = v2f_color;
  92: f.diffuse = v2f_diffuse;
  93: f.light = v2f_light;
  94: 
  95: 
  96:     FLWMain(f);
  97: }

[12:29:45] [main/ERROR]: Shader compilation log for flywheel:oriented.vert: No errors.

[12:29:45] [main/ERROR]: Source for shader 'flywheel:oriented.vert':
   1: #version 110
   2: #define DEBUG_NORMAL
   3: 
   4: uniform float uTime;
   5: uniform mat4 uViewProjection;
   6: uniform vec3 uCameraPos;
   7: 
   8: #if defined(USE_FOG)
   9: varying float FragDistance;
  10: #endif
  11: 
  12: void FLWFinalizeWorldPos(inout vec4 worldPos) {
  13:     #if defined(USE_FOG)
  14:     FragDistance = length(worldPos.xyz - uCameraPos);
  15:     #endif
  16: 
  17:     gl_Position = uViewProjection * worldPos;
  18: }
  19: 
  20: void FLWFinalizeNormal(inout vec3 normal) {
  21:     // noop
  22: }
  23: 
  24: 
  25: mat4 rotate(vec3 axis, float angle) {
  26:     float s = sin(angle);
  27:     float c = cos(angle);
  28:     float oc = 1. - c;
  29: 
  30:     vec3 sa = axis * s;
  31: 
  32:     mat4 mr = mat4(1.);
  33:     mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
  34:     mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
  35:     mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);
  36: 
  37:     return mr;
  38: }
  39: 
  40: mat4 rotation(vec3 rot) {
  41:     return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
  42: }
  43: 
  44: mat3 modelToNormal(mat4 mat) {
  45:     // Discard the edges. This won't be accurate for scaled or skewed matrices,
  46:     // but we don't have to work with those often.
  47:     mat3 m;
  48:     m[0] = mat[0].xyz;
  49:     m[1] = mat[1].xyz;
  50:     m[2] = mat[2].xyz;
  51:     return m;
  52: }
  53: 
  54: #define PIOVER2 1.5707963268
  55: 
  56: vec4 quat(vec3 axis, float angle) {
  57:     float halfAngle = angle * PIOVER2 / 180.0;
  58:     vec2 cs = sin(vec2(PIOVER2 - halfAngle, halfAngle)); // compute sin and cos in one instruction
  59:     return vec4(axis.xyz * cs.y,  cs.x);
  60: }
  61: 
  62: vec4 quatMult(vec4 q1, vec4 q2) {
  63:     // disgustingly vectorized quaternion multiplication
  64:     vec4 a = q1.w * q2.xyzw;
  65:     vec4 b = q1.x * q2.wzxy * vec4(1., -1., 1., -1.);
  66:     vec4 c = q1.y * q2.zwxy * vec4(1., 1., -1., -1.);
  67:     vec4 d = q1.z * q2.yxwz * vec4(-1., 1., 1., -1.);
  68: 
  69:     return a + b + c + d;
  70: }
  71: 
  72: vec3 rotateVertexByQuat(vec3 v, vec4 q) {
  73:     vec3 i = q.xyz;
  74:     return v + 2.0 * cross(i, cross(i, v) + q.w * v);
  75: }
  76: 
  77: vec3 rotateAbout(vec3 v, vec3 axis, float angle) {
  78:     return rotateVertexByQuat(v, quat(axis, angle));
  79: }
  80: 
  81: float diffuse(vec3 normal) {
  82:     vec3 n2 = normal * normal * vec3(.6, .25, .8);
  83:     return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
  84: }
  85: 
  86: 
  87: struct Oriented {
  88:     vec2 light;
  89:     vec4 color;
  90:     vec3 pos;
  91:     vec3 pivot;
  92:     vec4 rotation;
  93: };
  94: 
  95: 
  96: struct Vertex {
  97:     vec3 pos;
  98:     vec3 normal;
  99:     vec2 texCoords;
 100: };
 101: 
 102: struct BlockFrag {
 103:     vec2 texCoords;
 104:     vec4 color;
 105:     float diffuse;
 106:     vec2 light;
 107: };
 108: 
 109: BlockFrag FLWMain(Vertex v, Oriented o) {
 110:     vec4 worldPos = vec4(rotateVertexByQuat(v.pos - o.pivot, o.rotation) + o.pivot + o.pos, 1.);
 111: 
 112:     vec3 norm = rotateVertexByQuat(v.normal, o.rotation);
 113: 
 114:     FLWFinalizeWorldPos(worldPos);
 115:     FLWFinalizeNormal(norm);
 116: 
 117:     BlockFrag b;
 118:     b.diffuse = diffuse(norm);
 119:     b.texCoords = v.texCoords;
 120:     b.light = o.light;
 121:     #if defined(DEBUG_NORMAL)
 122:     b.color = vec4(norm, 1.);
 123:     #else
 124:     b.color = o.color;
 125:     #endif
 126:     return b;
 127: }
 128: attribute vec3 a_v_pos;
 129: attribute vec3 a_v_normal;
 130: attribute vec2 a_v_texCoords;
 131: 
 132: attribute vec2 a_i_light;
 133: attribute vec4 a_i_color;
 134: attribute vec3 a_i_pos;
 135: attribute vec3 a_i_pivot;
 136: attribute vec4 a_i_rotation;
 137: 
 138: 
 139: varying vec2 v2f_texCoords;
 140: varying vec4 v2f_color;
 141: varying float v2f_diffuse;
 142: varying vec2 v2f_light;
 143: 
 144: 
 145: void main() {
 146:     Vertex v;
 147:     v.pos = a_v_pos;
 148: v.normal = a_v_normal;
 149: v.texCoords = a_v_texCoords;
 150: 
 151: 
 152:     Oriented i;
 153:     i.light = a_i_light;
 154: i.color = a_i_color;
 155: i.pos = a_i_pos;
 156: i.pivot = a_i_pivot;
 157: i.rotation = a_i_rotation;
 158: 
 159: 
 160:     BlockFrag o = FLWMain(v, i);
 161: 
 162:     v2f_texCoords = o.texCoords;
 163: v2f_color = o.color;
 164: v2f_diffuse = o.diffuse;
 165: v2f_light = o.light;
 166: 
 167: }

[12:29:45] [main/ERROR]: Shader compilation log for flywheel:block.frag: No errors.

[12:29:45] [main/ERROR]: Source for shader 'flywheel:block.frag':
   1: #version 110
   2: #define DEBUG_NORMAL
   3: 
   4: #if defined(USE_FOG)
   5: varying float FragDistance;
   6: uniform vec4 uFogColor;
   7: #endif
   8: 
   9: #if defined(USE_FOG_LINEAR)
  10: uniform vec2 uFogRange;
  11: 
  12: float FLWFogFactor() {
  13:     return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
  14: }
  15:     #endif
  16: 
  17:     #if defined(USE_FOG_EXP2)
  18: uniform float uFogDensity;
  19: 
  20: float FLWFogFactor() {
  21:     float dist = FragDistance * uFogDensity;
  22:     return 1. / exp2(dist * dist);
  23: }
  24:     #endif
  25: // Adjust the [0,1] normalized lightmap value based on the texture matrix from LightTexture#enableLightmap
  26: vec2 shiftLight(vec2 lm) {
  27:     return lm * 0.99609375 + 0.03125;// * 255/256 + 1/32
  28: }
  29: 
  30: uniform sampler2D uBlockAtlas;
  31: uniform sampler2D uLightMap;
  32: 
  33: vec4 FLWBlockTexture(vec2 texCoords) {
  34:     return texture2D(uBlockAtlas, texCoords);
  35: }
  36: 
  37: void FLWFinalizeColor(vec4 color) {
  38:     #if defined(USE_FOG)
  39:     float a = color.a;
  40:     float fog = clamp(FLWFogFactor(), 0., 1.);
  41: 
  42:     color = mix(uFogColor, color, fog);
  43:     color.a = a;
  44:     #endif
  45: 
  46:     gl_FragColor = color;
  47: }
  48: 
  49: vec4 FLWLight(vec2 lightCoords) {
  50:     return texture2D(uLightMap, shiftLight(lightCoords));
  51: }
  52: 
  53: 
  54: 
  55: struct BlockFrag {
  56:     vec2 texCoords;
  57:     vec4 color;
  58:     float diffuse;
  59:     vec2 light;
  60: };
  61: 
  62: void FLWMain(BlockFrag r) {
  63:     vec4 tex = FLWBlockTexture(r.texCoords);
  64: 
  65:     vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;
  66: 
  67: //    flw_WorldPos = ;
  68: //    flw_Normal = ;
  69: //    flw_Albedo = tex.rgb;
  70: //    flw_Alpha = tex.a;
  71: //    flw_LightMap = r.light;
  72: //    flw_Tint = r.color;
  73:     FLWFinalizeColor(color);
  74: }
  75: 
  76: varying vec2 v2f_texCoords;
  77: varying vec4 v2f_color;
  78: varying float v2f_diffuse;
  79: varying vec2 v2f_light;
  80: 
  81: 
  82: //vec3 flw_WorldPos;
  83: //vec3 flw_Normal;
  84: //vec3 flw_Albedo;
  85: //float flw_Alpha;
  86: //vec2 flw_LightMap;
  87: //vec4 flw_Tint;
  88: 
  89: void main() {
  90:     BlockFrag f;
  91:     f.texCoords = v2f_texCoords;
  92: f.color = v2f_color;
  93: f.diffuse = v2f_diffuse;
  94: f.light = v2f_light;
  95: 
  96: 
  97:     FLWMain(f);
  98: }

[12:29:45] [main/ERROR]: Shader compilation log for flywheel:oriented.vert: No errors.

[12:29:45] [main/ERROR]: Source for shader 'flywheel:oriented.vert':
   1: #version 110
   2: #define USE_FOG
   3: #define USE_FOG_LINEAR
   4: 
   5: uniform float uTime;
   6: uniform mat4 uViewProjection;
   7: uniform vec3 uCameraPos;
   8: 
   9: #if defined(USE_FOG)
  10: varying float FragDistance;
  11: #endif
  12: 
  13: void FLWFinalizeWorldPos(inout vec4 worldPos) {
  14:     #if defined(USE_FOG)
  15:     FragDistance = length(worldPos.xyz - uCameraPos);
  16:     #endif
  17: 
  18:     gl_Position = uViewProjection * worldPos;
  19: }
  20: 
  21: void FLWFinalizeNormal(inout vec3 normal) {
  22:     // noop
  23: }
  24: 
  25: 
  26: mat4 rotate(vec3 axis, float angle) {
  27:     float s = sin(angle);
  28:     float c = cos(angle);
  29:     float oc = 1. - c;
  30: 
  31:     vec3 sa = axis * s;
  32: 
  33:     mat4 mr = mat4(1.);
  34:     mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
  35:     mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
  36:     mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);
  37: 
  38:     return mr;
  39: }
  40: 
  41: mat4 rotation(vec3 rot) {
  42:     return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
  43: }
  44: 
  45: mat3 modelToNormal(mat4 mat) {
  46:     // Discard the edges. This won't be accurate for scaled or skewed matrices,
  47:     // but we don't have to work with those often.
  48:     mat3 m;
  49:     m[0] = mat[0].xyz;
  50:     m[1] = mat[1].xyz;
  51:     m[2] = mat[2].xyz;
  52:     return m;
  53: }
  54: 
  55: #define PIOVER2 1.5707963268
  56: 
  57: vec4 quat(vec3 axis, float angle) {
  58:     float halfAngle = angle * PIOVER2 / 180.0;
  59:     vec2 cs = sin(vec2(PIOVER2 - halfAngle, halfAngle)); // compute sin and cos in one instruction
  60:     return vec4(axis.xyz * cs.y,  cs.x);
  61: }
  62: 
  63: vec4 quatMult(vec4 q1, vec4 q2) {
  64:     // disgustingly vectorized quaternion multiplication
  65:     vec4 a = q1.w * q2.xyzw;
  66:     vec4 b = q1.x * q2.wzxy * vec4(1., -1., 1., -1.);
  67:     vec4 c = q1.y * q2.zwxy * vec4(1., 1., -1., -1.);
  68:     vec4 d = q1.z * q2.yxwz * vec4(-1., 1., 1., -1.);
  69: 
  70:     return a + b + c + d;
  71: }
  72: 
  73: vec3 rotateVertexByQuat(vec3 v, vec4 q) {
  74:     vec3 i = q.xyz;
  75:     return v + 2.0 * cross(i, cross(i, v) + q.w * v);
  76: }
  77: 
  78: vec3 rotateAbout(vec3 v, vec3 axis, float angle) {
  79:     return rotateVertexByQuat(v, quat(axis, angle));
  80: }
  81: 
  82: float diffuse(vec3 normal) {
  83:     vec3 n2 = normal * normal * vec3(.6, .25, .8);
  84:     return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
  85: }
  86: 
  87: 
  88: struct Oriented {
  89:     vec2 light;
  90:     vec4 color;
  91:     vec3 pos;
  92:     vec3 pivot;
  93:     vec4 rotation;
  94: };
  95: 
  96: 
  97: struct Vertex {
  98:     vec3 pos;
  99:     vec3 normal;
 100:     vec2 texCoords;
 101: };
 102: 
 103: struct BlockFrag {
 104:     vec2 texCoords;
 105:     vec4 color;
 106:     float diffuse;
 107:     vec2 light;
 108: };
 109: 
 110: BlockFrag FLWMain(Vertex v, Oriented o) {
 111:     vec4 worldPos = vec4(rotateVertexByQuat(v.pos - o.pivot, o.rotation) + o.pivot + o.pos, 1.);
 112: 
 113:     vec3 norm = rotateVertexByQuat(v.normal, o.rotation);
 114: 
 115:     FLWFinalizeWorldPos(worldPos);
 116:     FLWFinalizeNormal(norm);
 117: 
 118:     BlockFrag b;
 119:     b.diffuse = diffuse(norm);
 120:     b.texCoords = v.texCoords;
 121:     b.light = o.light;
 122:     #if defined(DEBUG_NORMAL)
 123:     b.color = vec4(norm, 1.);
 124:     #else
 125:     b.color = o.color;
 126:     #endif
 127:     return b;
 128: }
 129: attribute vec3 a_v_pos;
 130: attribute vec3 a_v_normal;
 131: attribute vec2 a_v_texCoords;
 132: 
 133: attribute vec2 a_i_light;
 134: attribute vec4 a_i_color;
 135: attribute vec3 a_i_pos;
 136: attribute vec3 a_i_pivot;
 137: attribute vec4 a_i_rotation;
 138: 
 139: 
 140: varying vec2 v2f_texCoords;
 141: varying vec4 v2f_color;
 142: varying float v2f_diffuse;
 143: varying vec2 v2f_light;
 144: 
 145: 
 146: void main() {
 147:     Vertex v;
 148:     v.pos = a_v_pos;
 149: v.normal = a_v_normal;
 150: v.texCoords = a_v_texCoords;
 151: 
 152: 
 153:     Oriented i;
 154:     i.light = a_i_light;
 155: i.color = a_i_color;
 156: i.pos = a_i_pos;
 157: i.pivot = a_i_pivot;
 158: i.rotation = a_i_rotation;
 159: 
 160: 
 161:     BlockFrag o = FLWMain(v, i);
 162: 
 163:     v2f_texCoords = o.texCoords;
 164: v2f_color = o.color;
 165: v2f_diffuse = o.diffuse;
 166: v2f_light = o.light;
 167: 
 168: }

[12:29:45] [main/ERROR]: Shader compilation log for flywheel:block.frag: No errors.

[12:29:45] [main/ERROR]: Source for shader 'flywheel:block.frag':
   1: #version 110
   2: #define USE_FOG
   3: #define USE_FOG_LINEAR
   4: 
   5: #if defined(USE_FOG)
   6: varying float FragDistance;
   7: uniform vec4 uFogColor;
   8: #endif
   9: 
  10: #if defined(USE_FOG_LINEAR)
  11: uniform vec2 uFogRange;
  12: 
  13: float FLWFogFactor() {
  14:     return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
  15: }
  16:     #endif
  17: 
  18:     #if defined(USE_FOG_EXP2)
  19: uniform float uFogDensity;
  20: 
  21: float FLWFogFactor() {
  22:     float dist = FragDistance * uFogDensity;
  23:     return 1. / exp2(dist * dist);
  24: }
  25:     #endif
  26: // Adjust the [0,1] normalized lightmap value based on the texture matrix from LightTexture#enableLightmap
  27: vec2 shiftLight(vec2 lm) {
  28:     return lm * 0.99609375 + 0.03125;// * 255/256 + 1/32
  29: }
  30: 
  31: uniform sampler2D uBlockAtlas;
  32: uniform sampler2D uLightMap;
  33: 
  34: vec4 FLWBlockTexture(vec2 texCoords) {
  35:     return texture2D(uBlockAtlas, texCoords);
  36: }
  37: 
  38: void FLWFinalizeColor(vec4 color) {
  39:     #if defined(USE_FOG)
  40:     float a = color.a;
  41:     float fog = clamp(FLWFogFactor(), 0., 1.);
  42: 
  43:     color = mix(uFogColor, color, fog);
  44:     color.a = a;
  45:     #endif
  46: 
  47:     gl_FragColor = color;
  48: }
  49: 
  50: vec4 FLWLight(vec2 lightCoords) {
  51:     return texture2D(uLightMap, shiftLight(lightCoords));
  52: }
  53: 
  54: 
  55: 
  56: struct BlockFrag {
  57:     vec2 texCoords;
  58:     vec4 color;
  59:     float diffuse;
  60:     vec2 light;
  61: };
  62: 
  63: void FLWMain(BlockFrag r) {
  64:     vec4 tex = FLWBlockTexture(r.texCoords);
  65: 
  66:     vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;
  67: 
  68: //    flw_WorldPos = ;
  69: //    flw_Normal = ;
  70: //    flw_Albedo = tex.rgb;
  71: //    flw_Alpha = tex.a;
  72: //    flw_LightMap = r.light;
  73: //    flw_Tint = r.color;
  74:     FLWFinalizeColor(color);
  75: }
  76: 
  77: varying vec2 v2f_texCoords;
  78: varying vec4 v2f_color;
  79: varying float v2f_diffuse;
  80: varying vec2 v2f_light;
  81: 
  82: 
  83: //vec3 flw_WorldPos;
  84: //vec3 flw_Normal;
  85: //vec3 flw_Albedo;
  86: //float flw_Alpha;
  87: //vec2 flw_LightMap;
  88: //vec4 flw_Tint;
  89: 
  90: void main() {
  91:     BlockFrag f;
  92:     f.texCoords = v2f_texCoords;
  93: f.color = v2f_color;
  94: f.diffuse = v2f_diffuse;
  95: f.light = v2f_light;
  96: 
  97: 
  98:     FLWMain(f);
  99: }

[12:29:45] [main/ERROR]: Shader compilation log for flywheel:oriented.vert: No errors.

[12:29:45] [main/ERROR]: Source for shader 'flywheel:oriented.vert':
   1: #version 110
   2: #define USE_FOG
   3: #define USE_FOG_EXP2
   4: 
   5: uniform float uTime;
   6: uniform mat4 uViewProjection;
   7: uniform vec3 uCameraPos;
   8: 
   9: #if defined(USE_FOG)
  10: varying float FragDistance;
  11: #endif
  12: 
  13: void FLWFinalizeWorldPos(inout vec4 worldPos) {
  14:     #if defined(USE_FOG)
  15:     FragDistance = length(worldPos.xyz - uCameraPos);
  16:     #endif
  17: 
  18:     gl_Position = uViewProjection * worldPos;
  19: }
  20: 
  21: void FLWFinalizeNormal(inout vec3 normal) {
  22:     // noop
  23: }
  24: 
  25: 
  26: mat4 rotate(vec3 axis, float angle) {
  27:     float s = sin(angle);
  28:     float c = cos(angle);
  29:     float oc = 1. - c;
  30: 
  31:     vec3 sa = axis * s;
  32: 
  33:     mat4 mr = mat4(1.);
  34:     mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
  35:     mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
  36:     mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);
  37: 
  38:     return mr;
  39: }
  40: 
  41: mat4 rotation(vec3 rot) {
  42:     return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
  43: }
  44: 
  45: mat3 modelToNormal(mat4 mat) {
  46:     // Discard the edges. This won't be accurate for scaled or skewed matrices,
  47:     // but we don't have to work with those often.
  48:     mat3 m;
  49:     m[0] = mat[0].xyz;
  50:     m[1] = mat[1].xyz;
  51:     m[2] = mat[2].xyz;
  52:     return m;
  53: }
  54: 
  55: #define PIOVER2 1.5707963268
  56: 
  57: vec4 quat(vec3 axis, float angle) {
  58:     float halfAngle = angle * PIOVER2 / 180.0;
  59:     vec2 cs = sin(vec2(PIOVER2 - halfAngle, halfAngle)); // compute sin and cos in one instruction
  60:     return vec4(axis.xyz * cs.y,  cs.x);
  61: }
  62: 
  63: vec4 quatMult(vec4 q1, vec4 q2) {
  64:     // disgustingly vectorized quaternion multiplication
  65:     vec4 a = q1.w * q2.xyzw;
  66:     vec4 b = q1.x * q2.wzxy * vec4(1., -1., 1., -1.);
  67:     vec4 c = q1.y * q2.zwxy * vec4(1., 1., -1., -1.);
  68:     vec4 d = q1.z * q2.yxwz * vec4(-1., 1., 1., -1.);
  69: 
  70:     return a + b + c + d;
  71: }
  72: 
  73: vec3 rotateVertexByQuat(vec3 v, vec4 q) {
  74:     vec3 i = q.xyz;
  75:     return v + 2.0 * cross(i, cross(i, v) + q.w * v);
  76: }
  77: 
  78: vec3 rotateAbout(vec3 v, vec3 axis, float angle) {
  79:     return rotateVertexByQuat(v, quat(axis, angle));
  80: }
  81: 
  82: float diffuse(vec3 normal) {
  83:     vec3 n2 = normal * normal * vec3(.6, .25, .8);
  84:     return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
  85: }
  86: 
  87: 
  88: struct Oriented {
  89:     vec2 light;
  90:     vec4 color;
  91:     vec3 pos;
  92:     vec3 pivot;
  93:     vec4 rotation;
  94: };
  95: 
  96: 
  97: struct Vertex {
  98:     vec3 pos;
  99:     vec3 normal;
 100:     vec2 texCoords;
 101: };
 102: 
 103: struct BlockFrag {
 104:     vec2 texCoords;
 105:     vec4 color;
 106:     float diffuse;
 107:     vec2 light;
 108: };
 109: 
 110: BlockFrag FLWMain(Vertex v, Oriented o) {
 111:     vec4 worldPos = vec4(rotateVertexByQuat(v.pos - o.pivot, o.rotation) + o.pivot + o.pos, 1.);
 112: 
 113:     vec3 norm = rotateVertexByQuat(v.normal, o.rotation);
 114: 
 115:     FLWFinalizeWorldPos(worldPos);
 116:     FLWFinalizeNormal(norm);
 117: 
 118:     BlockFrag b;
 119:     b.diffuse = diffuse(norm);
 120:     b.texCoords = v.texCoords;
 121:     b.light = o.light;
 122:     #if defined(DEBUG_NORMAL)
 123:     b.color = vec4(norm, 1.);
 124:     #else
 125:     b.color = o.color;
 126:     #endif
 127:     return b;
 128: }
 129: attribute vec3 a_v_pos;
 130: attribute vec3 a_v_normal;
 131: attribute vec2 a_v_texCoords;
 132: 
 133: attribute vec2 a_i_light;
 134: attribute vec4 a_i_color;
 135: attribute vec3 a_i_pos;
 136: attribute vec3 a_i_pivot;
 137: attribute vec4 a_i_rotation;
 138: 
 139: 
 140: varying vec2 v2f_texCoords;
 141: varying vec4 v2f_color;
 142: varying float v2f_diffuse;
 143: varying vec2 v2f_light;
 144: 
 145: 
 146: void main() {
 147:     Vertex v;
 148:     v.pos = a_v_pos;
 149: v.normal = a_v_normal;
 150: v.texCoords = a_v_texCoords;
 151: 
 152: 
 153:     Oriented i;
 154:     i.light = a_i_light;
 155: i.color = a_i_color;
 156: i.pos = a_i_pos;
 157: i.pivot = a_i_pivot;
 158: i.rotation = a_i_rotation;
 159: 
 160: 
 161:     BlockFrag o = FLWMain(v, i);
 162: 
 163:     v2f_texCoords = o.texCoords;
 164: v2f_color = o.color;
 165: v2f_diffuse = o.diffuse;
 166: v2f_light = o.light;
 167: 
 168: }

[12:29:45] [main/ERROR]: Shader compilation log for flywheel:block.frag: No errors.

[12:29:45] [main/ERROR]: Source for shader 'flywheel:block.frag':
   1: #version 110
   2: #define USE_FOG
   3: #define USE_FOG_EXP2
   4: 
   5: #if defined(USE_FOG)
   6: varying float FragDistance;
   7: uniform vec4 uFogColor;
   8: #endif
   9: 
  10: #if defined(USE_FOG_LINEAR)
  11: uniform vec2 uFogRange;
  12: 
  13: float FLWFogFactor() {
  14:     return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
  15: }
  16:     #endif
  17: 
  18:     #if defined(USE_FOG_EXP2)
  19: uniform float uFogDensity;
  20: 
  21: float FLWFogFactor() {
  22:     float dist = FragDistance * uFogDensity;
  23:     return 1. / exp2(dist * dist);
  24: }
  25:     #endif
  26: // Adjust the [0,1] normalized lightmap value based on the texture matrix from LightTexture#enableLightmap
  27: vec2 shiftLight(vec2 lm) {
  28:     return lm * 0.99609375 + 0.03125;// * 255/256 + 1/32
  29: }
  30: 
  31: uniform sampler2D uBlockAtlas;
  32: uniform sampler2D uLightMap;
  33: 
  34: vec4 FLWBlockTexture(vec2 texCoords) {
  35:     return texture2D(uBlockAtlas, texCoords);
  36: }
  37: 
  38: void FLWFinalizeColor(vec4 color) {
  39:     #if defined(USE_FOG)
  40:     float a = color.a;
  41:     float fog = clamp(FLWFogFactor(), 0., 1.);
  42: 
  43:     color = mix(uFogColor, color, fog);
  44:     color.a = a;
  45:     #endif
  46: 
  47:     gl_FragColor = color;
  48: }
  49: 
  50: vec4 FLWLight(vec2 lightCoords) {
  51:     return texture2D(uLightMap, shiftLight(lightCoords));
  52: }
  53: 
  54: 
  55: 
  56: struct BlockFrag {
  57:     vec2 texCoords;
  58:     vec4 color;
  59:     float diffuse;
  60:     vec2 light;
  61: };
  62: 
  63: void FLWMain(BlockFrag r) {
  64:     vec4 tex = FLWBlockTexture(r.texCoords);
  65: 
  66:     vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;
  67: 
  68: //    flw_WorldPos = ;
  69: //    flw_Normal = ;
  70: //    flw_Albedo = tex.rgb;
  71: //    flw_Alpha = tex.a;
  72: //    flw_LightMap = r.light;
  73: //    flw_Tint = r.color;
  74:     FLWFinalizeColor(color);
  75: }
  76: 
  77: varying vec2 v2f_texCoords;
  78: varying vec4 v2f_color;
  79: varying float v2f_diffuse;
  80: varying vec2 v2f_light;
  81: 
  82: 
  83: //vec3 flw_WorldPos;
  84: //vec3 flw_Normal;
  85: //vec3 flw_Albedo;
  86: //float flw_Alpha;
  87: //vec2 flw_LightMap;
  88: //vec4 flw_Tint;
  89: 
  90: void main() {
  91:     BlockFrag f;
  92:     f.texCoords = v2f_texCoords;
  93: f.color = v2f_color;
  94: f.diffuse = v2f_diffuse;
  95: f.light = v2f_light;
  96: 
  97: 
  98:     FLWMain(f);
  99: }

[12:29:45] [main/ERROR]: Shader compilation log for flywheel:oriented.vert: No errors.

[12:29:45] [main/ERROR]: Source for shader 'flywheel:oriented.vert':
   1: #version 110
   2: 
   3: uniform float uTime;
   4: uniform mat4 uViewProjection;
   5: uniform vec3 uCameraPos;
   6: 
   7: #if defined(USE_FOG)
   8: varying float FragDistance;
   9: #endif
  10: 
  11: void FLWFinalizeWorldPos(inout vec4 worldPos) {
  12:     #if defined(USE_FOG)
  13:     FragDistance = length(worldPos.xyz - uCameraPos);
  14:     #endif
  15: 
  16:     gl_Position = uViewProjection * worldPos;
  17: }
  18: 
  19: void FLWFinalizeNormal(inout vec3 normal) {
  20:     // noop
  21: }
  22: 
  23: 
  24: mat4 rotate(vec3 axis, float angle) {
  25:     float s = sin(angle);
  26:     float c = cos(angle);
  27:     float oc = 1. - c;
  28: 
  29:     vec3 sa = axis * s;
  30: 
  31:     mat4 mr = mat4(1.);
  32:     mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
  33:     mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
  34:     mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);
  35: 
  36:     return mr;
  37: }
  38: 
  39: mat4 rotation(vec3 rot) {
  40:     return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
  41: }
  42: 
  43: mat3 modelToNormal(mat4 mat) {
  44:     // Discard the edges. This won't be accurate for scaled or skewed matrices,
  45:     // but we don't have to work with those often.
  46:     mat3 m;
  47:     m[0] = mat[0].xyz;
  48:     m[1] = mat[1].xyz;
  49:     m[2] = mat[2].xyz;
  50:     return m;
  51: }
  52: 
  53: #define PIOVER2 1.5707963268
  54: 
  55: vec4 quat(vec3 axis, float angle) {
  56:     float halfAngle = angle * PIOVER2 / 180.0;
  57:     vec2 cs = sin(vec2(PIOVER2 - halfAngle, halfAngle)); // compute sin and cos in one instruction
  58:     return vec4(axis.xyz * cs.y,  cs.x);
  59: }
  60: 
  61: vec4 quatMult(vec4 q1, vec4 q2) {
  62:     // disgustingly vectorized quaternion multiplication
  63:     vec4 a = q1.w * q2.xyzw;
  64:     vec4 b = q1.x * q2.wzxy * vec4(1., -1., 1., -1.);
  65:     vec4 c = q1.y * q2.zwxy * vec4(1., 1., -1., -1.);
  66:     vec4 d = q1.z * q2.yxwz * vec4(-1., 1., 1., -1.);
  67: 
  68:     return a + b + c + d;
  69: }
  70: 
  71: vec3 rotateVertexByQuat(vec3 v, vec4 q) {
  72:     vec3 i = q.xyz;
  73:     return v + 2.0 * cross(i, cross(i, v) + q.w * v);
  74: }
  75: 
  76: vec3 rotateAbout(vec3 v, vec3 axis, float angle) {
  77:     return rotateVertexByQuat(v, quat(axis, angle));
  78: }
  79: 
  80: float diffuse(vec3 normal) {
  81:     vec3 n2 = normal * normal * vec3(.6, .25, .8);
  82:     return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
  83: }
  84: 
  85: 
  86: struct Oriented {
  87:     vec2 light;
  88:     vec4 color;
  89:     vec3 pos;
  90:     vec3 pivot;
  91:     vec4 rotation;
  92: };
  93: 
  94: 
  95: struct Vertex {
  96:     vec3 pos;
  97:     vec3 normal;
  98:     vec2 texCoords;
  99: };
 100: 
 101: struct BlockFrag {
 102:     vec2 texCoords;
 103:     vec4 color;
 104:     float diffuse;
 105:     vec2 light;
 106: };
 107: 
 108: BlockFrag FLWMain(Vertex v, Oriented o) {
 109:     vec4 worldPos = vec4(rotateVertexByQuat(v.pos - o.pivot, o.rotation) + o.pivot + o.pos, 1.);
 110: 
 111:     vec3 norm = rotateVertexByQuat(v.normal, o.rotation);
 112: 
 113:     FLWFinalizeWorldPos(worldPos);
 114:     FLWFinalizeNormal(norm);
 115: 
 116:     BlockFrag b;
 117:     b.diffuse = diffuse(norm);
 118:     b.texCoords = v.texCoords;
 119:     b.light = o.light;
 120:     #if defined(DEBUG_NORMAL)
 121:     b.color = vec4(norm, 1.);
 122:     #else
 123:     b.color = o.color;
 124:     #endif
 125:     return b;
 126: }
 127: attribute vec3 a_v_pos;
 128: attribute vec3 a_v_normal;
 129: attribute vec2 a_v_texCoords;
 130: 
 131: attribute vec2 a_i_light;
 132: attribute vec4 a_i_color;
 133: attribute vec3 a_i_pos;
 134: attribute vec3 a_i_pivot;
 135: attribute vec4 a_i_rotation;
 136: 
 137: 
 138: varying vec2 v2f_texCoords;
 139: varying vec4 v2f_color;
 140: varying float v2f_diffuse;
 141: varying vec2 v2f_light;
 142: 
 143: 
 144: void main() {
 145:     Vertex v;
 146:     v.pos = a_v_pos;
 147: v.normal = a_v_normal;
 148: v.texCoords = a_v_texCoords;
 149: 
 150: 
 151:     Oriented i;
 152:     i.light = a_i_light;
 153: i.color = a_i_color;
 154: i.pos = a_i_pos;
 155: i.pivot = a_i_pivot;
 156: i.rotation = a_i_rotation;
 157: 
 158: 
 159:     BlockFrag o = FLWMain(v, i);
 160: 
 161:     v2f_texCoords = o.texCoords;
 162: v2f_color = o.color;
 163: v2f_diffuse = o.diffuse;
 164: v2f_light = o.light;
 165: 
 166: }

[12:29:45] [main/ERROR]: Shader compilation log for flywheel:block.frag: No errors.

[12:29:45] [main/ERROR]: Source for shader 'flywheel:block.frag':
   1: #version 110
   2: 
   3: #if defined(USE_FOG)
   4: varying float FragDistance;
   5: uniform vec4 uFogColor;
   6: #endif
   7: 
   8: #if defined(USE_FOG_LINEAR)
   9: uniform vec2 uFogRange;
  10: 
  11: float FLWFogFactor() {
  12:     return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
  13: }
  14:     #endif
  15: 
  16:     #if defined(USE_FOG_EXP2)
  17: uniform float uFogDensity;
  18: 
  19: float FLWFogFactor() {
  20:     float dist = FragDistance * uFogDensity;
  21:     return 1. / exp2(dist * dist);
  22: }
  23:     #endif
  24: // Adjust the [0,1] normalized lightmap value based on the texture matrix from LightTexture#enableLightmap
  25: vec2 shiftLight(vec2 lm) {
  26:     return lm * 0.99609375 + 0.03125;// * 255/256 + 1/32
  27: }
  28: 
  29: uniform sampler2D uBlockAtlas;
  30: uniform sampler2D uLightMap;
  31: 
  32: vec4 FLWBlockTexture(vec2 texCoords) {
  33:     return texture2D(uBlockAtlas, texCoords);
  34: }
  35: 
  36: void FLWFinalizeColor(vec4 color) {
  37:     #if defined(USE_FOG)
  38:     float a = color.a;
  39:     float fog = clamp(FLWFogFactor(), 0., 1.);
  40: 
  41:     color = mix(uFogColor, color, fog);
  42:     color.a = a;
  43:     #endif
  44: 
  45:     gl_FragColor = color;
  46: }
  47: 
  48: vec4 FLWLight(vec2 lightCoords) {
  49:     return texture2D(uLightMap, shiftLight(lightCoords));
  50: }
  51: 
  52: 
  53: 
  54: struct BlockFrag {
  55:     vec2 texCoords;
  56:     vec4 color;
  57:     float diffuse;
  58:     vec2 light;
  59: };
  60: 
  61: void FLWMain(BlockFrag r) {
  62:     vec4 tex = FLWBlockTexture(r.texCoords);
  63: 
  64:     vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;
  65: 
  66: //    flw_WorldPos = ;
  67: //    flw_Normal = ;
  68: //    flw_Albedo = tex.rgb;
  69: //    flw_Alpha = tex.a;
  70: //    flw_LightMap = r.light;
  71: //    flw_Tint = r.color;
  72:     FLWFinalizeColor(color);
  73: }
  74: 
  75: varying vec2 v2f_texCoords;
  76: varying vec4 v2f_color;
  77: varying float v2f_diffuse;
  78: varying vec2 v2f_light;
  79: 
  80: 
  81: //vec3 flw_WorldPos;
  82: //vec3 flw_Normal;
  83: //vec3 flw_Albedo;
  84: //float flw_Alpha;
  85: //vec2 flw_LightMap;
  86: //vec4 flw_Tint;
  87: 
  88: void main() {
  89:     BlockFrag f;
  90:     f.texCoords = v2f_texCoords;
  91: f.color = v2f_color;
  92: f.diffuse = v2f_diffuse;
  93: f.light = v2f_light;
  94: 
  95: 
  96:     FLWMain(f);
  97: }

[12:29:45] [main/ERROR]: Shader compilation log for flywheel:model.vert: No errors.

[12:29:45] [main/ERROR]: Source for shader 'flywheel:model.vert':
   1: #version 110
   2: #define DEBUG_NORMAL
   3: 
   4: uniform float uTime;
   5: uniform mat4 uViewProjection;
   6: uniform vec3 uCameraPos;
   7: 
   8: #if defined(USE_FOG)
   9: varying float FragDistance;
  10: #endif
  11: 
  12: void FLWFinalizeWorldPos(inout vec4 worldPos) {
  13:     #if defined(USE_FOG)
  14:     FragDistance = length(worldPos.xyz - uCameraPos);
  15:     #endif
  16: 
  17:     gl_Position = uViewProjection * worldPos;
  18: }
  19: 
  20: void FLWFinalizeNormal(inout vec3 normal) {
  21:     // noop
  22: }
  23: 
  24: 
  25: float diffuse(vec3 normal) {
  26:     vec3 n2 = normal * normal * vec3(.6, .25, .8);
  27:     return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
  28: }
  29: 
  30: 
  31: struct Vertex {
  32:     vec3 pos;
  33:     vec3 normal;
  34:     vec2 texCoords;
  35: };
  36: 
  37: struct BlockFrag {
  38:     vec2 texCoords;
  39:     vec4 color;
  40:     float diffuse;
  41:     vec2 light;
  42: };
  43: 
  44: 
  45: struct Instance {
  46:     vec2 light;
  47:     vec4 color;
  48:     mat4 transform;
  49:     mat3 normalMat;
  50: };
  51: 
  52: BlockFrag FLWMain(Vertex v, Instance i) {
  53:     vec4 worldPos = i.transform * vec4(v.pos, 1.);
  54: 
  55:     vec3 norm = i.normalMat * v.normal;
  56: 
  57:     FLWFinalizeWorldPos(worldPos);
  58:     FLWFinalizeNormal(norm);
  59: 
  60:     norm = normalize(norm);
  61: 
  62:     BlockFrag b;
  63:     b.diffuse = diffuse(norm);
  64:     b.texCoords = v.texCoords;
  65:     b.light = i.light;
  66:     #if defined(DEBUG_NORMAL)
  67:     b.color = vec4(norm, 1.);
  68:     #else
  69:     b.color = i.color;
  70:     #endif
  71:     return b;
  72: }
  73: attribute vec3 a_v_pos;
  74: attribute vec3 a_v_normal;
  75: attribute vec2 a_v_texCoords;
  76: 
  77: attribute vec2 a_i_light;
  78: attribute vec4 a_i_color;
  79: attribute mat4 a_i_transform;
  80: attribute mat3 a_i_normalMat;
  81: 
  82: 
  83: varying vec2 v2f_texCoords;
  84: varying vec4 v2f_color;
  85: varying float v2f_diffuse;
  86: varying vec2 v2f_light;
  87: 
  88: 
  89: void main() {
  90:     Vertex v;
  91:     v.pos = a_v_pos;
  92: v.normal = a_v_normal;
  93: v.texCoords = a_v_texCoords;
  94: 
  95: 
  96:     Instance i;
  97:     i.light = a_i_light;
  98: i.color = a_i_color;
  99: i.transform = a_i_transform;
 100: i.normalMat = a_i_normalMat;
 101: 
 102: 
 103:     BlockFrag o = FLWMain(v, i);
 104: 
 105:     v2f_texCoords = o.texCoords;
 106: v2f_color = o.color;
 107: v2f_diffuse = o.diffuse;
 108: v2f_light = o.light;
 109: 
 110: }

[12:29:45] [main/ERROR]: Shader compilation log for flywheel:block.frag: No errors.

[12:29:45] [main/ERROR]: Source for shader 'flywheel:block.frag':
   1: #version 110
   2: #define DEBUG_NORMAL
   3: 
   4: #if defined(USE_FOG)
   5: varying float FragDistance;
   6: uniform vec4 uFogColor;
   7: #endif
   8: 
   9: #if defined(USE_FOG_LINEAR)
  10: uniform vec2 uFogRange;
  11: 
  12: float FLWFogFactor() {
  13:     return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
  14: }
  15:     #endif
  16: 
  17:     #if defined(USE_FOG_EXP2)
  18: uniform float uFogDensity;
  19: 
  20: float FLWFogFactor() {
  21:     float dist = FragDistance * uFogDensity;
  22:     return 1. / exp2(dist * dist);
  23: }
  24:     #endif
  25: // Adjust the [0,1] normalized lightmap value based on the texture matrix from LightTexture#enableLightmap
  26: vec2 shiftLight(vec2 lm) {
  27:     return lm * 0.99609375 + 0.03125;// * 255/256 + 1/32
  28: }
  29: 
  30: uniform sampler2D uBlockAtlas;
  31: uniform sampler2D uLightMap;
  32: 
  33: vec4 FLWBlockTexture(vec2 texCoords) {
  34:     return texture2D(uBlockAtlas, texCoords);
  35: }
  36: 
  37: void FLWFinalizeColor(vec4 color) {
  38:     #if defined(USE_FOG)
  39:     float a = color.a;
  40:     float fog = clamp(FLWFogFactor(), 0., 1.);
  41: 
  42:     color = mix(uFogColor, color, fog);
  43:     color.a = a;
  44:     #endif
  45: 
  46:     gl_FragColor = color;
  47: }
  48: 
  49: vec4 FLWLight(vec2 lightCoords) {
  50:     return texture2D(uLightMap, shiftLight(lightCoords));
  51: }
  52: 
  53: 
  54: 
  55: struct BlockFrag {
  56:     vec2 texCoords;
  57:     vec4 color;
  58:     float diffuse;
  59:     vec2 light;
  60: };
  61: 
  62: void FLWMain(BlockFrag r) {
  63:     vec4 tex = FLWBlockTexture(r.texCoords);
  64: 
  65:     vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;
  66: 
  67: //    flw_WorldPos = ;
  68: //    flw_Normal = ;
  69: //    flw_Albedo = tex.rgb;
  70: //    flw_Alpha = tex.a;
  71: //    flw_LightMap = r.light;
  72: //    flw_Tint = r.color;
  73:     FLWFinalizeColor(color);
  74: }
  75: 
  76: varying vec2 v2f_texCoords;
  77: varying vec4 v2f_color;
  78: varying float v2f_diffuse;
  79: varying vec2 v2f_light;
  80: 
  81: 
  82: //vec3 flw_WorldPos;
  83: //vec3 flw_Normal;
  84: //vec3 flw_Albedo;
  85: //float flw_Alpha;
  86: //vec2 flw_LightMap;
  87: //vec4 flw_Tint;
  88: 
  89: void main() {
  90:     BlockFrag f;
  91:     f.texCoords = v2f_texCoords;
  92: f.color = v2f_color;
  93: f.diffuse = v2f_diffuse;
  94: f.light = v2f_light;
  95: 
  96: 
  97:     FLWMain(f);
  98: }

[12:29:45] [main/ERROR]: Shader compilation log for flywheel:model.vert: No errors.

[12:29:45] [main/ERROR]: Source for shader 'flywheel:model.vert':
   1: #version 110
   2: #define USE_FOG
   3: #define USE_FOG_LINEAR
   4: 
   5: uniform float uTime;
   6: uniform mat4 uViewProjection;
   7: uniform vec3 uCameraPos;
   8: 
   9: #if defined(USE_FOG)
  10: varying float FragDistance;
  11: #endif
  12: 
  13: void FLWFinalizeWorldPos(inout vec4 worldPos) {
  14:     #if defined(USE_FOG)
  15:     FragDistance = length(worldPos.xyz - uCameraPos);
  16:     #endif
  17: 
  18:     gl_Position = uViewProjection * worldPos;
  19: }
  20: 
  21: void FLWFinalizeNormal(inout vec3 normal) {
  22:     // noop
  23: }
  24: 
  25: 
  26: float diffuse(vec3 normal) {
  27:     vec3 n2 = normal * normal * vec3(.6, .25, .8);
  28:     return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
  29: }
  30: 
  31: 
  32: struct Vertex {
  33:     vec3 pos;
  34:     vec3 normal;
  35:     vec2 texCoords;
  36: };
  37: 
  38: struct BlockFrag {
  39:     vec2 texCoords;
  40:     vec4 color;
  41:     float diffuse;
  42:     vec2 light;
  43: };
  44: 
  45: 
  46: struct Instance {
  47:     vec2 light;
  48:     vec4 color;
  49:     mat4 transform;
  50:     mat3 normalMat;
  51: };
  52: 
  53: BlockFrag FLWMain(Vertex v, Instance i) {
  54:     vec4 worldPos = i.transform * vec4(v.pos, 1.);
  55: 
  56:     vec3 norm = i.normalMat * v.normal;
  57: 
  58:     FLWFinalizeWorldPos(worldPos);
  59:     FLWFinalizeNormal(norm);
  60: 
  61:     norm = normalize(norm);
  62: 
  63:     BlockFrag b;
  64:     b.diffuse = diffuse(norm);
  65:     b.texCoords = v.texCoords;
  66:     b.light = i.light;
  67:     #if defined(DEBUG_NORMAL)
  68:     b.color = vec4(norm, 1.);
  69:     #else
  70:     b.color = i.color;
  71:     #endif
  72:     return b;
  73: }
  74: attribute vec3 a_v_pos;
  75: attribute vec3 a_v_normal;
  76: attribute vec2 a_v_texCoords;
  77: 
  78: attribute vec2 a_i_light;
  79: attribute vec4 a_i_color;
  80: attribute mat4 a_i_transform;
  81: attribute mat3 a_i_normalMat;
  82: 
  83: 
  84: varying vec2 v2f_texCoords;
  85: varying vec4 v2f_color;
  86: varying float v2f_diffuse;
  87: varying vec2 v2f_light;
  88: 
  89: 
  90: void main() {
  91:     Vertex v;
  92:     v.pos = a_v_pos;
  93: v.normal = a_v_normal;
  94: v.texCoords = a_v_texCoords;
  95: 
  96: 
  97:     Instance i;
  98:     i.light = a_i_light;
  99: i.color = a_i_color;
 100: i.transform = a_i_transform;
 101: i.normalMat = a_i_normalMat;
 102: 
 103: 
 104:     BlockFrag o = FLWMain(v, i);
 105: 
 106:     v2f_texCoords = o.texCoords;
 107: v2f_color = o.color;
 108: v2f_diffuse = o.diffuse;
 109: v2f_light = o.light;
 110: 
 111: }

[12:29:45] [main/ERROR]: Shader compilation log for flywheel:block.frag: No errors.

[12:29:45] [main/ERROR]: Source for shader 'flywheel:block.frag':
   1: #version 110
   2: #define USE_FOG
   3: #define USE_FOG_LINEAR
   4: 
   5: #if defined(USE_FOG)
   6: varying float FragDistance;
   7: uniform vec4 uFogColor;
   8: #endif
   9: 
  10: #if defined(USE_FOG_LINEAR)
  11: uniform vec2 uFogRange;
  12: 
  13: float FLWFogFactor() {
  14:     return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
  15: }
  16:     #endif
  17: 
  18:     #if defined(USE_FOG_EXP2)
  19: uniform float uFogDensity;
  20: 
  21: float FLWFogFactor() {
  22:     float dist = FragDistance * uFogDensity;
  23:     return 1. / exp2(dist * dist);
  24: }
  25:     #endif
  26: // Adjust the [0,1] normalized lightmap value based on the texture matrix from LightTexture#enableLightmap
  27: vec2 shiftLight(vec2 lm) {
  28:     return lm * 0.99609375 + 0.03125;// * 255/256 + 1/32
  29: }
  30: 
  31: uniform sampler2D uBlockAtlas;
  32: uniform sampler2D uLightMap;
  33: 
  34: vec4 FLWBlockTexture(vec2 texCoords) {
  35:     return texture2D(uBlockAtlas, texCoords);
  36: }
  37: 
  38: void FLWFinalizeColor(vec4 color) {
  39:     #if defined(USE_FOG)
  40:     float a = color.a;
  41:     float fog = clamp(FLWFogFactor(), 0., 1.);
  42: 
  43:     color = mix(uFogColor, color, fog);
  44:     color.a = a;
  45:     #endif
  46: 
  47:     gl_FragColor = color;
  48: }
  49: 
  50: vec4 FLWLight(vec2 lightCoords) {
  51:     return texture2D(uLightMap, shiftLight(lightCoords));
  52: }
  53: 
  54: 
  55: 
  56: struct BlockFrag {
  57:     vec2 texCoords;
  58:     vec4 color;
  59:     float diffuse;
  60:     vec2 light;
  61: };
  62: 
  63: void FLWMain(BlockFrag r) {
  64:     vec4 tex = FLWBlockTexture(r.texCoords);
  65: 
  66:     vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;
  67: 
  68: //    flw_WorldPos = ;
  69: //    flw_Normal = ;
  70: //    flw_Albedo = tex.rgb;
  71: //    flw_Alpha = tex.a;
  72: //    flw_LightMap = r.light;
  73: //    flw_Tint = r.color;
  74:     FLWFinalizeColor(color);
  75: }
  76: 
  77: varying vec2 v2f_texCoords;
  78: varying vec4 v2f_color;
  79: varying float v2f_diffuse;
  80: varying vec2 v2f_light;
  81: 
  82: 
  83: //vec3 flw_WorldPos;
  84: //vec3 flw_Normal;
  85: //vec3 flw_Albedo;
  86: //float flw_Alpha;
  87: //vec2 flw_LightMap;
  88: //vec4 flw_Tint;
  89: 
  90: void main() {
  91:     BlockFrag f;
  92:     f.texCoords = v2f_texCoords;
  93: f.color = v2f_color;
  94: f.diffuse = v2f_diffuse;
  95: f.light = v2f_light;
  96: 
  97: 
  98:     FLWMain(f);
  99: }

[12:29:45] [main/ERROR]: Shader compilation log for flywheel:model.vert: No errors.

[12:29:45] [main/ERROR]: Source for shader 'flywheel:model.vert':
   1: #version 110
   2: #define USE_FOG
   3: #define USE_FOG_EXP2
   4: 
   5: uniform float uTime;
   6: uniform mat4 uViewProjection;
   7: uniform vec3 uCameraPos;
   8: 
   9: #if defined(USE_FOG)
  10: varying float FragDistance;
  11: #endif
  12: 
  13: void FLWFinalizeWorldPos(inout vec4 worldPos) {
  14:     #if defined(USE_FOG)
  15:     FragDistance = length(worldPos.xyz - uCameraPos);
  16:     #endif
  17: 
  18:     gl_Position = uViewProjection * worldPos;
  19: }
  20: 
  21: void FLWFinalizeNormal(inout vec3 normal) {
  22:     // noop
  23: }
  24: 
  25: 
  26: float diffuse(vec3 normal) {
  27:     vec3 n2 = normal * normal * vec3(.6, .25, .8);
  28:     return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
  29: }
  30: 
  31: 
  32: struct Vertex {
  33:     vec3 pos;
  34:     vec3 normal;
  35:     vec2 texCoords;
  36: };
  37: 
  38: struct BlockFrag {
  39:     vec2 texCoords;
  40:     vec4 color;
  41:     float diffuse;
  42:     vec2 light;
  43: };
  44: 
  45: 
  46: struct Instance {
  47:     vec2 light;
  48:     vec4 color;
  49:     mat4 transform;
  50:     mat3 normalMat;
  51: };
  52: 
  53: BlockFrag FLWMain(Vertex v, Instance i) {
  54:     vec4 worldPos = i.transform * vec4(v.pos, 1.);
  55: 
  56:     vec3 norm = i.normalMat * v.normal;
  57: 
  58:     FLWFinalizeWorldPos(worldPos);
  59:     FLWFinalizeNormal(norm);
  60: 
  61:     norm = normalize(norm);
  62: 
  63:     BlockFrag b;
  64:     b.diffuse = diffuse(norm);
  65:     b.texCoords = v.texCoords;
  66:     b.light = i.light;
  67:     #if defined(DEBUG_NORMAL)
  68:     b.color = vec4(norm, 1.);
  69:     #else
  70:     b.color = i.color;
  71:     #endif
  72:     return b;
  73: }
  74: attribute vec3 a_v_pos;
  75: attribute vec3 a_v_normal;
  76: attribute vec2 a_v_texCoords;
  77: 
  78: attribute vec2 a_i_light;
  79: attribute vec4 a_i_color;
  80: attribute mat4 a_i_transform;
  81: attribute mat3 a_i_normalMat;
  82: 
  83: 
  84: varying vec2 v2f_texCoords;
  85: varying vec4 v2f_color;
  86: varying float v2f_diffuse;
  87: varying vec2 v2f_light;
  88: 
  89: 
  90: void main() {
  91:     Vertex v;
  92:     v.pos = a_v_pos;
  93: v.normal = a_v_normal;
  94: v.texCoords = a_v_texCoords;
  95: 
  96: 
  97:     Instance i;
  98:     i.light = a_i_light;
  99: i.color = a_i_color;
 100: i.transform = a_i_transform;
 101: i.normalMat = a_i_normalMat;
 102: 
 103: 
 104:     BlockFrag o = FLWMain(v, i);
 105: 
 106:     v2f_texCoords = o.texCoords;
 107: v2f_color = o.color;
 108: v2f_diffuse = o.diffuse;
 109: v2f_light = o.light;
 110: 
 111: }

[12:29:45] [main/ERROR]: Shader compilation log for flywheel:block.frag: No errors.

[12:29:45] [main/ERROR]: Source for shader 'flywheel:block.frag':
   1: #version 110
   2: #define USE_FOG
   3: #define USE_FOG_EXP2
   4: 
   5: #if defined(USE_FOG)
   6: varying float FragDistance;
   7: uniform vec4 uFogColor;
   8: #endif
   9: 
  10: #if defined(USE_FOG_LINEAR)
  11: uniform vec2 uFogRange;
  12: 
  13: float FLWFogFactor() {
  14:     return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
  15: }
  16:     #endif
  17: 
  18:     #if defined(USE_FOG_EXP2)
  19: uniform float uFogDensity;
  20: 
  21: float FLWFogFactor() {
  22:     float dist = FragDistance * uFogDensity;
  23:     return 1. / exp2(dist * dist);
  24: }
  25:     #endif
  26: // Adjust the [0,1] normalized lightmap value based on the texture matrix from LightTexture#enableLightmap
  27: vec2 shiftLight(vec2 lm) {
  28:     return lm * 0.99609375 + 0.03125;// * 255/256 + 1/32
  29: }
  30: 
  31: uniform sampler2D uBlockAtlas;
  32: uniform sampler2D uLightMap;
  33: 
  34: vec4 FLWBlockTexture(vec2 texCoords) {
  35:     return texture2D(uBlockAtlas, texCoords);
  36: }
  37: 
  38: void FLWFinalizeColor(vec4 color) {
  39:     #if defined(USE_FOG)
  40:     float a = color.a;
  41:     float fog = clamp(FLWFogFactor(), 0., 1.);
  42: 
  43:     color = mix(uFogColor, color, fog);
  44:     color.a = a;
  45:     #endif
  46: 
  47:     gl_FragColor = color;
  48: }
  49: 
  50: vec4 FLWLight(vec2 lightCoords) {
  51:     return texture2D(uLightMap, shiftLight(lightCoords));
  52: }
  53: 
  54: 
  55: 
  56: struct BlockFrag {
  57:     vec2 texCoords;
  58:     vec4 color;
  59:     float diffuse;
  60:     vec2 light;
  61: };
  62: 
  63: void FLWMain(BlockFrag r) {
  64:     vec4 tex = FLWBlockTexture(r.texCoords);
  65: 
  66:     vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;
  67: 
  68: //    flw_WorldPos = ;
  69: //    flw_Normal = ;
  70: //    flw_Albedo = tex.rgb;
  71: //    flw_Alpha = tex.a;
  72: //    flw_LightMap = r.light;
  73: //    flw_Tint = r.color;
  74:     FLWFinalizeColor(color);
  75: }
  76: 
  77: varying vec2 v2f_texCoords;
  78: varying vec4 v2f_color;
  79: varying float v2f_diffuse;
  80: varying vec2 v2f_light;
  81: 
  82: 
  83: //vec3 flw_WorldPos;
  84: //vec3 flw_Normal;
  85: //vec3 flw_Albedo;
  86: //float flw_Alpha;
  87: //vec2 flw_LightMap;
  88: //vec4 flw_Tint;
  89: 
  90: void main() {
  91:     BlockFrag f;
  92:     f.texCoords = v2f_texCoords;
  93: f.color = v2f_color;
  94: f.diffuse = v2f_diffuse;
  95: f.light = v2f_light;
  96: 
  97: 
  98:     FLWMain(f);
  99: }

[12:29:45] [main/ERROR]: Shader compilation log for flywheel:model.vert: No errors.

[12:29:45] [main/ERROR]: Source for shader 'flywheel:model.vert':
   1: #version 110
   2: 
   3: uniform float uTime;
   4: uniform mat4 uViewProjection;
   5: uniform vec3 uCameraPos;
   6: 
   7: #if defined(USE_FOG)
   8: varying float FragDistance;
   9: #endif
  10: 
  11: void FLWFinalizeWorldPos(inout vec4 worldPos) {
  12:     #if defined(USE_FOG)
  13:     FragDistance = length(worldPos.xyz - uCameraPos);
  14:     #endif
  15: 
  16:     gl_Position = uViewProjection * worldPos;
  17: }
  18: 
  19: void FLWFinalizeNormal(inout vec3 normal) {
  20:     // noop
  21: }
  22: 
  23: 
  24: float diffuse(vec3 normal) {
  25:     vec3 n2 = normal * normal * vec3(.6, .25, .8);
  26:     return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
  27: }
  28: 
  29: 
  30: struct Vertex {
  31:     vec3 pos;
  32:     vec3 normal;
  33:     vec2 texCoords;
  34: };
  35: 
  36: struct BlockFrag {
  37:     vec2 texCoords;
  38:     vec4 color;
  39:     float diffuse;
  40:     vec2 light;
  41: };
  42: 
  43: 
  44: struct Instance {
  45:     vec2 light;
  46:     vec4 color;
  47:     mat4 transform;
  48:     mat3 normalMat;
  49: };
  50: 
  51: BlockFrag FLWMain(Vertex v, Instance i) {
  52:     vec4 worldPos = i.transform * vec4(v.pos, 1.);
  53: 
  54:     vec3 norm = i.normalMat * v.normal;
  55: 
  56:     FLWFinalizeWorldPos(worldPos);
  57:     FLWFinalizeNormal(norm);
  58: 
  59:     norm = normalize(norm);
  60: 
  61:     BlockFrag b;
  62:     b.diffuse = diffuse(norm);
  63:     b.texCoords = v.texCoords;
  64:     b.light = i.light;
  65:     #if defined(DEBUG_NORMAL)
  66:     b.color = vec4(norm, 1.);
  67:     #else
  68:     b.color = i.color;
  69:     #endif
  70:     return b;
  71: }
  72: attribute vec3 a_v_pos;
  73: attribute vec3 a_v_normal;
  74: attribute vec2 a_v_texCoords;
  75: 
  76: attribute vec2 a_i_light;
  77: attribute vec4 a_i_color;
  78: attribute mat4 a_i_transform;
  79: attribute mat3 a_i_normalMat;
  80: 
  81: 
  82: varying vec2 v2f_texCoords;
  83: varying vec4 v2f_color;
  84: varying float v2f_diffuse;
  85: varying vec2 v2f_light;
  86: 
  87: 
  88: void main() {
  89:     Vertex v;
  90:     v.pos = a_v_pos;
  91: v.normal = a_v_normal;
  92: v.texCoords = a_v_texCoords;
  93: 
  94: 
  95:     Instance i;
  96:     i.light = a_i_light;
  97: i.color = a_i_color;
  98: i.transform = a_i_transform;
  99: i.normalMat = a_i_normalMat;
 100: 
 101: 
 102:     BlockFrag o = FLWMain(v, i);
 103: 
 104:     v2f_texCoords = o.texCoords;
 105: v2f_color = o.color;
 106: v2f_diffuse = o.diffuse;
 107: v2f_light = o.light;
 108: 
 109: }

[12:29:45] [main/ERROR]: Shader compilation log for flywheel:block.frag: No errors.

[12:29:45] [main/ERROR]: Source for shader 'flywheel:block.frag':
   1: #version 110
   2: 
   3: #if defined(USE_FOG)
   4: varying float FragDistance;
   5: uniform vec4 uFogColor;
   6: #endif
   7: 
   8: #if defined(USE_FOG_LINEAR)
   9: uniform vec2 uFogRange;
  10: 
  11: float FLWFogFactor() {
  12:     return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
  13: }
  14:     #endif
  15: 
  16:     #if defined(USE_FOG_EXP2)
  17: uniform float uFogDensity;
  18: 
  19: float FLWFogFactor() {
  20:     float dist = FragDistance * uFogDensity;
  21:     return 1. / exp2(dist * dist);
  22: }
  23:     #endif
  24: // Adjust the [0,1] normalized lightmap value based on the texture matrix from LightTexture#enableLightmap
  25: vec2 shiftLight(vec2 lm) {
  26:     return lm * 0.99609375 + 0.03125;// * 255/256 + 1/32
  27: }
  28: 
  29: uniform sampler2D uBlockAtlas;
  30: uniform sampler2D uLightMap;
  31: 
  32: vec4 FLWBlockTexture(vec2 texCoords) {
  33:     return texture2D(uBlockAtlas, texCoords);
  34: }
  35: 
  36: void FLWFinalizeColor(vec4 color) {
  37:     #if defined(USE_FOG)
  38:     float a = color.a;
  39:     float fog = clamp(FLWFogFactor(), 0., 1.);
  40: 
  41:     color = mix(uFogColor, color, fog);
  42:     color.a = a;
  43:     #endif
  44: 
  45:     gl_FragColor = color;
  46: }
  47: 
  48: vec4 FLWLight(vec2 lightCoords) {
  49:     return texture2D(uLightMap, shiftLight(lightCoords));
  50: }
  51: 
  52: 
  53: 
  54: struct BlockFrag {
  55:     vec2 texCoords;
  56:     vec4 color;
  57:     float diffuse;
  58:     vec2 light;
  59: };
  60: 
  61: void FLWMain(BlockFrag r) {
  62:     vec4 tex = FLWBlockTexture(r.texCoords);
  63: 
  64:     vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;
  65: 
  66: //    flw_WorldPos = ;
  67: //    flw_Normal = ;
  68: //    flw_Albedo = tex.rgb;
  69: //    flw_Alpha = tex.a;
  70: //    flw_LightMap = r.light;
  71: //    flw_Tint = r.color;
  72:     FLWFinalizeColor(color);
  73: }
  74: 
  75: varying vec2 v2f_texCoords;
  76: varying vec4 v2f_color;
  77: varying float v2f_diffuse;
  78: varying vec2 v2f_light;
  79: 
  80: 
  81: //vec3 flw_WorldPos;
  82: //vec3 flw_Normal;
  83: //vec3 flw_Albedo;
  84: //float flw_Alpha;
  85: //vec2 flw_LightMap;
  86: //vec4 flw_Tint;
  87: 
  88: void main() {
  89:     BlockFrag f;
  90:     f.texCoords = v2f_texCoords;
  91: f.color = v2f_color;
  92: f.diffuse = v2f_diffuse;
  93: f.light = v2f_light;
  94: 
  95: 
  96:     FLWMain(f);
  97: }

[12:29:45] [main/INFO]: Loaded all shader programs.
[12:29:46] [Worker-Main-11/INFO]: Registered plugin at net.blay09.mods.cookingforblockheads.compat.WailaAddon
[12:29:46] [Worker-Main-11/INFO]: Registered plugin at mcp.mobius.waila.addons.minecraft.PluginMinecraft
[12:29:46] [Worker-Main-11/INFO]: Registered plugin at mekanism.common.integration.lookingat.hwyla.MekanismHwylaPlugin
[12:29:47] [Worker-Main-11/INFO]: Registered plugin at de.maxhenkel.gravestone.integration.waila.PluginGraveStone
[12:29:47] [Worker-Main-11/INFO]: Registered plugin at net.geforcemods.securitycraft.compat.waila.WailaDataProvider
[12:29:47] [Worker-Main-11/INFO]: Registered plugin at com.jaquadro.minecraft.storagedrawers.integration.Waila
[12:29:47] [main/INFO]: Journeymap PostInit
[12:29:47] [main/ERROR]: Couldn't locate icons for flat: C:\Users\kaues\AppData\Roaming\.minecraft\versions\Ender%20Tech\mods\journeymap-1.16.5-5.8.0.jar\assets\journeymap\theme\flat
[12:29:47] [main/INFO]: Preloaded theme textures: 0
[12:29:47] [main/INFO]: postInitialize EXIT, elapsed count 1 avg 160,29ms
[12:29:50] [JM-VersionCheck-1/ERROR]: Could not check version URL
javax.net.ssl.SSLHandshakeException: sun.security.validator.ValidatorException: PKIX path building failed: sun.security.provider.certpath.SunCertPathBuilderException: unable to find valid certification path to requested target
	at sun.security.ssl.Alerts.getSSLException(Alerts.java:192) ~[?:1.8.0_51]
	at sun.security.ssl.SSLSocketImpl.fatal(SSLSocketImpl.java:1949) ~[?:1.8.0_51]
	at sun.security.ssl.Handshaker.fatalSE(Handshaker.java:302) ~[?:1.8.0_51]
	at sun.security.ssl.Handshaker.fatalSE(Handshaker.java:296) ~[?:1.8.0_51]
	at sun.security.ssl.ClientHandshaker.serverCertificate(ClientHandshaker.java:1497) ~[?:1.8.0_51]
	at sun.security.ssl.ClientHandshaker.processMessage(ClientHandshaker.java:212) ~[?:1.8.0_51]
	at sun.security.ssl.Handshaker.processLoop(Handshaker.java:979) ~[?:1.8.0_51]
	at sun.security.ssl.Handshaker.process_record(Handshaker.java:914) ~[?:1.8.0_51]
	at sun.security.ssl.SSLSocketImpl.readRecord(SSLSocketImpl.java:1062) ~[?:1.8.0_51]
	at sun.security.ssl.SSLSocketImpl.performInitialHandshake(SSLSocketImpl.java:1375) ~[?:1.8.0_51]
	at sun.security.ssl.SSLSocketImpl.startHandshake(SSLSocketImpl.java:1403) ~[?:1.8.0_51]
	at sun.security.ssl.SSLSocketImpl.startHandshake(SSLSocketImpl.java:1387) ~[?:1.8.0_51]
	at org.apache.http.conn.ssl.SSLConnectionSocketFactory.createLayeredSocket(SSLConnectionSocketFactory.java:275) ~[httpclient-4.3.3.jar:4.3.3]
	at org.apache.http.conn.ssl.SSLConnectionSocketFactory.connectSocket(SSLConnectionSocketFactory.java:254) ~[httpclient-4.3.3.jar:4.3.3]
	at org.apache.http.impl.conn.HttpClientConnectionOperator.connect(HttpClientConnectionOperator.java:117) ~[httpclient-4.3.3.jar:4.3.3]
	at org.apache.http.impl.conn.PoolingHttpClientConnectionManager.connect(PoolingHttpClientConnectionManager.java:314) ~[httpclient-4.3.3.jar:4.3.3]
	at org.apache.http.impl.execchain.MainClientExec.establishRoute(MainClientExec.java:363) ~[httpclient-4.3.3.jar:4.3.3]
	at org.apache.http.impl.execchain.MainClientExec.execute(MainClientExec.java:219) ~[httpclient-4.3.3.jar:4.3.3]
	at org.apache.http.impl.execchain.ProtocolExec.execute(ProtocolExec.java:195) ~[httpclient-4.3.3.jar:4.3.3]
	at org.apache.http.impl.execchain.RetryExec.execute(RetryExec.java:86) ~[httpclient-4.3.3.jar:4.3.3]
	at org.apache.http.impl.execchain.RedirectExec.execute(RedirectExec.java:108) ~[httpclient-4.3.3.jar:4.3.3]
	at org.apache.http.impl.client.InternalHttpClient.doExecute(InternalHttpClient.java:186) ~[httpclient-4.3.3.jar:4.3.3]
	at org.apache.http.impl.client.CloseableHttpClient.execute(CloseableHttpClient.java:82) ~[httpclient-4.3.3.jar:4.3.3]
	at org.apache.http.impl.client.CloseableHttpClient.execute(CloseableHttpClient.java:106) ~[httpclient-4.3.3.jar:4.3.3]
	at org.apache.http.impl.client.CloseableHttpClient.execute(CloseableHttpClient.java:57) ~[httpclient-4.3.3.jar:4.3.3]
	at journeymap.common.version.VersionCheck.makeGetRequest(VersionCheck.java:211) [?:1.16.5-5.8.0]
	at journeymap.common.version.VersionCheck.lambda$checkVersion$1(VersionCheck.java:121) [?:1.16.5-5.8.0]
	at journeymap.common.version.VersionCheck$$Lambda$12342/1008209317.run(Unknown Source) [?:1.16.5-5.8.0]
	at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511) [?:1.8.0_51]
	at java.util.concurrent.FutureTask.run(FutureTask.java:266) [?:1.8.0_51]
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142) [?:1.8.0_51]
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617) [?:1.8.0_51]
	at java.lang.Thread.run(Thread.java:745) [?:1.8.0_51]
Caused by: sun.security.validator.ValidatorException: PKIX path building failed: sun.security.provider.certpath.SunCertPathBuilderException: unable to find valid certification path to requested target
	at sun.security.validator.PKIXValidator.doBuild(PKIXValidator.java:387) ~[?:1.8.0_51]
	at sun.security.validator.PKIXValidator.engineValidate(PKIXValidator.java:292) ~[?:1.8.0_51]
	at sun.security.validator.Validator.validate(Validator.java:260) ~[?:1.8.0_51]
	at sun.security.ssl.X509TrustManagerImpl.validate(X509TrustManagerImpl.java:324) ~[?:1.8.0_51]
	at sun.security.ssl.X509TrustManagerImpl.checkTrusted(X509TrustManagerImpl.java:229) ~[?:1.8.0_51]
	at sun.security.ssl.X509TrustManagerImpl.checkServerTrusted(X509TrustManagerImpl.java:124) ~[?:1.8.0_51]
	at sun.security.ssl.ClientHandshaker.serverCertificate(ClientHandshaker.java:1479) ~[?:1.8.0_51]
	... 28 more
Caused by: sun.security.provider.certpath.SunCertPathBuilderException: unable to find valid certification path to requested target
	at sun.security.provider.certpath.SunCertPathBuilder.build(SunCertPathBuilder.java:145) ~[?:1.8.0_51]
	at sun.security.provider.certpath.SunCertPathBuilder.engineBuild(SunCertPathBuilder.java:131) ~[?:1.8.0_51]
	at java.security.cert.CertPathBuilder.build(CertPathBuilder.java:280) ~[?:1.8.0_51]
	at sun.security.validator.PKIXValidator.doBuild(PKIXValidator.java:382) ~[?:1.8.0_51]
	at sun.security.validator.PKIXValidator.engineValidate(PKIXValidator.java:292) ~[?:1.8.0_51]
	at sun.security.validator.Validator.validate(Validator.java:260) ~[?:1.8.0_51]
	at sun.security.ssl.X509TrustManagerImpl.validate(X509TrustManagerImpl.java:324) ~[?:1.8.0_51]
	at sun.security.ssl.X509TrustManagerImpl.checkTrusted(X509TrustManagerImpl.java:229) ~[?:1.8.0_51]
	at sun.security.ssl.X509TrustManagerImpl.checkServerTrusted(X509TrustManagerImpl.java:124) ~[?:1.8.0_51]
	at sun.security.ssl.ClientHandshaker.serverCertificate(ClientHandshaker.java:1479) ~[?:1.8.0_51]
	... 28 more
[12:29:50] [JM-VersionCheck-1/ERROR]: Could not check version URL
javax.net.ssl.SSLHandshakeException: sun.security.validator.ValidatorException: PKIX path building failed: sun.security.provider.certpath.SunCertPathBuilderException: unable to find valid certification path to requested target
	at sun.security.ssl.Alerts.getSSLException(Alerts.java:192) ~[?:1.8.0_51]
	at sun.security.ssl.SSLSocketImpl.fatal(SSLSocketImpl.java:1949) ~[?:1.8.0_51]
	at sun.security.ssl.Handshaker.fatalSE(Handshaker.java:302) ~[?:1.8.0_51]
	at sun.security.ssl.Handshaker.fatalSE(Handshaker.java:296) ~[?:1.8.0_51]
	at sun.security.ssl.ClientHandshaker.serverCertificate(ClientHandshaker.java:1497) ~[?:1.8.0_51]
	at sun.security.ssl.ClientHandshaker.processMessage(ClientHandshaker.java:212) ~[?:1.8.0_51]
	at sun.security.ssl.Handshaker.processLoop(Handshaker.java:979) ~[?:1.8.0_51]
	at sun.security.ssl.Handshaker.process_record(Handshaker.java:914) ~[?:1.8.0_51]
	at sun.security.ssl.SSLSocketImpl.readRecord(SSLSocketImpl.java:1062) ~[?:1.8.0_51]
	at sun.security.ssl.SSLSocketImpl.performInitialHandshake(SSLSocketImpl.java:1375) ~[?:1.8.0_51]
	at sun.security.ssl.SSLSocketImpl.startHandshake(SSLSocketImpl.java:1403) ~[?:1.8.0_51]
	at sun.security.ssl.SSLSocketImpl.startHandshake(SSLSocketImpl.java:1387) ~[?:1.8.0_51]
	at org.apache.http.conn.ssl.SSLConnectionSocketFactory.createLayeredSocket(SSLConnectionSocketFactory.java:275) ~[httpclient-4.3.3.jar:4.3.3]
	at org.apache.http.conn.ssl.SSLConnectionSocketFactory.connectSocket(SSLConnectionSocketFactory.java:254) ~[httpclient-4.3.3.jar:4.3.3]
	at org.apache.http.impl.conn.HttpClientConnectionOperator.connect(HttpClientConnectionOperator.java:117) ~[httpclient-4.3.3.jar:4.3.3]
	at org.apache.http.impl.conn.PoolingHttpClientConnectionManager.connect(PoolingHttpClientConnectionManager.java:314) ~[httpclient-4.3.3.jar:4.3.3]
	at org.apache.http.impl.execchain.MainClientExec.establishRoute(MainClientExec.java:363) ~[httpclient-4.3.3.jar:4.3.3]
	at org.apache.http.impl.execchain.MainClientExec.execute(MainClientExec.java:219) ~[httpclient-4.3.3.jar:4.3.3]
	at org.apache.http.impl.execchain.ProtocolExec.execute(ProtocolExec.java:195) ~[httpclient-4.3.3.jar:4.3.3]
	at org.apache.http.impl.execchain.RetryExec.execute(RetryExec.java:86) ~[httpclient-4.3.3.jar:4.3.3]
	at org.apache.http.impl.execchain.RedirectExec.execute(RedirectExec.java:108) ~[httpclient-4.3.3.jar:4.3.3]
	at org.apache.http.impl.client.InternalHttpClient.doExecute(InternalHttpClient.java:186) ~[httpclient-4.3.3.jar:4.3.3]
	at org.apache.http.impl.client.CloseableHttpClient.execute(CloseableHttpClient.java:82) ~[httpclient-4.3.3.jar:4.3.3]
	at org.apache.http.impl.client.CloseableHttpClient.execute(CloseableHttpClient.java:106) ~[httpclient-4.3.3.jar:4.3.3]
	at org.apache.http.impl.client.CloseableHttpClient.execute(CloseableHttpClient.java:57) ~[httpclient-4.3.3.jar:4.3.3]
	at journeymap.common.version.VersionCheck.makeGetRequest(VersionCheck.java:211) [?:1.16.5-5.8.0]
	at journeymap.common.version.VersionCheck.lambda$checkVersion$1(VersionCheck.java:122) [?:1.16.5-5.8.0]
	at journeymap.common.version.VersionCheck$$Lambda$12342/1008209317.run(Unknown Source) [?:1.16.5-5.8.0]
	at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511) [?:1.8.0_51]
	at java.util.concurrent.FutureTask.run(FutureTask.java:266) [?:1.8.0_51]
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142) [?:1.8.0_51]
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617) [?:1.8.0_51]
	at java.lang.Thread.run(Thread.java:745) [?:1.8.0_51]
Caused by: sun.security.validator.ValidatorException: PKIX path building failed: sun.security.provider.certpath.SunCertPathBuilderException: unable to find valid certification path to requested target
	at sun.security.validator.PKIXValidator.doBuild(PKIXValidator.java:387) ~[?:1.8.0_51]
	at sun.security.validator.PKIXValidator.engineValidate(PKIXValidator.java:292) ~[?:1.8.0_51]
	at sun.security.validator.Validator.validate(Validator.java:260) ~[?:1.8.0_51]
	at sun.security.ssl.X509TrustManagerImpl.validate(X509TrustManagerImpl.java:324) ~[?:1.8.0_51]
	at sun.security.ssl.X509TrustManagerImpl.checkTrusted(X509TrustManagerImpl.java:229) ~[?:1.8.0_51]
	at sun.security.ssl.X509TrustManagerImpl.checkServerTrusted(X509TrustManagerImpl.java:124) ~[?:1.8.0_51]
	at sun.security.ssl.ClientHandshaker.serverCertificate(ClientHandshaker.java:1479) ~[?:1.8.0_51]
	... 28 more
Caused by: sun.security.provider.certpath.SunCertPathBuilderException: unable to find valid certification path to requested target
	at sun.security.provider.certpath.SunCertPathBuilder.build(SunCertPathBuilder.java:145) ~[?:1.8.0_51]
	at sun.security.provider.certpath.SunCertPathBuilder.engineBuild(SunCertPathBuilder.java:131) ~[?:1.8.0_51]
	at java.security.cert.CertPathBuilder.build(CertPathBuilder.java:280) ~[?:1.8.0_51]
	at sun.security.validator.PKIXValidator.doBuild(PKIXValidator.java:382) ~[?:1.8.0_51]
	at sun.security.validator.PKIXValidator.engineValidate(PKIXValidator.java:292) ~[?:1.8.0_51]
	at sun.security.validator.Validator.validate(Validator.java:260) ~[?:1.8.0_51]
	at sun.security.ssl.X509TrustManagerImpl.validate(X509TrustManagerImpl.java:324) ~[?:1.8.0_51]
	at sun.security.ssl.X509TrustManagerImpl.checkTrusted(X509TrustManagerImpl.java:229) ~[?:1.8.0_51]
	at sun.security.ssl.X509TrustManagerImpl.checkServerTrusted(X509TrustManagerImpl.java:124) ~[?:1.8.0_51]
	at sun.security.ssl.ClientHandshaker.serverCertificate(ClientHandshaker.java:1479) ~[?:1.8.0_51]
	... 28 more
[12:30:07] [main/INFO]: OpenAL initialized.
[12:30:07] [main/INFO]: Sound engine started
[12:30:08] [main/INFO]: Created: 256x256x0 jei:textures/atlas/gui.png-atlas
[12:30:08] [main/INFO]: [OptiFine] Animated sprites: 2
[12:30:08] [main/INFO]: Created: 256x128x0 mekanism:textures/atlas/robit.png-atlas
[12:30:08] [main/INFO]: [OptiFine] Animated sprites: 2
[12:30:08] [main/INFO]: Created: 2048x2048x4 minecraft:textures/atlas/blocks.png-atlas
[12:30:15] [main/INFO]: [OptiFine] Animated sprites: 223
[12:30:15] [main/INFO]: Created: 256x128x4 minecraft:textures/atlas/signs.png-atlas
[12:30:15] [main/INFO]: [OptiFine] Animated sprites: 2
[12:30:15] [main/INFO]: Created: 512x512x4 minecraft:textures/atlas/banner_patterns.png-atlas
[12:30:15] [main/INFO]: [OptiFine] Animated sprites: 2
[12:30:15] [main/INFO]: Created: 512x512x4 minecraft:textures/atlas/shield_patterns.png-atlas
[12:30:15] [main/INFO]: [OptiFine] Animated sprites: 2
[12:30:15] [main/INFO]: Created: 512x256x4 minecraft:textures/atlas/chest.png-atlas
[12:30:15] [main/INFO]: [OptiFine] Animated sprites: 2
[12:30:15] [main/INFO]: Created: 512x256x4 minecraft:textures/atlas/beds.png-atlas
[12:30:15] [main/INFO]: [OptiFine] Animated sprites: 2
[12:30:15] [main/INFO]: Created: 512x256x4 minecraft:textures/atlas/shulker_boxes.png-atlas
[12:30:15] [main/INFO]: [OptiFine] Animated sprites: 2
[12:30:36] [main/INFO]: Created: 256x256x0 minecraft:textures/atlas/particles.png-atlas
[12:30:36] [main/INFO]: [OptiFine] Animated sprites: 2
[12:30:36] [main/INFO]: Created: 256x256x0 minecraft:textures/atlas/paintings.png-atlas
[12:30:36] [main/INFO]: [OptiFine] Animated sprites: 2
[12:30:36] [main/INFO]: Created: 256x256x0 minecraft:textures/atlas/mob_effects.png-atlas
[12:30:36] [main/INFO]: [OptiFine] Animated sprites: 2
[12:30:36] [main/INFO]: [OptiFine] *** Reloading custom textures ***
[12:30:37] [main/WARN]: [OptiFine] Unknown resource pack file: mod_resources
[12:30:37] [main/WARN]: [OptiFine] Unknown resource pack file: mod_resources
[12:30:37] [main/WARN]: [OptiFine] Unknown resource pack file: mod_resources
[12:31:37] [main/WARN]: [OptiFine] Unknown resource pack file: mod_resources
[12:31:39] [main/WARN]: [OptiFine] Unknown resource pack file: mod_resources
[12:31:39] [main/WARN]: [OptiFine] Unknown resource pack file: mod_resources
[12:31:39] [main/INFO]: [OptiFine] Disable Forge light pipeline
[12:31:39] [main/INFO]: [OptiFine] Set ForgeConfig.CLIENT.forgeLightPipelineEnabled=false
[12:31:40] [main/INFO]: [de.keksuccino.fancymenu.mainwindow.MainWindowHandler:updateWindowIcon:67]: [FANCYMENU] Custom minecraft icon successfully loaded!
[12:31:40] [main/INFO]: [de.keksuccino.fancymenu.mainwindow.MainWindowHandler:updateWindowIcon:67]: [FANCYMENU] Custom minecraft icon successfully loaded!
[12:31:40] [Realms Notification Availability checker #1/INFO]: Could not authorize you against Realms server: Invalid session id
[12:31:41] [main/INFO]: [FANCYMENU] Updating animation sizes..
[12:53:38] [main/WARN]: Ambiguity between arguments [c, coupling, add, cart1] and [c, coupling, add, carts] with inputs: [Player, 0123, @e, dd12be42-52a9-4a91-a8a1-11c01849e498]
[12:53:38] [main/WARN]: Ambiguity between arguments [c, coupling, add, carts] and [c, coupling, add, cart1] with inputs: [Player, 0123, dd12be42-52a9-4a91-a8a1-11c01849e498]
[12:53:38] [main/WARN]: Ambiguity between arguments [cofh, ignite, duration] and [cofh, ignite, targets] with inputs: [0, -123, 123]
[12:53:38] [main/WARN]: Ambiguity between arguments [cofh, ignite, targets] and [cofh, ignite, duration] with inputs: [0123]
[12:53:38] [main/WARN]: Ambiguity between arguments [cofh, invis, flag] and [cofh, invis, targets] with inputs: [true, false]
[12:53:38] [main/WARN]: Ambiguity between arguments [cofh, invuln, flag] and [cofh, invuln, targets] with inputs: [true, false]
[12:53:38] [main/WARN]: Ambiguity between arguments [c, coupling, add, cart1] and [c, coupling, add, carts] with inputs: [Player, 0123, @e, dd12be42-52a9-4a91-a8a1-11c01849e498]
[12:53:38] [main/WARN]: Ambiguity between arguments [c, coupling, add, carts] and [c, coupling, add, cart1] with inputs: [Player, 0123, dd12be42-52a9-4a91-a8a1-11c01849e498]
[12:53:38] [main/WARN]: Ambiguity between arguments [ftbchunks, admin, view_loaded_chunks, reset] and [ftbchunks, admin, view_loaded_chunks, dimension] with inputs: [reset]
[12:53:38] [main/WARN]: Ambiguity between arguments [ftbteams, info, server_id] and [ftbteams, info, team] with inputs: [server_id]
[12:53:38] [main/WARN]: Ambiguity between arguments [mahousummon, treasury, stack, pos, anim_speed, proj_speed, acc, r, g, b, aim] and [mahousummon, treasury, stack, pos, anim_speed, proj_speed, acc, r, g, b, target] with inputs: [0.1 -0.5 .9, 0 0 0]
[12:53:38] [main/WARN]: Ambiguity between arguments [mahousummon, wepproj, stack, pos, proj_speed, acc, aim] and [mahousummon, wepproj, stack, pos, proj_speed, acc, target] with inputs: [0.1 -0.5 .9, 0 0 0]
[12:53:38] [main/WARN]: Ambiguity between arguments [teleport, destination] and [teleport, targets] with inputs: [Player, 0123, @e, dd12be42-52a9-4a91-a8a1-11c01849e498]
[12:53:38] [main/WARN]: Ambiguity between arguments [teleport, location] and [teleport, destination] with inputs: [0.1 -0.5 .9, 0 0 0]
[12:53:38] [main/WARN]: Ambiguity between arguments [teleport, location] and [teleport, targets] with inputs: [0.1 -0.5 .9, 0 0 0]
[12:53:38] [main/WARN]: Ambiguity between arguments [teleport, targets] and [teleport, destination] with inputs: [Player, 0123, dd12be42-52a9-4a91-a8a1-11c01849e498]
[12:53:38] [main/WARN]: Ambiguity between arguments [teleport, targets, location] and [teleport, targets, destination] with inputs: [0.1 -0.5 .9, 0 0 0]
[12:53:38] [main/WARN]: Ambiguity between arguments [waypoint, create, name, dimension, location, color, announce] and [waypoint, create, name, dimension, location, color, player] with inputs: [true, false]
[12:53:38] [main/WARN]: Ambiguity between arguments [waypoint, delete, name, announce] and [waypoint, delete, name, player] with inputs: [true, false]
[12:53:38] [main/INFO]: Reloading ResourceManager: Default, cgm-1.1.0-1.16.5.jar, jei-1.16.5-7.7.1.152.jar, RingsOfAscension-1.16.4-1.6.0.jar, Clumps-6.0.0.28.jar, journeymap-1.16.5-5.8.0.jar, CookingForBlockheads_1.16.5-9.3.4.jar, appliedenergistics2-8.4.7.jar, NaturesCompass-1.16.5-1.9.1-forge.jar, Artifacts-1.16.5-2.10.3.jar, compactmachines-4.0.0-beta.2.jar, potionsmaster-0.2.2-1.16.5-36.1.0.jar, DungeonCrawl-1.16.5-2.3.5.jar, Bookshelf-Forge-1.16.5-10.4.31.jar, sophisticatedbackpacks-1.16.5-3.15.12.552.jar, DarkUtilities-1.16.5-8.0.11.jar, hammers-v1.3.jar, mahoutsukai-1.16.5-v1.34.9.jar, MekanismGenerators-1.16.5-10.1.2.457.jar, Hwyla-forge-1.10.11-B78_1.16.2.jar, CraftTweaker-1.16.5-7.1.2.505.jar, Mekanism-1.16.5-10.1.2.457.jar, forge-1.16.5-36.2.33-universal.jar, tl_skin_cape_forge_1.16.5-1.17.jar, konkrete_forge_1.3.3_MC_1.16.2-1.16.5.jar, cofh_core-1.16.5-1.4.2.9.jar, ensorcellation-1.16.5-1.4.1.2.jar, industrial-foregoing-1.16.5-3.2.14.7-16.jar, titanium-1.16.5-3.2.8.7-22.jar, BiomesOPlenty-1.16.5-13.1.0.486-universal.jar, Lollipop-1.16.5-3.2.9.jar, allthemodium-1.5.18-1.16.5-36.1.23.jar, mining_dimension-1.16.5-1.0.6.jar, supermartijn642corelib-1.0.16-mc1.16.5.jar, Krate-1.16.5-0.1.4.jar, flywheel-1.16-0.2.5.jar, create-mc1.16.5_v0.3.2g.jar, curios-forge-1.16.5-4.0.5.3.jar, gravestone-1.16.5-1.0.7.jar, [1.16.5]+SecurityCraft+v1.8.23.jar, StorageDrawers-1.16.3-8.5.1.jar, FluxNetworks-1.16.5-6.2.1.14.jar, elevatorid-1.16.5-1.7.13.jar, ftb-ultimine-forge-1605.3.1-build.45.jar, obfuscate-0.6.2-1.16.3.jar, vehicle-mod-0.45.2-1.16.3.jar, Runelic-1.16.5-7.0.2.jar, fancymenu_forge_2.6.4_MC_1.16.2-1.16.5.jar, MekanismTools-1.16.5-10.1.2.457.jar, constructionwand-1.16.5-2.6.jar, cfm-7.0.0pre22-1.16.3.jar, morecfm-1.3.1-1.16.3.jar, architectury-1.30.55.jar, ftb-library-forge-1605.3.4-build.90.jar, item-filters-forge-1605.2.5-build.9.jar, ftb-teams-forge-1605.2.3-build.40.jar, ftb-chunks-forge-1605.3.2-build.115.jar, ftb-quests-forge-1605.3.5-build.72.jar, trashcans-1.0.12-mc1.16.jar, FallingTree-1.16.5-2.11.5.jar, expandability-2.0.2-forge.jar, CodeChickenLib-1.16.5-4.0.7.445-universal.jar, EnderStorage-1.16.5-2.8.0.168-universal.jar
[12:53:45] [main/INFO]: Skipping loading recipe morecfm:endergetic_stripped_poise_mail_box as it's serializer returned null
[12:53:45] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_blue_enchanted_chair as it's serializer returned null
[12:53:45] [main/INFO]: Skipping loading recipe morecfm:atmospheric_stripped_kousa_kitchen_sink_dark as it's serializer returned null
[12:53:45] [main/INFO]: Skipping loading recipe morecfm:atmospheric_yucca_table as it's serializer returned null
[12:53:45] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_willow_desk_cabinet as it's serializer returned null
[12:53:45] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_palm_chair as it's serializer returned null
[12:53:45] [main/INFO]: Skipping loading recipe morecfm:endergetic_stripped_poise_kitchen_drawer as it's serializer returned null
[12:53:45] [main/INFO]: Skipping loading recipe morecfm:atmospheric_stripped_aspen_bedside_cabinet as it's serializer returned null
[12:53:45] [main/INFO]: Skipping loading recipe morecfm:upgrade_aquatic_river_kitchen_counter as it's serializer returned null
[12:53:45] [main/INFO]: Skipping loading recipe morecfm:byg_ebony_chair as it's serializer returned null
[12:53:45] [main/INFO]: Skipping loading recipe morecfm:byg_blue_enchanted_blinds as it's serializer returned null
[12:53:45] [main/INFO]: Skipping loading recipe morecfm:byg_bulbis_chair as it's serializer returned null
[12:53:45] [main/INFO]: Skipping loading recipe morecfm:environmental_cherry_mail_box as it's serializer returned null
[12:53:45] [main/INFO]: Skipping loading recipe morecfm:atmospheric_stripped_aspen_upgraded_fence as it's serializer returned null
[12:53:45] [main/INFO]: Skipping loading recipe morecfm:byg_blue_enchanted_table as it's serializer returned null
[12:53:45] [main/INFO]: Skipping loading recipe morecfm:autumnity_stripped_maple_upgraded_fence as it's serializer returned null
[12:53:45] [main/INFO]: Skipping loading recipe morecfm:atmospheric_stripped_aspen_crate as it's serializer returned null
[12:53:45] [main/INFO]: Skipping loading recipe morecfm:byg_holly_desk_cabinet as it's serializer returned null
[12:53:45] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_mangrove_kitchen_drawer as it's serializer returned null
[12:53:45] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_sythian_park_bench as it's serializer returned null
[12:53:45] [main/INFO]: Skipping loading recipe morecfm:byg_jacaranda_kitchen_drawer as it's serializer returned null
[12:53:45] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_cypress_upgraded_fence as it's serializer returned null
[12:53:45] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_zelkova_mail_box as it's serializer returned null
[12:53:45] [main/INFO]: Skipping loading recipe morecfm:abundance_stripped_redbud_cabinet as it's serializer returned null
[12:53:45] [main/INFO]: Skipping loading recipe morecfm:byg_ether_crate as it's serializer returned null
[12:53:45] [main/INFO]: Skipping loading recipe morecfm:endergetic_stripped_poise_desk as it's serializer returned null
[12:53:45] [main/INFO]: Skipping loading recipe morecfm:byg_imparius_park_bench as it's serializer returned null
[12:53:45] [main/INFO]: Skipping loading recipe morecfm:byg_fir_desk as it's serializer returned null
[12:53:45] [main/INFO]: Skipping loading recipe morecfm:bayou_blues_stripped_cypress_cabinet as it's serializer returned null
[12:53:45] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_fir_coffee_table as it's serializer returned null
[12:53:45] [main/INFO]: Skipping loading recipe morecfm:upgrade_aquatic_stripped_river_crate as it's serializer returned null
[12:53:45] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_blue_enchanted_desk_cabinet as it's serializer returned null
[12:53:45] [main/INFO]: Skipping loading recipe morecfm:environmental_stripped_cherry_park_bench as it's serializer returned null
[12:53:45] [main/INFO]: Skipping loading recipe morecfm:atmospheric_grimwood_coffee_table as it's serializer returned null
[12:53:45] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_cypress_kitchen_counter as it's serializer returned null
[12:53:45] [main/INFO]: Skipping loading recipe morecfm:byg_green_enchanted_mail_box as it's serializer returned null
[12:53:45] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_holly_kitchen_sink_light as it's serializer returned null
[12:53:45] [main/INFO]: Skipping loading recipe morecfm:abundance_jacaranda_desk_cabinet as it's serializer returned null
[12:53:45] [main/INFO]: Skipping loading recipe morecfm:atmospheric_stripped_kousa_coffee_table as it's serializer returned null
[12:53:45] [main/INFO]: Skipping loading recipe morecfm:upgrade_aquatic_stripped_river_desk_cabinet as it's serializer returned null
[12:53:45] [main/INFO]: Skipping loading recipe morecfm:byg_mangrove_crate as it's serializer returned null
[12:53:45] [main/INFO]: Skipping loading recipe morecfm:atmospheric_stripped_yucca_kitchen_sink_dark as it's serializer returned null
[12:53:45] [main/INFO]: Skipping loading recipe morecfm:atmospheric_stripped_aspen_kitchen_sink_light as it's serializer returned null
[12:53:45] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_cypress_park_bench as it's serializer returned null
[12:53:45] [main/INFO]: Skipping loading recipe morecfm:byg_cherry_kitchen_sink_dark as it's serializer returned null
[12:53:45] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_skyris_chair as it's serializer returned null
[12:53:45] [main/INFO]: Skipping loading recipe morecfm:byg_lament_chair as it's serializer returned null
[12:53:45] [main/INFO]: Skipping loading recipe morecfm:byg_ebony_cabinet as it's serializer returned null
[12:53:45] [main/INFO]: Skipping loading recipe morecfm:atmospheric_kousa_coffee_table as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:byg_mangrove_upgraded_gate as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_green_enchanted_mail_box as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:byg_cika_mail_box as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_cherry_kitchen_sink_dark as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_ebony_table as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_skyris_desk_cabinet as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:byg_cherry_upgraded_fence as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:environmental_willow_bedside_cabinet as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:byg_mangrove_mail_box as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:upgrade_aquatic_driftwood_table as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:atmospheric_kousa_chair as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:upgrade_aquatic_river_blinds as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:abundance_stripped_redbud_desk as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:atmospheric_stripped_aspen_cabinet as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_lament_park_bench as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:byg_baobab_bedside_cabinet as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_redwood_kitchen_sink_dark as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:atmospheric_stripped_aspen_kitchen_counter as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:endergetic_stripped_poise_table as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_lament_kitchen_sink_light as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:atmospheric_stripped_kousa_upgraded_fence as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_pine_kitchen_drawer as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_sythian_chair as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:byg_sythian_mail_box as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_fir_chair as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_holly_crate as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:byg_holly_kitchen_drawer as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:byg_cherry_kitchen_sink_light as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:upgrade_aquatic_river_bedside_cabinet as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:byg_aspen_desk as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:endergetic_stripped_poise_blinds as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_zelkova_kitchen_drawer as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:abundance_stripped_jacaranda_kitchen_sink_dark as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:abundance_stripped_redbud_upgraded_gate as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:atmospheric_stripped_aspen_coffee_table as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:byg_cika_cabinet as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:byg_willow_mail_box as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:byg_green_enchanted_coffee_table as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:byg_nightshade_coffee_table as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:abundance_jacaranda_chair as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:byg_fir_park_bench as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:byg_ether_mail_box as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:byg_baobab_upgraded_gate as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:environmental_cherry_table as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:abundance_jacaranda_coffee_table as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:environmental_willow_crate as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:atmospheric_stripped_yucca_park_bench as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:bayou_blues_cypress_blinds as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:bayou_blues_cypress_chair as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_sythian_coffee_table as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:byg_ether_upgraded_gate as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:atmospheric_stripped_aspen_upgraded_gate as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:byg_mahogany_crate as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:byg_redwood_chair as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:byg_lament_cabinet as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_cherry_table as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:byg_aspen_blinds as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:atmospheric_grimwood_blinds as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:byg_willow_park_bench as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:byg_pine_mail_box as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:byg_mahogany_mail_box as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_cypress_desk as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:atmospheric_morado_chair as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe industrialforegoing:laser_drill_ore/ruby as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:byg_palm_table as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:byg_skyris_park_bench as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_willow_coffee_table as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:autumnity_stripped_maple_coffee_table as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:byg_rainbow_eucalyptus_cabinet as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:atmospheric_kousa_desk as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_sythian_kitchen_counter as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:byg_redwood_park_bench as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:byg_baobab_kitchen_counter as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe industrialforegoing:laser_drill_ore/tetrahedrite as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_cypress_kitchen_sink_light as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:byg_cherry_park_bench as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:upgrade_aquatic_driftwood_park_bench as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:environmental_stripped_willow_desk as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:byg_holly_coffee_table as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:byg_zelkova_desk_cabinet as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:byg_cherry_kitchen_drawer as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:byg_blue_enchanted_desk as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:byg_maple_park_bench as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:environmental_wisteria_upgraded_fence as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:byg_ether_desk as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_green_enchanted_desk as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_mangrove_kitchen_counter as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:atmospheric_stripped_kousa_desk_cabinet as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_witch_hazel_upgraded_gate as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:atmospheric_stripped_morado_bedside_cabinet as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:atmospheric_rosewood_kitchen_drawer as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:byg_nightshade_desk_cabinet as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_palm_desk_cabinet as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:byg_pine_chair as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:atmospheric_stripped_aspen_kitchen_drawer as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:byg_rainbow_eucalyptus_chair as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_willow_kitchen_drawer as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:abundance_stripped_jacaranda_kitchen_drawer as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:atmospheric_yucca_mail_box as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_sythian_desk_cabinet as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_cika_crate as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:byg_green_enchanted_chair as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_rainbow_eucalyptus_kitchen_counter as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:byg_maple_chair as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:byg_green_enchanted_kitchen_counter as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_jacaranda_desk as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_fir_upgraded_fence as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:byg_sythian_blinds as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:byg_nightshade_kitchen_drawer as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:atmospheric_aspen_desk_cabinet as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:byg_fir_cabinet as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_jacaranda_kitchen_drawer as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:byg_mangrove_bedside_cabinet as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:byg_imparius_crate as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:environmental_stripped_wisteria_upgraded_gate as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:environmental_stripped_wisteria_kitchen_drawer as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:byg_cika_kitchen_sink_light as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:byg_zelkova_table as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:byg_willow_blinds as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:byg_mahogany_blinds as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_jacaranda_upgraded_fence as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:byg_cherry_desk as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:byg_holly_table as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:byg_cypress_upgraded_gate as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_baobab_chair as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_nightshade_blinds as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:autumnity_maple_mail_box as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:byg_imparius_bedside_cabinet as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:bayou_blues_stripped_cypress_kitchen_drawer as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:byg_willow_bedside_cabinet as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:atmospheric_stripped_rosewood_kitchen_sink_dark as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:atmospheric_rosewood_upgraded_gate as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:upgrade_aquatic_driftwood_cabinet as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe industrialforegoing:laser_drill_ore/aluminum as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:atmospheric_stripped_kousa_blinds as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_green_enchanted_kitchen_drawer as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:byg_rainbow_eucalyptus_kitchen_sink_light as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_rainbow_eucalyptus_blinds as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_nightshade_upgraded_fence as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_zelkova_table as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_mangrove_blinds as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:atmospheric_stripped_morado_table as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:autumnity_stripped_maple_cabinet as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_witch_hazel_chair as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_rainbow_eucalyptus_crate as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:upgrade_aquatic_stripped_driftwood_park_bench as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:byg_pine_blinds as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:byg_redwood_kitchen_counter as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:upgrade_aquatic_driftwood_upgraded_gate as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_ebony_kitchen_drawer as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_maple_park_bench as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:byg_skyris_kitchen_drawer as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:byg_ebony_park_bench as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:byg_cypress_kitchen_sink_dark as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_redwood_crate as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe industrialforegoing:laser_drill_ore/bitumen as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_lament_crate as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_witch_hazel_kitchen_sink_light as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:byg_cypress_blinds as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:atmospheric_grimwood_desk_cabinet as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:atmospheric_aspen_desk as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_skyris_desk as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:environmental_willow_kitchen_counter as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_maple_mail_box as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_cypress_kitchen_drawer as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:atmospheric_grimwood_kitchen_sink_light as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_cypress_crate as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:byg_pine_bedside_cabinet as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_holly_blinds as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_jacaranda_mail_box as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:environmental_stripped_wisteria_upgraded_fence as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_jacaranda_chair as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe industrialforegoing:laser_drill_ore/peridot as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:atmospheric_yucca_blinds as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:byg_imparius_desk as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:byg_witch_hazel_blinds as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:byg_rainbow_eucalyptus_crate as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:atmospheric_stripped_kousa_table as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:atmospheric_morado_kitchen_drawer as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_fir_kitchen_counter as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:environmental_stripped_cherry_kitchen_drawer as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:byg_palm_upgraded_fence as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:byg_pine_kitchen_sink_light as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_pine_mail_box as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:byg_cherry_coffee_table as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:byg_aspen_crate as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:environmental_stripped_cherry_chair as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:upgrade_aquatic_river_coffee_table as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:abundance_stripped_redbud_coffee_table as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:upgrade_aquatic_river_kitchen_drawer as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:byg_skyris_kitchen_counter as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_aspen_table as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:autumnity_maple_bedside_cabinet as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_nightshade_park_bench as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:atmospheric_grimwood_cabinet as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:atmospheric_stripped_yucca_kitchen_counter as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_fir_blinds as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:atmospheric_grimwood_mail_box as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_ether_bedside_cabinet as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:byg_bulbis_kitchen_counter as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_ebony_desk as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_rainbow_eucalyptus_park_bench as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:abundance_jacaranda_kitchen_counter as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_witch_hazel_kitchen_sink_dark as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_zelkova_upgraded_fence as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:atmospheric_stripped_aspen_desk as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:byg_bulbis_desk_cabinet as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_rainbow_eucalyptus_upgraded_gate as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:byg_jacaranda_cabinet as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_aspen_desk_cabinet as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_jacaranda_desk_cabinet as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_maple_desk_cabinet as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_aspen_park_bench as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:bayou_blues_cypress_bedside_cabinet as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_mangrove_kitchen_sink_dark as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:atmospheric_stripped_morado_cabinet as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_ebony_upgraded_gate as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:autumnity_stripped_maple_kitchen_drawer as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_green_enchanted_cabinet as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:atmospheric_stripped_aspen_desk_cabinet as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:autumnity_maple_park_bench as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_palm_upgraded_gate as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:byg_cherry_blinds as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:byg_cypress_coffee_table as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_ebony_cabinet as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:byg_nightshade_chair as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_cypress_chair as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_ether_kitchen_counter as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_baobab_kitchen_sink_light as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:abundance_stripped_jacaranda_desk as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:byg_zelkova_blinds as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:upgrade_aquatic_stripped_river_kitchen_counter as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:byg_witch_hazel_mail_box as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:byg_green_enchanted_desk_cabinet as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:byg_jacaranda_upgraded_fence as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:byg_holly_upgraded_gate as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:atmospheric_stripped_yucca_bedside_cabinet as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:byg_palm_bedside_cabinet as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:abundance_stripped_redbud_park_bench as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_ether_upgraded_fence as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:byg_sythian_cabinet as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:byg_palm_park_bench as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:bayou_blues_cypress_kitchen_counter as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_palm_cabinet as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:byg_redwood_upgraded_fence as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_rainbow_eucalyptus_cabinet as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:byg_jacaranda_bedside_cabinet as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:byg_ebony_kitchen_counter as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:autumnity_maple_desk_cabinet as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:byg_palm_kitchen_sink_light as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:endergetic_stripped_poise_desk_cabinet as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:byg_ebony_kitchen_sink_dark as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:autumnity_maple_kitchen_counter as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:byg_mahogany_desk as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:atmospheric_stripped_grimwood_upgraded_gate as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:abundance_stripped_jacaranda_chair as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:endergetic_stripped_poise_upgraded_fence as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_maple_kitchen_sink_light as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_green_enchanted_blinds as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:byg_willow_kitchen_counter as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:autumnity_maple_crate as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_aspen_kitchen_sink_dark as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_willow_chair as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:upgrade_aquatic_stripped_driftwood_kitchen_drawer as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:byg_aspen_upgraded_gate as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_witch_hazel_kitchen_counter as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:byg_blue_enchanted_kitchen_sink_dark as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:environmental_willow_kitchen_sink_dark as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:atmospheric_rosewood_blinds as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_cika_cabinet as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe industrialforegoing:laser_drill_ore/galena as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:atmospheric_stripped_rosewood_bedside_cabinet as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:environmental_willow_upgraded_gate as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:byg_redwood_bedside_cabinet as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_baobab_kitchen_counter as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_cika_mail_box as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:byg_mahogany_kitchen_drawer as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:endergetic_stripped_poise_upgraded_gate as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_maple_kitchen_drawer as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe industrialforegoing:laser_drill_ore/tungsten as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:abundance_jacaranda_mail_box as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:byg_skyris_table as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:environmental_stripped_willow_blinds as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:byg_rainbow_eucalyptus_park_bench as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_fir_desk as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:byg_cypress_desk as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:byg_willow_chair as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:byg_zelkova_kitchen_counter as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_rainbow_eucalyptus_kitchen_drawer as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:atmospheric_stripped_kousa_kitchen_drawer as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:byg_palm_kitchen_counter as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:upgrade_aquatic_river_crate as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:byg_pine_upgraded_gate as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:environmental_stripped_willow_kitchen_sink_dark as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:byg_fir_desk_cabinet as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_willow_bedside_cabinet as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:byg_bulbis_kitchen_drawer as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:byg_lament_mail_box as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:upgrade_aquatic_stripped_driftwood_desk as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:atmospheric_rosewood_bedside_cabinet as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:byg_jacaranda_crate as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:byg_holly_kitchen_sink_light as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:atmospheric_yucca_kitchen_sink_light as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_green_enchanted_park_bench as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:environmental_stripped_cherry_coffee_table as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_maple_table as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_sythian_bedside_cabinet as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_holly_desk as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:atmospheric_stripped_grimwood_table as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:byg_mahogany_kitchen_sink_dark as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:upgrade_aquatic_river_mail_box as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_ether_desk_cabinet as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:byg_aspen_park_bench as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:atmospheric_yucca_kitchen_sink_dark as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:byg_lament_upgraded_gate as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:bayou_blues_stripped_cypress_kitchen_sink_dark as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:byg_imparius_cabinet as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:upgrade_aquatic_driftwood_kitchen_sink_light as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:environmental_willow_kitchen_drawer as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_cika_park_bench as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:byg_cika_chair as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:byg_palm_mail_box as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_willow_desk as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:atmospheric_aspen_coffee_table as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_baobab_mail_box as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_fir_desk_cabinet as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:byg_redwood_coffee_table as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:atmospheric_kousa_desk_cabinet as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:atmospheric_stripped_rosewood_chair as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_witch_hazel_desk_cabinet as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:byg_cika_upgraded_fence as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_lament_bedside_cabinet as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_skyris_upgraded_fence as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:atmospheric_stripped_yucca_chair as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:byg_redwood_upgraded_gate as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:upgrade_aquatic_driftwood_blinds as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:byg_ether_blinds as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_skyris_coffee_table as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:upgrade_aquatic_river_kitchen_sink_dark as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_nightshade_chair as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_mangrove_upgraded_fence as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:byg_ebony_desk_cabinet as it's serializer returned null
[12:53:46] [main/INFO]: Skipping loading recipe morecfm:environmental_stripped_wisteria_kitchen_sink_light as it's serializer returned null
[12:53:47] [main/INFO]: Skipping loading recipe morecfm:byg_cypress_upgraded_fence as it's serializer returned null
[12:53:47] [main/INFO]: Skipping loading recipe morecfm:environmental_stripped_cherry_kitchen_sink_dark as it's serializer returned null
[12:53:47] [main/INFO]: Skipping loading recipe morecfm:byg_lament_coffee_table as it's serializer returned null
[12:53:47] [main/INFO]: Skipping loading recipe industrialforegoing:laser_drill_ore/iridium as it's serializer returned null
[12:53:47] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_lament_kitchen_drawer as it's serializer returned null
[12:53:47] [main/INFO]: Skipping loading recipe morecfm:byg_jacaranda_upgraded_gate as it's serializer returned null
[12:53:47] [main/INFO]: Skipping loading recipe morecfm:byg_aspen_desk_cabinet as it's serializer returned null
[12:53:47] [main/INFO]: Skipping loading recipe morecfm:byg_nightshade_upgraded_gate as it's serializer returned null
[12:53:47] [main/INFO]: Skipping loading recipe morecfm:byg_willow_desk as it's serializer returned null
[12:53:47] [main/INFO]: Skipping loading recipe morecfm:byg_witch_hazel_desk_cabinet as it's serializer returned null
[12:53:47] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_rainbow_eucalyptus_desk as it's serializer returned null
[12:53:47] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_zelkova_kitchen_counter as it's serializer returned null
[12:53:47] [main/INFO]: Skipping loading recipe morecfm:abundance_redbud_blinds as it's serializer returned null
[12:53:47] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_lament_chair as it's serializer returned null
[12:53:47] [main/INFO]: Skipping loading recipe morecfm:byg_blue_enchanted_mail_box as it's serializer returned null
[12:53:47] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_redwood_coffee_table as it's serializer returned null
[12:53:47] [main/INFO]: Skipping loading recipe morecfm:byg_skyris_kitchen_sink_dark as it's serializer returned null
[12:53:47] [main/INFO]: Skipping loading recipe morecfm:abundance_jacaranda_upgraded_gate as it's serializer returned null
[12:53:47] [main/INFO]: Skipping loading recipe morecfm:atmospheric_stripped_morado_coffee_table as it's serializer returned null
[12:53:47] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_mahogany_kitchen_drawer as it's serializer returned null
[12:53:47] [main/INFO]: Skipping loading recipe morecfm:atmospheric_stripped_rosewood_cabinet as it's serializer returned null
[12:53:47] [main/INFO]: Skipping loading recipe morecfm:byg_willow_table as it's serializer returned null
[12:53:47] [main/INFO]: Skipping loading recipe morecfm:byg_ether_desk_cabinet as it's serializer returned null
[12:53:47] [main/INFO]: Skipping loading recipe morecfm:byg_green_enchanted_kitchen_drawer as it's serializer returned null
[12:53:47] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_cika_coffee_table as it's serializer returned null
[12:53:47] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_jacaranda_kitchen_sink_dark as it's serializer returned null
[12:53:47] [main/INFO]: Skipping loading recipe morecfm:atmospheric_rosewood_desk_cabinet as it's serializer returned null
[12:53:47] [main/INFO]: Skipping loading recipe morecfm:byg_baobab_table as it's serializer returned null
[12:53:47] [main/INFO]: Skipping loading recipe morecfm:autumnity_maple_chair as it's serializer returned null
[12:53:47] [main/INFO]: Skipping loading recipe morecfm:endergetic_stripped_poise_kitchen_sink_dark as it's serializer returned null
[12:53:47] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_nightshade_kitchen_sink_dark as it's serializer returned null
[12:53:47] [main/INFO]: Skipping loading recipe morecfm:byg_aspen_upgraded_fence as it's serializer returned null
[12:53:47] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_holly_chair as it's serializer returned null
[12:53:47] [main/INFO]: Skipping loading recipe morecfm:bayou_blues_stripped_cypress_desk_cabinet as it's serializer returned null
[12:53:47] [main/INFO]: Skipping loading recipe morecfm:atmospheric_grimwood_bedside_cabinet as it's serializer returned null
[12:53:47] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_ether_coffee_table as it's serializer returned null
[12:53:47] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_mahogany_table as it's serializer returned null
[12:53:47] [main/INFO]: Skipping loading recipe morecfm:byg_lament_kitchen_sink_light as it's serializer returned null
[12:53:47] [main/ERROR]: Parsing error loading recipe cfm:craft_sofa
com.google.gson.JsonSyntaxException: Invalid vehicle entity: vehicle:sofa
	at com.mrcrayfish.vehicle.crafting.VehicleRecipeSerializer.read(VehicleRecipeSerializer.java:48) ~[?:0.45.2-1.16.3]
	at com.mrcrayfish.vehicle.crafting.VehicleRecipeSerializer.func_199425_a_(VehicleRecipeSerializer.java:23) ~[?:0.45.2-1.16.3]
	at net.minecraft.item.crafting.RecipeManager.func_215377_a(RecipeManager.java:141) ~[?:?]
	at net.minecraft.item.crafting.RecipeManager.func_212853_a_(RecipeManager.java:61) [?:?]
	at net.minecraft.item.crafting.RecipeManager.func_212853_a_(RecipeManager.java:38) [?:?]
	at net.minecraft.client.resources.ReloadListener.func_215269_a(SourceFile:13) [?:?]
	at net.minecraft.client.resources.ReloadListener$$Lambda$9873/1436560249.accept(Unknown Source) [?:?]
	at java.util.concurrent.CompletableFuture.uniAccept(CompletableFuture.java:656) [?:1.8.0_51]
	at java.util.concurrent.CompletableFuture$UniAccept.tryFire(CompletableFuture.java:632) [?:1.8.0_51]
	at java.util.concurrent.CompletableFuture$Completion.run(CompletableFuture.java:442) [?:1.8.0_51]
	at net.minecraft.resources.AsyncReloader.func_219557_a(SourceFile:71) [?:?]
	at net.minecraft.resources.AsyncReloader$$Lambda$10018/707432592.run(Unknown Source) [?:?]
	at net.minecraft.util.concurrent.ThreadTaskExecutor.func_213166_h(ThreadTaskExecutor.java:191) [?:?]
	at net.minecraft.util.concurrent.RecursiveEventLoop.func_213166_h(SourceFile:23) [?:?]
	at net.minecraft.util.concurrent.ThreadTaskExecutor.func_213168_p(ThreadTaskExecutor.java:153) [?:?]
	at net.minecraft.util.concurrent.ThreadTaskExecutor.func_213161_c(ThreadTaskExecutor.java:169) [?:?]
	at net.minecraft.client.Minecraft.func_238189_a_(Minecraft.java:1865) [?:?]
	at net.minecraft.client.Minecraft.loadWorld(Minecraft.java:1714) [?:?]
	at net.minecraft.client.Minecraft.func_238192_a_(Minecraft.java:1687) [?:?]
	at net.minecraft.client.gui.screen.CreateWorldScreen.func_195352_j(CreateWorldScreen.java:260) [?:?]
	at net.minecraft.client.gui.screen.CreateWorldScreen.lambda$init$11(CreateWorldScreen.java:205) [?:?]
	at net.minecraft.client.gui.screen.CreateWorldScreen$$Lambda$12951/1871004871.onPress(Unknown Source) [?:?]
	at net.minecraft.client.gui.widget.button.Button.func_230930_b_(SourceFile:33) [?:?]
	at net.minecraft.client.gui.widget.button.AbstractButton.func_230982_a_(SourceFile:16) [?:?]
	at net.minecraft.client.gui.widget.Widget.func_231044_a_(Widget.java:136) [?:?]
	at net.minecraft.client.gui.INestedGuiEventHandler.func_231044_a_(SourceFile:27) [?:?]
	at net.minecraft.client.MouseHelper.func_198033_b(MouseHelper.java:87) [?:?]
	at net.minecraft.client.MouseHelper$$Lambda$12646/468309489.run(Unknown Source) [?:?]
	at net.minecraft.client.gui.screen.Screen.func_231153_a_(Screen.java:427) [?:?]
	at net.minecraft.client.MouseHelper.func_198023_a(MouseHelper.java:85) [?:?]
	at net.minecraft.client.MouseHelper.func_228030_c_(MouseHelper.java:181) [?:?]
	at net.minecraft.client.MouseHelper$$Lambda$12645/1510532588.run(Unknown Source) [?:?]
	at net.minecraft.util.concurrent.ThreadTaskExecutor.execute(ThreadTaskExecutor.java:106) [?:?]
	at net.minecraft.client.MouseHelper.func_228028_b_(MouseHelper.java:180) [?:?]
	at net.minecraft.client.MouseHelper$$Lambda$9851/1244357368.invoke(Unknown Source) [?:?]
	at org.lwjgl.glfw.GLFWMouseButtonCallbackI.callback(GLFWMouseButtonCallbackI.java:36) [lwjgl-glfw-3.2.2.jar:build 10]
	at org.lwjgl.system.JNI.invokeV(Native Method) ~[lwjgl-3.2.2.jar:build 10]
	at org.lwjgl.glfw.GLFW.glfwPollEvents(GLFW.java:3101) [lwjgl-glfw-3.2.2.jar:build 10]
	at com.mojang.blaze3d.systems.RenderSystem.flipFrame(SourceFile:102) [?:?]
	at net.minecraft.client.MainWindow.func_227802_e_(MainWindow.java:398) [?:?]
	at net.minecraft.client.Minecraft.func_195542_b(Minecraft.java:997) [?:?]
	at net.minecraft.client.Minecraft.func_99999_d(Minecraft.java:607) [?:?]
	at net.minecraft.client.main.Main.main(Main.java:184) [?:?]
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) ~[?:1.8.0_51]
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) ~[?:1.8.0_51]
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) ~[?:1.8.0_51]
	at java.lang.reflect.Method.invoke(Method.java:497) ~[?:1.8.0_51]
	at net.minecraftforge.fml.loading.FMLClientLaunchProvider.lambda$launchService$0(FMLClientLaunchProvider.java:51) [forge-1.16.5-36.2.33.jar:36.2]
	at net.minecraftforge.fml.loading.FMLClientLaunchProvider$$Lambda$496/1753746465.call(Unknown Source) [forge-1.16.5-36.2.33.jar:36.2]
	at cpw.mods.modlauncher.LaunchServiceHandlerDecorator.launch(LaunchServiceHandlerDecorator.java:37) [modlauncher-8.1.3.jar:?]
	at cpw.mods.modlauncher.LaunchServiceHandler.launch(LaunchServiceHandler.java:54) [modlauncher-8.1.3.jar:?]
	at cpw.mods.modlauncher.LaunchServiceHandler.launch(LaunchServiceHandler.java:72) [modlauncher-8.1.3.jar:?]
	at cpw.mods.modlauncher.Launcher.run(Launcher.java:82) [modlauncher-8.1.3.jar:?]
	at cpw.mods.modlauncher.Launcher.main(Launcher.java:66) [modlauncher-8.1.3.jar:?]
[12:53:47] [main/INFO]: Skipping loading recipe morecfm:atmospheric_kousa_upgraded_fence as it's serializer returned null
[12:53:47] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_mahogany_blinds as it's serializer returned null
[12:53:47] [main/INFO]: Skipping loading recipe morecfm:bayou_blues_stripped_cypress_upgraded_gate as it's serializer returned null
[12:53:47] [main/INFO]: Skipping loading recipe morecfm:environmental_stripped_wisteria_table as it's serializer returned null
[12:53:47] [main/INFO]: Skipping loading recipe morecfm:environmental_stripped_willow_desk_cabinet as it's serializer returned null
[12:53:47] [main/INFO]: Skipping loading recipe morecfm:environmental_willow_cabinet as it's serializer returned null
[12:53:47] [main/INFO]: Skipping loading recipe morecfm:environmental_willow_desk_cabinet as it's serializer returned null
[12:53:47] [main/INFO]: Skipping loading recipe morecfm:byg_rainbow_eucalyptus_mail_box as it's serializer returned null
[12:53:47] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_skyris_kitchen_sink_dark as it's serializer returned null
[12:53:47] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_palm_bedside_cabinet as it's serializer returned null
[12:53:47] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_mahogany_coffee_table as it's serializer returned null
[12:53:47] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_blue_enchanted_desk as it's serializer returned null
[12:53:47] [main/INFO]: Skipping loading recipe morecfm:atmospheric_stripped_grimwood_mail_box as it's serializer returned null
[12:53:47] [main/INFO]: Skipping loading recipe morecfm:upgrade_aquatic_driftwood_desk as it's serializer returned null
[12:53:47] [main/INFO]: Skipping loading recipe morecfm:environmental_cherry_desk_cabinet as it's serializer returned null
[12:53:47] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_pine_kitchen_sink_dark as it's serializer returned null
[12:53:47] [main/INFO]: Skipping loading recipe morecfm:byg_rainbow_eucalyptus_desk_cabinet as it's serializer returned null
[12:53:47] [main/INFO]: Skipping loading recipe morecfm:byg_baobab_park_bench as it's serializer returned null
[12:53:47] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_cika_chair as it's serializer returned null
[12:53:47] [main/INFO]: Skipping loading recipe morecfm:byg_imparius_mail_box as it's serializer returned null
[12:53:47] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_skyris_crate as it's serializer returned null
[12:53:47] [main/INFO]: Skipping loading recipe morecfm:byg_jacaranda_table as it's serializer returned null
[12:53:47] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_cika_table as it's serializer returned null
[12:53:47] [main/INFO]: Skipping loading recipe morecfm:upgrade_aquatic_river_cabinet as it's serializer returned null
[12:53:47] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_blue_enchanted_kitchen_counter as it's serializer returned null
[12:53:47] [main/INFO]: Skipping loading recipe morecfm:upgrade_aquatic_driftwood_kitchen_sink_dark as it's serializer returned null
[12:53:47] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_baobab_bedside_cabinet as it's serializer returned null
[12:53:47] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_ether_blinds as it's serializer returned null
[12:53:47] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_nightshade_crate as it's serializer returned null
[12:53:47] [main/INFO]: Skipping loading recipe morecfm:atmospheric_aspen_blinds as it's serializer returned null
[12:53:47] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_cypress_kitchen_sink_dark as it's serializer returned null
[12:53:47] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_holly_kitchen_sink_dark as it's serializer returned null
[12:53:47] [main/INFO]: Skipping loading recipe morecfm:byg_nightshade_kitchen_counter as it's serializer returned null
[12:53:47] [main/INFO]: Skipping loading recipe morecfm:endergetic_poise_upgraded_fence as it's serializer returned null
[12:53:47] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_aspen_upgraded_fence as it's serializer returned null
[12:53:47] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_ebony_kitchen_sink_dark as it's serializer returned null
[12:53:47] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_palm_crate as it's serializer returned null
[12:53:47] [main/INFO]: Skipping loading recipe morecfm:atmospheric_rosewood_coffee_table as it's serializer returned null
[12:53:47] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_jacaranda_upgraded_gate as it's serializer returned null
[12:53:47] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_mangrove_table as it's serializer returned null
[12:53:47] [main/INFO]: Skipping loading recipe morecfm:byg_cherry_mail_box as it's serializer returned null
[12:53:47] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_cherry_blinds as it's serializer returned null
[12:53:47] [main/INFO]: Skipping loading recipe morecfm:upgrade_aquatic_driftwood_kitchen_counter as it's serializer returned null
[12:53:47] [main/INFO]: Skipping loading recipe morecfm:atmospheric_kousa_cabinet as it's serializer returned null
[12:53:47] [main/INFO]: Skipping loading recipe morecfm:byg_ebony_crate as it's serializer returned null
[12:53:47] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_redwood_blinds as it's serializer returned null
[12:53:47] [main/INFO]: Skipping loading recipe morecfm:atmospheric_grimwood_desk as it's serializer returned null
[12:53:47] [main/INFO]: Skipping loading recipe morecfm:endergetic_poise_cabinet as it's serializer returned null
[12:53:47] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_ebony_kitchen_sink_light as it's serializer returned null
[12:53:47] [main/INFO]: Skipping loading recipe morecfm:endergetic_stripped_poise_bedside_cabinet as it's serializer returned null
[12:53:47] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_green_enchanted_kitchen_sink_dark as it's serializer returned null
[12:53:47] [main/INFO]: Skipping loading recipe morecfm:atmospheric_grimwood_crate as it's serializer returned null
[12:53:47] [main/INFO]: Skipping loading recipe morecfm:byg_imparius_blinds as it's serializer returned null
[12:53:47] [main/INFO]: Skipping loading recipe morecfm:upgrade_aquatic_stripped_river_upgraded_gate as it's serializer returned null
[12:53:47] [main/INFO]: Skipping loading recipe morecfm:byg_maple_kitchen_counter as it's serializer returned null
[12:53:47] [main/INFO]: Skipping loading recipe morecfm:byg_jacaranda_kitchen_sink_light as it's serializer returned null
[12:53:47] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_ebony_coffee_table as it's serializer returned null
[12:53:47] [main/INFO]: Skipping loading recipe morecfm:atmospheric_yucca_bedside_cabinet as it's serializer returned null
[12:53:47] [main/INFO]: Skipping loading recipe morecfm:byg_imparius_kitchen_sink_dark as it's serializer returned null
[12:53:47] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_pine_coffee_table as it's serializer returned null
[12:53:47] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_lament_mail_box as it's serializer returned null
[12:53:47] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_skyris_park_bench as it's serializer returned null
[12:53:47] [main/INFO]: Skipping loading recipe morecfm:environmental_cherry_cabinet as it's serializer returned null
[12:53:47] [main/INFO]: Skipping loading recipe morecfm:byg_cherry_bedside_cabinet as it's serializer returned null
[12:53:47] [main/INFO]: Skipping loading recipe morecfm:byg_willow_kitchen_sink_dark as it's serializer returned null
[12:53:47] [main/INFO]: Skipping loading recipe morecfm:byg_baobab_upgraded_fence as it's serializer returned null
[12:53:47] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_cika_kitchen_sink_dark as it's serializer returned null
[12:53:47] [main/INFO]: Skipping loading recipe morecfm:environmental_stripped_willow_mail_box as it's serializer returned null
[12:53:47] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_nightshade_cabinet as it's serializer returned null
[12:53:47] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_green_enchanted_table as it's serializer returned null
[12:53:47] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_blue_enchanted_blinds as it's serializer returned null
[12:53:47] [main/INFO]: Skipping loading recipe morecfm:byg_fir_mail_box as it's serializer returned null
[12:53:47] [main/INFO]: Skipping loading recipe morecfm:byg_skyris_upgraded_fence as it's serializer returned null
[12:53:47] [main/INFO]: Skipping loading recipe morecfm:byg_redwood_blinds as it's serializer returned null
[12:53:47] [main/INFO]: Skipping loading recipe morecfm:byg_maple_coffee_table as it's serializer returned null
[12:53:47] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_cika_blinds as it's serializer returned null
[12:53:47] [main/INFO]: Skipping loading recipe morecfm:byg_mahogany_kitchen_sink_light as it's serializer returned null
[12:53:47] [main/INFO]: Skipping loading recipe morecfm:environmental_stripped_cherry_table as it's serializer returned null
[12:53:47] [main/INFO]: Skipping loading recipe morecfm:environmental_stripped_wisteria_kitchen_counter as it's serializer returned null
[12:53:47] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_blue_enchanted_kitchen_sink_light as it's serializer returned null
[12:53:47] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_cika_desk_cabinet as it's serializer returned null
[12:53:47] [main/INFO]: Skipping loading recipe morecfm:abundance_stripped_redbud_desk_cabinet as it's serializer returned null
[12:53:47] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_mahogany_bedside_cabinet as it's serializer returned null
[12:53:47] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_blue_enchanted_upgraded_fence as it's serializer returned null
[12:53:47] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_baobab_blinds as it's serializer returned null
[12:53:47] [main/INFO]: Skipping loading recipe morecfm:environmental_cherry_kitchen_counter as it's serializer returned null
[12:53:47] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_cherry_crate as it's serializer returned null
[12:53:47] [main/INFO]: Skipping loading recipe morecfm:byg_holly_kitchen_counter as it's serializer returned null
[12:53:47] [main/INFO]: Skipping loading recipe morecfm:upgrade_aquatic_river_desk_cabinet as it's serializer returned null
[12:53:47] [main/INFO]: Skipping loading recipe morecfm:atmospheric_stripped_yucca_kitchen_sink_light as it's serializer returned null
[12:53:47] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_palm_park_bench as it's serializer returned null
[12:53:47] [main/INFO]: Skipping loading recipe morecfm:environmental_stripped_cherry_blinds as it's serializer returned null
[12:53:47] [main/INFO]: Skipping loading recipe morecfm:atmospheric_aspen_upgraded_fence as it's serializer returned null
[12:53:47] [main/INFO]: Skipping loading recipe morecfm:environmental_willow_kitchen_sink_light as it's serializer returned null
[12:53:47] [main/INFO]: Skipping loading recipe morecfm:byg_pine_park_bench as it's serializer returned null
[12:53:47] [main/INFO]: Skipping loading recipe morecfm:upgrade_aquatic_stripped_driftwood_blinds as it's serializer returned null
[12:53:47] [main/INFO]: Skipping loading recipe morecfm:atmospheric_stripped_kousa_desk as it's serializer returned null
[12:53:47] [main/INFO]: Skipping loading recipe morecfm:endergetic_poise_coffee_table as it's serializer returned null
[12:53:47] [main/INFO]: Skipping loading recipe morecfm:byg_imparius_coffee_table as it's serializer returned null
[12:53:47] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_fir_kitchen_drawer as it's serializer returned null
[12:53:47] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_ether_chair as it's serializer returned null
[12:53:47] [main/INFO]: Skipping loading recipe morecfm:bayou_blues_cypress_kitchen_drawer as it's serializer returned null
[12:53:47] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_willow_cabinet as it's serializer returned null
[12:53:47] [main/INFO]: Skipping loading recipe morecfm:upgrade_aquatic_river_desk as it's serializer returned null
[12:53:47] [main/INFO]: Skipping loading recipe morecfm:abundance_redbud_chair as it's serializer returned null
[12:53:47] [main/INFO]: Skipping loading recipe morecfm:byg_bulbis_upgraded_fence as it's serializer returned null
[12:53:47] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_witch_hazel_crate as it's serializer returned null
[12:53:47] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_aspen_desk as it's serializer returned null
[12:53:47] [main/INFO]: Skipping loading recipe morecfm:abundance_stripped_redbud_mail_box as it's serializer returned null
[12:53:47] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_rainbow_eucalyptus_mail_box as it's serializer returned null
[12:53:47] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_mahogany_kitchen_sink_dark as it's serializer returned null
[12:53:47] [main/INFO]: Skipping loading recipe morecfm:autumnity_stripped_maple_table as it's serializer returned null
[12:53:47] [main/INFO]: Skipping loading recipe morecfm:byg_willow_cabinet as it's serializer returned null
[12:53:47] [main/INFO]: Skipping loading recipe morecfm:environmental_stripped_cherry_desk_cabinet as it's serializer returned null
[12:53:47] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_sythian_mail_box as it's serializer returned null
[12:53:47] [main/INFO]: Skipping loading recipe morecfm:environmental_willow_mail_box as it's serializer returned null
[12:53:47] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_palm_kitchen_sink_dark as it's serializer returned null
[12:53:47] [main/INFO]: Skipping loading recipe morecfm:abundance_jacaranda_bedside_cabinet as it's serializer returned null
[12:53:47] [main/INFO]: Skipping loading recipe morecfm:environmental_willow_chair as it's serializer returned null
[12:53:47] [main/INFO]: Skipping loading recipe morecfm:byg_mahogany_cabinet as it's serializer returned null
[12:53:47] [main/INFO]: Skipping loading recipe morecfm:byg_cypress_crate as it's serializer returned null
[12:53:47] [main/INFO]: Skipping loading recipe morecfm:autumnity_maple_cabinet as it's serializer returned null
[12:53:47] [main/INFO]: Skipping loading recipe morecfm:atmospheric_aspen_table as it's serializer returned null
[12:53:47] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_willow_blinds as it's serializer returned null
[12:53:47] [main/INFO]: Skipping loading recipe morecfm:atmospheric_stripped_kousa_mail_box as it's serializer returned null
[12:53:47] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_cika_bedside_cabinet as it's serializer returned null
[12:53:47] [main/INFO]: Skipping loading recipe morecfm:atmospheric_stripped_rosewood_blinds as it's serializer returned null
[12:53:47] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_cherry_cabinet as it's serializer returned null
[12:53:47] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_mangrove_park_bench as it's serializer returned null
[12:53:47] [main/INFO]: Skipping loading recipe morecfm:byg_nightshade_upgraded_fence as it's serializer returned null
[12:53:47] [main/INFO]: Skipping loading recipe morecfm:environmental_stripped_cherry_desk as it's serializer returned null
[12:53:47] [main/INFO]: Skipping loading recipe morecfm:byg_redwood_crate as it's serializer returned null
[12:53:47] [main/INFO]: Skipping loading recipe morecfm:abundance_stripped_jacaranda_upgraded_fence as it's serializer returned null
[12:53:47] [main/INFO]: Skipping loading recipe morecfm:abundance_jacaranda_kitchen_sink_dark as it's serializer returned null
[12:53:47] [main/INFO]: Skipping loading recipe morecfm:byg_aspen_kitchen_drawer as it's serializer returned null
[12:53:47] [main/INFO]: Skipping loading recipe morecfm:atmospheric_morado_crate as it's serializer returned null
[12:53:47] [main/INFO]: Skipping loading recipe morecfm:byg_skyris_bedside_cabinet as it's serializer returned null
[12:53:47] [main/INFO]: Skipping loading recipe morecfm:byg_bulbis_kitchen_sink_dark as it's serializer returned null
[12:53:47] [main/INFO]: Skipping loading recipe industrialforegoing:laser_drill_ore/silver as it's serializer returned null
[12:53:47] [main/INFO]: Skipping loading recipe morecfm:byg_ebony_kitchen_sink_light as it's serializer returned null
[12:53:47] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_maple_crate as it's serializer returned null
[12:53:47] [main/INFO]: Skipping loading recipe morecfm:byg_cherry_cabinet as it's serializer returned null
[12:53:47] [main/INFO]: Skipping loading recipe morecfm:byg_sythian_kitchen_drawer as it's serializer returned null
[12:53:47] [main/INFO]: Skipping loading recipe morecfm:upgrade_aquatic_stripped_driftwood_table as it's serializer returned null
[12:53:47] [main/INFO]: Skipping loading recipe morecfm:upgrade_aquatic_stripped_driftwood_cabinet as it's serializer returned null
[12:53:47] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_willow_kitchen_counter as it's serializer returned null
[12:53:47] [main/INFO]: Skipping loading recipe morecfm:environmental_stripped_willow_cabinet as it's serializer returned null
[12:53:47] [main/INFO]: Skipping loading recipe morecfm:byg_skyris_mail_box as it's serializer returned null
[12:53:47] [main/INFO]: Skipping loading recipe morecfm:byg_bulbis_kitchen_sink_light as it's serializer returned null
[12:53:47] [main/INFO]: Skipping loading recipe morecfm:environmental_cherry_blinds as it's serializer returned null
[12:53:47] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_cika_upgraded_fence as it's serializer returned null
[12:53:47] [main/INFO]: Skipping loading recipe morecfm:endergetic_poise_kitchen_drawer as it's serializer returned null
[12:53:47] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_willow_upgraded_gate as it's serializer returned null
[12:53:47] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_ether_kitchen_sink_dark as it's serializer returned null
[12:53:47] [main/INFO]: Skipping loading recipe morecfm:byg_baobab_kitchen_drawer as it's serializer returned null
[12:53:47] [main/INFO]: Skipping loading recipe morecfm:byg_ether_kitchen_sink_dark as it's serializer returned null
[12:53:47] [main/INFO]: Skipping loading recipe morecfm:byg_zelkova_kitchen_drawer as it's serializer returned null
[12:53:47] [main/INFO]: Skipping loading recipe morecfm:atmospheric_rosewood_kitchen_sink_dark as it's serializer returned null
[12:53:47] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_fir_upgraded_gate as it's serializer returned null
[12:53:47] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_ebony_blinds as it's serializer returned null
[12:53:47] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_lament_blinds as it's serializer returned null
[12:53:47] [main/INFO]: Skipping loading recipe morecfm:bayou_blues_stripped_cypress_coffee_table as it's serializer returned null
[12:53:47] [main/INFO]: Skipping loading recipe morecfm:atmospheric_kousa_blinds as it's serializer returned null
[12:53:47] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_sythian_upgraded_gate as it's serializer returned null
[12:53:47] [main/INFO]: Skipping loading recipe morecfm:autumnity_stripped_maple_desk_cabinet as it's serializer returned null
[12:53:47] [main/INFO]: Skipping loading recipe morecfm:autumnity_maple_kitchen_drawer as it's serializer returned null
[12:53:47] [main/INFO]: Skipping loading recipe morecfm:abundance_stripped_jacaranda_kitchen_counter as it's serializer returned null
[12:53:47] [main/INFO]: Skipping loading recipe morecfm:bayou_blues_cypress_upgraded_fence as it's serializer returned null
[12:53:47] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_witch_hazel_cabinet as it's serializer returned null
[12:53:47] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_lament_desk as it's serializer returned null
[12:53:47] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_lament_cabinet as it's serializer returned null
[12:53:47] [main/INFO]: Skipping loading recipe morecfm:atmospheric_aspen_kitchen_drawer as it's serializer returned null
[12:53:47] [main/INFO]: Skipping loading recipe morecfm:byg_zelkova_upgraded_gate as it's serializer returned null
[12:53:47] [main/INFO]: Skipping loading recipe morecfm:abundance_redbud_crate as it's serializer returned null
[12:53:47] [main/INFO]: Skipping loading recipe morecfm:byg_palm_desk as it's serializer returned null
[12:53:47] [main/INFO]: Skipping loading recipe morecfm:autumnity_stripped_maple_kitchen_counter as it's serializer returned null
[12:53:47] [main/INFO]: Skipping loading recipe morecfm:abundance_redbud_bedside_cabinet as it's serializer returned null
[12:53:47] [main/INFO]: Skipping loading recipe morecfm:atmospheric_stripped_kousa_cabinet as it's serializer returned null
[12:53:47] [main/INFO]: Skipping loading recipe morecfm:upgrade_aquatic_river_park_bench as it's serializer returned null
[12:53:47] [main/INFO]: Skipping loading recipe morecfm:byg_witch_hazel_table as it's serializer returned null
[12:53:47] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_skyris_kitchen_sink_light as it's serializer returned null
[12:53:47] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_baobab_upgraded_gate as it's serializer returned null
[12:53:47] [main/INFO]: Skipping loading recipe morecfm:abundance_jacaranda_cabinet as it's serializer returned null
[12:53:47] [main/INFO]: Skipping loading recipe morecfm:byg_mangrove_kitchen_sink_dark as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_ebony_mail_box as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:abundance_stripped_jacaranda_crate as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_nightshade_desk_cabinet as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:environmental_wisteria_park_bench as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:environmental_stripped_willow_park_bench as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_baobab_blinds as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_cypress_mail_box as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:autumnity_stripped_maple_upgraded_gate as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_pine_cabinet as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_cherry_mail_box as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:atmospheric_stripped_aspen_table as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_fir_cabinet as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_pine_upgraded_fence as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_mahogany_bedside_cabinet as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_rainbow_eucalyptus_chair as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:atmospheric_rosewood_park_bench as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:environmental_stripped_wisteria_coffee_table as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:environmental_willow_upgraded_fence as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_blue_enchanted_upgraded_fence as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:atmospheric_stripped_yucca_mail_box as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_pine_cabinet as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:environmental_wisteria_kitchen_drawer as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe industrialforegoing:laser_drill_ore/nickel as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_blue_enchanted_kitchen_drawer as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:atmospheric_grimwood_kitchen_sink_dark as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_green_enchanted_upgraded_fence as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:atmospheric_stripped_morado_kitchen_sink_light as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_skyris_desk as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:upgrade_aquatic_river_chair as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_rainbow_eucalyptus_coffee_table as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_cherry_park_bench as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_sythian_desk_cabinet as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_nightshade_mail_box as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_jacaranda_desk_cabinet as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_mahogany_cabinet as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_maple_cabinet as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_fir_bedside_cabinet as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:atmospheric_kousa_bedside_cabinet as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_willow_kitchen_sink_dark as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:bayou_blues_stripped_cypress_table as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_ebony_blinds as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_cypress_kitchen_drawer as it's serializer returned null
[12:53:48] [main/ERROR]: Parsing error loading recipe vehicle:boost_ramp
com.google.gson.JsonSyntaxException: Unknown item 'vehicle:boost_pad'
	at net.minecraft.item.crafting.Ingredient.lambda$valueFromJson$11(Ingredient.java:216) ~[?:?]
	at net.minecraft.item.crafting.Ingredient$$Lambda$13999/193199105.get(Unknown Source) ~[?:?]
	at java.util.Optional.orElseThrow(Optional.java:290) ~[?:1.8.0_51]
	at net.minecraft.item.crafting.Ingredient.func_199803_a(Ingredient.java:215) ~[?:?]
	at net.minecraftforge.common.crafting.VanillaIngredientSerializer.parse(VanillaIngredientSerializer.java:41) ~[?:?]
	at net.minecraftforge.common.crafting.CraftingHelper.getIngredient(CraftingHelper.java:155) ~[?:?]
	at net.minecraft.item.crafting.Ingredient.func_199802_a(Ingredient.java:189) ~[?:?]
	at net.minecraft.item.crafting.ShapedRecipe.func_192408_a(ShapedRecipe.java:252) ~[?:?]
	at net.minecraft.item.crafting.ShapedRecipe.access$000(ShapedRecipe.java:24) ~[?:?]
	at net.minecraft.item.crafting.ShapedRecipe$Serializer.func_199425_a_(ShapedRecipe.java:276) ~[?:?]
	at net.minecraft.item.crafting.ShapedRecipe$Serializer.func_199425_a_(ShapedRecipe.java:272) ~[?:?]
	at net.minecraft.item.crafting.RecipeManager.func_215377_a(RecipeManager.java:141) ~[?:?]
	at net.minecraft.item.crafting.RecipeManager.func_212853_a_(RecipeManager.java:61) [?:?]
	at net.minecraft.item.crafting.RecipeManager.func_212853_a_(RecipeManager.java:38) [?:?]
	at net.minecraft.client.resources.ReloadListener.func_215269_a(SourceFile:13) [?:?]
	at net.minecraft.client.resources.ReloadListener$$Lambda$9873/1436560249.accept(Unknown Source) [?:?]
	at java.util.concurrent.CompletableFuture.uniAccept(CompletableFuture.java:656) [?:1.8.0_51]
	at java.util.concurrent.CompletableFuture$UniAccept.tryFire(CompletableFuture.java:632) [?:1.8.0_51]
	at java.util.concurrent.CompletableFuture$Completion.run(CompletableFuture.java:442) [?:1.8.0_51]
	at net.minecraft.resources.AsyncReloader.func_219557_a(SourceFile:71) [?:?]
	at net.minecraft.resources.AsyncReloader$$Lambda$10018/707432592.run(Unknown Source) [?:?]
	at net.minecraft.util.concurrent.ThreadTaskExecutor.func_213166_h(ThreadTaskExecutor.java:191) [?:?]
	at net.minecraft.util.concurrent.RecursiveEventLoop.func_213166_h(SourceFile:23) [?:?]
	at net.minecraft.util.concurrent.ThreadTaskExecutor.func_213168_p(ThreadTaskExecutor.java:153) [?:?]
	at net.minecraft.util.concurrent.ThreadTaskExecutor.func_213161_c(ThreadTaskExecutor.java:169) [?:?]
	at net.minecraft.client.Minecraft.func_238189_a_(Minecraft.java:1865) [?:?]
	at net.minecraft.client.Minecraft.loadWorld(Minecraft.java:1714) [?:?]
	at net.minecraft.client.Minecraft.func_238192_a_(Minecraft.java:1687) [?:?]
	at net.minecraft.client.gui.screen.CreateWorldScreen.func_195352_j(CreateWorldScreen.java:260) [?:?]
	at net.minecraft.client.gui.screen.CreateWorldScreen.lambda$init$11(CreateWorldScreen.java:205) [?:?]
	at net.minecraft.client.gui.screen.CreateWorldScreen$$Lambda$12951/1871004871.onPress(Unknown Source) [?:?]
	at net.minecraft.client.gui.widget.button.Button.func_230930_b_(SourceFile:33) [?:?]
	at net.minecraft.client.gui.widget.button.AbstractButton.func_230982_a_(SourceFile:16) [?:?]
	at net.minecraft.client.gui.widget.Widget.func_231044_a_(Widget.java:136) [?:?]
	at net.minecraft.client.gui.INestedGuiEventHandler.func_231044_a_(SourceFile:27) [?:?]
	at net.minecraft.client.MouseHelper.func_198033_b(MouseHelper.java:87) [?:?]
	at net.minecraft.client.MouseHelper$$Lambda$12646/468309489.run(Unknown Source) [?:?]
	at net.minecraft.client.gui.screen.Screen.func_231153_a_(Screen.java:427) [?:?]
	at net.minecraft.client.MouseHelper.func_198023_a(MouseHelper.java:85) [?:?]
	at net.minecraft.client.MouseHelper.func_228030_c_(MouseHelper.java:181) [?:?]
	at net.minecraft.client.MouseHelper$$Lambda$12645/1510532588.run(Unknown Source) [?:?]
	at net.minecraft.util.concurrent.ThreadTaskExecutor.execute(ThreadTaskExecutor.java:106) [?:?]
	at net.minecraft.client.MouseHelper.func_228028_b_(MouseHelper.java:180) [?:?]
	at net.minecraft.client.MouseHelper$$Lambda$9851/1244357368.invoke(Unknown Source) [?:?]
	at org.lwjgl.glfw.GLFWMouseButtonCallbackI.callback(GLFWMouseButtonCallbackI.java:36) [lwjgl-glfw-3.2.2.jar:build 10]
	at org.lwjgl.system.JNI.invokeV(Native Method) ~[lwjgl-3.2.2.jar:build 10]
	at org.lwjgl.glfw.GLFW.glfwPollEvents(GLFW.java:3101) [lwjgl-glfw-3.2.2.jar:build 10]
	at com.mojang.blaze3d.systems.RenderSystem.flipFrame(SourceFile:102) [?:?]
	at net.minecraft.client.MainWindow.func_227802_e_(MainWindow.java:398) [?:?]
	at net.minecraft.client.Minecraft.func_195542_b(Minecraft.java:997) [?:?]
	at net.minecraft.client.Minecraft.func_99999_d(Minecraft.java:607) [?:?]
	at net.minecraft.client.main.Main.main(Main.java:184) [?:?]
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) ~[?:1.8.0_51]
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) ~[?:1.8.0_51]
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) ~[?:1.8.0_51]
	at java.lang.reflect.Method.invoke(Method.java:497) ~[?:1.8.0_51]
	at net.minecraftforge.fml.loading.FMLClientLaunchProvider.lambda$launchService$0(FMLClientLaunchProvider.java:51) [forge-1.16.5-36.2.33.jar:36.2]
	at net.minecraftforge.fml.loading.FMLClientLaunchProvider$$Lambda$496/1753746465.call(Unknown Source) [forge-1.16.5-36.2.33.jar:36.2]
	at cpw.mods.modlauncher.LaunchServiceHandlerDecorator.launch(LaunchServiceHandlerDecorator.java:37) [modlauncher-8.1.3.jar:?]
	at cpw.mods.modlauncher.LaunchServiceHandler.launch(LaunchServiceHandler.java:54) [modlauncher-8.1.3.jar:?]
	at cpw.mods.modlauncher.LaunchServiceHandler.launch(LaunchServiceHandler.java:72) [modlauncher-8.1.3.jar:?]
	at cpw.mods.modlauncher.Launcher.run(Launcher.java:82) [modlauncher-8.1.3.jar:?]
	at cpw.mods.modlauncher.Launcher.main(Launcher.java:66) [modlauncher-8.1.3.jar:?]
[12:53:48] [main/INFO]: Skipping loading recipe industrialforegoing:laser_drill_ore/pyrite as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_maple_desk as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_ebony_upgraded_fence as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_aspen_upgraded_gate as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_bulbis_upgraded_gate as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:environmental_wisteria_mail_box as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_pine_table as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_aspen_kitchen_sink_dark as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:bayou_blues_cypress_coffee_table as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_rainbow_eucalyptus_blinds as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:atmospheric_kousa_kitchen_sink_light as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_jacaranda_park_bench as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:environmental_willow_blinds as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_jacaranda_kitchen_sink_dark as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_cypress_chair as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_mahogany_upgraded_fence as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_ether_upgraded_gate as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_lament_upgraded_fence as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:environmental_stripped_cherry_kitchen_sink_light as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_aspen_chair as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_green_enchanted_cabinet as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:environmental_wisteria_table as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_blue_enchanted_desk_cabinet as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_aspen_kitchen_sink_light as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_jacaranda_coffee_table as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_maple_upgraded_gate as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:atmospheric_kousa_mail_box as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_maple_table as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:atmospheric_rosewood_chair as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_ebony_chair as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:atmospheric_stripped_morado_upgraded_fence as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:abundance_stripped_jacaranda_park_bench as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_skyris_kitchen_drawer as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_mahogany_desk as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_baobab_coffee_table as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:endergetic_poise_kitchen_sink_light as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_pine_kitchen_sink_light as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_green_enchanted_kitchen_sink_light as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_bulbis_table as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:atmospheric_rosewood_mail_box as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:atmospheric_grimwood_chair as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:atmospheric_stripped_kousa_kitchen_counter as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_palm_upgraded_gate as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_skyris_cabinet as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_willow_mail_box as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_cypress_kitchen_sink_light as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_baobab_kitchen_drawer as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_sythian_desk as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_blue_enchanted_cabinet as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_blue_enchanted_table as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_bulbis_desk as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:environmental_cherry_upgraded_fence as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_mangrove_bedside_cabinet as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_holly_crate as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe industrialforegoing:laser_drill_ore/cinnabar as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:abundance_stripped_redbud_table as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_aspen_bedside_cabinet as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:atmospheric_morado_park_bench as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:abundance_jacaranda_table as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_palm_kitchen_drawer as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:atmospheric_stripped_kousa_kitchen_sink_light as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:endergetic_stripped_poise_coffee_table as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_green_enchanted_kitchen_sink_light as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:upgrade_aquatic_driftwood_desk_cabinet as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_sythian_kitchen_sink_light as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:autumnity_maple_coffee_table as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:autumnity_maple_kitchen_sink_dark as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_cherry_crate as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_zelkova_cabinet as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:endergetic_poise_chair as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_green_enchanted_blinds as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:environmental_stripped_willow_crate as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:autumnity_maple_blinds as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_willow_upgraded_gate as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:upgrade_aquatic_driftwood_chair as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_fir_mail_box as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_fir_kitchen_sink_light as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:environmental_stripped_cherry_upgraded_gate as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_cika_crate as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_pine_kitchen_counter as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:atmospheric_morado_upgraded_gate as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_zelkova_park_bench as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_sythian_desk as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_cherry_desk_cabinet as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_jacaranda_bedside_cabinet as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_willow_park_bench as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_pine_crate as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_baobab_table as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:atmospheric_kousa_table as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_aspen_coffee_table as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_green_enchanted_bedside_cabinet as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:atmospheric_morado_desk as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_bulbis_coffee_table as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:upgrade_aquatic_driftwood_kitchen_drawer as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_redwood_table as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:autumnity_stripped_maple_mail_box as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:atmospheric_stripped_morado_chair as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_fir_table as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:environmental_cherry_desk as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_zelkova_chair as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_ebony_kitchen_counter as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_mangrove_desk as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_cypress_desk_cabinet as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe industrialforegoing:laser_drill_ore/sheldonite as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:autumnity_stripped_maple_kitchen_sink_dark as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:atmospheric_kousa_kitchen_drawer as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_imparius_table as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_sythian_table as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_fir_kitchen_counter as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_witch_hazel_upgraded_fence as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_palm_coffee_table as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_jacaranda_crate as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_zelkova_mail_box as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:atmospheric_kousa_kitchen_sink_dark as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_cypress_bedside_cabinet as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_imparius_upgraded_gate as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_redwood_kitchen_drawer as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_rainbow_eucalyptus_bedside_cabinet as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:upgrade_aquatic_stripped_river_coffee_table as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_ebony_mail_box as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_mangrove_upgraded_gate as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:atmospheric_grimwood_upgraded_gate as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_cika_park_bench as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_rainbow_eucalyptus_upgraded_fence as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_fir_table as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_skyris_cabinet as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:endergetic_poise_blinds as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_witch_hazel_kitchen_counter as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_rainbow_eucalyptus_bedside_cabinet as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_cherry_upgraded_gate as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:atmospheric_morado_desk_cabinet as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_nightshade_crate as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_mangrove_upgraded_fence as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:environmental_wisteria_desk as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_pine_desk_cabinet as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:endergetic_poise_bedside_cabinet as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_ether_kitchen_sink_light as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:bayou_blues_cypress_cabinet as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:atmospheric_stripped_morado_blinds as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_willow_table as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:environmental_wisteria_crate as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_redwood_desk as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:atmospheric_stripped_morado_kitchen_drawer as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_fir_upgraded_fence as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:environmental_wisteria_desk_cabinet as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_ebony_desk as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_mangrove_cabinet as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:atmospheric_stripped_yucca_upgraded_fence as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_pine_bedside_cabinet as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_lament_upgraded_gate as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:abundance_stripped_jacaranda_upgraded_gate as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_pine_desk as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_blue_enchanted_coffee_table as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:bayou_blues_stripped_cypress_chair as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_aspen_table as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_sythian_kitchen_counter as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_palm_desk as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_green_enchanted_desk_cabinet as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_ebony_kitchen_drawer as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_blue_enchanted_bedside_cabinet as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_witch_hazel_crate as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_rainbow_eucalyptus_kitchen_sink_dark as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:upgrade_aquatic_stripped_driftwood_coffee_table as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:environmental_stripped_willow_upgraded_gate as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_cherry_chair as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_redwood_kitchen_sink_light as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_redwood_table as it's serializer returned null
[12:53:48] [main/ERROR]: Parsing error loading recipe vehicle:steep_boost_ramp
com.google.gson.JsonSyntaxException: Unknown item 'vehicle:boost_pad'
	at net.minecraft.item.crafting.Ingredient.lambda$valueFromJson$11(Ingredient.java:216) ~[?:?]
	at net.minecraft.item.crafting.Ingredient$$Lambda$13999/193199105.get(Unknown Source) ~[?:?]
	at java.util.Optional.orElseThrow(Optional.java:290) ~[?:1.8.0_51]
	at net.minecraft.item.crafting.Ingredient.func_199803_a(Ingredient.java:215) ~[?:?]
	at net.minecraftforge.common.crafting.VanillaIngredientSerializer.parse(VanillaIngredientSerializer.java:41) ~[?:?]
	at net.minecraftforge.common.crafting.CraftingHelper.getIngredient(CraftingHelper.java:155) ~[?:?]
	at net.minecraft.item.crafting.Ingredient.func_199802_a(Ingredient.java:189) ~[?:?]
	at net.minecraft.item.crafting.ShapedRecipe.func_192408_a(ShapedRecipe.java:252) ~[?:?]
	at net.minecraft.item.crafting.ShapedRecipe.access$000(ShapedRecipe.java:24) ~[?:?]
	at net.minecraft.item.crafting.ShapedRecipe$Serializer.func_199425_a_(ShapedRecipe.java:276) ~[?:?]
	at net.minecraft.item.crafting.ShapedRecipe$Serializer.func_199425_a_(ShapedRecipe.java:272) ~[?:?]
	at net.minecraft.item.crafting.RecipeManager.func_215377_a(RecipeManager.java:141) ~[?:?]
	at net.minecraft.item.crafting.RecipeManager.func_212853_a_(RecipeManager.java:61) [?:?]
	at net.minecraft.item.crafting.RecipeManager.func_212853_a_(RecipeManager.java:38) [?:?]
	at net.minecraft.client.resources.ReloadListener.func_215269_a(SourceFile:13) [?:?]
	at net.minecraft.client.resources.ReloadListener$$Lambda$9873/1436560249.accept(Unknown Source) [?:?]
	at java.util.concurrent.CompletableFuture.uniAccept(CompletableFuture.java:656) [?:1.8.0_51]
	at java.util.concurrent.CompletableFuture$UniAccept.tryFire(CompletableFuture.java:632) [?:1.8.0_51]
	at java.util.concurrent.CompletableFuture$Completion.run(CompletableFuture.java:442) [?:1.8.0_51]
	at net.minecraft.resources.AsyncReloader.func_219557_a(SourceFile:71) [?:?]
	at net.minecraft.resources.AsyncReloader$$Lambda$10018/707432592.run(Unknown Source) [?:?]
	at net.minecraft.util.concurrent.ThreadTaskExecutor.func_213166_h(ThreadTaskExecutor.java:191) [?:?]
	at net.minecraft.util.concurrent.RecursiveEventLoop.func_213166_h(SourceFile:23) [?:?]
	at net.minecraft.util.concurrent.ThreadTaskExecutor.func_213168_p(ThreadTaskExecutor.java:153) [?:?]
	at net.minecraft.util.concurrent.ThreadTaskExecutor.func_213161_c(ThreadTaskExecutor.java:169) [?:?]
	at net.minecraft.client.Minecraft.func_238189_a_(Minecraft.java:1865) [?:?]
	at net.minecraft.client.Minecraft.loadWorld(Minecraft.java:1714) [?:?]
	at net.minecraft.client.Minecraft.func_238192_a_(Minecraft.java:1687) [?:?]
	at net.minecraft.client.gui.screen.CreateWorldScreen.func_195352_j(CreateWorldScreen.java:260) [?:?]
	at net.minecraft.client.gui.screen.CreateWorldScreen.lambda$init$11(CreateWorldScreen.java:205) [?:?]
	at net.minecraft.client.gui.screen.CreateWorldScreen$$Lambda$12951/1871004871.onPress(Unknown Source) [?:?]
	at net.minecraft.client.gui.widget.button.Button.func_230930_b_(SourceFile:33) [?:?]
	at net.minecraft.client.gui.widget.button.AbstractButton.func_230982_a_(SourceFile:16) [?:?]
	at net.minecraft.client.gui.widget.Widget.func_231044_a_(Widget.java:136) [?:?]
	at net.minecraft.client.gui.INestedGuiEventHandler.func_231044_a_(SourceFile:27) [?:?]
	at net.minecraft.client.MouseHelper.func_198033_b(MouseHelper.java:87) [?:?]
	at net.minecraft.client.MouseHelper$$Lambda$12646/468309489.run(Unknown Source) [?:?]
	at net.minecraft.client.gui.screen.Screen.func_231153_a_(Screen.java:427) [?:?]
	at net.minecraft.client.MouseHelper.func_198023_a(MouseHelper.java:85) [?:?]
	at net.minecraft.client.MouseHelper.func_228030_c_(MouseHelper.java:181) [?:?]
	at net.minecraft.client.MouseHelper$$Lambda$12645/1510532588.run(Unknown Source) [?:?]
	at net.minecraft.util.concurrent.ThreadTaskExecutor.execute(ThreadTaskExecutor.java:106) [?:?]
	at net.minecraft.client.MouseHelper.func_228028_b_(MouseHelper.java:180) [?:?]
	at net.minecraft.client.MouseHelper$$Lambda$9851/1244357368.invoke(Unknown Source) [?:?]
	at org.lwjgl.glfw.GLFWMouseButtonCallbackI.callback(GLFWMouseButtonCallbackI.java:36) [lwjgl-glfw-3.2.2.jar:build 10]
	at org.lwjgl.system.JNI.invokeV(Native Method) ~[lwjgl-3.2.2.jar:build 10]
	at org.lwjgl.glfw.GLFW.glfwPollEvents(GLFW.java:3101) [lwjgl-glfw-3.2.2.jar:build 10]
	at com.mojang.blaze3d.systems.RenderSystem.flipFrame(SourceFile:102) [?:?]
	at net.minecraft.client.MainWindow.func_227802_e_(MainWindow.java:398) [?:?]
	at net.minecraft.client.Minecraft.func_195542_b(Minecraft.java:997) [?:?]
	at net.minecraft.client.Minecraft.func_99999_d(Minecraft.java:607) [?:?]
	at net.minecraft.client.main.Main.main(Main.java:184) [?:?]
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) ~[?:1.8.0_51]
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) ~[?:1.8.0_51]
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) ~[?:1.8.0_51]
	at java.lang.reflect.Method.invoke(Method.java:497) ~[?:1.8.0_51]
	at net.minecraftforge.fml.loading.FMLClientLaunchProvider.lambda$launchService$0(FMLClientLaunchProvider.java:51) [forge-1.16.5-36.2.33.jar:36.2]
	at net.minecraftforge.fml.loading.FMLClientLaunchProvider$$Lambda$496/1753746465.call(Unknown Source) [forge-1.16.5-36.2.33.jar:36.2]
	at cpw.mods.modlauncher.LaunchServiceHandlerDecorator.launch(LaunchServiceHandlerDecorator.java:37) [modlauncher-8.1.3.jar:?]
	at cpw.mods.modlauncher.LaunchServiceHandler.launch(LaunchServiceHandler.java:54) [modlauncher-8.1.3.jar:?]
	at cpw.mods.modlauncher.LaunchServiceHandler.launch(LaunchServiceHandler.java:72) [modlauncher-8.1.3.jar:?]
	at cpw.mods.modlauncher.Launcher.run(Launcher.java:82) [modlauncher-8.1.3.jar:?]
	at cpw.mods.modlauncher.Launcher.main(Launcher.java:66) [modlauncher-8.1.3.jar:?]
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_zelkova_blinds as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_redwood_park_bench as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_aspen_bedside_cabinet as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:endergetic_poise_kitchen_counter as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:atmospheric_stripped_grimwood_chair as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:abundance_redbud_kitchen_drawer as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:bayou_blues_stripped_cypress_park_bench as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:upgrade_aquatic_driftwood_mail_box as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:atmospheric_stripped_kousa_park_bench as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_sythian_blinds as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_cherry_kitchen_counter as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_ether_upgraded_fence as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_maple_chair as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_imparius_kitchen_drawer as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_cika_desk_cabinet as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_mangrove_kitchen_drawer as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:environmental_stripped_cherry_mail_box as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_ether_kitchen_sink_light as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:atmospheric_stripped_grimwood_kitchen_drawer as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:upgrade_aquatic_stripped_river_mail_box as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_holly_upgraded_gate as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_aspen_crate as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_blue_enchanted_kitchen_drawer as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_palm_upgraded_fence as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe industrialforegoing:laser_drill_ore/yellorium as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_rainbow_eucalyptus_table as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe industrialforegoing:laser_drill_ore/yellorite as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_redwood_cabinet as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:environmental_wisteria_kitchen_sink_dark as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_aspen_mail_box as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_cypress_cabinet as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_lament_table as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_blue_enchanted_kitchen_counter as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe industrialforegoing:laser_drill_ore/niter as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_fir_upgraded_gate as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:atmospheric_stripped_aspen_mail_box as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:environmental_wisteria_bedside_cabinet as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_zelkova_kitchen_sink_light as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:atmospheric_aspen_park_bench as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_palm_table as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:atmospheric_stripped_aspen_kitchen_sink_dark as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_cika_kitchen_drawer as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_sythian_upgraded_fence as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_nightshade_coffee_table as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_aspen_kitchen_counter as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_lament_kitchen_counter as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_cherry_desk as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:atmospheric_stripped_kousa_chair as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_ether_bedside_cabinet as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_nightshade_blinds as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_pine_blinds as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:atmospheric_stripped_aspen_blinds as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:atmospheric_stripped_yucca_cabinet as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:atmospheric_kousa_kitchen_counter as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_blue_enchanted_chair as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:endergetic_stripped_poise_kitchen_sink_light as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:abundance_stripped_jacaranda_blinds as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_blue_enchanted_upgraded_gate as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_blue_enchanted_park_bench as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_jacaranda_table as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_ether_cabinet as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:atmospheric_stripped_grimwood_park_bench as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_fir_bedside_cabinet as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:environmental_stripped_cherry_cabinet as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:atmospheric_stripped_grimwood_cabinet as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_mangrove_desk_cabinet as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_mahogany_upgraded_gate as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_nightshade_table as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_skyris_mail_box as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_holly_kitchen_drawer as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:endergetic_poise_kitchen_sink_dark as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_sythian_upgraded_gate as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:bayou_blues_cypress_table as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_lament_kitchen_drawer as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_cika_kitchen_sink_light as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_palm_desk_cabinet as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_zelkova_upgraded_gate as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:upgrade_aquatic_stripped_river_cabinet as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_skyris_upgraded_gate as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:abundance_stripped_redbud_blinds as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_pine_kitchen_sink_dark as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:bayou_blues_cypress_desk as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_lament_bedside_cabinet as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_baobab_kitchen_sink_light as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_witch_hazel_mail_box as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_palm_kitchen_drawer as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_witch_hazel_bedside_cabinet as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_blue_enchanted_cabinet as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_holly_desk_cabinet as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:environmental_wisteria_kitchen_counter as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_nightshade_kitchen_sink_light as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:atmospheric_stripped_yucca_table as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_cypress_kitchen_counter as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_skyris_crate as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_aspen_cabinet as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_jacaranda_coffee_table as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_cherry_coffee_table as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_fir_kitchen_sink_dark as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_redwood_kitchen_counter as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:endergetic_stripped_poise_cabinet as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe industrialforegoing:laser_drill_ore/platinum as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_skyris_coffee_table as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_zelkova_kitchen_sink_light as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_baobab_crate as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_nightshade_park_bench as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_ether_crate as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_pine_desk as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_green_enchanted_upgraded_gate as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:atmospheric_stripped_grimwood_kitchen_sink_light as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:upgrade_aquatic_stripped_river_park_bench as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:autumnity_stripped_maple_desk as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_willow_upgraded_fence as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_nightshade_table as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:atmospheric_aspen_mail_box as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:bayou_blues_stripped_cypress_bedside_cabinet as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_maple_mail_box as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_ether_kitchen_drawer as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:upgrade_aquatic_river_kitchen_sink_light as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:atmospheric_morado_mail_box as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:atmospheric_stripped_grimwood_upgraded_fence as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_mahogany_coffee_table as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_cypress_desk_cabinet as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:abundance_redbud_coffee_table as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_cypress_mail_box as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_cypress_blinds as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_blue_enchanted_kitchen_sink_dark as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:atmospheric_stripped_yucca_blinds as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_lament_coffee_table as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe industrialforegoing:laser_drill_ore/sapphire as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_pine_coffee_table as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_mangrove_cabinet as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_pine_upgraded_gate as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_sythian_crate as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_pine_kitchen_counter as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_baobab_desk_cabinet as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:atmospheric_morado_table as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_mahogany_kitchen_sink_light as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:atmospheric_stripped_morado_park_bench as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:abundance_stripped_redbud_kitchen_sink_dark as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:atmospheric_stripped_morado_desk as it's serializer returned null
[12:53:48] [main/ERROR]: Parsing error loading recipe industrialforegoing:manual
com.google.gson.JsonSyntaxException: Unknown item 'patchouli:guide_book'
	at net.minecraft.item.crafting.ShapedRecipe.func_222129_c(ShapedRecipe.java:262) ~[?:?]
	at net.minecraft.item.crafting.ShapedRecipe$$Lambda$14000/1603931266.get(Unknown Source) ~[?:?]
	at java.util.Optional.orElseThrow(Optional.java:290) ~[?:1.8.0_51]
	at net.minecraft.item.crafting.ShapedRecipe.func_199798_a(ShapedRecipe.java:261) ~[?:?]
	at net.minecraft.item.crafting.ShapelessRecipe$Serializer.func_199425_a_(ShapelessRecipe.java:86) ~[?:?]
	at net.minecraft.item.crafting.ShapelessRecipe$Serializer.func_199425_a_(ShapelessRecipe.java:76) ~[?:?]
	at net.minecraft.item.crafting.RecipeManager.func_215377_a(RecipeManager.java:141) ~[?:?]
	at net.minecraft.item.crafting.RecipeManager.func_212853_a_(RecipeManager.java:61) [?:?]
	at net.minecraft.item.crafting.RecipeManager.func_212853_a_(RecipeManager.java:38) [?:?]
	at net.minecraft.client.resources.ReloadListener.func_215269_a(SourceFile:13) [?:?]
	at net.minecraft.client.resources.ReloadListener$$Lambda$9873/1436560249.accept(Unknown Source) [?:?]
	at java.util.concurrent.CompletableFuture.uniAccept(CompletableFuture.java:656) [?:1.8.0_51]
	at java.util.concurrent.CompletableFuture$UniAccept.tryFire(CompletableFuture.java:632) [?:1.8.0_51]
	at java.util.concurrent.CompletableFuture$Completion.run(CompletableFuture.java:442) [?:1.8.0_51]
	at net.minecraft.resources.AsyncReloader.func_219557_a(SourceFile:71) [?:?]
	at net.minecraft.resources.AsyncReloader$$Lambda$10018/707432592.run(Unknown Source) [?:?]
	at net.minecraft.util.concurrent.ThreadTaskExecutor.func_213166_h(ThreadTaskExecutor.java:191) [?:?]
	at net.minecraft.util.concurrent.RecursiveEventLoop.func_213166_h(SourceFile:23) [?:?]
	at net.minecraft.util.concurrent.ThreadTaskExecutor.func_213168_p(ThreadTaskExecutor.java:153) [?:?]
	at net.minecraft.util.concurrent.ThreadTaskExecutor.func_213161_c(ThreadTaskExecutor.java:169) [?:?]
	at net.minecraft.client.Minecraft.func_238189_a_(Minecraft.java:1865) [?:?]
	at net.minecraft.client.Minecraft.loadWorld(Minecraft.java:1714) [?:?]
	at net.minecraft.client.Minecraft.func_238192_a_(Minecraft.java:1687) [?:?]
	at net.minecraft.client.gui.screen.CreateWorldScreen.func_195352_j(CreateWorldScreen.java:260) [?:?]
	at net.minecraft.client.gui.screen.CreateWorldScreen.lambda$init$11(CreateWorldScreen.java:205) [?:?]
	at net.minecraft.client.gui.screen.CreateWorldScreen$$Lambda$12951/1871004871.onPress(Unknown Source) [?:?]
	at net.minecraft.client.gui.widget.button.Button.func_230930_b_(SourceFile:33) [?:?]
	at net.minecraft.client.gui.widget.button.AbstractButton.func_230982_a_(SourceFile:16) [?:?]
	at net.minecraft.client.gui.widget.Widget.func_231044_a_(Widget.java:136) [?:?]
	at net.minecraft.client.gui.INestedGuiEventHandler.func_231044_a_(SourceFile:27) [?:?]
	at net.minecraft.client.MouseHelper.func_198033_b(MouseHelper.java:87) [?:?]
	at net.minecraft.client.MouseHelper$$Lambda$12646/468309489.run(Unknown Source) [?:?]
	at net.minecraft.client.gui.screen.Screen.func_231153_a_(Screen.java:427) [?:?]
	at net.minecraft.client.MouseHelper.func_198023_a(MouseHelper.java:85) [?:?]
	at net.minecraft.client.MouseHelper.func_228030_c_(MouseHelper.java:181) [?:?]
	at net.minecraft.client.MouseHelper$$Lambda$12645/1510532588.run(Unknown Source) [?:?]
	at net.minecraft.util.concurrent.ThreadTaskExecutor.execute(ThreadTaskExecutor.java:106) [?:?]
	at net.minecraft.client.MouseHelper.func_228028_b_(MouseHelper.java:180) [?:?]
	at net.minecraft.client.MouseHelper$$Lambda$9851/1244357368.invoke(Unknown Source) [?:?]
	at org.lwjgl.glfw.GLFWMouseButtonCallbackI.callback(GLFWMouseButtonCallbackI.java:36) [lwjgl-glfw-3.2.2.jar:build 10]
	at org.lwjgl.system.JNI.invokeV(Native Method) ~[lwjgl-3.2.2.jar:build 10]
	at org.lwjgl.glfw.GLFW.glfwPollEvents(GLFW.java:3101) [lwjgl-glfw-3.2.2.jar:build 10]
	at com.mojang.blaze3d.systems.RenderSystem.flipFrame(SourceFile:102) [?:?]
	at net.minecraft.client.MainWindow.func_227802_e_(MainWindow.java:398) [?:?]
	at net.minecraft.client.Minecraft.func_195542_b(Minecraft.java:997) [?:?]
	at net.minecraft.client.Minecraft.func_99999_d(Minecraft.java:607) [?:?]
	at net.minecraft.client.main.Main.main(Main.java:184) [?:?]
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) ~[?:1.8.0_51]
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) ~[?:1.8.0_51]
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) ~[?:1.8.0_51]
	at java.lang.reflect.Method.invoke(Method.java:497) ~[?:1.8.0_51]
	at net.minecraftforge.fml.loading.FMLClientLaunchProvider.lambda$launchService$0(FMLClientLaunchProvider.java:51) [forge-1.16.5-36.2.33.jar:36.2]
	at net.minecraftforge.fml.loading.FMLClientLaunchProvider$$Lambda$496/1753746465.call(Unknown Source) [forge-1.16.5-36.2.33.jar:36.2]
	at cpw.mods.modlauncher.LaunchServiceHandlerDecorator.launch(LaunchServiceHandlerDecorator.java:37) [modlauncher-8.1.3.jar:?]
	at cpw.mods.modlauncher.LaunchServiceHandler.launch(LaunchServiceHandler.java:54) [modlauncher-8.1.3.jar:?]
	at cpw.mods.modlauncher.LaunchServiceHandler.launch(LaunchServiceHandler.java:72) [modlauncher-8.1.3.jar:?]
	at cpw.mods.modlauncher.Launcher.run(Launcher.java:82) [modlauncher-8.1.3.jar:?]
	at cpw.mods.modlauncher.Launcher.main(Launcher.java:66) [modlauncher-8.1.3.jar:?]
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_palm_chair as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_mangrove_crate as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_willow_kitchen_drawer as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_palm_blinds as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_lament_park_bench as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:atmospheric_stripped_grimwood_bedside_cabinet as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:upgrade_aquatic_stripped_river_table as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_mangrove_mail_box as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_ether_cabinet as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:bayou_blues_cypress_upgraded_gate as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_green_enchanted_kitchen_counter as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_mahogany_crate as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:atmospheric_yucca_crate as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_green_enchanted_desk as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_baobab_park_bench as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:upgrade_aquatic_stripped_driftwood_kitchen_sink_dark as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_skyris_kitchen_sink_light as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_pine_kitchen_drawer as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:abundance_redbud_upgraded_fence as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_ebony_crate as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:atmospheric_rosewood_crate as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_aspen_kitchen_sink_light as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:atmospheric_stripped_rosewood_desk_cabinet as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:atmospheric_yucca_desk_cabinet as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_witch_hazel_kitchen_drawer as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:atmospheric_morado_bedside_cabinet as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:atmospheric_stripped_rosewood_table as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:abundance_redbud_cabinet as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_holly_blinds as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:environmental_cherry_upgraded_gate as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_blue_enchanted_crate as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:environmental_stripped_cherry_kitchen_counter as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:abundance_redbud_desk_cabinet as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:atmospheric_stripped_grimwood_kitchen_sink_dark as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_jacaranda_park_bench as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:atmospheric_aspen_bedside_cabinet as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_holly_upgraded_fence as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:atmospheric_stripped_yucca_desk as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_cherry_upgraded_gate as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_holly_bedside_cabinet as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:environmental_cherry_crate as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:atmospheric_rosewood_desk as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_cika_upgraded_gate as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_holly_desk as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_mangrove_table as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_skyris_desk_cabinet as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_mahogany_upgraded_fence as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:environmental_willow_table as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_sythian_coffee_table as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_mahogany_park_bench as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:environmental_stripped_wisteria_desk as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:endergetic_poise_upgraded_gate as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:upgrade_aquatic_river_table as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:endergetic_stripped_poise_crate as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_skyris_bedside_cabinet as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:environmental_stripped_willow_chair as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:environmental_stripped_wisteria_kitchen_sink_dark as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:upgrade_aquatic_driftwood_crate as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_maple_bedside_cabinet as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_mahogany_table as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_sythian_park_bench as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_willow_coffee_table as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_skyris_blinds as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:atmospheric_stripped_rosewood_upgraded_gate as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:abundance_redbud_park_bench as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_zelkova_upgraded_fence as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_zelkova_cabinet as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_baobab_cabinet as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_holly_bedside_cabinet as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_fir_kitchen_drawer as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:environmental_cherry_kitchen_sink_dark as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:environmental_willow_desk as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:abundance_jacaranda_park_bench as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:abundance_jacaranda_upgraded_fence as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:atmospheric_yucca_upgraded_gate as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:upgrade_aquatic_driftwood_upgraded_fence as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_skyris_table as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:endergetic_poise_desk_cabinet as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_zelkova_desk_cabinet as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_cika_desk as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:environmental_stripped_cherry_bedside_cabinet as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_cherry_kitchen_drawer as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:atmospheric_kousa_upgraded_gate as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_holly_table as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_witch_hazel_upgraded_gate as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_green_enchanted_coffee_table as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:atmospheric_aspen_kitchen_counter as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_ether_mail_box as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:environmental_stripped_willow_coffee_table as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_cypress_upgraded_gate as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:atmospheric_stripped_yucca_kitchen_drawer as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:environmental_wisteria_blinds as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_witch_hazel_kitchen_drawer as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_mangrove_kitchen_sink_light as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_ether_table as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:autumnity_stripped_maple_chair as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:atmospheric_morado_blinds as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_jacaranda_cabinet as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_ebony_table as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_ebony_coffee_table as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:atmospheric_stripped_morado_mail_box as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_lament_kitchen_sink_dark as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_imparius_upgraded_fence as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_ether_desk as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_cherry_bedside_cabinet as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:environmental_stripped_willow_bedside_cabinet as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:abundance_stripped_redbud_kitchen_counter as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_mahogany_upgraded_gate as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_blue_enchanted_mail_box as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:abundance_stripped_jacaranda_coffee_table as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_maple_kitchen_counter as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_nightshade_bedside_cabinet as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_lament_table as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_cika_kitchen_sink_dark as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:atmospheric_stripped_yucca_desk_cabinet as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:abundance_stripped_redbud_kitchen_drawer as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_mahogany_desk_cabinet as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_baobab_desk as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:bayou_blues_stripped_cypress_kitchen_counter as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_pine_chair as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_nightshade_bedside_cabinet as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:autumnity_maple_upgraded_fence as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_palm_cabinet as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_lament_upgraded_fence as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:abundance_jacaranda_desk as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_rainbow_eucalyptus_desk_cabinet as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:atmospheric_stripped_morado_crate as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_zelkova_crate as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:abundance_redbud_upgraded_gate as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_witch_hazel_park_bench as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_lament_desk as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:environmental_wisteria_cabinet as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_nightshade_desk as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_ebony_upgraded_gate as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_holly_park_bench as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_holly_chair as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_nightshade_cabinet as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:atmospheric_grimwood_park_bench as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_zelkova_chair as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:atmospheric_grimwood_upgraded_fence as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:endergetic_poise_park_bench as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:abundance_stripped_jacaranda_cabinet as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_sythian_table as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:atmospheric_stripped_morado_upgraded_gate as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_lament_desk_cabinet as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:bayou_blues_stripped_cypress_desk as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_cherry_chair as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:endergetic_poise_crate as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:environmental_wisteria_kitchen_sink_light as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_baobab_desk_cabinet as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_zelkova_kitchen_sink_dark as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_cika_coffee_table as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_willow_kitchen_sink_light as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_cypress_table as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe industrialforegoing:laser_drill_ore/sodalite as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_bulbis_blinds as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:environmental_stripped_wisteria_bedside_cabinet as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:upgrade_aquatic_stripped_driftwood_kitchen_counter as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_baobab_kitchen_sink_dark as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:environmental_cherry_bedside_cabinet as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_aspen_kitchen_drawer as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_ebony_upgraded_fence as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:atmospheric_stripped_rosewood_desk as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_mahogany_kitchen_counter as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:autumnity_stripped_maple_kitchen_sink_light as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_baobab_upgraded_fence as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_redwood_kitchen_sink_light as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_mangrove_desk as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_green_enchanted_table as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_cherry_kitchen_sink_light as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:atmospheric_aspen_crate as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:atmospheric_morado_kitchen_counter as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_sythian_kitchen_sink_dark as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:atmospheric_stripped_rosewood_upgraded_fence as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:atmospheric_stripped_yucca_upgraded_gate as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:environmental_cherry_kitchen_drawer as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe industrialforegoing:laser_drill_ore/ardite as it's serializer returned null
[12:53:48] [main/ERROR]: Parsing error loading recipe vehicle:boost_pad
com.google.gson.JsonSyntaxException: Unknown item 'vehicle:boost_pad'
	at net.minecraft.item.crafting.ShapedRecipe.func_222129_c(ShapedRecipe.java:262) ~[?:?]
	at net.minecraft.item.crafting.ShapedRecipe$$Lambda$14000/1603931266.get(Unknown Source) ~[?:?]
	at java.util.Optional.orElseThrow(Optional.java:290) ~[?:1.8.0_51]
	at net.minecraft.item.crafting.ShapedRecipe.func_199798_a(ShapedRecipe.java:261) ~[?:?]
	at net.minecraft.item.crafting.ShapedRecipe$Serializer.func_199425_a_(ShapedRecipe.java:281) ~[?:?]
	at net.minecraft.item.crafting.ShapedRecipe$Serializer.func_199425_a_(ShapedRecipe.java:272) ~[?:?]
	at net.minecraft.item.crafting.RecipeManager.func_215377_a(RecipeManager.java:141) ~[?:?]
	at net.minecraft.item.crafting.RecipeManager.func_212853_a_(RecipeManager.java:61) [?:?]
	at net.minecraft.item.crafting.RecipeManager.func_212853_a_(RecipeManager.java:38) [?:?]
	at net.minecraft.client.resources.ReloadListener.func_215269_a(SourceFile:13) [?:?]
	at net.minecraft.client.resources.ReloadListener$$Lambda$9873/1436560249.accept(Unknown Source) [?:?]
	at java.util.concurrent.CompletableFuture.uniAccept(CompletableFuture.java:656) [?:1.8.0_51]
	at java.util.concurrent.CompletableFuture$UniAccept.tryFire(CompletableFuture.java:632) [?:1.8.0_51]
	at java.util.concurrent.CompletableFuture$Completion.run(CompletableFuture.java:442) [?:1.8.0_51]
	at net.minecraft.resources.AsyncReloader.func_219557_a(SourceFile:71) [?:?]
	at net.minecraft.resources.AsyncReloader$$Lambda$10018/707432592.run(Unknown Source) [?:?]
	at net.minecraft.util.concurrent.ThreadTaskExecutor.func_213166_h(ThreadTaskExecutor.java:191) [?:?]
	at net.minecraft.util.concurrent.RecursiveEventLoop.func_213166_h(SourceFile:23) [?:?]
	at net.minecraft.util.concurrent.ThreadTaskExecutor.func_213168_p(ThreadTaskExecutor.java:153) [?:?]
	at net.minecraft.util.concurrent.ThreadTaskExecutor.func_213161_c(ThreadTaskExecutor.java:169) [?:?]
	at net.minecraft.client.Minecraft.func_238189_a_(Minecraft.java:1865) [?:?]
	at net.minecraft.client.Minecraft.loadWorld(Minecraft.java:1714) [?:?]
	at net.minecraft.client.Minecraft.func_238192_a_(Minecraft.java:1687) [?:?]
	at net.minecraft.client.gui.screen.CreateWorldScreen.func_195352_j(CreateWorldScreen.java:260) [?:?]
	at net.minecraft.client.gui.screen.CreateWorldScreen.lambda$init$11(CreateWorldScreen.java:205) [?:?]
	at net.minecraft.client.gui.screen.CreateWorldScreen$$Lambda$12951/1871004871.onPress(Unknown Source) [?:?]
	at net.minecraft.client.gui.widget.button.Button.func_230930_b_(SourceFile:33) [?:?]
	at net.minecraft.client.gui.widget.button.AbstractButton.func_230982_a_(SourceFile:16) [?:?]
	at net.minecraft.client.gui.widget.Widget.func_231044_a_(Widget.java:136) [?:?]
	at net.minecraft.client.gui.INestedGuiEventHandler.func_231044_a_(SourceFile:27) [?:?]
	at net.minecraft.client.MouseHelper.func_198033_b(MouseHelper.java:87) [?:?]
	at net.minecraft.client.MouseHelper$$Lambda$12646/468309489.run(Unknown Source) [?:?]
	at net.minecraft.client.gui.screen.Screen.func_231153_a_(Screen.java:427) [?:?]
	at net.minecraft.client.MouseHelper.func_198023_a(MouseHelper.java:85) [?:?]
	at net.minecraft.client.MouseHelper.func_228030_c_(MouseHelper.java:181) [?:?]
	at net.minecraft.client.MouseHelper$$Lambda$12645/1510532588.run(Unknown Source) [?:?]
	at net.minecraft.util.concurrent.ThreadTaskExecutor.execute(ThreadTaskExecutor.java:106) [?:?]
	at net.minecraft.client.MouseHelper.func_228028_b_(MouseHelper.java:180) [?:?]
	at net.minecraft.client.MouseHelper$$Lambda$9851/1244357368.invoke(Unknown Source) [?:?]
	at org.lwjgl.glfw.GLFWMouseButtonCallbackI.callback(GLFWMouseButtonCallbackI.java:36) [lwjgl-glfw-3.2.2.jar:build 10]
	at org.lwjgl.system.JNI.invokeV(Native Method) ~[lwjgl-3.2.2.jar:build 10]
	at org.lwjgl.glfw.GLFW.glfwPollEvents(GLFW.java:3101) [lwjgl-glfw-3.2.2.jar:build 10]
	at com.mojang.blaze3d.systems.RenderSystem.flipFrame(SourceFile:102) [?:?]
	at net.minecraft.client.MainWindow.func_227802_e_(MainWindow.java:398) [?:?]
	at net.minecraft.client.Minecraft.func_195542_b(Minecraft.java:997) [?:?]
	at net.minecraft.client.Minecraft.func_99999_d(Minecraft.java:607) [?:?]
	at net.minecraft.client.main.Main.main(Main.java:184) [?:?]
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) ~[?:1.8.0_51]
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) ~[?:1.8.0_51]
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) ~[?:1.8.0_51]
	at java.lang.reflect.Method.invoke(Method.java:497) ~[?:1.8.0_51]
	at net.minecraftforge.fml.loading.FMLClientLaunchProvider.lambda$launchService$0(FMLClientLaunchProvider.java:51) [forge-1.16.5-36.2.33.jar:36.2]
	at net.minecraftforge.fml.loading.FMLClientLaunchProvider$$Lambda$496/1753746465.call(Unknown Source) [forge-1.16.5-36.2.33.jar:36.2]
	at cpw.mods.modlauncher.LaunchServiceHandlerDecorator.launch(LaunchServiceHandlerDecorator.java:37) [modlauncher-8.1.3.jar:?]
	at cpw.mods.modlauncher.LaunchServiceHandler.launch(LaunchServiceHandler.java:54) [modlauncher-8.1.3.jar:?]
	at cpw.mods.modlauncher.LaunchServiceHandler.launch(LaunchServiceHandler.java:72) [modlauncher-8.1.3.jar:?]
	at cpw.mods.modlauncher.Launcher.run(Launcher.java:82) [modlauncher-8.1.3.jar:?]
	at cpw.mods.modlauncher.Launcher.main(Launcher.java:66) [modlauncher-8.1.3.jar:?]
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_aspen_chair as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_holly_coffee_table as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:atmospheric_stripped_grimwood_desk as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_cypress_bedside_cabinet as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:abundance_redbud_kitchen_sink_dark as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_holly_kitchen_counter as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:atmospheric_stripped_grimwood_desk_cabinet as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_blue_enchanted_kitchen_sink_light as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:atmospheric_morado_cabinet as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_skyris_chair as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:atmospheric_stripped_kousa_upgraded_gate as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_green_enchanted_chair as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_green_enchanted_crate as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_nightshade_mail_box as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:bayou_blues_cypress_park_bench as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_blue_enchanted_bedside_cabinet as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_cika_upgraded_gate as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_palm_kitchen_counter as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_mangrove_desk_cabinet as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:environmental_stripped_wisteria_cabinet as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_maple_desk_cabinet as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_holly_kitchen_sink_dark as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_maple_crate as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_imparius_kitchen_sink_light as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:atmospheric_stripped_aspen_park_bench as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_aspen_blinds as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:atmospheric_rosewood_table as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_zelkova_crate as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:upgrade_aquatic_stripped_driftwood_kitchen_sink_light as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:atmospheric_yucca_kitchen_counter as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_mangrove_kitchen_sink_light as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:upgrade_aquatic_driftwood_bedside_cabinet as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_redwood_desk as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_sythian_cabinet as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:environmental_cherry_park_bench as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:atmospheric_stripped_rosewood_kitchen_sink_light as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_fir_blinds as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:environmental_cherry_coffee_table as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:abundance_stripped_jacaranda_table as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:atmospheric_morado_kitchen_sink_light as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_green_enchanted_kitchen_sink_dark as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_zelkova_bedside_cabinet as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_fir_kitchen_sink_light as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:upgrade_aquatic_stripped_river_kitchen_drawer as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:endergetic_stripped_poise_park_bench as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_witch_hazel_upgraded_fence as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:atmospheric_stripped_rosewood_kitchen_drawer as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_mahogany_mail_box as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_holly_mail_box as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_cherry_kitchen_counter as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_pine_crate as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_mangrove_chair as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_aspen_cabinet as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:atmospheric_stripped_rosewood_crate as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:environmental_stripped_willow_kitchen_sink_light as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:bayou_blues_stripped_cypress_crate as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_jacaranda_mail_box as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:atmospheric_stripped_rosewood_kitchen_counter as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:atmospheric_aspen_chair as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:environmental_stripped_willow_kitchen_counter as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_redwood_chair as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:atmospheric_stripped_rosewood_mail_box as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:atmospheric_stripped_yucca_crate as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:upgrade_aquatic_stripped_driftwood_chair as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_jacaranda_chair as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:atmospheric_yucca_park_bench as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:abundance_stripped_redbud_kitchen_sink_light as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:atmospheric_stripped_kousa_bedside_cabinet as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_palm_blinds as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_skyris_blinds as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe industrialforegoing:laser_drill_ore/bauxite as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:atmospheric_stripped_grimwood_blinds as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_cika_kitchen_counter as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_zelkova_coffee_table as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_lament_kitchen_sink_dark as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:abundance_redbud_desk as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_bulbis_cabinet as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_redwood_kitchen_sink_dark as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_sythian_chair as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:bayou_blues_cypress_desk_cabinet as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:abundance_redbud_kitchen_sink_light as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_zelkova_bedside_cabinet as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:atmospheric_rosewood_kitchen_sink_light as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_fir_kitchen_sink_dark as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_cika_bedside_cabinet as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:atmospheric_stripped_morado_kitchen_sink_dark as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_baobab_chair as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_holly_park_bench as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:atmospheric_morado_upgraded_fence as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:atmospheric_stripped_aspen_chair as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_maple_coffee_table as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_mahogany_park_bench as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:upgrade_aquatic_river_upgraded_fence as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_baobab_kitchen_sink_dark as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:abundance_redbud_table as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_holly_cabinet as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:environmental_stripped_wisteria_desk_cabinet as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:atmospheric_yucca_desk as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_maple_cabinet as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:upgrade_aquatic_stripped_river_desk as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_sythian_kitchen_sink_light as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:upgrade_aquatic_stripped_river_chair as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:abundance_stripped_redbud_crate as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_witch_hazel_coffee_table as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_witch_hazel_kitchen_sink_dark as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_ether_park_bench as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_mangrove_coffee_table as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:atmospheric_yucca_upgraded_fence as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_ebony_bedside_cabinet as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:abundance_jacaranda_crate as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_rainbow_eucalyptus_kitchen_sink_light as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:upgrade_aquatic_stripped_driftwood_mail_box as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_lament_crate as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_baobab_cabinet as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:abundance_stripped_jacaranda_mail_box as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:bayou_blues_stripped_cypress_blinds as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_cika_desk as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_zelkova_desk as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_cherry_desk_cabinet as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_witch_hazel_chair as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:upgrade_aquatic_stripped_driftwood_bedside_cabinet as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:autumnity_maple_upgraded_gate as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_redwood_kitchen_drawer as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_ether_park_bench as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_ether_coffee_table as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:bayou_blues_stripped_cypress_mail_box as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_aspen_coffee_table as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_mangrove_chair as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_baobab_crate as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe industrialforegoing:laser_drill_ore/draconium as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:environmental_stripped_willow_kitchen_drawer as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:abundance_jacaranda_kitchen_sink_light as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_sythian_upgraded_fence as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_lament_kitchen_counter as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_blue_enchanted_park_bench as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_maple_bedside_cabinet as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe industrialforegoing:laser_drill_ore/cobalt as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:environmental_wisteria_chair as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_bulbis_crate as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:upgrade_aquatic_stripped_river_kitchen_sink_light as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_jacaranda_desk as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_lament_desk_cabinet as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_rainbow_eucalyptus_kitchen_counter as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_blue_enchanted_upgraded_gate as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_ebony_desk_cabinet as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_ether_chair as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:atmospheric_morado_coffee_table as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_maple_blinds as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_redwood_cabinet as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:abundance_stripped_jacaranda_bedside_cabinet as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:atmospheric_kousa_park_bench as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_witch_hazel_bedside_cabinet as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_pine_park_bench as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_nightshade_upgraded_gate as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:abundance_stripped_redbud_bedside_cabinet as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:environmental_wisteria_upgraded_gate as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_cherry_table as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_rainbow_eucalyptus_upgraded_gate as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_mahogany_chair as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:abundance_stripped_jacaranda_kitchen_sink_light as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_baobab_coffee_table as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_witch_hazel_coffee_table as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:atmospheric_rosewood_upgraded_fence as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_willow_desk_cabinet as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_cika_table as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_rainbow_eucalyptus_upgraded_fence as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_fir_crate as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_imparius_chair as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_blue_enchanted_crate as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_zelkova_park_bench as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_mangrove_blinds as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:atmospheric_stripped_grimwood_crate as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_maple_kitchen_drawer as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:atmospheric_kousa_crate as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_maple_kitchen_sink_dark as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_pine_table as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:upgrade_aquatic_driftwood_coffee_table as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_nightshade_kitchen_counter as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_sythian_crate as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_rainbow_eucalyptus_desk as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:atmospheric_yucca_coffee_table as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:autumnity_maple_table as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_lament_blinds as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:atmospheric_stripped_kousa_crate as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_green_enchanted_park_bench as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:atmospheric_rosewood_kitchen_counter as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_fir_crate as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:endergetic_poise_table as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe industrialforegoing:laser_drill_ore/sulfur as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_mahogany_chair as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_maple_kitchen_sink_dark as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_witch_hazel_kitchen_sink_light as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:environmental_stripped_wisteria_chair as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:abundance_redbud_mail_box as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_holly_cabinet as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_jacaranda_kitchen_counter as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_willow_crate as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:environmental_stripped_wisteria_blinds as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_green_enchanted_upgraded_fence as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_redwood_bedside_cabinet as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_imparius_kitchen_counter as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_nightshade_desk as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:abundance_stripped_jacaranda_desk_cabinet as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:bayou_blues_stripped_cypress_upgraded_fence as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:environmental_willow_park_bench as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_maple_kitchen_sink_light as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:upgrade_aquatic_stripped_river_upgraded_fence as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_skyris_kitchen_counter as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_zelkova_coffee_table as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:environmental_stripped_willow_upgraded_fence as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:environmental_stripped_wisteria_crate as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:atmospheric_grimwood_table as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:bayou_blues_stripped_cypress_kitchen_sink_light as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:upgrade_aquatic_river_upgraded_gate as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:atmospheric_yucca_cabinet as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_sythian_kitchen_sink_dark as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_zelkova_kitchen_sink_dark as it's serializer returned null
[12:53:48] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_maple_upgraded_fence as it's serializer returned null
[12:53:49] [main/INFO]: Skipping loading recipe morecfm:byg_cypress_table as it's serializer returned null
[12:53:49] [main/INFO]: Skipping loading recipe morecfm:upgrade_aquatic_stripped_river_bedside_cabinet as it's serializer returned null
[12:53:49] [main/INFO]: Skipping loading recipe morecfm:autumnity_maple_desk as it's serializer returned null
[12:53:49] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_willow_kitchen_sink_light as it's serializer returned null
[12:53:49] [main/INFO]: Skipping loading recipe morecfm:byg_ebony_bedside_cabinet as it's serializer returned null
[12:53:49] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_cypress_cabinet as it's serializer returned null
[12:53:49] [main/INFO]: Skipping loading recipe morecfm:environmental_cherry_chair as it's serializer returned null
[12:53:49] [main/INFO]: Skipping loading recipe morecfm:upgrade_aquatic_stripped_river_blinds as it's serializer returned null
[12:53:49] [main/INFO]: Skipping loading recipe morecfm:atmospheric_stripped_grimwood_coffee_table as it's serializer returned null
[12:53:49] [main/INFO]: Skipping loading recipe morecfm:byg_cika_blinds as it's serializer returned null
[12:53:49] [main/INFO]: Skipping loading recipe morecfm:byg_redwood_desk_cabinet as it's serializer returned null
[12:53:49] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_sythian_kitchen_drawer as it's serializer returned null
[12:53:49] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_redwood_upgraded_fence as it's serializer returned null
[12:53:49] [main/INFO]: Skipping loading recipe morecfm:atmospheric_yucca_kitchen_drawer as it's serializer returned null
[12:53:49] [main/INFO]: Skipping loading recipe morecfm:atmospheric_grimwood_kitchen_drawer as it's serializer returned null
[12:53:49] [main/INFO]: Skipping loading recipe morecfm:byg_jacaranda_kitchen_counter as it's serializer returned null
[12:53:49] [main/INFO]: Skipping loading recipe morecfm:byg_bulbis_mail_box as it's serializer returned null
[12:53:49] [main/INFO]: Skipping loading recipe morecfm:byg_nightshade_kitchen_sink_dark as it's serializer returned null
[12:53:49] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_mahogany_desk_cabinet as it's serializer returned null
[12:53:49] [main/INFO]: Skipping loading recipe morecfm:byg_fir_chair as it's serializer returned null
[12:53:49] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_maple_upgraded_gate as it's serializer returned null
[12:53:49] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_pine_desk_cabinet as it's serializer returned null
[12:53:49] [main/INFO]: Skipping loading recipe morecfm:bayou_blues_cypress_kitchen_sink_dark as it's serializer returned null
[12:53:49] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_fir_park_bench as it's serializer returned null
[12:53:49] [main/INFO]: Skipping loading recipe morecfm:byg_baobab_mail_box as it's serializer returned null
[12:53:49] [main/INFO]: Skipping loading recipe morecfm:byg_zelkova_desk as it's serializer returned null
[12:53:49] [main/INFO]: Skipping loading recipe morecfm:atmospheric_stripped_grimwood_kitchen_counter as it's serializer returned null
[12:53:49] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_green_enchanted_bedside_cabinet as it's serializer returned null
[12:53:49] [main/INFO]: Skipping loading recipe morecfm:byg_cika_kitchen_drawer as it's serializer returned null
[12:53:49] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_redwood_upgraded_gate as it's serializer returned null
[12:53:49] [main/INFO]: Skipping loading recipe morecfm:environmental_stripped_willow_table as it's serializer returned null
[12:53:49] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_redwood_mail_box as it's serializer returned null
[12:53:49] [main/INFO]: Skipping loading recipe industrialforegoing:laser_drill_ore/arcane as it's serializer returned null
[12:53:49] [main/INFO]: Skipping loading recipe morecfm:abundance_jacaranda_blinds as it's serializer returned null
[12:53:49] [main/INFO]: Skipping loading recipe morecfm:upgrade_aquatic_stripped_driftwood_upgraded_fence as it's serializer returned null
[12:53:49] [main/INFO]: Skipping loading recipe morecfm:abundance_stripped_redbud_upgraded_fence as it's serializer returned null
[12:53:49] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_rainbow_eucalyptus_kitchen_sink_dark as it's serializer returned null
[12:53:49] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_ebony_park_bench as it's serializer returned null
[12:53:49] [main/INFO]: Skipping loading recipe morecfm:environmental_stripped_wisteria_park_bench as it's serializer returned null
[12:53:49] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_jacaranda_kitchen_sink_light as it's serializer returned null
[12:53:49] [main/INFO]: Skipping loading recipe morecfm:endergetic_poise_desk as it's serializer returned null
[12:53:49] [main/INFO]: Skipping loading recipe morecfm:abundance_stripped_redbud_chair as it's serializer returned null
[12:53:49] [main/INFO]: Skipping loading recipe morecfm:byg_bulbis_park_bench as it's serializer returned null
[12:53:49] [main/INFO]: Skipping loading recipe morecfm:atmospheric_stripped_morado_kitchen_counter as it's serializer returned null
[12:53:49] [main/INFO]: Skipping loading recipe morecfm:atmospheric_aspen_kitchen_sink_dark as it's serializer returned null
[12:53:49] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_holly_mail_box as it's serializer returned null
[12:53:49] [main/INFO]: Skipping loading recipe morecfm:atmospheric_stripped_yucca_coffee_table as it's serializer returned null
[12:53:49] [main/INFO]: Skipping loading recipe morecfm:byg_aspen_kitchen_counter as it's serializer returned null
[12:53:49] [main/INFO]: Skipping loading recipe morecfm:byg_mahogany_kitchen_counter as it's serializer returned null
[12:53:49] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_willow_crate as it's serializer returned null
[12:53:49] [main/INFO]: Skipping loading recipe morecfm:byg_maple_blinds as it's serializer returned null
[12:53:49] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_redwood_desk_cabinet as it's serializer returned null
[12:53:49] [main/INFO]: Skipping loading recipe morecfm:environmental_cherry_kitchen_sink_light as it's serializer returned null
[12:53:49] [main/INFO]: Skipping loading recipe morecfm:byg_bulbis_bedside_cabinet as it's serializer returned null
[12:53:49] [main/INFO]: Skipping loading recipe morecfm:atmospheric_stripped_rosewood_coffee_table as it's serializer returned null
[12:53:49] [main/INFO]: Skipping loading recipe morecfm:byg_palm_kitchen_sink_dark as it's serializer returned null
[12:53:49] [main/INFO]: Skipping loading recipe morecfm:byg_fir_coffee_table as it's serializer returned null
[12:53:49] [main/INFO]: Skipping loading recipe morecfm:upgrade_aquatic_stripped_river_kitchen_sink_dark as it's serializer returned null
[12:53:49] [main/INFO]: Skipping loading recipe morecfm:byg_mangrove_kitchen_counter as it's serializer returned null
[12:53:49] [main/INFO]: Skipping loading recipe morecfm:environmental_stripped_wisteria_mail_box as it's serializer returned null
[12:53:49] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_palm_kitchen_sink_light as it's serializer returned null
[12:53:49] [main/INFO]: Skipping loading recipe morecfm:byg_witch_hazel_desk as it's serializer returned null
[12:53:49] [main/INFO]: Skipping loading recipe morecfm:upgrade_aquatic_stripped_driftwood_desk_cabinet as it's serializer returned null
[12:53:49] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_palm_coffee_table as it's serializer returned null
[12:53:49] [main/INFO]: Skipping loading recipe morecfm:byg_maple_upgraded_fence as it's serializer returned null
[12:53:49] [main/INFO]: Skipping loading recipe morecfm:byg_rainbow_eucalyptus_kitchen_drawer as it's serializer returned null
[12:53:49] [main/INFO]: Skipping loading recipe morecfm:environmental_willow_coffee_table as it's serializer returned null
[12:53:49] [main/INFO]: Skipping loading recipe morecfm:bayou_blues_cypress_mail_box as it's serializer returned null
[12:53:49] [main/INFO]: Skipping loading recipe morecfm:atmospheric_stripped_rosewood_park_bench as it's serializer returned null
[12:53:49] [main/INFO]: Skipping loading recipe morecfm:environmental_wisteria_coffee_table as it's serializer returned null
[12:53:49] [main/INFO]: Skipping loading recipe morecfm:atmospheric_stripped_morado_desk_cabinet as it's serializer returned null
[12:53:49] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_nightshade_kitchen_drawer as it's serializer returned null
[12:53:49] [main/INFO]: Skipping loading recipe morecfm:autumnity_stripped_maple_crate as it's serializer returned null
[12:53:49] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_cika_kitchen_counter as it's serializer returned null
[12:53:49] [main/INFO]: Skipping loading recipe morecfm:byg_cypress_park_bench as it's serializer returned null
[12:53:49] [main/INFO]: Skipping loading recipe morecfm:endergetic_poise_mail_box as it's serializer returned null
[12:53:49] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_witch_hazel_desk as it's serializer returned null
[12:53:49] [main/INFO]: Skipping loading recipe morecfm:byg_witch_hazel_park_bench as it's serializer returned null
[12:53:49] [main/INFO]: Skipping loading recipe morecfm:byg_palm_crate as it's serializer returned null
[12:53:49] [main/INFO]: Skipping loading recipe morecfm:byg_aspen_mail_box as it's serializer returned null
[12:53:49] [main/INFO]: Skipping loading recipe morecfm:upgrade_aquatic_stripped_driftwood_upgraded_gate as it's serializer returned null
[12:53:49] [main/INFO]: Skipping loading recipe morecfm:environmental_stripped_cherry_upgraded_fence as it's serializer returned null
[12:53:49] [main/INFO]: Skipping loading recipe morecfm:atmospheric_rosewood_cabinet as it's serializer returned null
[12:53:49] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_green_enchanted_crate as it's serializer returned null
[12:53:49] [main/INFO]: Skipping loading recipe morecfm:endergetic_stripped_poise_kitchen_counter as it's serializer returned null
[12:53:49] [main/INFO]: Skipping loading recipe morecfm:endergetic_stripped_poise_chair as it's serializer returned null
[12:53:49] [main/INFO]: Skipping loading recipe morecfm:bayou_blues_cypress_crate as it's serializer returned null
[12:53:49] [main/INFO]: Skipping loading recipe morecfm:bayou_blues_cypress_kitchen_sink_light as it's serializer returned null
[12:53:49] [main/INFO]: Skipping loading recipe morecfm:byg_jacaranda_blinds as it's serializer returned null
[12:53:49] [main/INFO]: Skipping loading recipe morecfm:environmental_stripped_cherry_crate as it's serializer returned null
[12:53:49] [main/INFO]: Skipping loading recipe morecfm:byg_baobab_desk as it's serializer returned null
[12:53:49] [main/INFO]: Skipping loading recipe morecfm:byg_pine_upgraded_fence as it's serializer returned null
[12:53:49] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_willow_upgraded_fence as it's serializer returned null
[12:53:49] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_palm_mail_box as it's serializer returned null
[12:53:49] [main/INFO]: Skipping loading recipe morecfm:byg_witch_hazel_cabinet as it's serializer returned null
[12:53:49] [main/INFO]: Skipping loading recipe morecfm:atmospheric_aspen_cabinet as it's serializer returned null
[12:53:49] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_witch_hazel_blinds as it's serializer returned null
[12:53:49] [main/INFO]: Skipping loading recipe morecfm:byg_redwood_mail_box as it's serializer returned null
[12:53:49] [main/INFO]: Skipping loading recipe morecfm:byg_ether_kitchen_counter as it's serializer returned null
[12:53:49] [main/INFO]: Skipping loading recipe morecfm:byg_rainbow_eucalyptus_coffee_table as it's serializer returned null
[12:53:49] [main/INFO]: Skipping loading recipe morecfm:autumnity_maple_kitchen_sink_light as it's serializer returned null
[12:53:49] [main/INFO]: Skipping loading recipe morecfm:autumnity_stripped_maple_bedside_cabinet as it's serializer returned null
[12:53:49] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_nightshade_kitchen_sink_light as it's serializer returned null
[12:53:49] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_ether_kitchen_drawer as it's serializer returned null
[12:53:49] [main/INFO]: Skipping loading recipe morecfm:abundance_redbud_kitchen_counter as it's serializer returned null
[12:53:49] [main/INFO]: Skipping loading recipe morecfm:autumnity_stripped_maple_blinds as it's serializer returned null
[12:53:49] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_witch_hazel_table as it's serializer returned null
[12:53:49] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_cherry_upgraded_fence as it's serializer returned null
[12:53:49] [main/INFO]: Skipping loading recipe morecfm:byg_imparius_desk_cabinet as it's serializer returned null
[12:53:49] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_cypress_coffee_table as it's serializer returned null
[12:53:49] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_blue_enchanted_coffee_table as it's serializer returned null
[12:53:49] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_mangrove_coffee_table as it's serializer returned null
[12:53:49] [main/INFO]: Skipping loading recipe morecfm:atmospheric_aspen_upgraded_gate as it's serializer returned null
[12:53:49] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_jacaranda_blinds as it's serializer returned null
[12:53:49] [main/INFO]: Skipping loading recipe morecfm:atmospheric_aspen_kitchen_sink_light as it's serializer returned null
[12:53:49] [main/INFO]: Skipping loading recipe morecfm:byg_mangrove_park_bench as it's serializer returned null
[12:53:49] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_ether_table as it's serializer returned null
[12:53:49] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_skyris_upgraded_gate as it's serializer returned null
[12:53:49] [main/INFO]: Skipping loading recipe morecfm:byg_sythian_bedside_cabinet as it's serializer returned null
[12:53:49] [main/INFO]: Skipping loading recipe morecfm:abundance_jacaranda_kitchen_drawer as it's serializer returned null
[12:53:49] [main/INFO]: Skipping loading recipe morecfm:upgrade_aquatic_stripped_driftwood_crate as it's serializer returned null
[12:53:49] [main/INFO]: Skipping loading recipe industrialforegoing:laser_drill_fluid/oil as it's serializer returned null
[12:53:49] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_maple_desk as it's serializer returned null
[12:53:49] [main/INFO]: Skipping loading recipe morecfm:atmospheric_grimwood_kitchen_counter as it's serializer returned null
[12:53:49] [main/INFO]: Skipping loading recipe morecfm:byg_stripped_rainbow_eucalyptus_table as it's serializer returned null
[12:53:49] [main/INFO]: Skipping loading recipe morecfm:byg_green_enchanted_upgraded_gate as it's serializer returned null
[12:53:49] [main/INFO]: Skipping loading recipe morecfm:autumnity_stripped_maple_park_bench as it's serializer returned null
[12:53:49] [main/INFO]: Skipping loading recipe morecfm:atmospheric_yucca_chair as it's serializer returned null
[12:53:49] [main/INFO]: Skipping loading recipe morecfm:byg_holly_upgraded_fence as it's serializer returned null
[12:53:49] [main/INFO]: Skipping loading recipe morecfm:atmospheric_morado_kitchen_sink_dark as it's serializer returned null
[12:53:49] [main/INFO]: Loaded 60 recipes
[12:53:49] [main/ERROR]: Couldn't parse loot table iceandfire:blocks/unobtainium_pile
java.lang.IllegalArgumentException: Can't find block iceandfire:unobtainium_pile
	at net.minecraft.loot.conditions.BlockStateProperty$Serializer.func_227569_a_(SourceFile:79) ~[?:?]
	at net.minecraft.loot.conditions.BlockStateProperty$Serializer$$Lambda$14069/628376296.get(Unknown Source) ~[?:?]
	at java.util.Optional.orElseThrow(Optional.java:290) ~[?:1.8.0_51]
	at net.minecraft.loot.conditions.BlockStateProperty$Serializer.func_230423_a_(SourceFile:79) ~[?:?]
	at net.minecraft.loot.conditions.BlockStateProperty$Serializer.func_230423_a_(SourceFile:68) ~[?:?]
	at net.minecraft.loot.LootTypesManager$Serializer.deserialize(SourceFile:83) ~[?:?]
	at com.google.gson.internal.bind.TreeTypeAdapter.read(TreeTypeAdapter.java:69) ~[gson-2.8.0.jar:?]
	at com.google.gson.internal.bind.TypeAdapterRuntimeTypeWrapper.read(TypeAdapterRuntimeTypeWrapper.java:41) ~[gson-2.8.0.jar:?]
	at com.google.gson.internal.bind.ArrayTypeAdapter.read(ArrayTypeAdapter.java:72) ~[gson-2.8.0.jar:?]
	at com.google.gson.Gson.fromJson(Gson.java:887) ~[gson-2.8.0.jar:?]
	at com.google.gson.Gson.fromJson(Gson.java:952) ~[gson-2.8.0.jar:?]
	at com.google.gson.internal.bind.TreeTypeAdapter$GsonContextImpl.deserialize(TreeTypeAdapter.java:162) ~[gson-2.8.0.jar:?]
	at net.minecraft.util.JSONUtils.func_188179_a(SourceFile:440) ~[?:?]
	at net.minecraft.util.JSONUtils.func_188177_a(SourceFile:456) ~[?:?]
	at net.minecraft.loot.LootEntry$Serializer.func_230423_a_(SourceFile:85) ~[?:?]
	at net.minecraft.loot.LootEntry$Serializer.func_230423_a_(SourceFile:74) ~[?:?]
	at net.minecraft.loot.LootTypesManager$Serializer.deserialize(SourceFile:83) ~[?:?]
	at com.google.gson.internal.bind.TreeTypeAdapter.read(TreeTypeAdapter.java:69) ~[gson-2.8.0.jar:?]
	at com.google.gson.internal.bind.TypeAdapterRuntimeTypeWrapper.read(TypeAdapterRuntimeTypeWrapper.java:41) ~[gson-2.8.0.jar:?]
	at com.google.gson.internal.bind.ArrayTypeAdapter.read(ArrayTypeAdapter.java:72) ~[gson-2.8.0.jar:?]
	at com.google.gson.Gson.fromJson(Gson.java:887) ~[gson-2.8.0.jar:?]
	at com.google.gson.Gson.fromJson(Gson.java:952) ~[gson-2.8.0.jar:?]
	at com.google.gson.internal.bind.TreeTypeAdapter$GsonContextImpl.deserialize(TreeTypeAdapter.java:162) ~[gson-2.8.0.jar:?]
	at net.minecraft.util.JSONUtils.func_188179_a(SourceFile:440) ~[?:?]
	at net.minecraft.util.JSONUtils.func_188174_a(SourceFile:448) ~[?:?]
	at net.minecraft.loot.LootPool$Serializer.deserialize(LootPool.java:183) ~[?:?]
	at net.minecraft.loot.LootPool$Serializer.deserialize(LootPool.java:180) ~[?:?]
	at com.google.gson.internal.bind.TreeTypeAdapter.read(TreeTypeAdapter.java:69) ~[gson-2.8.0.jar:?]
	at com.google.gson.internal.bind.TypeAdapterRuntimeTypeWrapper.read(TypeAdapterRuntimeTypeWrapper.java:41) ~[gson-2.8.0.jar:?]
	at com.google.gson.internal.bind.ArrayTypeAdapter.read(ArrayTypeAdapter.java:72) ~[gson-2.8.0.jar:?]
	at com.google.gson.Gson.fromJson(Gson.java:887) ~[gson-2.8.0.jar:?]
	at com.google.gson.Gson.fromJson(Gson.java:952) ~[gson-2.8.0.jar:?]
	at com.google.gson.internal.bind.TreeTypeAdapter$GsonContextImpl.deserialize(TreeTypeAdapter.java:162) ~[gson-2.8.0.jar:?]
	at net.minecraft.util.JSONUtils.func_188179_a(SourceFile:440) ~[?:?]
	at net.minecraft.util.JSONUtils.func_188177_a(SourceFile:456) ~[?:?]
	at net.minecraft.loot.LootTable$Serializer.deserialize(LootTable.java:252) ~[?:?]
	at net.minecraft.loot.LootTable$Serializer.deserialize(LootTable.java:249) ~[?:?]
	at com.google.gson.internal.bind.TreeTypeAdapter.read(TreeTypeAdapter.java:69) ~[gson-2.8.0.jar:?]
	at com.google.gson.Gson.fromJson(Gson.java:887) ~[gson-2.8.0.jar:?]
	at com.google.gson.Gson.fromJson(Gson.java:952) ~[gson-2.8.0.jar:?]
	at com.google.gson.Gson.fromJson(Gson.java:925) ~[gson-2.8.0.jar:?]
	at net.minecraftforge.common.ForgeHooks.loadLootTable(ForgeHooks.java:888) ~[?:?]
	at net.minecraft.loot.LootTableManager.lambda$apply$0(LootTableManager.java:40) [?:?]
	at net.minecraft.loot.LootTableManager$$Lambda$14065/295727300.accept(Unknown Source) [?:?]
	at java.util.HashMap.forEach(HashMap.java:1280) [?:1.8.0_51]
	at net.minecraft.loot.LootTableManager.func_212853_a_(LootTableManager.java:38) [?:?]
	at net.minecraft.loot.LootTableManager.func_212853_a_(LootTableManager.java:16) [?:?]
	at net.minecraft.client.resources.ReloadListener.func_215269_a(SourceFile:13) [?:?]
	at net.minecraft.client.resources.ReloadListener$$Lambda$9873/1436560249.accept(Unknown Source) [?:?]
	at java.util.concurrent.CompletableFuture.uniAccept(CompletableFuture.java:656) [?:1.8.0_51]
	at java.util.concurrent.CompletableFuture$UniAccept.tryFire(CompletableFuture.java:632) [?:1.8.0_51]
	at java.util.concurrent.CompletableFuture$Completion.run(CompletableFuture.java:442) [?:1.8.0_51]
	at net.minecraft.resources.AsyncReloader.func_219557_a(SourceFile:71) [?:?]
	at net.minecraft.resources.AsyncReloader$$Lambda$10018/707432592.run(Unknown Source) [?:?]
	at net.minecraft.util.concurrent.ThreadTaskExecutor.func_213166_h(ThreadTaskExecutor.java:191) [?:?]
	at net.minecraft.util.concurrent.RecursiveEventLoop.func_213166_h(SourceFile:23) [?:?]
	at net.minecraft.util.concurrent.ThreadTaskExecutor.func_213168_p(ThreadTaskExecutor.java:153) [?:?]
	at net.minecraft.util.concurrent.ThreadTaskExecutor.func_213161_c(ThreadTaskExecutor.java:169) [?:?]
	at net.minecraft.client.Minecraft.func_238189_a_(Minecraft.java:1865) [?:?]
	at net.minecraft.client.Minecraft.loadWorld(Minecraft.java:1714) [?:?]
	at net.minecraft.client.Minecraft.func_238192_a_(Minecraft.java:1687) [?:?]
	at net.minecraft.client.gui.screen.CreateWorldScreen.func_195352_j(CreateWorldScreen.java:260) [?:?]
	at net.minecraft.client.gui.screen.CreateWorldScreen.lambda$init$11(CreateWorldScreen.java:205) [?:?]
	at net.minecraft.client.gui.screen.CreateWorldScreen$$Lambda$12951/1871004871.onPress(Unknown Source) [?:?]
	at net.minecraft.client.gui.widget.button.Button.func_230930_b_(SourceFile:33) [?:?]
	at net.minecraft.client.gui.widget.button.AbstractButton.func_230982_a_(SourceFile:16) [?:?]
	at net.minecraft.client.gui.widget.Widget.func_231044_a_(Widget.java:136) [?:?]
	at net.minecraft.client.gui.INestedGuiEventHandler.func_231044_a_(SourceFile:27) [?:?]
	at net.minecraft.client.MouseHelper.func_198033_b(MouseHelper.java:87) [?:?]
	at net.minecraft.client.MouseHelper$$Lambda$12646/468309489.run(Unknown Source) [?:?]
	at net.minecraft.client.gui.screen.Screen.func_231153_a_(Screen.java:427) [?:?]
	at net.minecraft.client.MouseHelper.func_198023_a(MouseHelper.java:85) [?:?]
	at net.minecraft.client.MouseHelper.func_228030_c_(MouseHelper.java:181) [?:?]
	at net.minecraft.client.MouseHelper$$Lambda$12645/1510532588.run(Unknown Source) [?:?]
	at net.minecraft.util.concurrent.ThreadTaskExecutor.execute(ThreadTaskExecutor.java:106) [?:?]
	at net.minecraft.client.MouseHelper.func_228028_b_(MouseHelper.java:180) [?:?]
	at net.minecraft.client.MouseHelper$$Lambda$9851/1244357368.invoke(Unknown Source) [?:?]
	at org.lwjgl.glfw.GLFWMouseButtonCallbackI.callback(GLFWMouseButtonCallbackI.java:36) [lwjgl-glfw-3.2.2.jar:build 10]
	at org.lwjgl.system.JNI.invokeV(Native Method) ~[lwjgl-3.2.2.jar:build 10]
	at org.lwjgl.glfw.GLFW.glfwPollEvents(GLFW.java:3101) [lwjgl-glfw-3.2.2.jar:build 10]
	at com.mojang.blaze3d.systems.RenderSystem.flipFrame(SourceFile:102) [?:?]
	at net.minecraft.client.MainWindow.func_227802_e_(MainWindow.java:398) [?:?]
	at net.minecraft.client.Minecraft.func_195542_b(Minecraft.java:997) [?:?]
	at net.minecraft.client.Minecraft.func_99999_d(Minecraft.java:607) [?:?]
	at net.minecraft.client.main.Main.main(Main.java:184) [?:?]
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) ~[?:1.8.0_51]
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) ~[?:1.8.0_51]
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) ~[?:1.8.0_51]
	at java.lang.reflect.Method.invoke(Method.java:497) ~[?:1.8.0_51]
	at net.minecraftforge.fml.loading.FMLClientLaunchProvider.lambda$launchService$0(FMLClientLaunchProvider.java:51) [forge-1.16.5-36.2.33.jar:36.2]
	at net.minecraftforge.fml.loading.FMLClientLaunchProvider$$Lambda$496/1753746465.call(Unknown Source) [forge-1.16.5-36.2.33.jar:36.2]
	at cpw.mods.modlauncher.LaunchServiceHandlerDecorator.launch(LaunchServiceHandlerDecorator.java:37) [modlauncher-8.1.3.jar:?]
	at cpw.mods.modlauncher.LaunchServiceHandler.launch(LaunchServiceHandler.java:54) [modlauncher-8.1.3.jar:?]
	at cpw.mods.modlauncher.LaunchServiceHandler.launch(LaunchServiceHandler.java:72) [modlauncher-8.1.3.jar:?]
	at cpw.mods.modlauncher.Launcher.run(Launcher.java:82) [modlauncher-8.1.3.jar:?]
	at cpw.mods.modlauncher.Launcher.main(Launcher.java:66) [modlauncher-8.1.3.jar:?]
[12:53:50] [main/ERROR]: Couldn't parse loot table iceandfire:blocks/vibranium_pile
java.lang.IllegalArgumentException: Can't find block iceandfire:vibranium_pile
	at net.minecraft.loot.conditions.BlockStateProperty$Serializer.func_227569_a_(SourceFile:79) ~[?:?]
	at net.minecraft.loot.conditions.BlockStateProperty$Serializer$$Lambda$14069/628376296.get(Unknown Source) ~[?:?]
	at java.util.Optional.orElseThrow(Optional.java:290) ~[?:1.8.0_51]
	at net.minecraft.loot.conditions.BlockStateProperty$Serializer.func_230423_a_(SourceFile:79) ~[?:?]
	at net.minecraft.loot.conditions.BlockStateProperty$Serializer.func_230423_a_(SourceFile:68) ~[?:?]
	at net.minecraft.loot.LootTypesManager$Serializer.deserialize(SourceFile:83) ~[?:?]
	at com.google.gson.internal.bind.TreeTypeAdapter.read(TreeTypeAdapter.java:69) ~[gson-2.8.0.jar:?]
	at com.google.gson.internal.bind.TypeAdapterRuntimeTypeWrapper.read(TypeAdapterRuntimeTypeWrapper.java:41) ~[gson-2.8.0.jar:?]
	at com.google.gson.internal.bind.ArrayTypeAdapter.read(ArrayTypeAdapter.java:72) ~[gson-2.8.0.jar:?]
	at com.google.gson.Gson.fromJson(Gson.java:887) ~[gson-2.8.0.jar:?]
	at com.google.gson.Gson.fromJson(Gson.java:952) ~[gson-2.8.0.jar:?]
	at com.google.gson.internal.bind.TreeTypeAdapter$GsonContextImpl.deserialize(TreeTypeAdapter.java:162) ~[gson-2.8.0.jar:?]
	at net.minecraft.util.JSONUtils.func_188179_a(SourceFile:440) ~[?:?]
	at net.minecraft.util.JSONUtils.func_188177_a(SourceFile:456) ~[?:?]
	at net.minecraft.loot.LootEntry$Serializer.func_230423_a_(SourceFile:85) ~[?:?]
	at net.minecraft.loot.LootEntry$Serializer.func_230423_a_(SourceFile:74) ~[?:?]
	at net.minecraft.loot.LootTypesManager$Serializer.deserialize(SourceFile:83) ~[?:?]
	at com.google.gson.internal.bind.TreeTypeAdapter.read(TreeTypeAdapter.java:69) ~[gson-2.8.0.jar:?]
	at com.google.gson.internal.bind.TypeAdapterRuntimeTypeWrapper.read(TypeAdapterRuntimeTypeWrapper.java:41) ~[gson-2.8.0.jar:?]
	at com.google.gson.internal.bind.ArrayTypeAdapter.read(ArrayTypeAdapter.java:72) ~[gson-2.8.0.jar:?]
	at com.google.gson.Gson.fromJson(Gson.java:887) ~[gson-2.8.0.jar:?]
	at com.google.gson.Gson.fromJson(Gson.java:952) ~[gson-2.8.0.jar:?]
	at com.google.gson.internal.bind.TreeTypeAdapter$GsonContextImpl.deserialize(TreeTypeAdapter.java:162) ~[gson-2.8.0.jar:?]
	at net.minecraft.util.JSONUtils.func_188179_a(SourceFile:440) ~[?:?]
	at net.minecraft.util.JSONUtils.func_188174_a(SourceFile:448) ~[?:?]
	at net.minecraft.loot.LootPool$Serializer.deserialize(LootPool.java:183) ~[?:?]
	at net.minecraft.loot.LootPool$Serializer.deserialize(LootPool.java:180) ~[?:?]
	at com.google.gson.internal.bind.TreeTypeAdapter.read(TreeTypeAdapter.java:69) ~[gson-2.8.0.jar:?]
	at com.google.gson.internal.bind.TypeAdapterRuntimeTypeWrapper.read(TypeAdapterRuntimeTypeWrapper.java:41) ~[gson-2.8.0.jar:?]
	at com.google.gson.internal.bind.ArrayTypeAdapter.read(ArrayTypeAdapter.java:72) ~[gson-2.8.0.jar:?]
	at com.google.gson.Gson.fromJson(Gson.java:887) ~[gson-2.8.0.jar:?]
	at com.google.gson.Gson.fromJson(Gson.java:952) ~[gson-2.8.0.jar:?]
	at com.google.gson.internal.bind.TreeTypeAdapter$GsonContextImpl.deserialize(TreeTypeAdapter.java:162) ~[gson-2.8.0.jar:?]
	at net.minecraft.util.JSONUtils.func_188179_a(SourceFile:440) ~[?:?]
	at net.minecraft.util.JSONUtils.func_188177_a(SourceFile:456) ~[?:?]
	at net.minecraft.loot.LootTable$Serializer.deserialize(LootTable.java:252) ~[?:?]
	at net.minecraft.loot.LootTable$Serializer.deserialize(LootTable.java:249) ~[?:?]
	at com.google.gson.internal.bind.TreeTypeAdapter.read(TreeTypeAdapter.java:69) ~[gson-2.8.0.jar:?]
	at com.google.gson.Gson.fromJson(Gson.java:887) ~[gson-2.8.0.jar:?]
	at com.google.gson.Gson.fromJson(Gson.java:952) ~[gson-2.8.0.jar:?]
	at com.google.gson.Gson.fromJson(Gson.java:925) ~[gson-2.8.0.jar:?]
	at net.minecraftforge.common.ForgeHooks.loadLootTable(ForgeHooks.java:888) ~[?:?]
	at net.minecraft.loot.LootTableManager.lambda$apply$0(LootTableManager.java:40) [?:?]
	at net.minecraft.loot.LootTableManager$$Lambda$14065/295727300.accept(Unknown Source) [?:?]
	at java.util.HashMap.forEach(HashMap.java:1280) [?:1.8.0_51]
	at net.minecraft.loot.LootTableManager.func_212853_a_(LootTableManager.java:38) [?:?]
	at net.minecraft.loot.LootTableManager.func_212853_a_(LootTableManager.java:16) [?:?]
	at net.minecraft.client.resources.ReloadListener.func_215269_a(SourceFile:13) [?:?]
	at net.minecraft.client.resources.ReloadListener$$Lambda$9873/1436560249.accept(Unknown Source) [?:?]
	at java.util.concurrent.CompletableFuture.uniAccept(CompletableFuture.java:656) [?:1.8.0_51]
	at java.util.concurrent.CompletableFuture$UniAccept.tryFire(CompletableFuture.java:632) [?:1.8.0_51]
	at java.util.concurrent.CompletableFuture$Completion.run(CompletableFuture.java:442) [?:1.8.0_51]
	at net.minecraft.resources.AsyncReloader.func_219557_a(SourceFile:71) [?:?]
	at net.minecraft.resources.AsyncReloader$$Lambda$10018/707432592.run(Unknown Source) [?:?]
	at net.minecraft.util.concurrent.ThreadTaskExecutor.func_213166_h(ThreadTaskExecutor.java:191) [?:?]
	at net.minecraft.util.concurrent.RecursiveEventLoop.func_213166_h(SourceFile:23) [?:?]
	at net.minecraft.util.concurrent.ThreadTaskExecutor.func_213168_p(ThreadTaskExecutor.java:153) [?:?]
	at net.minecraft.util.concurrent.ThreadTaskExecutor.func_213161_c(ThreadTaskExecutor.java:169) [?:?]
	at net.minecraft.client.Minecraft.func_238189_a_(Minecraft.java:1865) [?:?]
	at net.minecraft.client.Minecraft.loadWorld(Minecraft.java:1714) [?:?]
	at net.minecraft.client.Minecraft.func_238192_a_(Minecraft.java:1687) [?:?]
	at net.minecraft.client.gui.screen.CreateWorldScreen.func_195352_j(CreateWorldScreen.java:260) [?:?]
	at net.minecraft.client.gui.screen.CreateWorldScreen.lambda$init$11(CreateWorldScreen.java:205) [?:?]
	at net.minecraft.client.gui.screen.CreateWorldScreen$$Lambda$12951/1871004871.onPress(Unknown Source) [?:?]
	at net.minecraft.client.gui.widget.button.Button.func_230930_b_(SourceFile:33) [?:?]
	at net.minecraft.client.gui.widget.button.AbstractButton.func_230982_a_(SourceFile:16) [?:?]
	at net.minecraft.client.gui.widget.Widget.func_231044_a_(Widget.java:136) [?:?]
	at net.minecraft.client.gui.INestedGuiEventHandler.func_231044_a_(SourceFile:27) [?:?]
	at net.minecraft.client.MouseHelper.func_198033_b(MouseHelper.java:87) [?:?]
	at net.minecraft.client.MouseHelper$$Lambda$12646/468309489.run(Unknown Source) [?:?]
	at net.minecraft.client.gui.screen.Screen.func_231153_a_(Screen.java:427) [?:?]
	at net.minecraft.client.MouseHelper.func_198023_a(MouseHelper.java:85) [?:?]
	at net.minecraft.client.MouseHelper.func_228030_c_(MouseHelper.java:181) [?:?]
	at net.minecraft.client.MouseHelper$$Lambda$12645/1510532588.run(Unknown Source) [?:?]
	at net.minecraft.util.concurrent.ThreadTaskExecutor.execute(ThreadTaskExecutor.java:106) [?:?]
	at net.minecraft.client.MouseHelper.func_228028_b_(MouseHelper.java:180) [?:?]
	at net.minecraft.client.MouseHelper$$Lambda$9851/1244357368.invoke(Unknown Source) [?:?]
	at org.lwjgl.glfw.GLFWMouseButtonCallbackI.callback(GLFWMouseButtonCallbackI.java:36) [lwjgl-glfw-3.2.2.jar:build 10]
	at org.lwjgl.system.JNI.invokeV(Native Method) ~[lwjgl-3.2.2.jar:build 10]
	at org.lwjgl.glfw.GLFW.glfwPollEvents(GLFW.java:3101) [lwjgl-glfw-3.2.2.jar:build 10]
	at com.mojang.blaze3d.systems.RenderSystem.flipFrame(SourceFile:102) [?:?]
	at net.minecraft.client.MainWindow.func_227802_e_(MainWindow.java:398) [?:?]
	at net.minecraft.client.Minecraft.func_195542_b(Minecraft.java:997) [?:?]
	at net.minecraft.client.Minecraft.func_99999_d(Minecraft.java:607) [?:?]
	at net.minecraft.client.main.Main.main(Main.java:184) [?:?]
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) ~[?:1.8.0_51]
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) ~[?:1.8.0_51]
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) ~[?:1.8.0_51]
	at java.lang.reflect.Method.invoke(Method.java:497) ~[?:1.8.0_51]
	at net.minecraftforge.fml.loading.FMLClientLaunchProvider.lambda$launchService$0(FMLClientLaunchProvider.java:51) [forge-1.16.5-36.2.33.jar:36.2]
	at net.minecraftforge.fml.loading.FMLClientLaunchProvider$$Lambda$496/1753746465.call(Unknown Source) [forge-1.16.5-36.2.33.jar:36.2]
	at cpw.mods.modlauncher.LaunchServiceHandlerDecorator.launch(LaunchServiceHandlerDecorator.java:37) [modlauncher-8.1.3.jar:?]
	at cpw.mods.modlauncher.LaunchServiceHandler.launch(LaunchServiceHandler.java:54) [modlauncher-8.1.3.jar:?]
	at cpw.mods.modlauncher.LaunchServiceHandler.launch(LaunchServiceHandler.java:72) [modlauncher-8.1.3.jar:?]
	at cpw.mods.modlauncher.Launcher.run(Launcher.java:82) [modlauncher-8.1.3.jar:?]
	at cpw.mods.modlauncher.Launcher.main(Launcher.java:66) [modlauncher-8.1.3.jar:?]
[12:53:52] [main/ERROR]: Couldn't parse loot table iceandfire:blocks/allthemodium_pile
java.lang.IllegalArgumentException: Can't find block iceandfire:allthemodium_pile
	at net.minecraft.loot.conditions.BlockStateProperty$Serializer.func_227569_a_(SourceFile:79) ~[?:?]
	at net.minecraft.loot.conditions.BlockStateProperty$Serializer$$Lambda$14069/628376296.get(Unknown Source) ~[?:?]
	at java.util.Optional.orElseThrow(Optional.java:290) ~[?:1.8.0_51]
	at net.minecraft.loot.conditions.BlockStateProperty$Serializer.func_230423_a_(SourceFile:79) ~[?:?]
	at net.minecraft.loot.conditions.BlockStateProperty$Serializer.func_230423_a_(SourceFile:68) ~[?:?]
	at net.minecraft.loot.LootTypesManager$Serializer.deserialize(SourceFile:83) ~[?:?]
	at com.google.gson.internal.bind.TreeTypeAdapter.read(TreeTypeAdapter.java:69) ~[gson-2.8.0.jar:?]
	at com.google.gson.internal.bind.TypeAdapterRuntimeTypeWrapper.read(TypeAdapterRuntimeTypeWrapper.java:41) ~[gson-2.8.0.jar:?]
	at com.google.gson.internal.bind.ArrayTypeAdapter.read(ArrayTypeAdapter.java:72) ~[gson-2.8.0.jar:?]
	at com.google.gson.Gson.fromJson(Gson.java:887) ~[gson-2.8.0.jar:?]
	at com.google.gson.Gson.fromJson(Gson.java:952) ~[gson-2.8.0.jar:?]
	at com.google.gson.internal.bind.TreeTypeAdapter$GsonContextImpl.deserialize(TreeTypeAdapter.java:162) ~[gson-2.8.0.jar:?]
	at net.minecraft.util.JSONUtils.func_188179_a(SourceFile:440) ~[?:?]
	at net.minecraft.util.JSONUtils.func_188177_a(SourceFile:456) ~[?:?]
	at net.minecraft.loot.LootEntry$Serializer.func_230423_a_(SourceFile:85) ~[?:?]
	at net.minecraft.loot.LootEntry$Serializer.func_230423_a_(SourceFile:74) ~[?:?]
	at net.minecraft.loot.LootTypesManager$Serializer.deserialize(SourceFile:83) ~[?:?]
	at com.google.gson.internal.bind.TreeTypeAdapter.read(TreeTypeAdapter.java:69) ~[gson-2.8.0.jar:?]
	at com.google.gson.internal.bind.TypeAdapterRuntimeTypeWrapper.read(TypeAdapterRuntimeTypeWrapper.java:41) ~[gson-2.8.0.jar:?]
	at com.google.gson.internal.bind.ArrayTypeAdapter.read(ArrayTypeAdapter.java:72) ~[gson-2.8.0.jar:?]
	at com.google.gson.Gson.fromJson(Gson.java:887) ~[gson-2.8.0.jar:?]
	at com.google.gson.Gson.fromJson(Gson.java:952) ~[gson-2.8.0.jar:?]
	at com.google.gson.internal.bind.TreeTypeAdapter$GsonContextImpl.deserialize(TreeTypeAdapter.java:162) ~[gson-2.8.0.jar:?]
	at net.minecraft.util.JSONUtils.func_188179_a(SourceFile:440) ~[?:?]
	at net.minecraft.util.JSONUtils.func_188174_a(SourceFile:448) ~[?:?]
	at net.minecraft.loot.LootPool$Serializer.deserialize(LootPool.java:183) ~[?:?]
	at net.minecraft.loot.LootPool$Serializer.deserialize(LootPool.java:180) ~[?:?]
	at com.google.gson.internal.bind.TreeTypeAdapter.read(TreeTypeAdapter.java:69) ~[gson-2.8.0.jar:?]
	at com.google.gson.internal.bind.TypeAdapterRuntimeTypeWrapper.read(TypeAdapterRuntimeTypeWrapper.java:41) ~[gson-2.8.0.jar:?]
	at com.google.gson.internal.bind.ArrayTypeAdapter.read(ArrayTypeAdapter.java:72) ~[gson-2.8.0.jar:?]
	at com.google.gson.Gson.fromJson(Gson.java:887) ~[gson-2.8.0.jar:?]
	at com.google.gson.Gson.fromJson(Gson.java:952) ~[gson-2.8.0.jar:?]
	at com.google.gson.internal.bind.TreeTypeAdapter$GsonContextImpl.deserialize(TreeTypeAdapter.java:162) ~[gson-2.8.0.jar:?]
	at net.minecraft.util.JSONUtils.func_188179_a(SourceFile:440) ~[?:?]
	at net.minecraft.util.JSONUtils.func_188177_a(SourceFile:456) ~[?:?]
	at net.minecraft.loot.LootTable$Serializer.deserialize(LootTable.java:252) ~[?:?]
	at net.minecraft.loot.LootTable$Serializer.deserialize(LootTable.java:249) ~[?:?]
	at com.google.gson.internal.bind.TreeTypeAdapter.read(TreeTypeAdapter.java:69) ~[gson-2.8.0.jar:?]
	at com.google.gson.Gson.fromJson(Gson.java:887) ~[gson-2.8.0.jar:?]
	at com.google.gson.Gson.fromJson(Gson.java:952) ~[gson-2.8.0.jar:?]
	at com.google.gson.Gson.fromJson(Gson.java:925) ~[gson-2.8.0.jar:?]
	at net.minecraftforge.common.ForgeHooks.loadLootTable(ForgeHooks.java:888) ~[?:?]
	at net.minecraft.loot.LootTableManager.lambda$apply$0(LootTableManager.java:40) [?:?]
	at net.minecraft.loot.LootTableManager$$Lambda$14065/295727300.accept(Unknown Source) [?:?]
	at java.util.HashMap.forEach(HashMap.java:1280) [?:1.8.0_51]
	at net.minecraft.loot.LootTableManager.func_212853_a_(LootTableManager.java:38) [?:?]
	at net.minecraft.loot.LootTableManager.func_212853_a_(LootTableManager.java:16) [?:?]
	at net.minecraft.client.resources.ReloadListener.func_215269_a(SourceFile:13) [?:?]
	at net.minecraft.client.resources.ReloadListener$$Lambda$9873/1436560249.accept(Unknown Source) [?:?]
	at java.util.concurrent.CompletableFuture.uniAccept(CompletableFuture.java:656) [?:1.8.0_51]
	at java.util.concurrent.CompletableFuture$UniAccept.tryFire(CompletableFuture.java:632) [?:1.8.0_51]
	at java.util.concurrent.CompletableFuture$Completion.run(CompletableFuture.java:442) [?:1.8.0_51]
	at net.minecraft.resources.AsyncReloader.func_219557_a(SourceFile:71) [?:?]
	at net.minecraft.resources.AsyncReloader$$Lambda$10018/707432592.run(Unknown Source) [?:?]
	at net.minecraft.util.concurrent.ThreadTaskExecutor.func_213166_h(ThreadTaskExecutor.java:191) [?:?]
	at net.minecraft.util.concurrent.RecursiveEventLoop.func_213166_h(SourceFile:23) [?:?]
	at net.minecraft.util.concurrent.ThreadTaskExecutor.func_213168_p(ThreadTaskExecutor.java:153) [?:?]
	at net.minecraft.util.concurrent.ThreadTaskExecutor.func_213161_c(ThreadTaskExecutor.java:169) [?:?]
	at net.minecraft.client.Minecraft.func_238189_a_(Minecraft.java:1865) [?:?]
	at net.minecraft.client.Minecraft.loadWorld(Minecraft.java:1714) [?:?]
	at net.minecraft.client.Minecraft.func_238192_a_(Minecraft.java:1687) [?:?]
	at net.minecraft.client.gui.screen.CreateWorldScreen.func_195352_j(CreateWorldScreen.java:260) [?:?]
	at net.minecraft.client.gui.screen.CreateWorldScreen.lambda$init$11(CreateWorldScreen.java:205) [?:?]
	at net.minecraft.client.gui.screen.CreateWorldScreen$$Lambda$12951/1871004871.onPress(Unknown Source) [?:?]
	at net.minecraft.client.gui.widget.button.Button.func_230930_b_(SourceFile:33) [?:?]
	at net.minecraft.client.gui.widget.button.AbstractButton.func_230982_a_(SourceFile:16) [?:?]
	at net.minecraft.client.gui.widget.Widget.func_231044_a_(Widget.java:136) [?:?]
	at net.minecraft.client.gui.INestedGuiEventHandler.func_231044_a_(SourceFile:27) [?:?]
	at net.minecraft.client.MouseHelper.func_198033_b(MouseHelper.java:87) [?:?]
	at net.minecraft.client.MouseHelper$$Lambda$12646/468309489.run(Unknown Source) [?:?]
	at net.minecraft.client.gui.screen.Screen.func_231153_a_(Screen.java:427) [?:?]
	at net.minecraft.client.MouseHelper.func_198023_a(MouseHelper.java:85) [?:?]
	at net.minecraft.client.MouseHelper.func_228030_c_(MouseHelper.java:181) [?:?]
	at net.minecraft.client.MouseHelper$$Lambda$12645/1510532588.run(Unknown Source) [?:?]
	at net.minecraft.util.concurrent.ThreadTaskExecutor.execute(ThreadTaskExecutor.java:106) [?:?]
	at net.minecraft.client.MouseHelper.func_228028_b_(MouseHelper.java:180) [?:?]
	at net.minecraft.client.MouseHelper$$Lambda$9851/1244357368.invoke(Unknown Source) [?:?]
	at org.lwjgl.glfw.GLFWMouseButtonCallbackI.callback(GLFWMouseButtonCallbackI.java:36) [lwjgl-glfw-3.2.2.jar:build 10]
	at org.lwjgl.system.JNI.invokeV(Native Method) ~[lwjgl-3.2.2.jar:build 10]
	at org.lwjgl.glfw.GLFW.glfwPollEvents(GLFW.java:3101) [lwjgl-glfw-3.2.2.jar:build 10]
	at com.mojang.blaze3d.systems.RenderSystem.flipFrame(SourceFile:102) [?:?]
	at net.minecraft.client.MainWindow.func_227802_e_(MainWindow.java:398) [?:?]
	at net.minecraft.client.Minecraft.func_195542_b(Minecraft.java:997) [?:?]
	at net.minecraft.client.Minecraft.func_99999_d(Minecraft.java:607) [?:?]
	at net.minecraft.client.main.Main.main(Main.java:184) [?:?]
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) ~[?:1.8.0_51]
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) ~[?:1.8.0_51]
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) ~[?:1.8.0_51]
	at java.lang.reflect.Method.invoke(Method.java:497) ~[?:1.8.0_51]
	at net.minecraftforge.fml.loading.FMLClientLaunchProvider.lambda$launchService$0(FMLClientLaunchProvider.java:51) [forge-1.16.5-36.2.33.jar:36.2]
	at net.minecraftforge.fml.loading.FMLClientLaunchProvider$$Lambda$496/1753746465.call(Unknown Source) [forge-1.16.5-36.2.33.jar:36.2]
	at cpw.mods.modlauncher.LaunchServiceHandlerDecorator.launch(LaunchServiceHandlerDecorator.java:37) [modlauncher-8.1.3.jar:?]
	at cpw.mods.modlauncher.LaunchServiceHandler.launch(LaunchServiceHandler.java:54) [modlauncher-8.1.3.jar:?]
	at cpw.mods.modlauncher.LaunchServiceHandler.launch(LaunchServiceHandler.java:72) [modlauncher-8.1.3.jar:?]
	at cpw.mods.modlauncher.Launcher.run(Launcher.java:82) [modlauncher-8.1.3.jar:?]
	at cpw.mods.modlauncher.Launcher.main(Launcher.java:66) [modlauncher-8.1.3.jar:?]
[12:53:53] [main/INFO]: Loaded 3473 advancements
[12:53:53] [main/INFO]: Loading data...
[12:53:55] [main/INFO]: Done.
[12:53:55] [main/INFO]: CraftTweaker reload starting!
[12:53:56] [main/INFO]: CraftTweaker reload complete!
[12:54:08] [main/INFO]: Environment: authHost='https://authserver.mojang.com', accountsHost='https://api.mojang.com', sessionHost='https://sessionserver.mojang.com', servicesHost='https://api.minecraftservices.com', name='PROD'
[12:54:08] [Server thread/INFO]: Starting integrated minecraft server version 1.16.5
[12:54:08] [Server thread/INFO]: Generating keypair
[12:54:09] [Server thread/WARN]: Configuration file C:\Users\kaues\AppData\Roaming\.minecraft\versions\Ender Tech\saves\Novo mundo (2)\serverconfig\cgm-server.toml is not correct. Correcting
[12:54:09] [Server thread/WARN]: Incorrect key server was corrected from null to its default, SimpleCommentedConfig:{}. 
[12:54:09] [Server thread/WARN]: Incorrect key server.grenade was corrected from null to its default, SimpleCommentedConfig:{}. 
[12:54:09] [Server thread/WARN]: Incorrect key server.grenade.alphaOverlay was corrected from null to its default, 255. 
[12:54:09] [Server thread/WARN]: Incorrect key server.grenade.alphaFadeThreshold was corrected from null to its default, 40. 
[12:54:09] [Server thread/WARN]: Incorrect key server.grenade.soundPercentage was corrected from null to its default, 0.05. 
[12:54:09] [Server thread/WARN]: Incorrect key server.grenade.soundFadeThreshold was corrected from null to its default, 90. 
[12:54:09] [Server thread/WARN]: Incorrect key server.grenade.ringVolume was corrected from null to its default, 1.0. 
[12:54:09] [Server thread/WARN]: Incorrect key server.audio was corrected from null to its default, SimpleCommentedConfig:{}. 
[12:54:09] [Server thread/WARN]: Incorrect key server.audio.gunShotMaxDistance was corrected from null to its default, 100.0. 
[12:54:09] [Server thread/WARN]: Incorrect key server.audio.reloadMaxDistance was corrected from null to its default, 24.0. 
[12:54:09] [Server thread/WARN]: Incorrect key server.enableCameraRecoil was corrected from null to its default, true. 
[12:54:09] [Server thread/WARN]: Configuration file C:\Users\kaues\AppData\Roaming\.minecraft\versions\Ender Tech\saves\Novo mundo (2)\serverconfig\journeymap-server.toml is not correct. Correcting
[12:54:09] [Server thread/WARN]: Incorrect key admins was corrected from null to its default, SimpleCommentedConfig:{}. 
[12:54:09] [Server thread/WARN]: Incorrect key admins.opAccess was corrected from null to its default, true. 
[12:54:09] [Server thread/WARN]: Incorrect key admins.serverAdmins was corrected from null to its default, [mysticdrew, 79f597fe-2877-4ecb-acdf-8c58cc1854ca]. 
[12:54:09] [Server thread/INFO]: Loading JourneyMap Forge Configs
[12:54:09] [Server thread/WARN]: Configuration file C:\Users\kaues\AppData\Roaming\.minecraft\versions\Ender Tech\saves\Novo mundo (2)\serverconfig\compactmachines-server.toml is not correct. Correcting
[12:54:09] [Server thread/WARN]: Incorrect key machines was corrected from null to its default, SimpleCommentedConfig:{}. 
[12:54:09] [Server thread/WARN]: Incorrect key machines.breakHandling was corrected from null to its default, UNBREAKABLE. 
[12:54:09] [Server thread/WARN]: Incorrect key machines.chunkloading was corrected from null to its default, true. 
[12:54:09] [Server thread/WARN]: Incorrect key machines.floor was corrected from null to its default, 40. 
[12:54:09] [Server thread/WARN]: Configuration file C:\Users\kaues\AppData\Roaming\.minecraft\versions\Ender Tech\saves\Novo mundo (2)\serverconfig\mahoutsukai-server.toml is not correct. Correcting
[12:54:09] [Server thread/WARN]: Incorrect key boundary was corrected from null to its default, SimpleCommentedConfig:{}. 
[12:54:09] [Server thread/WARN]: Incorrect key boundary.ALARM_BARRIER_MANA_COST was corrected from null to its default, 1. 
[12:54:09] [Server thread/WARN]: Incorrect key boundary.ALARM_BARRIER_MANA_CYCLE was corrected from null to its default, 10. 
[12:54:09] [Server thread/WARN]: Incorrect key boundary.ALARM_BARRIER_RADIUS was corrected from null to its default, 10. 
[12:54:09] [Server thread/WARN]: Incorrect key boundary.ALARM_BARRIER_CYCLE was corrected from null to its default, 20. 
[12:54:09] [Server thread/WARN]: Incorrect key boundary.DISPLACEMENT_BARRIER_MANA_COST was corrected from null to its default, 1. 
[12:54:09] [Server thread/WARN]: Incorrect key boundary.DISPLACEMENT_BARRIER_MANA_CYCLE was corrected from null to its default, 5. 
[12:54:09] [Server thread/WARN]: Incorrect key boundary.DISPLACEMENT_BARRIER_RADIUS was corrected from null to its default, 11. 
[12:54:09] [Server thread/WARN]: Incorrect key boundary.DISPLACEMENT_BARRIER_CYCLE was corrected from null to its default, 4. 
[12:54:09] [Server thread/WARN]: Incorrect key boundary.DRAIN_LIFE_BARRIER_MANA_COST was corrected from null to its default, 5. 
[12:54:09] [Server thread/WARN]: Incorrect key boundary.DRAIN_LIFE_BARRIER_MANA_CYCLE was corrected from null to its default, 1. 
[12:54:09] [Server thread/WARN]: Incorrect key boundary.DRAIN_LIFE_BARRIER_RADIUS was corrected from null to its default, 10. 
[12:54:09] [Server thread/WARN]: Incorrect key boundary.DRAIN_LIFE_BARRIER_CYCLE was corrected from null to its default, 20. 
[12:54:09] [Server thread/WARN]: Incorrect key boundary.DRAIN_LIFE_IGNORE_HUNGER was corrected from null to its default, false. 
[12:54:09] [Server thread/WARN]: Incorrect key boundary.DRAIN_LIFE_MANA_REGEN was corrected from null to its default, 1. 
[12:54:09] [Server thread/WARN]: Incorrect key boundary.DRAIN_LIFE_HEAL_FACTOR was corrected from null to its default, 0.5. 
[12:54:09] [Server thread/WARN]: Incorrect key boundary.DRAIN_LIFE_DAMAGE was corrected from null to its default, 2.0. 
[12:54:09] [Server thread/WARN]: Incorrect key boundary.DRAIN_LIFE_PUNISH_RESIST was corrected from null to its default, 1.8. 
[12:54:09] [Server thread/WARN]: Incorrect key boundary.DRAIN_LIFE_ENTITY_BLACKLIST was corrected from null to its default, []. 
[12:54:09] [Server thread/WARN]: Incorrect key boundary.GRAVITY_BARRIER_MANA_COST was corrected from null to its default, 1. 
[12:54:09] [Server thread/WARN]: Incorrect key boundary.GRAVITY_BARRIER_MANA_CYCLE was corrected from null to its default, 2. 
[12:54:09] [Server thread/WARN]: Incorrect key boundary.GRAVITY_BARRIER_RADIUS was corrected from null to its default, 10. 
[12:54:09] [Server thread/WARN]: Incorrect key boundary.GRAVITY_BARRIER_CYCLE was corrected from null to its default, 1. 
[12:54:09] [Server thread/WARN]: Incorrect key boundary.ENCLOSURE_BARRIER_MANA_COST was corrected from null to its default, 20. 
[12:54:09] [Server thread/WARN]: Incorrect key boundary.ENCLOSURE_BARRIER_CYCLE was corrected from null to its default, 20. 
[12:54:09] [Server thread/WARN]: Incorrect key boundary.ENCLOSURE_BARRIER_RADIUS was corrected from null to its default, 5. 
[12:54:09] [Server thread/WARN]: Incorrect key boundary.TANGIBLE_BARRIER_MANA_COST was corrected from null to its default, 1. 
[12:54:09] [Server thread/WARN]: Incorrect key boundary.TANGIBLE_BARRIER_MANA_CYCLE was corrected from null to its default, 3. 
[12:54:09] [Server thread/WARN]: Incorrect key boundary.TANGIBLE_BARRIER_RADIUS was corrected from null to its default, 10. 
[12:54:09] [Server thread/WARN]: Incorrect key boundary.TANGIBLE_BARRIER_CYCLE was corrected from null to its default, 20. 
[12:54:09] [Server thread/WARN]: Incorrect key boundary.ALARM_ACTION_BAR_MESSAGES was corrected from null to its default, true. 
[12:54:09] [Server thread/WARN]: Incorrect key displacement was corrected from null to its default, SimpleCommentedConfig:{}. 
[12:54:09] [Server thread/WARN]: Incorrect key displacement.ASCENSION_BLOCK_CYCLE was corrected from null to its default, 4. 
[12:54:09] [Server thread/WARN]: Incorrect key displacement.ASCENSION_SCROLL_MANA_COST was corrected from null to its default, 30. 
[12:54:09] [Server thread/WARN]: Incorrect key displacement.EQUIVALENT_DISPLACEMENT_BLOCK_CYCLE was corrected from null to its default, 4. 
[12:54:09] [Server thread/WARN]: Incorrect key displacement.EQUIVALENT_DISPLACEMENT_RECEIVE_COOLDOWN was corrected from null to its default, 15. 
[12:54:09] [Server thread/WARN]: Incorrect key displacement.EQUIVALENT_DISPLACEMENT_MANA_COST was corrected from null to its default, 60. 
[12:54:09] [Server thread/WARN]: Incorrect key displacement.EQUIVALENT_DISPLACEMENT_MAX_DISTANCE was corrected from null to its default, -1.0. 
[12:54:09] [Server thread/WARN]: Incorrect key displacement.EQUIVALENT_DISPLACEMENT_DIMENSIONAL_TRAVEL was corrected from null to its default, true. 
[12:54:09] [Server thread/WARN]: Incorrect key displacement.MENTAL_DISPLACEMENT_MANA_COST was corrected from null to its default, 300. 
[12:54:09] [Server thread/WARN]: Incorrect key displacement.MENTAL_DISPLACEMENT_RANGE was corrected from null to its default, 20. 
[12:54:09] [Server thread/WARN]: Incorrect key displacement.PROJECTILE_DISPLACEMENT_MANA_COST was corrected from null to its default, 50. 
[12:54:09] [Server thread/WARN]: Incorrect key displacement.ORDERED_DISPLACEMENT_BLOCK_CYCLE was corrected from null to its default, 4. 
[12:54:09] [Server thread/WARN]: Incorrect key displacement.ORDERED_DISPLACEMENT_RECEIVE_COOLDOWN was corrected from null to its default, 15. 
[12:54:09] [Server thread/WARN]: Incorrect key displacement.ORDERED_DISPLACEMENT_MANA_COST was corrected from null to its default, 40. 
[12:54:09] [Server thread/WARN]: Incorrect key displacement.ORDERED_DISPLACEMENT_RADIUS was corrected from null to its default, 20. 
[12:54:09] [Server thread/WARN]: Incorrect key displacement.PROTECTIVE_DISPLACEMENT_MANA_COST was corrected from null to its default, 50. 
[12:54:09] [Server thread/WARN]: Incorrect key displacement.SCRYING_MANA_COST was corrected from null to its default, 50. 
[12:54:09] [Server thread/WARN]: Incorrect key displacement.SCRYING_DURATION was corrected from null to its default, 1200. 
[12:54:09] [Server thread/WARN]: Incorrect key displacement.SCRYING_BLOCK_CYCLE was corrected from null to its default, 4. 
[12:54:09] [Server thread/WARN]: Incorrect key projection was corrected from null to its default, SimpleCommentedConfig:{}. 
[12:54:09] [Server thread/WARN]: Incorrect key projection.WEAPON_SHOOTER_MANA_COST was corrected from null to its default, 100. 
[12:54:09] [Server thread/WARN]: Incorrect key projection.WEAPON_SHOOTER_PROJECTILE_SPEED was corrected from null to its default, 3.0. 
[12:54:09] [Server thread/WARN]: Incorrect key projection.WEAPON_SHOOTER_DAMAGE_MULTIPLIER was corrected from null to its default, 1.0. 
[12:54:09] [Server thread/WARN]: Incorrect key projection.WEAPON_SHOOTER_DURABILITY was corrected from null to its default, 30. 
[12:54:09] [Server thread/WARN]: Incorrect key projection.TREASURY_PROJECTION_SCROLL_MANA_COST was corrected from null to its default, 1000. 
[12:54:09] [Server thread/WARN]: Incorrect key projection.TREASURY_PROJECTION_GAUNTLET_MANA_COST was corrected from null to its default, 120. 
[12:54:09] [Server thread/WARN]: Incorrect key projection.TREASURY_PROJECTION_COOLDOWN was corrected from null to its default, 10. 
[12:54:09] [Server thread/WARN]: Incorrect key projection.TREASURY_PROJECTION_CHAINS_MANA_COST was corrected from null to its default, 120. 
[12:54:09] [Server thread/WARN]: Incorrect key projection.TREASURY_PROJECTION_CHAINS_COOLDOWN was corrected from null to its default, 10. 
[12:54:09] [Server thread/WARN]: Incorrect key projection.TREASURY_PROJECTION_CHAINS_COUNT was corrected from null to its default, 16. 
[12:54:09] [Server thread/WARN]: Incorrect key projection.TREASURY_PROJECTION_CHAINS_DAMAGE was corrected from null to its default, 1.0. 
[12:54:09] [Server thread/WARN]: Incorrect key projection.TREASURY_PROJECTION_AOE_MANA_COST was corrected from null to its default, 120. 
[12:54:09] [Server thread/WARN]: Incorrect key projection.TREASURY_PROJECTION_AOE_COOLDOWN was corrected from null to its default, 4. 
[12:54:09] [Server thread/WARN]: Incorrect key projection.TREASURY_PROJECTION_DISTANCE was corrected from null to its default, 20. 
[12:54:09] [Server thread/WARN]: Incorrect key projection.TREASURY_PROJECTION_MIN_DISTANCE was corrected from null to its default, 8. 
[12:54:09] [Server thread/WARN]: Incorrect key projection.TREASURY_PROJECTION_SPEED was corrected from null to its default, 30.0. 
[12:54:09] [Server thread/WARN]: Incorrect key projection.TREASURY_PROJECTION_ALLOW_ALL was corrected from null to its default, false. 
[12:54:09] [Server thread/WARN]: Incorrect key projection.TREASURY_PROJECTION_DENY_ALL was corrected from null to its default, false. 
[12:54:09] [Server thread/WARN]: Incorrect key projection.TREASURY_PROJECTION_DESPAWN_AFTER_LAND was corrected from null to its default, false. 
[12:54:09] [Server thread/WARN]: Incorrect key projection.TREASURY_PROJECTION_WHITELIST was corrected from null to its default, []. 
[12:54:09] [Server thread/WARN]: Incorrect key projection.TREASURY_PROJECTION_BLACKLIST was corrected from null to its default, []. 
[12:54:09] [Server thread/WARN]: Incorrect key projection.TREASURY_PROJECTION_SPEED_INCREASE_PER_SWORD was corrected from null to its default, 1.0. 
[12:54:09] [Server thread/WARN]: Incorrect key projection.TREASURY_PROJECTION_SPEED_MIN was corrected from null to its default, 10.0. 
[12:54:09] [Server thread/WARN]: Incorrect key projection.TREASURY_PROJECTION_COOLDOWN_INCREASE_PER_SWORD was corrected from null to its default, 1.0. 
[12:54:09] [Server thread/WARN]: Incorrect key projection.TREASURY_PROJECTION_COOLDOWN_MIN was corrected from null to its default, 3.0. 
[12:54:09] [Server thread/WARN]: Incorrect key projection.TREASURY_PROJECTION_AOE_MAX_SPAWNS was corrected from null to its default, 3.0. 
[12:54:09] [Server thread/WARN]: Incorrect key projection.TREASURY_PROJECTION_AOE_SWORDS_PER_SPAWN was corrected from null to its default, 5.0. 
[12:54:09] [Server thread/WARN]: Incorrect key projection.TREASURY_PROJECTION_INCREASE_REQUIRES_UNIQUE was corrected from null to its default, true. 
[12:54:09] [Server thread/WARN]: Incorrect key projection.TREASURY_PROJECTION_ENDER_CHEST_ONLY was corrected from null to its default, false. 
[12:54:09] [Server thread/WARN]: Incorrect key projection.STRENGTHENING_MANA_COST was corrected from null to its default, 50. 
[12:54:09] [Server thread/WARN]: Incorrect key projection.STRENGTHENING_ITEM_SPAWN_BLACKLIST was corrected from null to its default, []. 
[12:54:09] [Server thread/WARN]: Incorrect key projection.STRENGTHENING_ITEM_BLACKLIST was corrected from null to its default, []. 
[12:54:09] [Server thread/WARN]: Incorrect key projection.STRENGTHENING_CAP was corrected from null to its default, 50. 
[12:54:09] [Server thread/WARN]: Incorrect key projection.MARBLE_MANA_COST was corrected from null to its default, 4000. 
[12:54:09] [Server thread/WARN]: Incorrect key projection.MARBLE_DIMENSION was corrected from null to its default, -1. 
[12:54:09] [Server thread/WARN]: Incorrect key projection.MARBLE_DIMENSION_DURABILITY was corrected from null to its default, 3. 
[12:54:09] [Server thread/WARN]: Incorrect key projection.MARBLE_DIMENSION_SPAWN_RATE was corrected from null to its default, 13. 
[12:54:09] [Server thread/WARN]: Incorrect key projection.MARBLE_DIMENSION_SPAWN_CHANCE was corrected from null to its default, 0.8. 
[12:54:09] [Server thread/WARN]: Incorrect key projection.MARBLE_SWORD_SPAWN_LIST was corrected from null to its default, [minecraft:iron_sword, minecraft:diamond_sword, minecraft:stone_sword]. 
[12:54:09] [Server thread/WARN]: Incorrect key projection.MARBLE_MOB_BLACKLIST was corrected from null to its default, []. 
[12:54:09] [Server thread/WARN]: Incorrect key projection.PROXIMITY_PROJECTION_MANA_COST was corrected from null to its default, 160. 
[12:54:09] [Server thread/WARN]: Incorrect key projection.PROXIMITY_PROJECTION_DURABILITY was corrected from null to its default, 30. 
[12:54:09] [Server thread/WARN]: Incorrect key projection.PROJECTION_MANA_COST was corrected from null to its default, 100. 
[12:54:09] [Server thread/WARN]: Incorrect key projection.PROJECTION_BLACKLIST was corrected from null to its default, []. 
[12:54:09] [Server thread/WARN]: Incorrect key projection.PROJECTION_IS_BLACKLIST was corrected from null to its default, true. 
[12:54:09] [Server thread/WARN]: Incorrect key projection.PROJECTION_ENCHANTMENT_BLACKLIST was corrected from null to its default, []. 
[12:54:09] [Server thread/WARN]: Incorrect key projection.PROJECTION_DURABILITY_FACTOR was corrected from null to its default, 5. 
[12:54:09] [Server thread/WARN]: Incorrect key projection.PROJECTION_DURABILITY_FLAT was corrected from null to its default, true. 
[12:54:09] [Server thread/WARN]: Incorrect key projection.PROJECTION_ANVIL_CANCEL was corrected from null to its default, false. 
[12:54:09] [Server thread/WARN]: Incorrect key projection.PROJECTION_EXPLICIT_WHITELIST was corrected from null to its default, []. 
[12:54:09] [Server thread/WARN]: Incorrect key projection.POWER_CONSOLIDATION_SWORD_MANA_COST was corrected from null to its default, 5000. 
[12:54:09] [Server thread/WARN]: Incorrect key projection.POWER_CONSOLIDATION_LAKE_MANA_COST was corrected from null to its default, 30. 
[12:54:09] [Server thread/WARN]: Incorrect key projection.POWER_CONSOLIDATION_LAKE_CYCLE was corrected from null to its default, 20. 
[12:54:09] [Server thread/WARN]: Incorrect key projection.POWER_CONSOLIDATION_LAKE_RADIUS was corrected from null to its default, 12. 
[12:54:09] [Server thread/WARN]: Incorrect key projection.POWER_CONSOLIDATION_LAKE_THRESHHOLD was corrected from null to its default, 150. 
[12:54:09] [Server thread/WARN]: Incorrect key projection.POWER_CONSOLIDATION_NERF_FACTOR was corrected from null to its default, 0.6. 
[12:54:09] [Server thread/WARN]: Incorrect key projection.POWER_CONSOLIDATION_FOG_RADIUS was corrected from null to its default, 8.0. 
[12:54:09] [Server thread/WARN]: Incorrect key projection.POWER_CONSOLIDATION_PULL_RADIUS was corrected from null to its default, 20. 
[12:54:09] [Server thread/WARN]: Incorrect key projection.POWER_CONSOLIDATION_SMITE_RADIUS was corrected from null to its default, 10. 
[12:54:09] [Server thread/WARN]: Incorrect key projection.POWER_CONSOLIDATION_DURABILITY was corrected from null to its default, 1000. 
[12:54:09] [Server thread/WARN]: Incorrect key projection.POWER_CONSOLIDATION_FEAR_RADIUS was corrected from null to its default, 15. 
[12:54:09] [Server thread/WARN]: Incorrect key projection.POWER_CONSOLIDATION_SWEEP_RADIUS was corrected from null to its default, 6. 
[12:54:09] [Server thread/WARN]: Incorrect key projection.POWER_CONSOLIDATION_ATTACK_CAP was corrected from null to its default, 5000000. 
[12:54:09] [Server thread/WARN]: Incorrect key projection.POWER_CONSOLIDATION_SWEEP_LOOK_RADIUS was corrected from null to its default, 3. 
[12:54:09] [Server thread/WARN]: Incorrect key projection.POWER_CONSOLIDATION_BLACKLIST was corrected from null to its default, [mahoutsukai:clarent, mahoutsukai:morgan]. 
[12:54:09] [Server thread/WARN]: Incorrect key projection.POWER_CONSOLIDATION_CALIBURN_BLACKLIST_TOGGLE was corrected from null to its default, true. 
[12:54:09] [Server thread/WARN]: Incorrect key projection.POWER_CONSOLIDATION_RETRO_FOG_FIX was corrected from null to its default, false. 
[12:54:09] [Server thread/WARN]: Incorrect key projection.POWER_CONSOLIDATION_FEAR_BLACKLIST was corrected from null to its default, []. 
[12:54:09] [Server thread/WARN]: Incorrect key projection.POWER_CONSOLIDATION_ENCHANT_BLACKLIST was corrected from null to its default, [minecraft:mending]. 
[12:54:09] [Server thread/WARN]: Incorrect key projection.POWER_CONSOLIDATION_TIERS was corrected from null to its default, [100.0, 150.0, 200.0, 250.0, 300.0, 350.0, 400.0, 500.0, 600.0, 700.0, 800.0, 950.0, 1100.0, 1251.0, 1452.0, 1653.0, 1904.0, 2155.0, 2457.0, 2809.0, 3211.0, 3664.0, 4167.0, 4721.0, 5325.0, 6030.0, 6836.0, 7742.0, 8749.0, 9857.0, 11116.0, 12528.0, 14141.0, 15956.0, 17972.0, 20240.0, 22812.0, 25736.0, 29013.0, 32694.0, 36829.0, 41518.0, 46763.0, 52663.0, 59320.0, 66834.0, 75306.0, 84838.0, 95580.0, 107634.0, 121251.0, 136584.0, 153833.0, 173251.0, 195141.0, 219755.0, 247495.0, 278716.0, 313871.0, 353465.0, 398053.0, 448290.0, 504832.0, 568536.0, 640260.0, 721014.0, 811957.0, 914349.0, 1029654.0, 1159535.0, 1305759.0, 1470444.0, 1655911.0, 1864731.0, 2099881.0, 2364689.0, 2662889.0, 2998717.0, 3376864.0, 3802727.0, 4282259.0, 4822269.0, 5000000.0]. 
[12:54:09] [Server thread/WARN]: Incorrect key projection.POWER_CONSOLIDATION_TIER_UPGRADE_ITEM was corrected from null to its default, [minecraft:nether_star]. 
[12:54:09] [Server thread/WARN]: Incorrect key projection.RHONGOMYNIAD_NERF_FACTOR was corrected from null to its default, 0.6. 
[12:54:09] [Server thread/WARN]: Incorrect key projection.RHONGOMYNIAD_SPEED_FACTOR was corrected from null to its default, 1.4. 
[12:54:09] [Server thread/WARN]: Incorrect key projection.RHONGOMYNIAD_MANA_COST was corrected from null to its default, 300. 
[12:54:09] [Server thread/WARN]: Incorrect key projection.RHONGOMYNIAD_MAX_SMITES was corrected from null to its default, 10. 
[12:54:09] [Server thread/WARN]: Incorrect key projection.RHONGOMYNIAD_RANGE was corrected from null to its default, 20. 
[12:54:09] [Server thread/WARN]: Incorrect key projection.RHONGOMYNIAD_RESPECT_IMMUNE was corrected from null to its default, false. 
[12:54:09] [Server thread/WARN]: Incorrect key projection.CLARENT_UNBREAKABLE was corrected from null to its default, true. 
[12:54:09] [Server thread/WARN]: Incorrect key projection.CLARENT_DURABILITY was corrected from null to its default, 1500. 
[12:54:09] [Server thread/WARN]: Incorrect key projection.CLARENT_WOUND_TICKS was corrected from null to its default, 600. 
[12:54:09] [Server thread/WARN]: Incorrect key projection.CLARENT_WOUND_DAMAGE was corrected from null to its default, 0.2. 
[12:54:09] [Server thread/WARN]: Incorrect key projection.CLARENT_DECREASE_PER_BLOCKING_TICK was corrected from null to its default, 0.02. 
[12:54:09] [Server thread/WARN]: Incorrect key projection.CLARENT_WOUND_DAMAGE_HITS was corrected from null to its default, 3. 
[12:54:09] [Server thread/WARN]: Incorrect key projection.CLARENT_SWORD_BLACKLIST was corrected from null to its default, [mahoutsukai:caliburn, mahoutsukai:morgan]. 
[12:54:09] [Server thread/WARN]: Incorrect key projection.CLARENT_ATTACK_CAP was corrected from null to its default, 5000000. 
[12:54:09] [Server thread/WARN]: Incorrect key projection.CLARENT_STORED_FACTOR was corrected from null to its default, 0.5. 
[12:54:09] [Server thread/WARN]: Incorrect key projection.CLARENT_BLACKLIST_TOGGLE was corrected from null to its default, true. 
[12:54:09] [Server thread/WARN]: Incorrect key projection.CLARENT_MANA_PER_DAMAGE was corrected from null to its default, 10.0. 
[12:54:09] [Server thread/WARN]: Incorrect key projection.EMRYS_MAX_RANGE was corrected from null to its default, 22. 
[12:54:09] [Server thread/WARN]: Incorrect key projection.EMRYS_DAMAGE_FOCUSED_PER_SECOND was corrected from null to its default, 4.0. 
[12:54:09] [Server thread/WARN]: Incorrect key projection.EMRYS_DAMAGE_ZAP was corrected from null to its default, 1.5. 
[12:54:09] [Server thread/WARN]: Incorrect key projection.EMRYS_BOLT_FIRE was corrected from null to its default, false. 
[12:54:09] [Server thread/WARN]: Incorrect key projection.EMRYS_MANA_COST_FOCUSED was corrected from null to its default, 200. 
[12:54:09] [Server thread/WARN]: Incorrect key projection.EMRYS_MANA_COST_PASSIVE was corrected from null to its default, 80. 
[12:54:09] [Server thread/WARN]: Incorrect key projection.DISABLE_EMRYS was corrected from null to its default, false. 
[12:54:09] [Server thread/WARN]: Incorrect key projection.MORGAN_TRANSFORM_ENTITY_WHITELIST was corrected from null to its default, [minecraft:wolf]. 
[12:54:09] [Server thread/WARN]: Incorrect key projection.MORGAN_TRANSFORM_WOLFS_ALLOWED was corrected from null to its default, true. 
[12:54:09] [Server thread/WARN]: Incorrect key projection.MORGAN_CHILD_INCREASE was corrected from null to its default, 1.0. 
[12:54:09] [Server thread/WARN]: Incorrect key projection.MORGAN_ADULT_INCREASE was corrected from null to its default, 0.2. 
[12:54:09] [Server thread/WARN]: Incorrect key projection.MORGAN_HEAL_FACTOR was corrected from null to its default, 30. 
[12:54:09] [Server thread/WARN]: Incorrect key projection.MORGAN_CALIBURN_POWER_COOLDOWN was corrected from null to its default, 600. 
[12:54:09] [Server thread/WARN]: Incorrect key projection.MORGAN_RAGE_TIME was corrected from null to its default, 120. 
[12:54:09] [Server thread/WARN]: Incorrect key projection.MORGAN_MAX_BALL_RANGE was corrected from null to its default, 15. 
[12:54:09] [Server thread/WARN]: Incorrect key projection.MORGAN_SPIKE_RANGE was corrected from null to its default, 10. 
[12:54:09] [Server thread/WARN]: Incorrect key projection.MORGAN_UPGRADE_MANA_COST was corrected from null to its default, 400. 
[12:54:09] [Server thread/WARN]: Incorrect key projection.CALIBURN_MORGAN_ABILITY_MANA_COST was corrected from null to its default, 300. 
[12:54:09] [Server thread/WARN]: Incorrect key projection.REPLICA_BASE_DAMAGE was corrected from null to its default, 4.0. 
[12:54:09] [Server thread/WARN]: Incorrect key projection.REPLICA_TELEPORT_FRIEND_RANGE was corrected from null to its default, 6.0. 
[12:54:09] [Server thread/WARN]: Incorrect key projection.REPLICA_TELEPORT_MAX_DISTANCE was corrected from null to its default, -1.0. 
[12:54:09] [Server thread/WARN]: Incorrect key projection.REPLICA_TELEPORT_START_TELEPORTING was corrected from null to its default, 110. 
[12:54:09] [Server thread/WARN]: Incorrect key projection.REPLICA_TELEPORT_STOP_TELEPORTING was corrected from null to its default, 120. 
[12:54:09] [Server thread/WARN]: Incorrect key projection.REPLICA_TELEPORT_LIFE was corrected from null to its default, 140. 
[12:54:09] [Server thread/WARN]: Incorrect key projection.REPLICA_TELEPORT_MANA_COST was corrected from null to its default, 300. 
[12:54:09] [Server thread/WARN]: Incorrect key projection.REPLICA_ATTACK_MANA_COST was corrected from null to its default, 30. 
[12:54:09] [Server thread/WARN]: Incorrect key projection.REPLICA_SHOCKWAVE_COOLDOWN was corrected from null to its default, 50. 
[12:54:09] [Server thread/WARN]: Incorrect key projection.REPLICA_ATTACK_RANGE was corrected from null to its default, 8.0. 
[12:54:09] [Server thread/WARN]: Incorrect key projection.REPLICA_TELEPORT_CROSS_DIMENSION was corrected from null to its default, true. 
[12:54:09] [Server thread/WARN]: Incorrect key projection.REPLICA_COVER_MOVE_RANGE was corrected from null to its default, 20.0. 
[12:54:09] [Server thread/WARN]: Incorrect key projection.REPLICA_MAX_DAMAGE was corrected from null to its default, 5000000.0. 
[12:54:09] [Server thread/WARN]: Incorrect key projection.REPLICA_DISABLED was corrected from null to its default, false. 
[12:54:09] [Server thread/WARN]: Incorrect key projection.REPLICA_BANNED_DAMAGE_TYPES was corrected from null to its default, []. 
[12:54:09] [Server thread/WARN]: Incorrect key projection.REPLICA_DURABILITY was corrected from null to its default, 10000. 
[12:54:09] [Server thread/WARN]: Incorrect key projection.REPLICA_IS_UNBREAKABLE was corrected from null to its default, true. 
[12:54:09] [Server thread/WARN]: Incorrect key projection.UNHOLY_WORDS was corrected from null to its default, [zomb, vampir, demon, devil, skele, lich, evil, curse, undead, wither]. 
[12:54:09] [Server thread/WARN]: Incorrect key exchange was corrected from null to its default, SimpleCommentedConfig:{}. 
[12:54:09] [Server thread/WARN]: Incorrect key exchange.ALCHEMICAL_EXCHANGE_BLOCK_CYCLE was corrected from null to its default, 20. 
[12:54:09] [Server thread/WARN]: Incorrect key exchange.ALCHEMICAL_EXCHANGE_HEIGHT was corrected from null to its default, 5. 
[12:54:09] [Server thread/WARN]: Incorrect key exchange.ALCHEMICAL_EXCHANGE_MANA_COST was corrected from null to its default, 16. 
[12:54:09] [Server thread/WARN]: Incorrect key exchange.ALCHEMICAL_DIRT_CLASS was corrected from null to its default, [minecraft:dirt, minecraft:sand, minecraft:soul_sand, minecraft:snow_block]. 
[12:54:09] [Server thread/WARN]: Incorrect key exchange.ALCHEMICAL_STONE_CLASS was corrected from null to its default, [minecraft:stone, minecraft:ice, minecraft:packed_ice, minecraft:sandstone, minecraft:red_sandstone, minecraft:gravel, minecraft:end_stone, minecraft:purpur_block, minecraft:magma_block, minecraft:netherrack, minecraft:terracotta]. 
[12:54:09] [Server thread/WARN]: Incorrect key exchange.ALCHEMICAL_METAL_CLASS was corrected from null to its default, [minecraft:iron_ore, minecraft:gold_ore, minecraft:nether_quartz_ore]. 
[12:54:09] [Server thread/WARN]: Incorrect key exchange.ALCHEMICAL_GEM_CLASS was corrected from null to its default, [minecraft:diamond_ore, minecraft:emerald_ore]. 
[12:54:09] [Server thread/WARN]: Incorrect key exchange.ALCHEMICAL_CLAY_CLASS was corrected from null to its default, [minecraft:clay, minecraft:coal_ore, minecraft:redstone_ore, minecraft:lapis_ore]. 
[12:54:09] [Server thread/WARN]: Incorrect key exchange.ALCHEMICAL_WOOD_CLASS was corrected from null to its default, [minecraft:oak_log, minecraft:birch_log, minecraft:acacia_log, minecraft:jungle_log, minecraft:spruce_log, minecraft:dark_oak_log, minecraft:cactus, minecraft:pumpkin, minecraft:melon, minecraft:brown_mushroom_block, minecraft:red_mushroom_block, minecraft:hay_block, minecraft:nether_wart_block]. 
[12:54:09] [Server thread/WARN]: Incorrect key exchange.ALCHEMICAL_SPECIAL_CLASS was corrected from null to its default, [minecraft:prismarine, minecraft:glowstone, minecraft:sea_lantern, minecraft:obsidian, minecraft:slime_block]. 
[12:54:09] [Server thread/WARN]: Incorrect key exchange.ALCHEMICAL_GRASS_CLASS was corrected from null to its default, [minecraft:grass_block, minecraft:mycelium]. 
[12:54:09] [Server thread/WARN]: Incorrect key exchange.ALCHEMICAL_FLUID_CLASS was corrected from null to its default, [minecraft:lava, minecraft:water]. 
[12:54:09] [Server thread/WARN]: Incorrect key exchange.ALCHEMICAL_MOVING_FLUID_CLASS was corrected from null to its default, []. 
[12:54:09] [Server thread/WARN]: Incorrect key exchange.CATALYST_EXCHANGE_BLOCK_CYCLE was corrected from null to its default, 4. 
[12:54:09] [Server thread/WARN]: Incorrect key exchange.CATALYST_EXCHANGE_MANA_COST was corrected from null to its default, 50. 
[12:54:09] [Server thread/WARN]: Incorrect key exchange.CHRONAL_EXCHANGE_BLOCK_CYCLE was corrected from null to its default, 20. 
[12:54:09] [Server thread/WARN]: Incorrect key exchange.CHRONAL_EXCHANGE_MANA_GAIN_LOSS was corrected from null to its default, 10. 
[12:54:09] [Server thread/WARN]: Incorrect key exchange.DURABILITY_EXCHANGE_BLOCK_CYCLE was corrected from null to its default, 20. 
[12:54:09] [Server thread/WARN]: Incorrect key exchange.DURABILITY_EXCHANGE_MANA_GAIN_CAP was corrected from null to its default, 10. 
[12:54:09] [Server thread/WARN]: Incorrect key exchange.DURABILITY_EXCHANGE_EFFICIENCY was corrected from null to its default, 1. 
[12:54:09] [Server thread/WARN]: Incorrect key exchange.DURABILITY_EXCHANGE_BLACKLIST was corrected from null to its default, []. 
[12:54:09] [Server thread/WARN]: Incorrect key exchange.DURABILITY_EXCHANGE_TAX_BRACKETS was corrected from null to its default, [5000.0, 20000.0, 100000.0]. 
[12:54:09] [Server thread/WARN]: Incorrect key exchange.DURABILITY_EXCHANGE_TAX_RATES was corrected from null to its default, [0.02, 0.03, 0.04]. 
[12:54:09] [Server thread/WARN]: Incorrect key exchange.DAMAGE_EXCHANGE_MANA_COST was corrected from null to its default, 40. 
[12:54:09] [Server thread/WARN]: Incorrect key exchange.DAMAGE_EXCHANGE_MANA_GAIN was corrected from null to its default, 20. 
[12:54:09] [Server thread/WARN]: Incorrect key exchange.DAMAGE_EXCHANGE_REDUCE_TO was corrected from null to its default, 1.0. 
[12:54:09] [Server thread/WARN]: Incorrect key exchange.DAMAGE_EXCHANGE_CAP was corrected from null to its default, 5. 
[12:54:09] [Server thread/WARN]: Incorrect key exchange.CONTRACT_MANA_COST was corrected from null to its default, 10. 
[12:54:09] [Server thread/WARN]: Incorrect key exchange.CONTRACT_BLOCK_CYCLE was corrected from null to its default, 4. 
[12:54:09] [Server thread/WARN]: Incorrect key exchange.CONTRACT_RADIUS was corrected from null to its default, 10. 
[12:54:09] [Server thread/WARN]: Incorrect key exchange.IMMUNITY_EXCHANGE_MANA_COST was corrected from null to its default, 400. 
[12:54:09] [Server thread/WARN]: Incorrect key exchange.IMMUNITY_EXCHANGE_TIME was corrected from null to its default, 1200. 
[12:54:09] [Server thread/WARN]: Incorrect key mystic was corrected from null to its default, SimpleCommentedConfig:{}. 
[12:54:09] [Server thread/WARN]: Incorrect key mystic.SPATIAL_DISORIENTATION_MANA_COST was corrected from null to its default, 100. 
[12:54:09] [Server thread/WARN]: Incorrect key mystic.SPATIAL_DISORIENTATION_MANA_COST_AOE was corrected from null to its default, 20. 
[12:54:09] [Server thread/WARN]: Incorrect key mystic.SPATIAL_DISORIENTATION_MANA_COST_ST was corrected from null to its default, 200. 
[12:54:09] [Server thread/WARN]: Incorrect key mystic.SPATIAL_DISORIENTATION_AIR_RESISTANCE was corrected from null to its default, false. 
[12:54:09] [Server thread/WARN]: Incorrect key mystic.SPATIAL_DISORIENTATION_SPEED was corrected from null to its default, 7.0. 
[12:54:09] [Server thread/WARN]: Incorrect key mystic.SPATIAL_DISORIENTATION_AOE_RADIUS was corrected from null to its default, 4.0. 
[12:54:09] [Server thread/WARN]: Incorrect key mystic.MYSTIC_STAFF_SUMMON_MANA_COST was corrected from null to its default, 100. 
[12:54:09] [Server thread/WARN]: Incorrect key mystic.MYSTIC_STAFF_BIG_MANA_COST was corrected from null to its default, 5000. 
[12:54:09] [Server thread/WARN]: Incorrect key mystic.MYSTIC_STAFF_AOE_MANA_COST was corrected from null to its default, 600. 
[12:54:09] [Server thread/WARN]: Incorrect key mystic.MYSTIC_STAFF_BIG_SCALES was corrected from null to its default, true. 
[12:54:09] [Server thread/WARN]: Incorrect key mystic.MYSTIC_STAFF_AOE_SCALES was corrected from null to its default, true. 
[12:54:09] [Server thread/WARN]: Incorrect key mystic.MYSTIC_STAFF_BIG_FACTOR was corrected from null to its default, 0.002. 
[12:54:09] [Server thread/WARN]: Incorrect key mystic.MYSTIC_STAFF_AOE_FACTOR was corrected from null to its default, 0.001. 
[12:54:09] [Server thread/WARN]: Incorrect key mystic.MYSTIC_STAFF_AOE_SIZE was corrected from null to its default, 4. 
[12:54:09] [Server thread/WARN]: Incorrect key mystic.MYSTIC_STAFF_BIG_SIZE was corrected from null to its default, 30. 
[12:54:09] [Server thread/WARN]: Incorrect key mystic.MYSTIC_STAFF_AOE_DELAY was corrected from null to its default, 3. 
[12:54:09] [Server thread/WARN]: Incorrect key mystic.MYSTIC_STAFF_BIG_RAIN was corrected from null to its default, true. 
[12:54:09] [Server thread/WARN]: Incorrect key mystic.MYSTIC_STAFF_BEAM_MANA_PER_TICK was corrected from null to its default, 500. 
[12:54:09] [Server thread/WARN]: Incorrect key mystic.MYSTIC_STAFF_BEAM_DAMAGE_FACTOR was corrected from null to its default, 0.001. 
[12:54:09] [Server thread/WARN]: Incorrect key mystic.MYSTIC_STAFF_BEAM_DAMAGE_SCALES was corrected from null to its default, true. 
[12:54:09] [Server thread/WARN]: Incorrect key mystic.MYSTIC_STAFF_BEAM_DAMAGE_ACCELERATION was corrected from null to its default, 1.5. 
[12:54:09] [Server thread/WARN]: Incorrect key mystic.MYSTIC_STAFF_BEAM_MAX_BLOCK_BREAK_PER_TICK was corrected from null to its default, 90. 
[12:54:09] [Server thread/WARN]: Incorrect key mystic.MYSTIC_STAFF_SCALING_MANA was corrected from null to its default, 0.0. 
[12:54:09] [Server thread/WARN]: Incorrect key mystic.MYSTIC_STAFF_WORLD_DAMAGE was corrected from null to its default, true. 
[12:54:09] [Server thread/WARN]: Incorrect key mystic.MYSTIC_STAFF_BEAM_BLOCK_WHITELIST was corrected from null to its default, []. 
[12:54:09] [Server thread/WARN]: Incorrect key mystic.RHO_AIAS_MANA_COST was corrected from null to its default, 300. 
[12:54:09] [Server thread/WARN]: Incorrect key mystic.RHO_AIAS_KILL_RANGE was corrected from null to its default, 30. 
[12:54:09] [Server thread/WARN]: Incorrect key mystic.RHO_AIAS_LIFE was corrected from null to its default, 1200. 
[12:54:09] [Server thread/WARN]: Incorrect key mystic.RHO_AIAS_ENTITY_KILL_LIST was corrected from null to its default, [mahoutsukai:gandr_entity]. 
[12:54:09] [Server thread/WARN]: Incorrect key mystic.RHO_AIAS_COLLIDE_KILL_LIST was corrected from null to its default, [mahoutsukai:gandr_entity]. 
[12:54:09] [Server thread/WARN]: Incorrect key mystic.RHO_AIAS_KILL_DEBUG was corrected from null to its default, false. 
[12:54:09] [Server thread/WARN]: Incorrect key mystic.RHO_AIAS_SNEAK_BOOP was corrected from null to its default, true. 
[12:54:09] [Server thread/WARN]: Incorrect key mystic.DAMAGE_REPLICATION_MANA_COST was corrected from null to its default, 160. 
[12:54:09] [Server thread/WARN]: Incorrect key mystic.AUTHORITY_MANA_COST was corrected from null to its default, 900. 
[12:54:09] [Server thread/WARN]: Incorrect key mystic.AUTHORITY_TIME was corrected from null to its default, 400. 
[12:54:09] [Server thread/WARN]: Incorrect key mystic.AUTHORITY_DAMAGE_TO_SELF was corrected from null to its default, 1.5. 
[12:54:09] [Server thread/WARN]: Incorrect key mystic.AUTHORITY_DAMAGE_TO_OTHER was corrected from null to its default, 3.0. 
[12:54:09] [Server thread/WARN]: Incorrect key mystic.AUTHORITY_BREAK_SLOW_DOWN_FACTOR was corrected from null to its default, 0.5. 
[12:54:09] [Server thread/WARN]: Incorrect key mystic.AUTHORITY_NORMAL_SLOW_DOWN_FACTOR was corrected from null to its default, 0.875. 
[12:54:09] [Server thread/WARN]: Incorrect key mystic.AUTHORITY_SPEED_MULTIPLIER was corrected from null to its default, 3.2. 
[12:54:09] [Server thread/WARN]: Incorrect key mystic.AUTHORITY_BLOCK_RESISTANCE_LIMIT was corrected from null to its default, 45. 
[12:54:09] [Server thread/WARN]: Incorrect key mystic.AUTHORITY_DROPS_BLOCKS was corrected from null to its default, true. 
[12:54:09] [Server thread/WARN]: Incorrect key mystic.HEAVENS_CUP_MANA_COST was corrected from null to its default, 2. 
[12:54:09] [Server thread/WARN]: Incorrect key mystic.HEAVENS_CUP_START_DISTANCE was corrected from null to its default, 20. 
[12:54:09] [Server thread/WARN]: Incorrect key mystic.HEAVENS_CUP_DURATION was corrected from null to its default, 1200. 
[12:54:09] [Server thread/WARN]: Incorrect key mystic.HEAVENS_CUP_NETWORK_DISTANCE was corrected from null to its default, 30. 
[12:54:09] [Server thread/WARN]: Incorrect key mystic.HEAVENS_CUP_TWO_EFFECT was corrected from null to its default, poison. 
[12:54:09] [Server thread/WARN]: Incorrect key mystic.HEAVENS_CUP_THREE_EFFECT was corrected from null to its default, weakness. 
[12:54:09] [Server thread/WARN]: Incorrect key mystic.HEAVENS_CUP_FIVE_EFFECT was corrected from null to its default, blindness. 
[12:54:09] [Server thread/WARN]: Incorrect key mystic.HEAVENS_CUP_SEVEN_EFFECT was corrected from null to its default, slowness. 
[12:54:09] [Server thread/WARN]: Incorrect key mystic.HEAVENS_CUP_ELEVEN_EFFECT was corrected from null to its default, wither. 
[12:54:09] [Server thread/WARN]: Incorrect key mystic.HEAVENS_CUP_THIRTEEN_EFFECT was corrected from null to its default, levitation. 
[12:54:09] [Server thread/WARN]: Incorrect key eyes was corrected from null to its default, SimpleCommentedConfig:{}. 
[12:54:09] [Server thread/WARN]: Incorrect key eyes.CLAIRVOYANCE_MANA_COST was corrected from null to its default, 220. 
[12:54:09] [Server thread/WARN]: Incorrect key eyes.CLAIRVOYANCE_TIME was corrected from null to its default, 1200. 
[12:54:09] [Server thread/WARN]: Incorrect key eyes.CLAIRVOYANCE_RANGE was corrected from null to its default, 30. 
[12:54:09] [Server thread/WARN]: Incorrect key eyes.MYSTIC_EYES_MANA_COST was corrected from null to its default, 320. 
[12:54:09] [Server thread/WARN]: Incorrect key eyes.MYSTIC_EYES_TIME was corrected from null to its default, 600. 
[12:54:09] [Server thread/WARN]: Incorrect key eyes.MYSTIC_EYES_RANGE_FROM_USER was corrected from null to its default, 5. 
[12:54:09] [Server thread/WARN]: Incorrect key eyes.MYSTIC_EYES_RANGE_FROM_LOOK_VEC was corrected from null to its default, 4. 
[12:54:09] [Server thread/WARN]: Incorrect key eyes.REVERSION_EYES_MANA_COST was corrected from null to its default, 410. 
[12:54:09] [Server thread/WARN]: Incorrect key eyes.REVERSION_EYES_TIME was corrected from null to its default, 600. 
[12:54:09] [Server thread/WARN]: Incorrect key eyes.REVERSION_EYES_RANGE_FROM_USER was corrected from null to its default, 10. 
[12:54:09] [Server thread/WARN]: Incorrect key eyes.REVERSION_EYES_RANGE_FROM_LOOK_VEC was corrected from null to its default, 4. 
[12:54:09] [Server thread/WARN]: Incorrect key eyes.DEATH_COLLECTION_MANA_COST was corrected from null to its default, 400. 
[12:54:09] [Server thread/WARN]: Incorrect key eyes.DEATH_COLLECTION_TIME was corrected from null to its default, 600. 
[12:54:09] [Server thread/WARN]: Incorrect key eyes.DEATH_COLLECTION_RANGE_FROM_USER was corrected from null to its default, 10. 
[12:54:09] [Server thread/WARN]: Incorrect key eyes.DEATH_COLLECTION_SOUL_VALUE_MOB was corrected from null to its default, 0.25. 
[12:54:09] [Server thread/WARN]: Incorrect key eyes.DEATH_COLLECTION_SOUL_VALUE_PLAYER was corrected from null to its default, 1.0. 
[12:54:09] [Server thread/WARN]: Incorrect key eyes.DEATH_COLLECTION_REVIVE_VALUE was corrected from null to its default, 12.0. 
[12:54:09] [Server thread/WARN]: Incorrect key eyes.DEATH_COLLECTION_MAX was corrected from null to its default, 1.0E7. 
[12:54:09] [Server thread/WARN]: Incorrect key eyes.DEATH_COLLECTION_DRAIN_PER_SOUL was corrected from null to its default, 1.0. 
[12:54:09] [Server thread/WARN]: Incorrect key eyes.DEATH_COLLECTION_NEGATIVE_REGEN_PUNISHMENT was corrected from null to its default, true. 
[12:54:09] [Server thread/WARN]: Incorrect key eyes.BLACK_FLAME_MANA_COST was corrected from null to its default, 300. 
[12:54:09] [Server thread/WARN]: Incorrect key eyes.BLACK_FLAME_TIME was corrected from null to its default, 100. 
[12:54:09] [Server thread/WARN]: Incorrect key eyes.BLACK_FLAME_RANGE_FROM_USER was corrected from null to its default, 30. 
[12:54:09] [Server thread/WARN]: Incorrect key eyes.BLACK_FLAME_IGNITION_TICKS was corrected from null to its default, 1. 
[12:54:09] [Server thread/WARN]: Incorrect key eyes.BLACK_FLAME_UPDATE_TICKS was corrected from null to its default, 1. 
[12:54:09] [Server thread/WARN]: Incorrect key eyes.BLACK_FLAME_DEATH_AGE was corrected from null to its default, 6. 
[12:54:09] [Server thread/WARN]: Incorrect key eyes.BLACK_FLAME_DAMAGE was corrected from null to its default, 1.0. 
[12:54:09] [Server thread/WARN]: Incorrect key eyes.FAY_SIGHT_MANA_COST was corrected from null to its default, 100. 
[12:54:09] [Server thread/WARN]: Incorrect key eyes.FAY_SIGHT_TIME was corrected from null to its default, 600. 
[12:54:09] [Server thread/WARN]: Incorrect key eyes.LEY_PUNISHMENT was corrected from null to its default, -1. 
[12:54:09] [Server thread/WARN]: Incorrect key eyes.LEY_FACTOR was corrected from null to its default, 0.01. 
[12:54:09] [Server thread/WARN]: Incorrect key eyes.LEY_FLAT was corrected from null to its default, false. 
[12:54:09] [Server thread/WARN]: Incorrect key eyes.LEY_DISTANCE was corrected from null to its default, 300. 
[12:54:09] [Server thread/WARN]: Incorrect key eyes.LEY_OFFSET was corrected from null to its default, 0. 
[12:54:09] [Server thread/WARN]: Incorrect key eyes.LEY_AFFECTS_MANA was corrected from null to its default, true. 
[12:54:09] [Server thread/WARN]: Incorrect key eyes.LEY_RENDER_HEIGHT was corrected from null to its default, 70. 
[12:54:09] [Server thread/WARN]: Incorrect key eyes.FAE_SPAWN_RATE was corrected from null to its default, 1.0. 
[12:54:09] [Server thread/WARN]: Incorrect key eyes.LEY_RUNES was corrected from null to its default, true. 
[12:54:09] [Server thread/WARN]: Incorrect key eyes.LEY_BLACKLIST was corrected from null to its default, true. 
[12:54:09] [Server thread/WARN]: Incorrect key eyes.LEY_ELYTRA_LIMITED_TO_FAY_SIGHT was corrected from null to its default, false. 
[12:54:09] [Server thread/WARN]: Incorrect key eyes.LEY_DIMENSION_LIST was corrected from null to its default, []. 
[12:54:09] [Server thread/WARN]: Incorrect key eyes.INSIGHT_MANA_COST was corrected from null to its default, 320. 
[12:54:09] [Server thread/WARN]: Incorrect key eyes.INSIGHT_TIME was corrected from null to its default, 1200. 
[12:54:09] [Server thread/WARN]: Incorrect key familiar was corrected from null to its default, SimpleCommentedConfig:{}. 
[12:54:09] [Server thread/WARN]: Incorrect key familiar.POSSESS_ENTITY_MANA_COST was corrected from null to its default, 200. 
[12:54:09] [Server thread/WARN]: Incorrect key familiar.RECALL_FAMILIAR_MANA_COST was corrected from null to its default, 20. 
[12:54:09] [Server thread/WARN]: Incorrect key familiar.SUMMON_FAMILIAR_MANA_COST was corrected from null to its default, 200. 
[12:54:09] [Server thread/WARN]: Incorrect key familiar.BUTTERFLY_EFFECT_MANA_COST was corrected from null to its default, 100. 
[12:54:09] [Server thread/WARN]: Incorrect key familiar.BUTTERFLY_EFFECT_DURATION was corrected from null to its default, 400. 
[12:54:09] [Server thread/WARN]: Incorrect key familiar.BUTTERFLY_EFFECT_SINGLE_USE was corrected from null to its default, false. 
[12:54:09] [Server thread/WARN]: Incorrect key familiar.BUTTERFLY_EFFECT_VISIBLE_TO_OTHERS was corrected from null to its default, false. 
[12:54:09] [Server thread/WARN]: Incorrect key familiar.FAMILIAR_REPORT_SURROUNDINGS_TIME was corrected from null to its default, 400. 
[12:54:09] [Server thread/WARN]: Incorrect key familiar.FAMILIAR_HEALTH was corrected from null to its default, 10. 
[12:54:09] [Server thread/WARN]: Incorrect key familiar.FAMILIAR_OUCH_CHANCE was corrected from null to its default, 0.3. 
[12:54:09] [Server thread/WARN]: Incorrect key familiar.SWAP_FAMILIAR_MANA_COST was corrected from null to its default, 40. 
[12:54:09] [Server thread/WARN]: Incorrect key familiar.FAMILIARS_GARDEN_MANA_COST was corrected from null to its default, 200. 
[12:54:09] [Server thread/WARN]: Incorrect key familiar.FAMILIARS_GARDEN_RANGE was corrected from null to its default, 7. 
[12:54:09] [Server thread/WARN]: Incorrect key familiar.FAMILIARS_GARDEN_TIME was corrected from null to its default, 1200. 
[12:54:09] [Server thread/WARN]: Incorrect key familiar.FAMILIAR_ACTION_BAR_MESSAGES was corrected from null to its default, true. 
[12:54:09] [Server thread/WARN]: Incorrect key secret was corrected from null to its default, SimpleCommentedConfig:{}. 
[12:54:09] [Server thread/WARN]: Incorrect key secret.RETRIBUTION_MANA_PER_DIFFERENCE was corrected from null to its default, 40. 
[12:54:09] [Server thread/WARN]: Incorrect key secret.RETRIBUTION_MANA_CHARGED_PER_PERCENT was corrected from null to its default, false. 
[12:54:09] [Server thread/WARN]: Incorrect key secret.RETRIBUTION_BLACKLIST was corrected from null to its default, []. 
[12:54:09] [Server thread/WARN]: Incorrect key secret.RIPPER_COOLDOWN was corrected from null to its default, 800. 
[12:54:09] [Server thread/WARN]: Incorrect key secret.RIPPER_MANA_COST was corrected from null to its default, 800. 
[12:54:09] [Server thread/WARN]: Incorrect key secret.RIPPER_FOG_RANGE was corrected from null to its default, 20. 
[12:54:09] [Server thread/WARN]: Incorrect key secret.RIPPER_FOG_DISTANCE was corrected from null to its default, 5. 
[12:54:09] [Server thread/WARN]: Incorrect key secret.RIPPER_INVIS_COOLDOWN was corrected from null to its default, 40. 
[12:54:09] [Server thread/WARN]: Incorrect key secret.RIPPER_GIVES_INVIS was corrected from null to its default, true. 
[12:54:09] [Server thread/WARN]: Incorrect key secret.RIPPER_SPEED was corrected from null to its default, 3.0. 
[12:54:09] [Server thread/WARN]: Incorrect key secret.RIPPER_MOVEMENT_SPEED was corrected from null to its default, 0.05. 
[12:54:09] [Server thread/WARN]: Incorrect key secret.RIPPER_DAMAGE was corrected from null to its default, 2.5. 
[12:54:09] [Server thread/WARN]: Incorrect key secret.RIPPER_DAMAGE_BONUS_FROM_BEHIND was corrected from null to its default, 6.0. 
[12:54:09] [Server thread/WARN]: Incorrect key secret.RIPPER_DAMAGE_BONUS_SCALES_WITH_MANA was corrected from null to its default, false. 
[12:54:09] [Server thread/WARN]: Incorrect key secret.RIPPER_DURABILITY was corrected from null to its default, 1200. 
[12:54:09] [Server thread/WARN]: Incorrect key secret.RIPPER_FOG_MANA_COST was corrected from null to its default, 200. 
[12:54:09] [Server thread/WARN]: Incorrect key secret.RIPPER_INVIS_MANA_COST was corrected from null to its default, 0. 
[12:54:09] [Server thread/WARN]: Incorrect key secret.GANDR_BLACK_PARTICLES_HIT was corrected from null to its default, 150. 
[12:54:09] [Server thread/WARN]: Incorrect key secret.GANDR_RED_PARTICLES_HIT was corrected from null to its default, 40. 
[12:54:09] [Server thread/WARN]: Incorrect key secret.GANDR_RED_PARTICLES_LAUNCH was corrected from null to its default, 25. 
[12:54:09] [Server thread/WARN]: Incorrect key secret.GANDR_HIT_RADIUS was corrected from null to its default, 6.0. 
[12:54:09] [Server thread/WARN]: Incorrect key secret.GANDR_CLOUD_DURATION was corrected from null to its default, 200. 
[12:54:09] [Server thread/WARN]: Incorrect key secret.GANDR_MANA_SCALES was corrected from null to its default, true. 
[12:54:09] [Server thread/WARN]: Incorrect key secret.GANDR_MANA_COST_FACTOR was corrected from null to its default, 0.05. 
[12:54:09] [Server thread/WARN]: Incorrect key secret.GANDR_DAMAGE_SCALES was corrected from null to its default, true. 
[12:54:09] [Server thread/WARN]: Incorrect key secret.GANDR_DAMAGE_FACTOR was corrected from null to its default, 0.009999999776482582. 
[12:54:09] [Server thread/WARN]: Incorrect key secret.GANDR_MAX_DAMAGE was corrected from null to its default, 1000.0. 
[12:54:09] [Server thread/WARN]: Incorrect key secret.GANDR_MIN_DAMAGE was corrected from null to its default, 5.0. 
[12:54:09] [Server thread/WARN]: Incorrect key secret.GANDR_SPEED was corrected from null to its default, 1.0. 
[12:54:09] [Server thread/WARN]: Incorrect key secret.GANDR_EFFECT_BLACKLIST was corrected from null to its default, []. 
[12:54:09] [Server thread/WARN]: Incorrect key secret.GANDR_EFFECT_WHITELIST was corrected from null to its default, [mahoutsukai:misfortune, mahoutsukai:bound, mahoutsukai:fear, mahoutsukai:black_burning, mahoutsukai:wounded, mahoutsukai:confusion]. 
[12:54:09] [Server thread/WARN]: Incorrect key secret.FALLEN_DOWN_BLOCK_BREAK_PER_TICK was corrected from null to its default, 800. 
[12:54:09] [Server thread/WARN]: Incorrect key secret.FALLEN_DOWN_RADIUS was corrected from null to its default, 30. 
[12:54:09] [Server thread/WARN]: Incorrect key secret.FALLEN_DOWN_MANA_COST was corrected from null to its default, 2000. 
[12:54:09] [Server thread/WARN]: Incorrect key secret.FALLEN_DOWN_BEAM_IN was corrected from null to its default, [minecraft:grass_block, minecraft:sand, minecraft:red_sand, minecraft:cobblestone, minecraft:clay, minecraft:ice, minecraft:packed_ice, minecraft:blue_ice]. 
[12:54:09] [Server thread/WARN]: Incorrect key secret.FALLEN_DOWN_BEAM_OUT was corrected from null to its default, [minecraft:dirt, minecraft:glass, minecraft:red_stained_glass, minecraft:stone, minecraft:terracotta, minecraft:water, minecraft:water, minecraft:water]. 
[12:54:09] [Server thread/WARN]: Incorrect key secret.FALLEN_DOWN_BEAM_DAMAGE was corrected from null to its default, 2.0. 
[12:54:09] [Server thread/WARN]: Incorrect key secret.FALLEN_DOWN_BEAM_GROWTH was corrected from null to its default, 0.12. 
[12:54:09] [Server thread/WARN]: Incorrect key secret.GEAS_MANA_COST was corrected from null to its default, 30. 
[12:54:09] [Server thread/WARN]: Incorrect key secret.MANA_REGEN_PER_GEAS was corrected from null to its default, 3.0. 
[12:54:09] [Server thread/WARN]: Incorrect key secret.GEAS_MAX_MANA_REGEN was corrected from null to its default, 1.0E7. 
[12:54:09] [Server thread/WARN]: Incorrect key secret.RULE_BREAKER_DURABILITY was corrected from null to its default, 40. 
[12:54:09] [Server thread/WARN]: Incorrect key secret.RULE_BREAKER_DURATION was corrected from null to its default, 800. 
[12:54:09] [Server thread/WARN]: Incorrect key secret.RULE_BREAKER_MANA_COST was corrected from null to its default, 5000. 
[12:54:09] [Server thread/WARN]: Incorrect key secret.RULE_BREAKER_RANGE was corrected from null to its default, 20. 
[12:54:09] [Server thread/WARN]: Incorrect key secret.RULE_BREAKER_ITEM_WHITELIST was corrected from null to its default, [minecraft:chorus_fruit]. 
[12:54:09] [Server thread/WARN]: Incorrect key secret.SELECTIVE_DISPLACEMENT_TIME was corrected from null to its default, 1200. 
[12:54:09] [Server thread/WARN]: Incorrect key secret.SELECTIVE_DISPLACEMENT_RANGE was corrected from null to its default, 40. 
[12:54:09] [Server thread/WARN]: Incorrect key secret.SELECTIVE_DISPLACEMENT_COOLDOWN was corrected from null to its default, 60. 
[12:54:09] [Server thread/WARN]: Incorrect key secret.SELECTIVE_DISPLACEMENT_MANA_COST was corrected from null to its default, 900. 
[12:54:09] [Server thread/WARN]: Incorrect key kodoku was corrected from null to its default, SimpleCommentedConfig:{}. 
[12:54:09] [Server thread/WARN]: Incorrect key kodoku.KODOKU_FIRE_CHANCE was corrected from null to its default, 0.1. 
[12:54:09] [Server thread/WARN]: Incorrect key kodoku.KODOKU_SPLASH_CHANCE was corrected from null to its default, 0.05. 
[12:54:09] [Server thread/WARN]: Incorrect key kodoku.KODOKU_HOP_CHANCE was corrected from null to its default, 0.08. 
[12:54:09] [Server thread/WARN]: Incorrect key kodoku.KODOKU_GLOW_CHANCE was corrected from null to its default, 0.02. 
[12:54:09] [Server thread/WARN]: Incorrect key kodoku.KODOKU_CONFUSE_CHANCE was corrected from null to its default, 0.01. 
[12:54:09] [Server thread/WARN]: Incorrect key kodoku.KODOKU_TELEPORT_CHANCE was corrected from null to its default, 0.08. 
[12:54:09] [Server thread/WARN]: Incorrect key kodoku.KODOKU_HUNGER_CHANCE was corrected from null to its default, 0.15. 
[12:54:09] [Server thread/WARN]: Incorrect key kodoku.KODOKU_MISFORTUNE_LIGHTNING_CHANCE was corrected from null to its default, 2.0E-5. 
[12:54:09] [Server thread/WARN]: Incorrect key kodoku.KODOKU_MISFORTUNE_AGGRO_CHANCE was corrected from null to its default, 4.0E-4. 
[12:54:09] [Server thread/WARN]: Incorrect key kodoku.KODOKU_MISFORTUNE_DROP_CHANCE was corrected from null to its default, 7.142857142857143E-5. 
[12:54:09] [Server thread/WARN]: Incorrect key kodoku.KODOKU_MISFORTUNE_TRIP_CHANCE was corrected from null to its default, 4.0E-5. 
[12:54:09] [Server thread/WARN]: Incorrect key kodoku.KODOKU_LOOT_DIVISOR was corrected from null to its default, 10. 
[12:54:09] [Server thread/WARN]: Incorrect key kodoku.KODOKU_TOOL_BREAK_DIVISOR was corrected from null to its default, 10. 
[12:54:09] [Server thread/WARN]: Incorrect key kodoku.KODOKU_HEALTH_FACTOR was corrected from null to its default, 0.1. 
[12:54:09] [Server thread/WARN]: Incorrect key kodoku.KODOKU_ARMOR_FACTOR was corrected from null to its default, 0.0. 
[12:54:09] [Server thread/WARN]: Incorrect key kodoku.KODOKU_HEALTH_FACTOR_MOB was corrected from null to its default, 0.1. 
[12:54:09] [Server thread/WARN]: Incorrect key kodoku.KODOKU_ARMOR_FACTOR_MOB was corrected from null to its default, 0.0. 
[12:54:09] [Server thread/WARN]: Incorrect key other was corrected from null to its default, SimpleCommentedConfig:{}. 
[12:54:09] [Server thread/WARN]: Incorrect key other.ARMOR_STANDS_IMMUNE was corrected from null to its default, true. 
[12:54:09] [Server thread/WARN]: Incorrect key other.BLEEDING_FROM_DAGGER_ONLY was corrected from null to its default, false. 
[12:54:09] [Server thread/WARN]: Incorrect key other.GLOBAL_LOOK_RANGE was corrected from null to its default, 100. 
[12:54:09] [Server thread/WARN]: Incorrect key other.CREATIVE_MODE_SPELLS was corrected from null to its default, false. 
[12:54:09] [Server thread/WARN]: Incorrect key other.MANA_CIRCUIT_MAGITECH_CAPACITY was corrected from null to its default, 100000. 
[12:54:09] [Server thread/WARN]: Incorrect key other.MANA_CIRCUIT_CAPACITY was corrected from null to its default, 100000. 
[12:54:09] [Server thread/WARN]: Incorrect key other.MANA_CIRCUIT_RANGE was corrected from null to its default, 10. 
[12:54:09] [Server thread/WARN]: Incorrect key other.MAX_MANA_CAP was corrected from null to its default, 200000. 
[12:54:09] [Server thread/WARN]: Incorrect key other.MAGIC_DAMAGES_PLAYER was corrected from null to its default, false. 
[12:54:09] [Server thread/WARN]: Incorrect key other.MAGIC_DAMAGE_FLAT was corrected from null to its default, true. 
[12:54:09] [Server thread/WARN]: Incorrect key other.MAGIC_DAMAGE_VALUE was corrected from null to its default, 1.0. 
[12:54:09] [Server thread/WARN]: Incorrect key other.MAGIC_DAMAGE_GENERIC was corrected from null to its default, true. 
[12:54:09] [Server thread/WARN]: Incorrect key other.FIRST_SORCERY_DURABILITY was corrected from null to its default, 50. 
[12:54:09] [Server thread/WARN]: Incorrect key other.BLOOD_CIRCLE_SOLID_ONLY was corrected from null to its default, true. 
[12:54:09] [Server thread/WARN]: Incorrect key other.MANA_UP_COUNTER was corrected from null to its default, 100. 
[12:54:09] [Server thread/WARN]: Incorrect key other.MANA_ADDED_SCALING_REGEN_PER_TICK was corrected from null to its default, 0.0. 
[12:54:09] [Server thread/WARN]: Incorrect key other.MANA_INCREASE was corrected from null to its default, 1. 
[12:54:09] [Server thread/WARN]: Incorrect key other.MANA_REGEN_PER_TICK was corrected from null to its default, 1. 
[12:54:09] [Server thread/WARN]: Incorrect key other.MANA_RECOVERY_SLEEP was corrected from null to its default, 0.5. 
[12:54:09] [Server thread/WARN]: Incorrect key other.MAGIC_CIRCLES was corrected from null to its default, []. 
[12:54:09] [Server thread/WARN]: Incorrect key other.MAGIC_RUNES was corrected from null to its default, []. 
[12:54:09] [Server thread/WARN]: Incorrect key other.PROJECTOR_DEFAULT_ROTATION_SPEED was corrected from null to its default, 1.0. 
[12:54:09] [Server thread/WARN]: Incorrect key other.PROJECTOR_CONTINUES_ROTATE_WHEN_OFF was corrected from null to its default, false. 
[12:54:09] [Server thread/WARN]: Incorrect key other.PROJECTOR_OFFSET_CAP was corrected from null to its default, 60.0. 
[12:54:09] [Server thread/WARN]: Incorrect key other.FOG_PROJECTOR_MAX_RADIUS was corrected from null to its default, 30.0. 
[12:54:09] [Server thread/WARN]: Incorrect key other.CREATIVE_IGNORES_MANA_COSTS was corrected from null to its default, true. 
[12:54:09] [Server thread/WARN]: Incorrect key other.MANA_REGEN_HUNGER_FACTOR was corrected from null to its default, 1.0. 
[12:54:09] [Server thread/WARN]: Incorrect key other.MANA_INCREASE_LOG_PUNISHMENT was corrected from null to its default, false. 
[12:54:09] [Server thread/WARN]: Incorrect key other.MANA_INCREASE_PUNISHMENT_FACTOR was corrected from null to its default, 0.0. 
[12:54:09] [Server thread/WARN]: Incorrect key other.ATTUNED_DIAMOND_CAPACITY was corrected from null to its default, 10000. 
[12:54:09] [Server thread/WARN]: Incorrect key other.ATTUNED_EMERALD_CAPACITY was corrected from null to its default, 5000. 
[12:54:09] [Server thread/WARN]: Incorrect key other.MYSTIC_CODE_FIRST_SORCERY_BLACKLIST was corrected from null to its default, [mahoutsukai:scroll_boundary_drain_life]. 
[12:54:09] [Server thread/WARN]: Incorrect key other.MYSTIC_CODE_ENCHANT_BLACKLIST was corrected from null to its default, []. 
[12:54:09] [Server thread/WARN]: Incorrect key other.SPELL_BLACKLIST was corrected from null to its default, []. 
[12:54:09] [Server thread/WARN]: Incorrect key other.GAMESTAGES_ENABLED was corrected from null to its default, false. 
[12:54:09] [Server thread/WARN]: Incorrect key other.ONE_LIFE was corrected from null to its default, false. 
[12:54:09] [Server thread/WARN]: Configuration file C:\Users\kaues\AppData\Roaming\.minecraft\versions\Ender Tech\saves\Novo mundo (2)\serverconfig\forge-server.toml is not correct. Correcting
[12:54:09] [Server thread/WARN]: Incorrect key server was corrected from null to its default, SimpleCommentedConfig:{}. 
[12:54:09] [Server thread/WARN]: Incorrect key server.removeErroringEntities was corrected from null to its default, false. 
[12:54:09] [Server thread/WARN]: Incorrect key server.removeErroringTileEntities was corrected from null to its default, false. 
[12:54:09] [Server thread/WARN]: Incorrect key server.fullBoundingBoxLadders was corrected from null to its default, false. 
[12:54:09] [Server thread/WARN]: Incorrect key server.zombieBaseSummonChance was corrected from null to its default, 0.1. 
[12:54:09] [Server thread/WARN]: Incorrect key server.zombieBabyChance was corrected from null to its default, 0.05. 
[12:54:09] [Server thread/WARN]: Incorrect key server.logCascadingWorldGeneration was corrected from null to its default, true. 
[12:54:09] [Server thread/WARN]: Incorrect key server.fixVanillaCascading was corrected from null to its default, false. 
[12:54:09] [Server thread/WARN]: Incorrect key server.dimensionUnloadQueueDelay was corrected from null to its default, 0. 
[12:54:09] [Server thread/WARN]: Incorrect key server.treatEmptyTagsAsAir was corrected from null to its default, false. 
[12:54:09] [Server thread/WARN]: Incorrect key server.fixAdvancementLoading was corrected from null to its default, true. 
[12:54:09] [Server thread/WARN]: Configuration file C:\Users\kaues\AppData\Roaming\.minecraft\versions\Ender Tech\saves\Novo mundo (2)\serverconfig\cofh_core-server.toml is not correct. Correcting
[12:54:09] [Server thread/WARN]: Incorrect key Commands was corrected from null to its default, SimpleCommentedConfig:{}. 
[12:54:09] [Server thread/WARN]: Incorrect key Commands.Crafting Permission Level was corrected from null to its default, 2. 
[12:54:09] [Server thread/WARN]: Incorrect key Commands.EnderChest Permission Level was corrected from null to its default, 2. 
[12:54:09] [Server thread/WARN]: Incorrect key Commands.Heal Permission Level was corrected from null to its default, 2. 
[12:54:09] [Server thread/WARN]: Incorrect key Commands.Ignite Permission Level was corrected from null to its default, 2. 
[12:54:09] [Server thread/WARN]: Incorrect key Commands.Repair Permission Level was corrected from null to its default, 2. 
[12:54:09] [Server thread/WARN]: Incorrect key Enchantments was corrected from null to its default, SimpleCommentedConfig:{}. 
[12:54:09] [Server thread/WARN]: Incorrect key Enchantments.Improved Feather Falling was corrected from null to its default, true. 
[12:54:09] [Server thread/WARN]: Incorrect key Enchantments.Improved Mending was corrected from null to its default, true. 
[12:54:09] [Server thread/WARN]: Incorrect key Enchantments.Holding was corrected from null to its default, SimpleCommentedConfig:{}. 
[12:54:09] [Server thread/WARN]: Incorrect key Enchantments.Holding.Enable was corrected from null to its default, true. 
[12:54:09] [Server thread/WARN]: Incorrect key Enchantments.Holding.Treasure was corrected from null to its default, false. 
[12:54:09] [Server thread/WARN]: Incorrect key Enchantments.Holding.Max Level was corrected from null to its default, 4. 
[12:54:09] [Server thread/WARN]: Incorrect key Fishing was corrected from null to its default, SimpleCommentedConfig:{}. 
[12:54:09] [Server thread/WARN]: Incorrect key Fishing.Fishing Exhaustion was corrected from null to its default, false. 
[12:54:09] [Server thread/WARN]: Incorrect key Fishing.Fishing Exhaustion Amount was corrected from null to its default, 0.125. 
[12:54:09] [Server thread/WARN]: Incorrect key World was corrected from null to its default, SimpleCommentedConfig:{}. 
[12:54:09] [Server thread/WARN]: Incorrect key World.Sapling Growth Reduction was corrected from null to its default, false. 
[12:54:09] [Server thread/WARN]: Incorrect key World.Sapling Growth Reduction Factor was corrected from null to its default, 4. 
[12:54:09] [Server thread/WARN]: Configuration file C:\Users\kaues\AppData\Roaming\.minecraft\versions\Ender Tech\saves\Novo mundo (2)\serverconfig\ensorcellation-server.toml is not correct. Correcting
[12:54:09] [Server thread/WARN]: Incorrect key Enchantments was corrected from null to its default, SimpleCommentedConfig:{}. 
[12:54:10] [Server thread/WARN]: Incorrect key Enchantments.Magic Protection was corrected from null to its default, SimpleCommentedConfig:{}. 
[12:54:10] [Server thread/WARN]: Incorrect key Enchantments.Magic Protection.Enable was corrected from null to its default, true. 
[12:54:10] [Server thread/WARN]: Incorrect key Enchantments.Magic Protection.Treasure was corrected from null to its default, false. 
[12:54:10] [Server thread/WARN]: Incorrect key Enchantments.Magic Protection.Max Level was corrected from null to its default, 4. 
[12:54:10] [Server thread/WARN]: Incorrect key Enchantments.Displacement was corrected from null to its default, SimpleCommentedConfig:{}. 
[12:54:10] [Server thread/WARN]: Incorrect key Enchantments.Displacement.Enable was corrected from null to its default, false. 
[12:54:10] [Server thread/WARN]: Incorrect key Enchantments.Displacement.Treasure was corrected from null to its default, true. 
[12:54:10] [Server thread/WARN]: Incorrect key Enchantments.Displacement.Max Level was corrected from null to its default, 3. 
[12:54:10] [Server thread/WARN]: Incorrect key Enchantments.Displacement.Effect Chance was corrected from null to its default, 20. 
[12:54:10] [Server thread/WARN]: Incorrect key Enchantments.Displacement.Mobs Teleport Players was corrected from null to its default, false. 
[12:54:10] [Server thread/WARN]: Incorrect key Enchantments.Flaming Rebuke was corrected from null to its default, SimpleCommentedConfig:{}. 
[12:54:10] [Server thread/WARN]: Incorrect key Enchantments.Flaming Rebuke.Enable was corrected from null to its default, false. 
[12:54:10] [Server thread/WARN]: Incorrect key Enchantments.Flaming Rebuke.Treasure was corrected from null to its default, true. 
[12:54:10] [Server thread/WARN]: Incorrect key Enchantments.Flaming Rebuke.Max Level was corrected from null to its default, 3. 
[12:54:10] [Server thread/WARN]: Incorrect key Enchantments.Flaming Rebuke.Effect Chance was corrected from null to its default, 20. 
[12:54:10] [Server thread/WARN]: Incorrect key Enchantments.Flaming Rebuke.Mobs Knockback Players was corrected from null to its default, false. 
[12:54:10] [Server thread/WARN]: Incorrect key Enchantments.Chilling Rebuke was corrected from null to its default, SimpleCommentedConfig:{}. 
[12:54:10] [Server thread/WARN]: Incorrect key Enchantments.Chilling Rebuke.Enable was corrected from null to its default, false. 
[12:54:10] [Server thread/WARN]: Incorrect key Enchantments.Chilling Rebuke.Treasure was corrected from null to its default, true. 
[12:54:10] [Server thread/WARN]: Incorrect key Enchantments.Chilling Rebuke.Max Level was corrected from null to its default, 3. 
[12:54:10] [Server thread/WARN]: Incorrect key Enchantments.Chilling Rebuke.Effect Chance was corrected from null to its default, 20. 
[12:54:10] [Server thread/WARN]: Incorrect key Enchantments.Chilling Rebuke.Mobs Knockback Players was corrected from null to its default, false. 
[12:54:10] [Server thread/WARN]: Incorrect key Enchantments.Air Affinity was corrected from null to its default, SimpleCommentedConfig:{}. 
[12:54:10] [Server thread/WARN]: Incorrect key Enchantments.Air Affinity.Enable was corrected from null to its default, true. 
[12:54:10] [Server thread/WARN]: Incorrect key Enchantments.Air Affinity.Treasure was corrected from null to its default, false. 
[12:54:10] [Server thread/WARN]: Incorrect key Enchantments.Insight was corrected from null to its default, SimpleCommentedConfig:{}. 
[12:54:10] [Server thread/WARN]: Incorrect key Enchantments.Insight.Enable was corrected from null to its default, true. 
[12:54:10] [Server thread/WARN]: Incorrect key Enchantments.Insight.Treasure was corrected from null to its default, false. 
[12:54:10] [Server thread/WARN]: Incorrect key Enchantments.Insight.Max Level was corrected from null to its default, 3. 
[12:54:10] [Server thread/WARN]: Incorrect key Enchantments.Insight.Experience Amount was corrected from null to its default, 4. 
[12:54:10] [Server thread/WARN]: Incorrect key Enchantments.Gourmand was corrected from null to its default, SimpleCommentedConfig:{}. 
[12:54:10] [Server thread/WARN]: Incorrect key Enchantments.Gourmand.Enable was corrected from null to its default, false. 
[12:54:10] [Server thread/WARN]: Incorrect key Enchantments.Gourmand.Treasure was corrected from null to its default, false. 
[12:54:10] [Server thread/WARN]: Incorrect key Enchantments.Gourmand.Max Level was corrected from null to its default, 2. 
[12:54:10] [Server thread/WARN]: Incorrect key Enchantments.Reach was corrected from null to its default, SimpleCommentedConfig:{}. 
[12:54:10] [Server thread/WARN]: Incorrect key Enchantments.Reach.Enable was corrected from null to its default, true. 
[12:54:10] [Server thread/WARN]: Incorrect key Enchantments.Reach.Treasure was corrected from null to its default, true. 
[12:54:10] [Server thread/WARN]: Incorrect key Enchantments.Reach.Max Level was corrected from null to its default, 3. 
[12:54:10] [Server thread/WARN]: Incorrect key Enchantments.Vitality was corrected from null to its default, SimpleCommentedConfig:{}. 
[12:54:10] [Server thread/WARN]: Incorrect key Enchantments.Vitality.Enable was corrected from null to its default, true. 
[12:54:10] [Server thread/WARN]: Incorrect key Enchantments.Vitality.Treasure was corrected from null to its default, true. 
[12:54:10] [Server thread/WARN]: Incorrect key Enchantments.Vitality.Max Level was corrected from null to its default, 3. 
[12:54:10] [Server thread/WARN]: Incorrect key Enchantments.Vitality.Health / Level was corrected from null to its default, 4. 
[12:54:10] [Server thread/WARN]: Incorrect key Enchantments.Ender Disruption was corrected from null to its default, SimpleCommentedConfig:{}. 
[12:54:10] [Server thread/WARN]: Incorrect key Enchantments.Ender Disruption.Enable was corrected from null to its default, false. 
[12:54:10] [Server thread/WARN]: Incorrect key Enchantments.Ender Disruption.Treasure was corrected from null to its default, true. 
[12:54:10] [Server thread/WARN]: Incorrect key Enchantments.Ender Disruption.Max Level was corrected from null to its default, 5. 
[12:54:10] [Server thread/WARN]: Incorrect key Enchantments.Vigilante was corrected from null to its default, SimpleCommentedConfig:{}. 
[12:54:10] [Server thread/WARN]: Incorrect key Enchantments.Vigilante.Enable was corrected from null to its default, true. 
[12:54:10] [Server thread/WARN]: Incorrect key Enchantments.Vigilante.Treasure was corrected from null to its default, true. 
[12:54:10] [Server thread/WARN]: Incorrect key Enchantments.Vigilante.Max Level was corrected from null to its default, 5. 
[12:54:10] [Server thread/WARN]: Incorrect key Enchantments.Outlaw was corrected from null to its default, SimpleCommentedConfig:{}. 
[12:54:10] [Server thread/WARN]: Incorrect key Enchantments.Outlaw.Enable was corrected from null to its default, false. 
[12:54:10] [Server thread/WARN]: Incorrect key Enchantments.Outlaw.Treasure was corrected from null to its default, false. 
[12:54:10] [Server thread/WARN]: Incorrect key Enchantments.Outlaw.Max Level was corrected from null to its default, 5. 
[12:54:10] [Server thread/WARN]: Incorrect key Enchantments.Outlaw.Emerald Drops was corrected from null to its default, true. 
[12:54:10] [Server thread/WARN]: Incorrect key Enchantments.Cavalier was corrected from null to its default, SimpleCommentedConfig:{}. 
[12:54:10] [Server thread/WARN]: Incorrect key Enchantments.Cavalier.Enable was corrected from null to its default, false. 
[12:54:10] [Server thread/WARN]: Incorrect key Enchantments.Cavalier.Treasure was corrected from null to its default, true. 
[12:54:10] [Server thread/WARN]: Incorrect key Enchantments.Cavalier.Max Level was corrected from null to its default, 3. 
[12:54:10] [Server thread/WARN]: Incorrect key Enchantments.Frost Aspect was corrected from null to its default, SimpleCommentedConfig:{}. 
[12:54:10] [Server thread/WARN]: Incorrect key Enchantments.Frost Aspect.Enable was corrected from null to its default, true. 
[12:54:10] [Server thread/WARN]: Incorrect key Enchantments.Frost Aspect.Treasure was corrected from null to its default, true. 
[12:54:10] [Server thread/WARN]: Incorrect key Enchantments.Frost Aspect.Max Level was corrected from null to its default, 2. 
[12:54:10] [Server thread/WARN]: Incorrect key Enchantments.Instigating was corrected from null to its default, SimpleCommentedConfig:{}. 
[12:54:10] [Server thread/WARN]: Incorrect key Enchantments.Instigating.Enable was corrected from null to its default, false. 
[12:54:10] [Server thread/WARN]: Incorrect key Enchantments.Instigating.Treasure was corrected from null to its default, true. 
[12:54:10] [Server thread/WARN]: Incorrect key Enchantments.Leech was corrected from null to its default, SimpleCommentedConfig:{}. 
[12:54:10] [Server thread/WARN]: Incorrect key Enchantments.Leech.Enable was corrected from null to its default, true. 
[12:54:10] [Server thread/WARN]: Incorrect key Enchantments.Leech.Treasure was corrected from null to its default, false. 
[12:54:10] [Server thread/WARN]: Incorrect key Enchantments.Leech.Max Level was corrected from null to its default, 4. 
[12:54:10] [Server thread/WARN]: Incorrect key Enchantments.Magic Edge was corrected from null to its default, SimpleCommentedConfig:{}. 
[12:54:10] [Server thread/WARN]: Incorrect key Enchantments.Magic Edge.Enable was corrected from null to its default, true. 
[12:54:10] [Server thread/WARN]: Incorrect key Enchantments.Magic Edge.Treasure was corrected from null to its default, true. 
[12:54:10] [Server thread/WARN]: Incorrect key Enchantments.Magic Edge.Max Level was corrected from null to its default, 3. 
[12:54:10] [Server thread/WARN]: Incorrect key Enchantments.Vorpal was corrected from null to its default, SimpleCommentedConfig:{}. 
[12:54:10] [Server thread/WARN]: Incorrect key Enchantments.Vorpal.Enable was corrected from null to its default, true. 
[12:54:10] [Server thread/WARN]: Incorrect key Enchantments.Vorpal.Treasure was corrected from null to its default, true. 
[12:54:10] [Server thread/WARN]: Incorrect key Enchantments.Vorpal.Max Level was corrected from null to its default, 3. 
[12:54:10] [Server thread/WARN]: Incorrect key Enchantments.Vorpal.Base Critical Chance was corrected from null to its default, 5. 
[12:54:10] [Server thread/WARN]: Incorrect key Enchantments.Vorpal.Critical Chance / Level was corrected from null to its default, 5. 
[12:54:10] [Server thread/WARN]: Incorrect key Enchantments.Vorpal.Critical Damage Multiplier was corrected from null to its default, 5. 
[12:54:10] [Server thread/WARN]: Incorrect key Enchantments.Vorpal.Base Head Drop Chance was corrected from null to its default, 10. 
[12:54:10] [Server thread/WARN]: Incorrect key Enchantments.Vorpal.Head Drop Chance / Level was corrected from null to its default, 10. 
[12:54:10] [Server thread/WARN]: Incorrect key Enchantments.Excavating was corrected from null to its default, SimpleCommentedConfig:{}. 
[12:54:10] [Server thread/WARN]: Incorrect key Enchantments.Excavating.Enable was corrected from null to its default, true. 
[12:54:10] [Server thread/WARN]: Incorrect key Enchantments.Excavating.Treasure was corrected from null to its default, true. 
[12:54:10] [Server thread/WARN]: Incorrect key Enchantments.Hunter's Bounty was corrected from null to its default, SimpleCommentedConfig:{}. 
[12:54:10] [Server thread/WARN]: Incorrect key Enchantments.Hunter's Bounty.Enable was corrected from null to its default, true. 
[12:54:10] [Server thread/WARN]: Incorrect key Enchantments.Hunter's Bounty.Treasure was corrected from null to its default, true. 
[12:54:10] [Server thread/WARN]: Incorrect key Enchantments.Hunter's Bounty.Max Level was corrected from null to its default, 2. 
[12:54:10] [Server thread/WARN]: Incorrect key Enchantments.Hunter's Bounty.Effect Chance was corrected from null to its default, 50. 
[12:54:10] [Server thread/WARN]: Incorrect key Enchantments.Quick Draw was corrected from null to its default, SimpleCommentedConfig:{}. 
[12:54:10] [Server thread/WARN]: Incorrect key Enchantments.Quick Draw.Enable was corrected from null to its default, true. 
[12:54:10] [Server thread/WARN]: Incorrect key Enchantments.Quick Draw.Treasure was corrected from null to its default, false. 
[12:54:10] [Server thread/WARN]: Incorrect key Enchantments.Quick Draw.Max Level was corrected from null to its default, 3. 
[12:54:10] [Server thread/WARN]: Incorrect key Enchantments.Trueshot was corrected from null to its default, SimpleCommentedConfig:{}. 
[12:54:10] [Server thread/WARN]: Incorrect key Enchantments.Trueshot.Enable was corrected from null to its default, true. 
[12:54:10] [Server thread/WARN]: Incorrect key Enchantments.Trueshot.Treasure was corrected from null to its default, false. 
[12:54:10] [Server thread/WARN]: Incorrect key Enchantments.Trueshot.Max Level was corrected from null to its default, 2. 
[12:54:10] [Server thread/WARN]: Incorrect key Enchantments.Volley was corrected from null to its default, SimpleCommentedConfig:{}. 
[12:54:10] [Server thread/WARN]: Incorrect key Enchantments.Volley.Enable was corrected from null to its default, true. 
[12:54:10] [Server thread/WARN]: Incorrect key Enchantments.Volley.Treasure was corrected from null to its default, false. 
[12:54:10] [Server thread/WARN]: Incorrect key Enchantments.Angler's Bounty was corrected from null to its default, SimpleCommentedConfig:{}. 
[12:54:10] [Server thread/WARN]: Incorrect key Enchantments.Angler's Bounty.Enable was corrected from null to its default, true. 
[12:54:10] [Server thread/WARN]: Incorrect key Enchantments.Angler's Bounty.Treasure was corrected from null to its default, true. 
[12:54:10] [Server thread/WARN]: Incorrect key Enchantments.Angler's Bounty.Max Level was corrected from null to its default, 2. 
[12:54:10] [Server thread/WARN]: Incorrect key Enchantments.Angler's Bounty.Effect Chance was corrected from null to its default, 50. 
[12:54:10] [Server thread/WARN]: Incorrect key Enchantments.Pilfering was corrected from null to its default, SimpleCommentedConfig:{}. 
[12:54:10] [Server thread/WARN]: Incorrect key Enchantments.Pilfering.Enable was corrected from null to its default, true. 
[12:54:10] [Server thread/WARN]: Incorrect key Enchantments.Pilfering.Treasure was corrected from null to its default, true. 
[12:54:10] [Server thread/WARN]: Incorrect key Enchantments.Pilfering.Allow Player Stealing was corrected from null to its default, true. 
[12:54:10] [Server thread/WARN]: Incorrect key Enchantments.Furrowing was corrected from null to its default, SimpleCommentedConfig:{}. 
[12:54:10] [Server thread/WARN]: Incorrect key Enchantments.Furrowing.Enable was corrected from null to its default, true. 
[12:54:10] [Server thread/WARN]: Incorrect key Enchantments.Furrowing.Treasure was corrected from null to its default, false. 
[12:54:10] [Server thread/WARN]: Incorrect key Enchantments.Furrowing.Max Level was corrected from null to its default, 4. 
[12:54:10] [Server thread/WARN]: Incorrect key Enchantments.Tilling was corrected from null to its default, SimpleCommentedConfig:{}. 
[12:54:10] [Server thread/WARN]: Incorrect key Enchantments.Tilling.Enable was corrected from null to its default, true. 
[12:54:10] [Server thread/WARN]: Incorrect key Enchantments.Tilling.Treasure was corrected from null to its default, true. 
[12:54:10] [Server thread/WARN]: Incorrect key Enchantments.Tilling.Max Level was corrected from null to its default, 4. 
[12:54:10] [Server thread/WARN]: Incorrect key Enchantments.Weeding was corrected from null to its default, SimpleCommentedConfig:{}. 
[12:54:10] [Server thread/WARN]: Incorrect key Enchantments.Weeding.Enable was corrected from null to its default, false. 
[12:54:10] [Server thread/WARN]: Incorrect key Enchantments.Weeding.Treasure was corrected from null to its default, false. 
[12:54:10] [Server thread/WARN]: Incorrect key Enchantments.Bulwark was corrected from null to its default, SimpleCommentedConfig:{}. 
[12:54:10] [Server thread/WARN]: Incorrect key Enchantments.Bulwark.Enable was corrected from null to its default, true. 
[12:54:10] [Server thread/WARN]: Incorrect key Enchantments.Bulwark.Treasure was corrected from null to its default, false. 
[12:54:10] [Server thread/WARN]: Incorrect key Enchantments.Phalanx was corrected from null to its default, SimpleCommentedConfig:{}. 
[12:54:10] [Server thread/WARN]: Incorrect key Enchantments.Phalanx.Enable was corrected from null to its default, true. 
[12:54:10] [Server thread/WARN]: Incorrect key Enchantments.Phalanx.Treasure was corrected from null to its default, false. 
[12:54:10] [Server thread/WARN]: Incorrect key Enchantments.Phalanx.Max Level was corrected from null to its default, 2. 
[12:54:10] [Server thread/WARN]: Incorrect key Enchantments.Soulbound was corrected from null to its default, SimpleCommentedConfig:{}. 
[12:54:10] [Server thread/WARN]: Incorrect key Enchantments.Soulbound.Enable was corrected from null to its default, true. 
[12:54:10] [Server thread/WARN]: Incorrect key Enchantments.Soulbound.Treasure was corrected from null to its default, false. 
[12:54:10] [Server thread/WARN]: Incorrect key Enchantments.Soulbound.Max Level was corrected from null to its default, 3. 
[12:54:10] [Server thread/WARN]: Incorrect key Enchantments.Soulbound.Permanent was corrected from null to its default, true. 
[12:54:10] [Server thread/WARN]: Incorrect key Enchantments.Curse of Foolishness was corrected from null to its default, SimpleCommentedConfig:{}. 
[12:54:10] [Server thread/WARN]: Incorrect key Enchantments.Curse of Foolishness.Enable was corrected from null to its default, true. 
[12:54:10] [Server thread/WARN]: Incorrect key Enchantments.Curse of Mercy was corrected from null to its default, SimpleCommentedConfig:{}. 
[12:54:10] [Server thread/WARN]: Incorrect key Enchantments.Curse of Mercy.Enable was corrected from null to its default, true. 
[12:54:10] [Server thread/WARN]: Incorrect key Overrides was corrected from null to its default, SimpleCommentedConfig:{}. 
[12:54:10] [Server thread/WARN]: Incorrect key Overrides.Protection was corrected from null to its default, SimpleCommentedConfig:{}. 
[12:54:10] [Server thread/WARN]: Incorrect key Overrides.Protection.Enable was corrected from null to its default, true. 
[12:54:10] [Server thread/WARN]: Incorrect key Overrides.Protection.Max Level was corrected from null to its default, 4. 
[12:54:10] [Server thread/WARN]: Incorrect key Overrides.Blast Protection was corrected from null to its default, SimpleCommentedConfig:{}. 
[12:54:10] [Server thread/WARN]: Incorrect key Overrides.Blast Protection.Enable was corrected from null to its default, true. 
[12:54:10] [Server thread/WARN]: Incorrect key Overrides.Blast Protection.Max Level was corrected from null to its default, 4. 
[12:54:10] [Server thread/WARN]: Incorrect key Overrides.Feather Falling was corrected from null to its default, SimpleCommentedConfig:{}. 
[12:54:10] [Server thread/WARN]: Incorrect key Overrides.Feather Falling.Enable was corrected from null to its default, true. 
[12:54:10] [Server thread/WARN]: Incorrect key Overrides.Feather Falling.Max Level was corrected from null to its default, 4. 
[12:54:10] [Server thread/WARN]: Incorrect key Overrides.Fire Protection was corrected from null to its default, SimpleCommentedConfig:{}. 
[12:54:10] [Server thread/WARN]: Incorrect key Overrides.Fire Protection.Enable was corrected from null to its default, true. 
[12:54:10] [Server thread/WARN]: Incorrect key Overrides.Fire Protection.Max Level was corrected from null to its default, 4. 
[12:54:10] [Server thread/WARN]: Incorrect key Overrides.Projectile Protection was corrected from null to its default, SimpleCommentedConfig:{}. 
[12:54:10] [Server thread/WARN]: Incorrect key Overrides.Projectile Protection.Enable was corrected from null to its default, true. 
[12:54:10] [Server thread/WARN]: Incorrect key Overrides.Projectile Protection.Max Level was corrected from null to its default, 4. 
[12:54:10] [Server thread/WARN]: Incorrect key Overrides.Fire Aspect was corrected from null to its default, SimpleCommentedConfig:{}. 
[12:54:10] [Server thread/WARN]: Incorrect key Overrides.Fire Aspect.Enable was corrected from null to its default, true. 
[12:54:10] [Server thread/WARN]: Incorrect key Overrides.Fire Aspect.Max Level was corrected from null to its default, 2. 
[12:54:10] [Server thread/WARN]: Incorrect key Overrides.Frost Walker was corrected from null to its default, SimpleCommentedConfig:{}. 
[12:54:10] [Server thread/WARN]: Incorrect key Overrides.Frost Walker.Enable was corrected from null to its default, true. 
[12:54:10] [Server thread/WARN]: Incorrect key Overrides.Frost Walker.Treasure was corrected from null to its default, true. 
[12:54:10] [Server thread/WARN]: Incorrect key Overrides.Frost Walker.Max Level was corrected from null to its default, 2. 
[12:54:10] [Server thread/WARN]: Incorrect key Overrides.Frost Walker.Freeze Lava was corrected from null to its default, true. 
[12:54:10] [Server thread/WARN]: Incorrect key Overrides.Knockback was corrected from null to its default, SimpleCommentedConfig:{}. 
[12:54:10] [Server thread/WARN]: Incorrect key Overrides.Knockback.Enable was corrected from null to its default, true. 
[12:54:10] [Server thread/WARN]: Incorrect key Overrides.Knockback.Max Level was corrected from null to its default, 2. 
[12:54:10] [Server thread/WARN]: Incorrect key Overrides.Looting was corrected from null to its default, SimpleCommentedConfig:{}. 
[12:54:10] [Server thread/WARN]: Incorrect key Overrides.Looting.Enable was corrected from null to its default, true. 
[12:54:10] [Server thread/WARN]: Incorrect key Overrides.Looting.Max Level was corrected from null to its default, 3. 
[12:54:10] [Server thread/WARN]: Incorrect key Overrides.Thorns was corrected from null to its default, SimpleCommentedConfig:{}. 
[12:54:10] [Server thread/WARN]: Incorrect key Overrides.Thorns.Enable was corrected from null to its default, true. 
[12:54:10] [Server thread/WARN]: Incorrect key Overrides.Thorns.Max Level was corrected from null to its default, 4. 
[12:54:10] [Server thread/WARN]: Incorrect key Overrides.Thorns.Effect Chance was corrected from null to its default, 15. 
[12:54:10] [Server thread/WARN]: Incorrect key Overrides.Mending was corrected from null to its default, SimpleCommentedConfig:{}. 
[12:54:10] [Server thread/WARN]: Incorrect key Overrides.Mending.Alternate Mending was corrected from null to its default, false. 
[12:54:10] [Server thread/WARN]: Incorrect key Overrides.Mending.Treasure was corrected from null to its default, true. 
[12:54:10] [Server thread/WARN]: Incorrect key Overrides.Mending.Anvil Damage Chance was corrected from null to its default, 3. 
[12:54:10] [Server thread/WARN]: Configuration file C:\Users\kaues\AppData\Roaming\.minecraft\versions\Ender Tech\saves\Novo mundo (2)\serverconfig\mining_dimension-server.toml is not correct. Correcting
[12:54:10] [Server thread/WARN]: Incorrect key overworld_dimension was corrected from null to its default, minecraft:overworld. 
[12:54:10] [Server thread/WARN]: Incorrect key spawn_deep was corrected from null to its default, true. 
[12:54:10] [Server thread/WARN]: Configuration file C:\Users\kaues\AppData\Roaming\.minecraft\versions\Ender Tech\saves\Novo mundo (2)\serverconfig\curios-server.toml is not correct. Correcting
[12:54:10] [Server thread/WARN]: Incorrect key curiosSettings was corrected from null to its default, []. 
[12:54:10] [Server thread/WARN]: Configuration file C:\Users\kaues\AppData\Roaming\.minecraft\versions\Ender Tech\saves\Novo mundo (2)\serverconfig\gravestone-server.toml is not correct. Correcting
[12:54:10] [Server thread/WARN]: Incorrect key enable_obituary was corrected from null to its default, true. 
[12:54:10] [Server thread/WARN]: Incorrect key replaceable_blocks was corrected from null to its default, [#gravestone:grave_replaceable]. 
[12:54:10] [Server thread/WARN]: Incorrect key remove_obituary was corrected from null to its default, false. 
[12:54:10] [Server thread/WARN]: Incorrect key only_owners_can_break was corrected from null to its default, false. 
[12:54:10] [Server thread/WARN]: Incorrect key spawn_ghost was corrected from null to its default, false. 
[12:54:10] [Server thread/WARN]: Incorrect key friendly_ghost was corrected from null to its default, true. 
[12:54:10] [Server thread/WARN]: Incorrect key sneak_pickup was corrected from null to its default, false. 
[12:54:10] [Server thread/WARN]: Incorrect key break_pickup was corrected from null to its default, true. 
[12:54:10] [Server thread/WARN]: Configuration file C:\Users\kaues\AppData\Roaming\.minecraft\versions\Ender Tech\saves\Novo mundo (2)\serverconfig\securitycraft-server.toml is not correct. Correcting
[12:54:10] [Server thread/WARN]: Incorrect key allowCodebreakerItem was corrected from null to its default, true. 
[12:54:10] [Server thread/WARN]: Incorrect key allowAdminTool was corrected from null to its default, false. 
[12:54:10] [Server thread/WARN]: Incorrect key shouldSpawnFire was corrected from null to its default, true. 
[12:54:10] [Server thread/WARN]: Incorrect key ableToBreakMines was corrected from null to its default, true. 
[12:54:10] [Server thread/WARN]: Incorrect key smallerMineExplosion was corrected from null to its default, false. 
[12:54:10] [Server thread/WARN]: Incorrect key mineExplodesWhenInCreative was corrected from null to its default, true. 
[12:54:10] [Server thread/WARN]: Incorrect key mineExplosionsBreakBlocks was corrected from null to its default, true. 
[12:54:10] [Server thread/WARN]: Incorrect key laserBlockRange was corrected from null to its default, 5. 
[12:54:10] [Server thread/WARN]: Incorrect key inventoryScannerRange was corrected from null to its default, 2. 
[12:54:10] [Server thread/WARN]: Incorrect key maxAlarmRange was corrected from null to its default, 100. 
[12:54:10] [Server thread/WARN]: Incorrect key allowBlockClaim was corrected from null to its default, false. 
[12:54:10] [Server thread/WARN]: Incorrect key respect_invisibility was corrected from null to its default, false. 
[12:54:10] [Server thread/WARN]: Incorrect key reinforced_block_tint was corrected from null to its default, true. 
[12:54:10] [Server thread/WARN]: Incorrect key force_reinforced_block_tint was corrected from null to its default, false. 
[12:54:10] [Server thread/WARN]: Incorrect key retinalScannerFace was corrected from null to its default, true. 
[12:54:10] [Server thread/WARN]: Configuration file C:\Users\kaues\AppData\Roaming\.minecraft\versions\Ender Tech\saves\Novo mundo (2)\serverconfig\fluxnetworks-server.toml is not correct. Correcting
[12:54:10] [Server thread/WARN]: Incorrect key energy was corrected from null to its default, SimpleCommentedConfig:{}. 
[12:54:10] [Server thread/WARN]: Incorrect key energy.defaultLimit was corrected from null to its default, 800000. 
[12:54:10] [Server thread/WARN]: Incorrect key energy.basicCapacity was corrected from null to its default, 1000000. 
[12:54:10] [Server thread/WARN]: Incorrect key energy.basicTransfer was corrected from null to its default, 20000. 
[12:54:10] [Server thread/WARN]: Incorrect key energy.herculeanCapacity was corrected from null to its default, 8000000. 
[12:54:10] [Server thread/WARN]: Incorrect key energy.herculeanTransfer was corrected from null to its default, 120000. 
[12:54:10] [Server thread/WARN]: Incorrect key energy.gargantuanCapacity was corrected from null to its default, 128000000. 
[12:54:10] [Server thread/WARN]: Incorrect key energy.gargantuanTransfer was corrected from null to its default, 1440000. 
[12:54:10] [Server thread/INFO]: SERVER CONFIG LOADED
[12:54:10] [Server thread/WARN]: Configuration file C:\Users\kaues\AppData\Roaming\.minecraft\versions\Ender Tech\saves\Novo mundo (2)\serverconfig\elevatorid-server.toml is not correct. Correcting
[12:54:10] [Server thread/WARN]: Incorrect key General was corrected from null to its default, SimpleCommentedConfig:{}. 
[12:54:10] [Server thread/WARN]: Incorrect key General.sameColor was corrected from null to its default, false. 
[12:54:10] [Server thread/WARN]: Incorrect key General.range was corrected from null to its default, 256. 
[12:54:10] [Server thread/WARN]: Incorrect key General.precisionTarget was corrected from null to its default, true. 
[12:54:10] [Server thread/WARN]: Incorrect key General.mobSpawn was corrected from null to its default, false. 
[12:54:10] [Server thread/WARN]: Incorrect key General.resetPitchNormal was corrected from null to its default, false. 
[12:54:10] [Server thread/WARN]: Incorrect key General.resetPitchDirectional was corrected from null to its default, true. 
[12:54:10] [Server thread/WARN]: Incorrect key General.useXP was corrected from null to its default, false. 
[12:54:10] [Server thread/WARN]: Incorrect key General.XPPointsAmount was corrected from null to its default, 1. 
[12:54:10] [Server thread/WARN]: Configuration file C:\Users\kaues\AppData\Roaming\.minecraft\versions\Ender Tech\saves\Novo mundo (2)\serverconfig\vehicle-server.toml is not correct. Correcting
[12:54:10] [Server thread/WARN]: Incorrect key common was corrected from null to its default, SimpleCommentedConfig:{}. 
[12:54:10] [Server thread/WARN]: Incorrect key common.general was corrected from null to its default, SimpleCommentedConfig:{}. 
[12:54:10] [Server thread/WARN]: Incorrect key common.general.fuelEnabled was corrected from null to its default, true. 
[12:54:10] [Server thread/WARN]: Incorrect key common.general.vehicleDamage was corrected from null to its default, true. 
[12:54:10] [Server thread/WARN]: Incorrect key common.general.pickUpVehicles was corrected from null to its default, true. 
[12:54:10] [Server thread/WARN]: Incorrect key common.general.fuelConsumptionModifier was corrected from null to its default, 1.0. 
[12:54:10] [Server thread/WARN]: Incorrect key common.trailer was corrected from null to its default, SimpleCommentedConfig:{}. 
[12:54:10] [Server thread/WARN]: Incorrect key common.trailer.trailerDetachThreshold was corrected from null to its default, 6.0. 
[12:54:10] [Server thread/WARN]: Incorrect key common.trailer.trailerSyncCooldown was corrected from null to its default, 100. 
[12:54:10] [Server thread/WARN]: Incorrect key common.trailer.trailerInventorySyncCooldown was corrected from null to its default, 20. 
[12:54:10] [Server thread/WARN]: Incorrect key common.blocks was corrected from null to its default, SimpleCommentedConfig:{}. 
[12:54:10] [Server thread/WARN]: Incorrect key common.blocks.gas_pump was corrected from null to its default, SimpleCommentedConfig:{}. 
[12:54:10] [Server thread/WARN]: Incorrect key common.blocks.gas_pump.maxHoseDistance was corrected from null to its default, 6.0. 
[12:54:10] [Server thread/WARN]: Incorrect key common.blocks.gas_pump.gasPumpCapacity was corrected from null to its default, 50000. 
[12:54:10] [Server thread/WARN]: Incorrect key common.blocks.fluid_pipe was corrected from null to its default, SimpleCommentedConfig:{}. 
[12:54:10] [Server thread/WARN]: Incorrect key common.blocks.fluid_pipe.pipeTransferAmount was corrected from null to its default, 50. 
[12:54:10] [Server thread/WARN]: Incorrect key common.blocks.fluid_pipe.pipeCapacity was corrected from null to its default, 500. 
[12:54:10] [Server thread/WARN]: Incorrect key common.blocks.fluid_pump was corrected from null to its default, SimpleCommentedConfig:{}. 
[12:54:10] [Server thread/WARN]: Incorrect key common.blocks.fluid_pump.pumpTransferAmount was corrected from null to its default, 50. 
[12:54:10] [Server thread/WARN]: Incorrect key common.blocks.fluid_pump.pumpCapacity was corrected from null to its default, 500. 
[12:54:10] [Server thread/WARN]: Incorrect key common.blocks.fluid_extractor was corrected from null to its default, SimpleCommentedConfig:{}. 
[12:54:10] [Server thread/WARN]: Incorrect key common.blocks.fluid_extractor.extractorExtractTime was corrected from null to its default, 600. 
[12:54:10] [Server thread/WARN]: Incorrect key common.blocks.fluid_extractor.extractorCapacity was corrected from null to its default, 5000. 
[12:54:10] [Server thread/WARN]: Incorrect key common.blocks.fluid_mixer was corrected from null to its default, SimpleCommentedConfig:{}. 
[12:54:10] [Server thread/WARN]: Incorrect key common.blocks.fluid_mixer.mixerMixTime was corrected from null to its default, 100. 
[12:54:10] [Server thread/WARN]: Incorrect key common.blocks.fluid_mixer.mixerInputCapacity was corrected from null to its default, 5000. 
[12:54:10] [Server thread/WARN]: Incorrect key common.blocks.fluid_mixer.mixerOutputCapacity was corrected from null to its default, 10000. 
[12:54:10] [Server thread/WARN]: Incorrect key common.blocks.fuel_drum was corrected from null to its default, SimpleCommentedConfig:{}. 
[12:54:10] [Server thread/WARN]: Incorrect key common.blocks.fuel_drum.fuelDrumCapacity was corrected from null to its default, 40000. 
[12:54:10] [Server thread/WARN]: Incorrect key common.blocks.fuel_drum.industrialFuelDrumCapacity was corrected from null to its default, 75000. 
[12:54:11] [Server thread/WARN]: Configuration file C:\Users\kaues\AppData\Roaming\.minecraft\versions\Ender Tech\saves\Novo mundo (2)\serverconfig\constructionwand-server.toml is not correct. Correcting
[12:54:11] [Server thread/WARN]: Incorrect key stone_wand was corrected from null to its default, SimpleCommentedConfig:{}. 
[12:54:11] [Server thread/WARN]: Incorrect key stone_wand.durability was corrected from null to its default, 131. 
[12:54:11] [Server thread/WARN]: Incorrect key stone_wand.limit was corrected from null to its default, 9. 
[12:54:11] [Server thread/WARN]: Incorrect key stone_wand.angel was corrected from null to its default, 0. 
[12:54:11] [Server thread/WARN]: Incorrect key stone_wand.destruction was corrected from null to its default, 0. 
[12:54:11] [Server thread/WARN]: Incorrect key stone_wand.upgradeable was corrected from null to its default, false. 
[12:54:11] [Server thread/WARN]: Incorrect key iron_wand was corrected from null to its default, SimpleCommentedConfig:{}. 
[12:54:11] [Server thread/WARN]: Incorrect key iron_wand.durability was corrected from null to its default, 250. 
[12:54:11] [Server thread/WARN]: Incorrect key iron_wand.limit was corrected from null to its default, 27. 
[12:54:11] [Server thread/WARN]: Incorrect key iron_wand.angel was corrected from null to its default, 2. 
[12:54:11] [Server thread/WARN]: Incorrect key iron_wand.destruction was corrected from null to its default, 9. 
[12:54:11] [Server thread/WARN]: Incorrect key iron_wand.upgradeable was corrected from null to its default, true. 
[12:54:11] [Server thread/WARN]: Incorrect key diamond_wand was corrected from null to its default, SimpleCommentedConfig:{}. 
[12:54:11] [Server thread/WARN]: Incorrect key diamond_wand.durability was corrected from null to its default, 1561. 
[12:54:11] [Server thread/WARN]: Incorrect key diamond_wand.limit was corrected from null to its default, 128. 
[12:54:11] [Server thread/WARN]: Incorrect key diamond_wand.angel was corrected from null to its default, 8. 
[12:54:11] [Server thread/WARN]: Incorrect key diamond_wand.destruction was corrected from null to its default, 25. 
[12:54:11] [Server thread/WARN]: Incorrect key diamond_wand.upgradeable was corrected from null to its default, true. 
[12:54:11] [Server thread/WARN]: Incorrect key infinity_wand was corrected from null to its default, SimpleCommentedConfig:{}. 
[12:54:11] [Server thread/WARN]: Incorrect key infinity_wand.limit was corrected from null to its default, 1024. 
[12:54:11] [Server thread/WARN]: Incorrect key infinity_wand.angel was corrected from null to its default, 16. 
[12:54:11] [Server thread/WARN]: Incorrect key infinity_wand.destruction was corrected from null to its default, 81. 
[12:54:11] [Server thread/WARN]: Incorrect key infinity_wand.upgradeable was corrected from null to its default, true. 
[12:54:11] [Server thread/WARN]: Incorrect key misc was corrected from null to its default, SimpleCommentedConfig:{}. 
[12:54:11] [Server thread/WARN]: Incorrect key misc.InfinityWandCreative was corrected from null to its default, 2048. 
[12:54:11] [Server thread/WARN]: Incorrect key misc.MaxRange was corrected from null to its default, 100. 
[12:54:11] [Server thread/WARN]: Incorrect key misc.UndoHistory was corrected from null to its default, 3. 
[12:54:11] [Server thread/WARN]: Incorrect key misc.AngelFalling was corrected from null to its default, false. 
[12:54:11] [Server thread/WARN]: Incorrect key misc.SimilarBlocks was corrected from null to its default, [minecraft:dirt;minecraft:grass_block;minecraft:coarse_dirt;minecraft:podzol;minecraft:mycelium;minecraft:farmland;minecraft:grass_path]. 
[12:54:11] [Server thread/WARN]: Incorrect key tileentity was corrected from null to its default, SimpleCommentedConfig:{}. 
[12:54:11] [Server thread/WARN]: Incorrect key tileentity.TEList was corrected from null to its default, [chiselsandbits]. 
[12:54:11] [Server thread/WARN]: Incorrect key tileentity.TEWhitelist was corrected from null to its default, false. 
[12:54:11] [Server thread/WARN]: Configuration file C:\Users\kaues\AppData\Roaming\.minecraft\versions\Ender Tech\saves\Novo mundo (2)\serverconfig\create-server.toml is not correct. Correcting
[12:54:11] [Server thread/WARN]: Incorrect key infrastructure was corrected from null to its default, SimpleCommentedConfig:{}. 
[12:54:11] [Server thread/WARN]: Incorrect key infrastructure.tickrateSyncTimer was corrected from null to its default, 20. 
[12:54:11] [Server thread/WARN]: Incorrect key recipes was corrected from null to its default, SimpleCommentedConfig:{}. 
[12:54:11] [Server thread/WARN]: Incorrect key recipes.bulkPressing was corrected from null to its default, false. 
[12:54:11] [Server thread/WARN]: Incorrect key recipes.bulkCutting was corrected from null to its default, false. 
[12:54:11] [Server thread/WARN]: Incorrect key recipes.allowShapelessInMixer was corrected from null to its default, true. 
[12:54:11] [Server thread/WARN]: Incorrect key recipes.allowShapedSquareInPress was corrected from null to its default, true. 
[12:54:11] [Server thread/WARN]: Incorrect key recipes.allowRegularCraftingInCrafter was corrected from null to its default, true. 
[12:54:11] [Server thread/WARN]: Incorrect key recipes.allowBiggerFireworksInCrafter was corrected from null to its default, false. 
[12:54:11] [Server thread/WARN]: Incorrect key recipes.allowStonecuttingOnSaw was corrected from null to its default, true. 
[12:54:11] [Server thread/WARN]: Incorrect key recipes.allowWoodcuttingOnSaw was corrected from null to its default, true. 
[12:54:11] [Server thread/WARN]: Incorrect key recipes.allowCastingBySpout was corrected from null to its default, true. 
[12:54:11] [Server thread/WARN]: Incorrect key recipes.lightSourceCountForRefinedRadiance was corrected from null to its default, 10. 
[12:54:11] [Server thread/WARN]: Incorrect key recipes.enableRefinedRadianceRecipe was corrected from null to its default, true. 
[12:54:11] [Server thread/WARN]: Incorrect key recipes.enableShadowSteelRecipe was corrected from null to its default, true. 
[12:54:11] [Server thread/WARN]: Incorrect key kinetics was corrected from null to its default, SimpleCommentedConfig:{}. 
[12:54:11] [Server thread/WARN]: Incorrect key kinetics.disableStress was corrected from null to its default, false. 
[12:54:11] [Server thread/WARN]: Incorrect key kinetics.maxBeltLength was corrected from null to its default, 20. 
[12:54:11] [Server thread/WARN]: Incorrect key kinetics.crushingDamage was corrected from null to its default, 4. 
[12:54:11] [Server thread/WARN]: Incorrect key kinetics.maxMotorSpeed was corrected from null to its default, 256. 
[12:54:11] [Server thread/WARN]: Incorrect key kinetics.waterWheelBaseSpeed was corrected from null to its default, 4. 
[12:54:11] [Server thread/WARN]: Incorrect key kinetics.waterWheelFlowSpeed was corrected from null to its default, 4. 
[12:54:11] [Server thread/WARN]: Incorrect key kinetics.furnaceEngineSpeed was corrected from null to its default, 16. 
[12:54:11] [Server thread/WARN]: Incorrect key kinetics.maxRotationSpeed was corrected from null to its default, 256. 
[12:54:11] [Server thread/WARN]: Incorrect key kinetics.ignoreDeployerAttacks was corrected from null to its default, CREEPERS. 
[12:54:11] [Server thread/WARN]: Incorrect key kinetics.kineticValidationFrequency was corrected from null to its default, 60. 
[12:54:11] [Server thread/WARN]: Incorrect key kinetics.crankHungerMultiplier was corrected from null to its default, 0.009999999776482582. 
[12:54:11] [Server thread/WARN]: Incorrect key kinetics.minimumWindmillSails was corrected from null to its default, 8. 
[12:54:11] [Server thread/WARN]: Incorrect key kinetics.windmillSailsPerRPM was corrected from null to its default, 8. 
[12:54:11] [Server thread/WARN]: Incorrect key kinetics.maxEjectorDistance was corrected from null to its default, 32. 
[12:54:11] [Server thread/WARN]: Incorrect key kinetics.ejectorScanInterval was corrected from null to its default, 120. 
[12:54:11] [Server thread/WARN]: Incorrect key kinetics.encasedFan was corrected from null to its default, SimpleCommentedConfig:{}. 
[12:54:11] [Server thread/WARN]: Incorrect key kinetics.encasedFan.fanPushDistance was corrected from null to its default, 20. 
[12:54:11] [Server thread/WARN]: Incorrect key kinetics.encasedFan.fanPullDistance was corrected from null to its default, 20. 
[12:54:11] [Server thread/WARN]: Incorrect key kinetics.encasedFan.fanBlockCheckRate was corrected from null to its default, 30. 
[12:54:11] [Server thread/WARN]: Incorrect key kinetics.encasedFan.fanRotationArgmax was corrected from null to its default, 256. 
[12:54:11] [Server thread/WARN]: Incorrect key kinetics.encasedFan.generatingFanSpeed was corrected from null to its default, 4. 
[12:54:11] [Server thread/WARN]: Incorrect key kinetics.encasedFan.inWorldProcessingTime was corrected from null to its default, 150. 
[12:54:11] [Server thread/WARN]: Incorrect key kinetics.contraptions was corrected from null to its default, SimpleCommentedConfig:{}. 
[12:54:11] [Server thread/WARN]: Incorrect key kinetics.contraptions.maxBlocksMoved was corrected from null to its default, 2048. 
[12:54:11] [Server thread/WARN]: Incorrect key kinetics.contraptions.maxChassisRange was corrected from null to its default, 16. 
[12:54:11] [Server thread/WARN]: Incorrect key kinetics.contraptions.maxPistonPoles was corrected from null to its default, 64. 
[12:54:11] [Server thread/WARN]: Incorrect key kinetics.contraptions.maxRopeLength was corrected from null to its default, 128. 
[12:54:11] [Server thread/WARN]: Incorrect key kinetics.contraptions.maxCartCouplingLength was corrected from null to its default, 32. 
[12:54:11] [Server thread/WARN]: Incorrect key kinetics.contraptions.movableSpawners was corrected from null to its default, NO_PICKUP. 
[12:54:11] [Server thread/WARN]: Incorrect key kinetics.contraptions.movableObsidian was corrected from null to its default, UNMOVABLE. 
[12:54:11] [Server thread/WARN]: Incorrect key kinetics.contraptions.moveItemsToStorage was corrected from null to its default, true. 
[12:54:11] [Server thread/WARN]: Incorrect key kinetics.contraptions.harvestPartiallyGrown was corrected from null to its default, false. 
[12:54:11] [Server thread/WARN]: Incorrect key kinetics.contraptions.harvesterReplants was corrected from null to its default, true. 
[12:54:11] [Server thread/WARN]: Incorrect key kinetics.stressValues was corrected from null to its default, SimpleCommentedConfig:{}. 
[12:54:11] [Server thread/WARN]: Incorrect key kinetics.stressValues.v2 was corrected from null to its default, SimpleCommentedConfig:{}. 
[12:54:11] [Server thread/WARN]: Incorrect key kinetics.stressValues.v2.impact was corrected from null to its default, SimpleCommentedConfig:{}. 
[12:54:11] [Server thread/WARN]: Incorrect key kinetics.stressValues.v2.impact.deployer was corrected from null to its default, 4.0. 
[12:54:11] [Server thread/WARN]: Incorrect key kinetics.stressValues.v2.impact.mechanical_piston was corrected from null to its default, 4.0. 
[12:54:11] [Server thread/WARN]: Incorrect key kinetics.stressValues.v2.impact.millstone was corrected from null to its default, 4.0. 
[12:54:11] [Server thread/WARN]: Incorrect key kinetics.stressValues.v2.impact.mechanical_bearing was corrected from null to its default, 4.0. 
[12:54:11] [Server thread/WARN]: Incorrect key kinetics.stressValues.v2.impact.clockwork_bearing was corrected from null to its default, 4.0. 
[12:54:11] [Server thread/WARN]: Incorrect key kinetics.stressValues.v2.impact.cuckoo_clock was corrected from null to its default, 1.0. 
[12:54:11] [Server thread/WARN]: Incorrect key kinetics.stressValues.v2.impact.speedometer was corrected from null to its default, 0.0. 
[12:54:11] [Server thread/WARN]: Incorrect key kinetics.stressValues.v2.impact.copper_backtank was corrected from null to its default, 4.0. 
[12:54:11] [Server thread/WARN]: Incorrect key kinetics.stressValues.v2.impact.mechanical_saw was corrected from null to its default, 4.0. 
[12:54:11] [Server thread/WARN]: Incorrect key kinetics.stressValues.v2.impact.flywheel was corrected from null to its default, 0.0. 
[12:54:11] [Server thread/WARN]: Incorrect key kinetics.stressValues.v2.impact.encased_chain_drive was corrected from null to its default, 0.0. 
[12:54:11] [Server thread/WARN]: Incorrect key kinetics.stressValues.v2.impact.clutch was corrected from null to its default, 0.0. 
[12:54:11] [Server thread/WARN]: Incorrect key kinetics.stressValues.v2.impact.encased_fan was corrected from null to its default, 2.0. 
[12:54:11] [Server thread/WARN]: Incorrect key kinetics.stressValues.v2.impact.adjustable_chain_gearshift was corrected from null to its default, 0.0. 
[12:54:11] [Server thread/WARN]: Incorrect key kinetics.stressValues.v2.impact.mechanical_pump was corrected from null to its default, 4.0. 
[12:54:11] [Server thread/WARN]: Incorrect key kinetics.stressValues.v2.impact.crushing_wheel was corrected from null to its default, 8.0. 
[12:54:11] [Server thread/WARN]: Incorrect key kinetics.stressValues.v2.impact.mechanical_mixer was corrected from null to its default, 4.0. 
[12:54:11] [Server thread/WARN]: Incorrect key kinetics.stressValues.v2.impact.gantry_shaft was corrected from null to its default, 0.0. 
[12:54:11] [Server thread/WARN]: Incorrect key kinetics.stressValues.v2.impact.rope_pulley was corrected from null to its default, 4.0. 
[12:54:11] [Server thread/WARN]: Incorrect key kinetics.stressValues.v2.impact.rotation_speed_controller was corrected from null to its default, 0.0. 
[12:54:11] [Server thread/WARN]: Incorrect key kinetics.stressValues.v2.impact.mechanical_arm was corrected from null to its default, 2.0. 
[12:54:11] [Server thread/WARN]: Incorrect key kinetics.stressValues.v2.impact.andesite_encased_shaft was corrected from null to its default, 0.0. 
[12:54:11] [Server thread/WARN]: Incorrect key kinetics.stressValues.v2.impact.mechanical_press was corrected from null to its default, 8.0. 
[12:54:11] [Server thread/WARN]: Incorrect key kinetics.stressValues.v2.impact.large_cogwheel was corrected from null to its default, 0.0. 
[12:54:11] [Server thread/WARN]: Incorrect key kinetics.stressValues.v2.impact.mechanical_drill was corrected from null to its default, 4.0. 
[12:54:11] [Server thread/WARN]: Incorrect key kinetics.stressValues.v2.impact.mysterious_cuckoo_clock was corrected from null to its default, 1.0. 
[12:54:11] [Server thread/WARN]: Incorrect key kinetics.stressValues.v2.impact.stressometer was corrected from null to its default, 0.0. 
[12:54:11] [Server thread/WARN]: Incorrect key kinetics.stressValues.v2.impact.shaft was corrected from null to its default, 0.0. 
[12:54:11] [Server thread/WARN]: Incorrect key kinetics.stressValues.v2.impact.brass_encased_shaft was corrected from null to its default, 0.0. 
[12:54:11] [Server thread/WARN]: Incorrect key kinetics.stressValues.v2.impact.gearshift was corrected from null to its default, 0.0. 
[12:54:11] [Server thread/WARN]: Incorrect key kinetics.stressValues.v2.impact.turntable was corrected from null to its default, 4.0. 
[12:54:11] [Server thread/WARN]: Incorrect key kinetics.stressValues.v2.impact.sticky_mechanical_piston was corrected from null to its default, 4.0. 
[12:54:11] [Server thread/WARN]: Incorrect key kinetics.stressValues.v2.impact.sequenced_gearshift was corrected from null to its default, 0.0. 
[12:54:11] [Server thread/WARN]: Incorrect key kinetics.stressValues.v2.impact.weighted_ejector was corrected from null to its default, 2.0. 
[12:54:11] [Server thread/WARN]: Incorrect key kinetics.stressValues.v2.impact.cogwheel was corrected from null to its default, 0.0. 
[12:54:11] [Server thread/WARN]: Incorrect key kinetics.stressValues.v2.impact.belt was corrected from null to its default, 1.0. 
[12:54:11] [Server thread/WARN]: Incorrect key kinetics.stressValues.v2.impact.gearbox was corrected from null to its default, 0.0. 
[12:54:11] [Server thread/WARN]: Incorrect key kinetics.stressValues.v2.impact.hose_pulley was corrected from null to its default, 4.0. 
[12:54:11] [Server thread/WARN]: Incorrect key kinetics.stressValues.v2.impact.mechanical_crafter was corrected from null to its default, 2.0. 
[12:54:11] [Server thread/WARN]: Incorrect key kinetics.stressValues.v2.capacity was corrected from null to its default, SimpleCommentedConfig:{}. 
[12:54:11] [Server thread/WARN]: Incorrect key kinetics.stressValues.v2.capacity.hand_crank was corrected from null to its default, 8.0. 
[12:54:11] [Server thread/WARN]: Incorrect key kinetics.stressValues.v2.capacity.furnace_engine was corrected from null to its default, 1024.0. 
[12:54:11] [Server thread/WARN]: Incorrect key kinetics.stressValues.v2.capacity.encased_fan was corrected from null to its default, 16.0. 
[12:54:11] [Server thread/WARN]: Incorrect key kinetics.stressValues.v2.capacity.creative_motor was corrected from null to its default, 16384.0. 
[12:54:11] [Server thread/WARN]: Incorrect key kinetics.stressValues.v2.capacity.water_wheel was corrected from null to its default, 16.0. 
[12:54:11] [Server thread/WARN]: Incorrect key kinetics.stressValues.v2.capacity.windmill_bearing was corrected from null to its default, 512.0. 
[12:54:11] [Server thread/WARN]: Incorrect key kinetics.stressValues.stats was corrected from null to its default, SimpleCommentedConfig:{}. 
[12:54:11] [Server thread/WARN]: Incorrect key kinetics.stressValues.stats.mediumSpeed was corrected from null to its default, 30.0. 
[12:54:11] [Server thread/WARN]: Incorrect key kinetics.stressValues.stats.fastSpeed was corrected from null to its default, 100.0. 
[12:54:11] [Server thread/WARN]: Incorrect key kinetics.stressValues.stats.mediumStressImpact was corrected from null to its default, 4.0. 
[12:54:11] [Server thread/WARN]: Incorrect key kinetics.stressValues.stats.highStressImpact was corrected from null to its default, 8.0. 
[12:54:11] [Server thread/WARN]: Incorrect key kinetics.stressValues.stats.mediumCapacity was corrected from null to its default, 128.0. 
[12:54:11] [Server thread/WARN]: Incorrect key kinetics.stressValues.stats.highCapacity was corrected from null to its default, 512.0. 
[12:54:11] [Server thread/WARN]: Incorrect key fluids was corrected from null to its default, SimpleCommentedConfig:{}. 
[12:54:11] [Server thread/WARN]: Incorrect key fluids.fluidTankCapacity was corrected from null to its default, 8. 
[12:54:11] [Server thread/WARN]: Incorrect key fluids.fluidTankMaxHeight was corrected from null to its default, 32. 
[12:54:11] [Server thread/WARN]: Incorrect key fluids.mechanicalPumpRange was corrected from null to its default, 16. 
[12:54:11] [Server thread/WARN]: Incorrect key fluids.hosePulleyBlockThreshold was corrected from null to its default, 10000. 
[12:54:11] [Server thread/WARN]: Incorrect key fluids.fillInfinite was corrected from null to its default, false. 
[12:54:11] [Server thread/WARN]: Incorrect key fluids.hosePulleyRange was corrected from null to its default, 128. 
[12:54:11] [Server thread/WARN]: Incorrect key fluids.placeFluidSourceBlocks was corrected from null to its default, true. 
[12:54:11] [Server thread/WARN]: Incorrect key logistics was corrected from null to its default, SimpleCommentedConfig:{}. 
[12:54:11] [Server thread/WARN]: Incorrect key logistics.defaultExtractionLimit was corrected from null to its default, 64. 
[12:54:11] [Server thread/WARN]: Incorrect key logistics.defaultExtractionTimer was corrected from null to its default, 8. 
[12:54:11] [Server thread/WARN]: Incorrect key logistics.psiTimeout was corrected from null to its default, 20. 
[12:54:11] [Server thread/WARN]: Incorrect key logistics.mechanicalArmRange was corrected from null to its default, 5. 
[12:54:11] [Server thread/WARN]: Incorrect key logistics.linkRange was corrected from null to its default, 128. 
[12:54:11] [Server thread/WARN]: Incorrect key schematics was corrected from null to its default, SimpleCommentedConfig:{}. 
[12:54:11] [Server thread/WARN]: Incorrect key schematics.creativePrintIncludesAir was corrected from null to its default, false. 
[12:54:11] [Server thread/WARN]: Incorrect key schematics.maxSchematics was corrected from null to its default, 256. 
[12:54:11] [Server thread/WARN]: Incorrect key schematics.maxSchematicPacketSize was corrected from null to its default, 1024. 
[12:54:11] [Server thread/WARN]: Incorrect key schematics.schematicIdleTimeout was corrected from null to its default, 600. 
[12:54:11] [Server thread/WARN]: Incorrect key schematics.schematicannon was corrected from null to its default, SimpleCommentedConfig:{}. 
[12:54:11] [Server thread/WARN]: Incorrect key schematics.schematicannon.schematicannonDelay was corrected from null to its default, 10. 
[12:54:11] [Server thread/WARN]: Incorrect key schematics.schematicannon.schematicannonSkips was corrected from null to its default, 10. 
[12:54:11] [Server thread/WARN]: Incorrect key schematics.schematicannon.schematicannonGunpowderWorth was corrected from null to its default, 20.0. 
[12:54:11] [Server thread/WARN]: Incorrect key schematics.schematicannon.schematicannonFuelUsage was corrected from null to its default, 0.05000000074505806. 
[12:54:11] [Server thread/WARN]: Incorrect key curiosities was corrected from null to its default, SimpleCommentedConfig:{}. 
[12:54:11] [Server thread/WARN]: Incorrect key curiosities.maxSymmetryWandRange was corrected from null to its default, 50. 
[12:54:11] [Server thread/WARN]: Incorrect key curiosities.placementAssistRange was corrected from null to its default, 12. 
[12:54:11] [Server thread/WARN]: Incorrect key curiosities.toolboxRange was corrected from null to its default, 10. 
[12:54:11] [Server thread/WARN]: Incorrect key curiosities.airInBacktank was corrected from null to its default, 900. 
[12:54:11] [Server thread/WARN]: Incorrect key curiosities.enchantedBacktankCapacity was corrected from null to its default, 300. 
[12:54:11] [Server thread/WARN]: Incorrect key curiosities.maxExtendoGripActions was corrected from null to its default, 1000. 
[12:54:11] [Server thread/WARN]: Incorrect key curiosities.maxPotatoCannonShots was corrected from null to its default, 200. 
[12:54:11] [Server thread/WARN]: Configuration file C:\Users\kaues\AppData\Roaming\.minecraft\versions\Ender Tech\saves\Novo mundo (2)\serverconfig\jei-server.toml is not correct. Correcting
[12:54:11] [Server thread/WARN]: Incorrect key cheat mode was corrected from null to its default, SimpleCommentedConfig:{}. 
[12:54:11] [Server thread/WARN]: Incorrect key cheat mode.enableCheatModeForOp was corrected from null to its default, true. 
[12:54:11] [Server thread/WARN]: Incorrect key cheat mode.enableCheatModeForCreative was corrected from null to its default, true. 
[12:54:11] [Server thread/WARN]: Incorrect key cheat mode.enableCheatModeForGive was corrected from null to its default, false. 
[12:54:11] [Server thread/WARN]: Configuration file C:\Users\kaues\AppData\Roaming\.minecraft\versions\Ender Tech\saves\Novo mundo (2)\serverconfig\artifacts-server.toml is not correct. Correcting
[12:54:11] [Server thread/WARN]: Incorrect key items was corrected from null to its default, SimpleCommentedConfig:{}. 
[12:54:11] [Server thread/WARN]: Incorrect key items.cosmetics was corrected from null to its default, []. 
[12:54:11] [Server thread/WARN]: Incorrect key items.antidote_vessel was corrected from null to its default, SimpleCommentedConfig:{}. 
[12:54:11] [Server thread/WARN]: Incorrect key items.antidote_vessel.durability was corrected from null to its default, 0. 
[12:54:11] [Server thread/WARN]: Incorrect key items.antidote_vessel.negative_effects was corrected from null to its default, [minecraft:slowness, minecraft:mining_fatigue, minecraft:nausea, minecraft:blindness, minecraft:hunger, minecraft:weakness, minecraft:poison, minecraft:wither, minecraft:levitation]. 
[12:54:11] [Server thread/WARN]: Incorrect key items.antidote_vessel.max_effect_duration was corrected from null to its default, 120. 
[12:54:11] [Server thread/WARN]: Incorrect key items.aqua_dashers was corrected from null to its default, SimpleCommentedConfig:{}. 
[12:54:11] [Server thread/WARN]: Incorrect key items.aqua_dashers.durability was corrected from null to its default, 0. 
[12:54:11] [Server thread/WARN]: Incorrect key items.bunny_hoppers was corrected from null to its default, SimpleCommentedConfig:{}. 
[12:54:11] [Server thread/WARN]: Incorrect key items.bunny_hoppers.durability was corrected from null to its default, 0. 
[12:54:11] [Server thread/WARN]: Incorrect key items.bunny_hoppers.should_cancel_fall_damage was corrected from null to its default, true. 
[12:54:11] [Server thread/WARN]: Incorrect key items.bunny_hoppers.jump_boost_level was corrected from null to its default, 2. 
[12:54:11] [Server thread/WARN]: Incorrect key items.charm_of_sinking was corrected from null to its default, SimpleCommentedConfig:{}. 
[12:54:11] [Server thread/WARN]: Incorrect key items.charm_of_sinking.durability was corrected from null to its default, 0. 
[12:54:11] [Server thread/WARN]: Incorrect key items.cloud_in_a_bottle was corrected from null to its default, SimpleCommentedConfig:{}. 
[12:54:11] [Server thread/WARN]: Incorrect key items.cloud_in_a_bottle.durability was corrected from null to its default, 0. 
[12:54:11] [Server thread/WARN]: Incorrect key items.cloud_in_a_bottle.sprint_jump_height_multiplier was corrected from null to its default, 1.5. 
[12:54:11] [Server thread/WARN]: Incorrect key items.cloud_in_a_bottle.sprint_jump_distance_multiplier was corrected from null to its default, 0.5. 
[12:54:11] [Server thread/WARN]: Incorrect key items.cross_necklace was corrected from null to its default, SimpleCommentedConfig:{}. 
[12:54:11] [Server thread/WARN]: Incorrect key items.cross_necklace.durability was corrected from null to its default, 0. 
[12:54:11] [Server thread/WARN]: Incorrect key items.cross_necklace.invincibility_bonus was corrected from null to its default, 20. 
[12:54:11] [Server thread/WARN]: Incorrect key items.crystal_heart was corrected from null to its default, SimpleCommentedConfig:{}. 
[12:54:11] [Server thread/WARN]: Incorrect key items.crystal_heart.durability was corrected from null to its default, 0. 
[12:54:11] [Server thread/WARN]: Incorrect key items.crystal_heart.health_bonus was corrected from null to its default, 10. 
[12:54:11] [Server thread/WARN]: Incorrect key items.digging_claws was corrected from null to its default, SimpleCommentedConfig:{}. 
[12:54:11] [Server thread/WARN]: Incorrect key items.digging_claws.durability was corrected from null to its default, 0. 
[12:54:11] [Server thread/WARN]: Incorrect key items.digging_claws.mining_speed_bonus was corrected from null to its default, 3.2. 
[12:54:11] [Server thread/WARN]: Incorrect key items.digging_claws.harvest_level was corrected from null to its default, 2. 
[12:54:11] [Server thread/WARN]: Incorrect key items.digging_claws.tool_types was corrected from null to its default, [*]. 
[12:54:11] [Server thread/WARN]: Incorrect key items.eternal_steak was corrected from null to its default, SimpleCommentedConfig:{}. 
[12:54:11] [Server thread/WARN]: Incorrect key items.eternal_steak.durability was corrected from null to its default, 0. 
[12:54:11] [Server thread/WARN]: Incorrect key items.eternal_steak.cooldown was corrected from null to its default, 300. 
[12:54:11] [Server thread/WARN]: Incorrect key items.eternal_steak.use_duration was corrected from null to its default, 24. 
[12:54:11] [Server thread/WARN]: Incorrect key items.everlasting_beef was corrected from null to its default, SimpleCommentedConfig:{}. 
[12:54:11] [Server thread/WARN]: Incorrect key items.everlasting_beef.durability was corrected from null to its default, 0. 
[12:54:11] [Server thread/WARN]: Incorrect key items.everlasting_beef.cooldown was corrected from null to its default, 300. 
[12:54:11] [Server thread/WARN]: Incorrect key items.everlasting_beef.use_duration was corrected from null to its default, 24. 
[12:54:11] [Server thread/WARN]: Incorrect key items.feral_claws was corrected from null to its default, SimpleCommentedConfig:{}. 
[12:54:11] [Server thread/WARN]: Incorrect key items.feral_claws.durability was corrected from null to its default, 0. 
[12:54:11] [Server thread/WARN]: Incorrect key items.feral_claws.attack_speed_bonus was corrected from null to its default, 0.75. 
[12:54:11] [Server thread/WARN]: Incorrect key items.fire_gauntlet was corrected from null to its default, SimpleCommentedConfig:{}. 
[12:54:11] [Server thread/WARN]: Incorrect key items.fire_gauntlet.durability was corrected from null to its default, 0. 
[12:54:11] [Server thread/WARN]: Incorrect key items.fire_gauntlet.fire_duration was corrected from null to its default, 8. 
[12:54:11] [Server thread/WARN]: Incorrect key items.flame_pendant was corrected from null to its default, SimpleCommentedConfig:{}. 
[12:54:11] [Server thread/WARN]: Incorrect key items.flame_pendant.durability was corrected from null to its default, 0. 
[12:54:11] [Server thread/WARN]: Incorrect key items.flame_pendant.strike_chance was corrected from null to its default, 0.4. 
[12:54:11] [Server thread/WARN]: Incorrect key items.flame_pendant.fire_duration was corrected from null to its default, 10. 
[12:54:11] [Server thread/WARN]: Incorrect key items.flippers was corrected from null to its default, SimpleCommentedConfig:{}. 
[12:54:11] [Server thread/WARN]: Incorrect key items.flippers.durability was corrected from null to its default, 0. 
[12:54:11] [Server thread/WARN]: Incorrect key items.flippers.swim_speed_bonus was corrected from null to its default, 1.0. 
[12:54:11] [Server thread/WARN]: Incorrect key items.golden_hook was corrected from null to its default, SimpleCommentedConfig:{}. 
[12:54:11] [Server thread/WARN]: Incorrect key items.golden_hook.durability was corrected from null to its default, 0. 
[12:54:11] [Server thread/WARN]: Incorrect key items.golden_hook.tracked_entities was corrected from null to its default, 25. 
[12:54:11] [Server thread/WARN]: Incorrect key items.golden_hook.maximum_kill_ratio was corrected from null to its default, 0.5. 
[12:54:11] [Server thread/WARN]: Incorrect key items.golden_hook.max_experience_multiplier was corrected from null to its default, 5.0. 
[12:54:11] [Server thread/WARN]: Incorrect key items.golden_hook.min_experience_multiplier was corrected from null to its default, 0.0. 
[12:54:11] [Server thread/WARN]: Incorrect key items.golden_hook.max_experience was corrected from null to its default, 50. 
[12:54:11] [Server thread/WARN]: Incorrect key items.helium_flamingo was corrected from null to its default, SimpleCommentedConfig:{}. 
[12:54:11] [Server thread/WARN]: Incorrect key items.helium_flamingo.durability was corrected from null to its default, 0. 
[12:54:11] [Server thread/WARN]: Incorrect key items.helium_flamingo.max_flight_time was corrected from null to its default, 150. 
[12:54:11] [Server thread/WARN]: Incorrect key items.helium_flamingo.recharge_time was corrected from null to its default, 300. 
[12:54:11] [Server thread/WARN]: Incorrect key items.kitty_slippers was corrected from null to its default, SimpleCommentedConfig:{}. 
[12:54:11] [Server thread/WARN]: Incorrect key items.kitty_slippers.durability was corrected from null to its default, 0. 
[12:54:11] [Server thread/WARN]: Incorrect key items.lucky_scarf was corrected from null to its default, SimpleCommentedConfig:{}. 
[12:54:11] [Server thread/WARN]: Incorrect key items.lucky_scarf.durability was corrected from null to its default, 0. 
[12:54:11] [Server thread/WARN]: Incorrect key items.lucky_scarf.fortune_bonus was corrected from null to its default, 1. 
[12:54:11] [Server thread/WARN]: Incorrect key items.night_vision_goggles was corrected from null to its default, SimpleCommentedConfig:{}. 
[12:54:11] [Server thread/WARN]: Incorrect key items.night_vision_goggles.durability was corrected from null to its default, 0. 
[12:54:11] [Server thread/WARN]: Incorrect key items.novelty_drinking_hat was corrected from null to its default, SimpleCommentedConfig:{}. 
[12:54:11] [Server thread/WARN]: Incorrect key items.novelty_drinking_hat.durability was corrected from null to its default, 0. 
[12:54:11] [Server thread/WARN]: Incorrect key items.novelty_drinking_hat.drinking_duration_multiplier was corrected from null to its default, 0.25. 
[12:54:11] [Server thread/WARN]: Incorrect key items.novelty_drinking_hat.enable_fast_eating was corrected from null to its default, false. 
[12:54:11] [Server thread/WARN]: Incorrect key items.obsidian_skull was corrected from null to its default, SimpleCommentedConfig:{}. 
[12:54:11] [Server thread/WARN]: Incorrect key items.obsidian_skull.durability was corrected from null to its default, 0. 
[12:54:11] [Server thread/WARN]: Incorrect key items.obsidian_skull.cooldown was corrected from null to its default, 1200. 
[12:54:11] [Server thread/WARN]: Incorrect key items.obsidian_skull.fire_resistance_duration was corrected from null to its default, 600. 
[12:54:11] [Server thread/WARN]: Incorrect key items.panic_necklace was corrected from null to its default, SimpleCommentedConfig:{}. 
[12:54:11] [Server thread/WARN]: Incorrect key items.panic_necklace.durability was corrected from null to its default, 0. 
[12:54:11] [Server thread/WARN]: Incorrect key items.panic_necklace.speed_level was corrected from null to its default, 1. 
[12:54:11] [Server thread/WARN]: Incorrect key items.panic_necklace.speed_duration was corrected from null to its default, 160. 
[12:54:11] [Server thread/WARN]: Incorrect key items.plastic_drinking_hat was corrected from null to its default, SimpleCommentedConfig:{}. 
[12:54:11] [Server thread/WARN]: Incorrect key items.plastic_drinking_hat.durability was corrected from null to its default, 0. 
[12:54:11] [Server thread/WARN]: Incorrect key items.plastic_drinking_hat.drinking_duration_multiplier was corrected from null to its default, 0.25. 
[12:54:11] [Server thread/WARN]: Incorrect key items.plastic_drinking_hat.enable_fast_eating was corrected from null to its default, false. 
[12:54:11] [Server thread/WARN]: Incorrect key items.pocket_piston was corrected from null to its default, SimpleCommentedConfig:{}. 
[12:54:11] [Server thread/WARN]: Incorrect key items.pocket_piston.durability was corrected from null to its default, 0. 
[12:54:11] [Server thread/WARN]: Incorrect key items.pocket_piston.knockback_bonus was corrected from null to its default, 1.5. 
[12:54:11] [Server thread/WARN]: Incorrect key items.power_glove was corrected from null to its default, SimpleCommentedConfig:{}. 
[12:54:11] [Server thread/WARN]: Incorrect key items.power_glove.durability was corrected from null to its default, 0. 
[12:54:11] [Server thread/WARN]: Incorrect key items.power_glove.attack_damage_bonus was corrected from null to its default, 4. 
[12:54:11] [Server thread/WARN]: Incorrect key items.running_shoes was corrected from null to its default, SimpleCommentedConfig:{}. 
[12:54:11] [Server thread/WARN]: Incorrect key items.running_shoes.durability was corrected from null to its default, 0. 
[12:54:11] [Server thread/WARN]: Incorrect key items.running_shoes.speed_multiplier was corrected from null to its default, 0.4. 
[12:54:11] [Server thread/WARN]: Incorrect key items.scarf_of_invisibility was corrected from null to its default, SimpleCommentedConfig:{}. 
[12:54:11] [Server thread/WARN]: Incorrect key items.scarf_of_invisibility.durability was corrected from null to its default, 0. 
[12:54:11] [Server thread/WARN]: Incorrect key items.shock_pendant was corrected from null to its default, SimpleCommentedConfig:{}. 
[12:54:11] [Server thread/WARN]: Incorrect key items.shock_pendant.durability was corrected from null to its default, 0. 
[12:54:11] [Server thread/WARN]: Incorrect key items.shock_pendant.strike_chance was corrected from null to its default, 0.25. 
[12:54:11] [Server thread/WARN]: Incorrect key items.snorkel was corrected from null to its default, SimpleCommentedConfig:{}. 
[12:54:11] [Server thread/WARN]: Incorrect key items.snorkel.durability was corrected from null to its default, 0. 
[12:54:11] [Server thread/WARN]: Incorrect key items.steadfast_spikes was corrected from null to its default, SimpleCommentedConfig:{}. 
[12:54:11] [Server thread/WARN]: Incorrect key items.steadfast_spikes.durability was corrected from null to its default, 0. 
[12:54:11] [Server thread/WARN]: Incorrect key items.superstitious_hat was corrected from null to its default, SimpleCommentedConfig:{}. 
[12:54:11] [Server thread/WARN]: Incorrect key items.superstitious_hat.durability was corrected from null to its default, 0. 
[12:54:11] [Server thread/WARN]: Incorrect key items.superstitious_hat.looting_bonus was corrected from null to its default, 1. 
[12:54:11] [Server thread/WARN]: Incorrect key items.thorn_pendant was corrected from null to its default, SimpleCommentedConfig:{}. 
[12:54:11] [Server thread/WARN]: Incorrect key items.thorn_pendant.durability was corrected from null to its default, 0. 
[12:54:11] [Server thread/WARN]: Incorrect key items.thorn_pendant.strike_chance was corrected from null to its default, 0.5. 
[12:54:11] [Server thread/WARN]: Incorrect key items.thorn_pendant.min_damage was corrected from null to its default, 2. 
[12:54:11] [Server thread/WARN]: Incorrect key items.thorn_pendant.max_damage was corrected from null to its default, 6. 
[12:54:11] [Server thread/WARN]: Incorrect key items.umbrella was corrected from null to its default, SimpleCommentedConfig:{}. 
[12:54:11] [Server thread/WARN]: Incorrect key items.umbrella.durability was corrected from null to its default, 0. 
[12:54:11] [Server thread/WARN]: Incorrect key items.umbrella.is_shield was corrected from null to its default, true. 
[12:54:11] [Server thread/WARN]: Incorrect key items.universal_attractor was corrected from null to its default, SimpleCommentedConfig:{}. 
[12:54:11] [Server thread/WARN]: Incorrect key items.universal_attractor.durability was corrected from null to its default, 0. 
[12:54:11] [Server thread/WARN]: Incorrect key items.universal_attractor.range was corrected from null to its default, 5. 
[12:54:11] [Server thread/WARN]: Incorrect key items.universal_attractor.motionMultiplier was corrected from null to its default, 0.6. 
[12:54:11] [Server thread/WARN]: Incorrect key items.universal_attractor.cooldown was corrected from null to its default, 200. 
[12:54:11] [Server thread/WARN]: Incorrect key items.vampiric_glove was corrected from null to its default, SimpleCommentedConfig:{}. 
[12:54:11] [Server thread/WARN]: Incorrect key items.vampiric_glove.durability was corrected from null to its default, 0. 
[12:54:11] [Server thread/WARN]: Incorrect key items.vampiric_glove.absorption_ratio was corrected from null to its default, 0.25. 
[12:54:11] [Server thread/WARN]: Incorrect key items.vampiric_glove.max_health_absorbed was corrected from null to its default, 6. 
[12:54:11] [Server thread/WARN]: Incorrect key items.villager_hat was corrected from null to its default, SimpleCommentedConfig:{}. 
[12:54:11] [Server thread/WARN]: Incorrect key items.villager_hat.durability was corrected from null to its default, 0. 
[12:54:11] [Server thread/WARN]: Incorrect key items.villager_hat.reputation_bonus was corrected from null to its default, 100. 
[12:54:11] [Server thread/WARN]: Incorrect key items.whoopee_cushion was corrected from null to its default, SimpleCommentedConfig:{}. 
[12:54:11] [Server thread/WARN]: Incorrect key items.whoopee_cushion.durability was corrected from null to its default, 0. 
[12:54:11] [Server thread/WARN]: Incorrect key items.whoopee_cushion.flatulence was corrected from null to its default, 0.125. 
[12:54:13] [Server thread/WARN]: Unable to find spawn biome
[12:55:27] [Server thread/INFO]: FluxNetworkData has been successfully loaded
[12:55:28] [Server thread/INFO]: Preparing start region for dimension minecraft:overworld
[12:55:29] [main/INFO]: Time elapsed: 699 ms
[12:55:30] [Server thread/INFO]: compactmachines~compact_world (Initialized) Setting config file to version "5.8.0": journeymap.server.compactmachines~compact_world.config
[12:55:30] [Server thread/INFO]: compactmachines~compact_world (Valid) Creating config file: C:\Users\kaues\AppData\Roaming\.minecraft\versions\Ender Tech\journeymap\server\5.8\journeymap.server.compactmachines~compact_world.config
[12:55:42] [Server thread/INFO]: Changing view distance to 5, from 10
[12:55:42] [Server thread/WARN]: Can't keep up! Is the server overloaded? Running 11023ms or 220 ticks behind
[12:55:50] [Netty Server IO #1/INFO]: Skipping config sync, No mods have registered a syncable config.
[12:55:52] [main/WARN]: Couldn't look up profile properties for com.mojang.authlib.GameProfile@59534928[id=cb2a9bf2-9730-42ff-9575-79d48c089416,name=kaues,properties={},legacy=false]
com.mojang.authlib.exceptions.InvalidCredentialsException: Invalid arguments
	at com.mojang.authlib.yggdrasil.YggdrasilAuthenticationService.makeRequest(YggdrasilAuthenticationService.java:91) ~[authlib-2.0.28.12.jar:?]
	at com.mojang.authlib.yggdrasil.YggdrasilAuthenticationService.makeRequest(YggdrasilAuthenticationService.java:78) ~[authlib-2.0.28.12.jar:?]
	at com.mojang.authlib.yggdrasil.YggdrasilMinecraftSessionService.fillGameProfile(YggdrasilMinecraftSessionService.java:174) [authlib-2.0.28.12.jar:?]
	at com.mojang.authlib.yggdrasil.YggdrasilMinecraftSessionService.fillProfileProperties(YggdrasilMinecraftSessionService.java:167) [authlib-2.0.28.12.jar:?]
	at net.minecraft.client.Minecraft.loadWorld(Minecraft.java:1799) [?:?]
	at net.minecraft.client.Minecraft.func_238192_a_(Minecraft.java:1687) [?:?]
	at net.minecraft.client.gui.screen.CreateWorldScreen.func_195352_j(CreateWorldScreen.java:260) [?:?]
	at net.minecraft.client.gui.screen.CreateWorldScreen.lambda$init$11(CreateWorldScreen.java:205) [?:?]
	at net.minecraft.client.gui.screen.CreateWorldScreen$$Lambda$12951/1871004871.onPress(Unknown Source) [?:?]
	at net.minecraft.client.gui.widget.button.Button.func_230930_b_(SourceFile:33) [?:?]
	at net.minecraft.client.gui.widget.button.AbstractButton.func_230982_a_(SourceFile:16) [?:?]
	at net.minecraft.client.gui.widget.Widget.func_231044_a_(Widget.java:136) [?:?]
	at net.minecraft.client.gui.INestedGuiEventHandler.func_231044_a_(SourceFile:27) [?:?]
	at net.minecraft.client.MouseHelper.func_198033_b(MouseHelper.java:87) [?:?]
	at net.minecraft.client.MouseHelper$$Lambda$12646/468309489.run(Unknown Source) [?:?]
	at net.minecraft.client.gui.screen.Screen.func_231153_a_(Screen.java:427) [?:?]
	at net.minecraft.client.MouseHelper.func_198023_a(MouseHelper.java:85) [?:?]
	at net.minecraft.client.MouseHelper.func_228030_c_(MouseHelper.java:181) [?:?]
	at net.minecraft.client.MouseHelper$$Lambda$12645/1510532588.run(Unknown Source) [?:?]
	at net.minecraft.util.concurrent.ThreadTaskExecutor.execute(ThreadTaskExecutor.java:106) [?:?]
	at net.minecraft.client.MouseHelper.func_228028_b_(MouseHelper.java:180) [?:?]
	at net.minecraft.client.MouseHelper$$Lambda$9851/1244357368.invoke(Unknown Source) [?:?]
	at org.lwjgl.glfw.GLFWMouseButtonCallbackI.callback(GLFWMouseButtonCallbackI.java:36) [lwjgl-glfw-3.2.2.jar:build 10]
	at org.lwjgl.system.JNI.invokeV(Native Method) ~[lwjgl-3.2.2.jar:build 10]
	at org.lwjgl.glfw.GLFW.glfwPollEvents(GLFW.java:3101) [lwjgl-glfw-3.2.2.jar:build 10]
	at com.mojang.blaze3d.systems.RenderSystem.flipFrame(SourceFile:102) [?:?]
	at net.minecraft.client.MainWindow.func_227802_e_(MainWindow.java:398) [?:?]
	at net.minecraft.client.Minecraft.func_195542_b(Minecraft.java:997) [?:?]
	at net.minecraft.client.Minecraft.func_99999_d(Minecraft.java:607) [?:?]
	at net.minecraft.client.main.Main.main(Main.java:184) [?:?]
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) ~[?:1.8.0_51]
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) ~[?:1.8.0_51]
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) ~[?:1.8.0_51]
	at java.lang.reflect.Method.invoke(Method.java:497) ~[?:1.8.0_51]
	at net.minecraftforge.fml.loading.FMLClientLaunchProvider.lambda$launchService$0(FMLClientLaunchProvider.java:51) [forge-1.16.5-36.2.33.jar:36.2]
	at net.minecraftforge.fml.loading.FMLClientLaunchProvider$$Lambda$496/1753746465.call(Unknown Source) [forge-1.16.5-36.2.33.jar:36.2]
	at cpw.mods.modlauncher.LaunchServiceHandlerDecorator.launch(LaunchServiceHandlerDecorator.java:37) [modlauncher-8.1.3.jar:?]
	at cpw.mods.modlauncher.LaunchServiceHandler.launch(LaunchServiceHandler.java:54) [modlauncher-8.1.3.jar:?]
	at cpw.mods.modlauncher.LaunchServiceHandler.launch(LaunchServiceHandler.java:72) [modlauncher-8.1.3.jar:?]
	at cpw.mods.modlauncher.Launcher.run(Launcher.java:82) [modlauncher-8.1.3.jar:?]
	at cpw.mods.modlauncher.Launcher.main(Launcher.java:66) [modlauncher-8.1.3.jar:?]
[12:55:53] [Netty Local Client IO #0/INFO]: Successfully synchronized gun properties from server
[12:55:53] [Netty Local Client IO #0/INFO]: Connected to a modded server.
[12:55:55] [Server thread/INFO]: Using new advancement loading for net.minecraft.advancements.PlayerAdvancements@415d1c5
[12:55:55] [Server thread/INFO]: kaues[local:E:4724745d] logged in with entity id 198 at (8.5, 65.0, 8.5)
[12:55:57] [Server thread/INFO]: kaues entrou no jogo
[12:56:00] [Server thread/INFO]: Syncing config to kaues (cb2a9bf2-9730-42ff-9575-79d48c089416)
[12:56:00] [main/INFO]: No shader config found.
[12:56:02] [Server thread/INFO]: Saving and pausing game...
[12:56:02] [Server thread/INFO]: Saving chunks for level 'ServerLevel[Novo mundo]'/minecraft:overworld
[12:56:07] [Server thread/INFO]: Saving chunks for level 'ServerLevel[Novo mundo]'/minecraft:the_nether
[12:56:07] [Server thread/INFO]: Saving chunks for level 'ServerLevel[Novo mundo]'/minecraft:the_end
[12:56:07] [Server thread/INFO]: Saving chunks for level 'ServerLevel[Novo mundo]'/compactmachines:compact_world
[12:56:07] [Server thread/INFO]: Saving chunks for level 'ServerLevel[Novo mundo]'/allthemodium:mining
[12:56:07] [Server thread/INFO]: Saving chunks for level 'ServerLevel[Novo mundo]'/mining_dimension:mining
[12:56:07] [Server thread/INFO]: Saving chunks for level 'ServerLevel[Novo mundo]'/mahoutsukai:reality_marble
[12:56:07] [Server thread/INFO]: Saving chunks for level 'ServerLevel[Novo mundo]'/allthemodium:the_other
[12:56:07] [Server thread/WARN]: Can't keep up! Is the server overloaded? Running 9878ms or 197 ticks behind
[12:56:08] [main/INFO]: [org.tlauncher.util.TLModCfg:<clinit>:28]: [TLSkinCape] Current TLSkinCape version is 1.17
[12:56:08] [main/INFO]: [org.tlauncher.util.TLModCfg:<clinit>:51]: [TLSkinCape] Current Minecraft version is 1.15.
[12:56:08] [main/INFO]: [org.tlauncher.util.TLModCfg:<clinit>:55]: [TLSkinCape] OptiFine detected.
[12:56:13] [main/WARN]: Unknown recipe category: vehicle:crafting/vehicle:craft_storage_trailer
[12:56:13] [main/WARN]: Unknown recipe category: vehicle:crafting/vehicle:craft_vehicle_trailer
[12:56:13] [main/WARN]: Unknown recipe category: cfm:freezer_solidify/minecraft:packed_ice_from_freezing
[12:56:13] [main/WARN]: Unknown recipe category: cgm:workbench/cgm:shotgun
[12:56:13] [main/WARN]: Unknown recipe category: cgm:workbench/cgm:machine_pistol
[12:56:13] [main/WARN]: Unknown recipe category: appliedenergistics2:inscriber/appliedenergistics2:inscriber/logic_processor
[12:56:13] [main/WARN]: Unknown recipe category: industrialforegoing:dissolution_chamber/industrialforegoing:dissolution_chamber/pink_slime_ball
[12:56:13] [main/WARN]: Unknown recipe category: industrialforegoing:dissolution_chamber/industrialforegoing:dissolution_chamber/range_addon9
[12:56:13] [main/WARN]: Unknown recipe category: industrialforegoing:stonework_generate/industrialforegoing:stonework_generate/granite
[12:56:13] [main/WARN]: Unknown recipe category: industrialforegoing:crusher/industrialforegoing:crusher/cobble_gravel
[12:56:13] [main/WARN]: Unknown recipe category: vehicle:crafting/vehicle:craft_bumper_car
[12:56:13] [main/WARN]: Unknown recipe category: cgm:workbench/cgm:weighted_stock
[12:56:13] [main/WARN]: Unknown recipe category: industrialforegoing:dissolution_chamber/industrialforegoing:dissolution_chamber/laser_lens9
[12:56:13] [main/WARN]: Unknown recipe category: appliedenergistics2:entropy/appliedenergistics2:entropy/cool/water_ice
[12:56:13] [main/WARN]: Unknown recipe category: industrialforegoing:dissolution_chamber/industrialforegoing:dissolution_chamber/infinity_backpack
[12:56:13] [main/WARN]: Unknown recipe category: cfm:grill_cooking/minecraft:cooked_mutton_from_grill_cooking
[12:56:13] [main/WARN]: Unknown recipe category: cgm:workbench/cgm:grenade
[12:56:13] [main/WARN]: Unknown recipe category: appliedenergistics2:inscriber/appliedenergistics2:inscriber/engineering_processor
[12:56:13] [main/WARN]: Unknown recipe category: appliedenergistics2:inscriber/appliedenergistics2:inscriber/silicon_press
[12:56:13] [main/WARN]: Unknown recipe category: appliedenergistics2:inscriber/appliedenergistics2:inscriber/logic_processor_print
[12:56:13] [main/WARN]: Unknown recipe category: industrialforegoing:dissolution_chamber/industrialforegoing:dissolution_chamber/laser_lens5
[12:56:13] [main/WARN]: Unknown recipe category: industrialforegoing:dissolution_chamber/industrialforegoing:dissolution_chamber/speed_addon_1
[12:56:13] [main/WARN]: Unknown recipe category: appliedenergistics2:grinder/appliedenergistics2:grinder/gold_dust_ore
[12:56:13] [main/WARN]: Unknown recipe category: industrialforegoing:fluid_extractor/industrialforegoing:fluid_extractor/jungle
[12:56:13] [main/WARN]: Unknown recipe category: vehicle:crafting/vehicle:craft_atv
[12:56:13] [main/WARN]: Unknown recipe category: industrialforegoing:dissolution_chamber/industrialforegoing:dissolution_chamber/infinity_trident
[12:56:13] [main/WARN]: Unknown recipe category: industrialforegoing:fluid_extractor/industrialforegoing:fluid_extractor/oak
[12:56:13] [main/WARN]: Unknown recipe category: industrialforegoing:stonework_generate/industrialforegoing:stonework_generate/cobblestone
[12:56:13] [main/WARN]: Unknown recipe category: cgm:workbench/cgm:missile
[12:56:13] [main/WARN]: Unknown recipe category: industrialforegoing:dissolution_chamber/industrialforegoing:dissolution_chamber/processing_addon_2
[12:56:13] [main/WARN]: Unknown recipe category: vehicle:crafting/vehicle:craft_dirt_bike
[12:56:13] [main/WARN]: Unknown recipe category: vehicle:crafting/vehicle:craft_golf_cart
[12:56:13] [main/WARN]: Unknown recipe category: vehicle:crafting/vehicle:craft_seeder
[12:56:13] [main/WARN]: Unknown recipe category: cfm:grill_cooking/minecraft:dried_kelp_from_grill_cooking
[12:56:13] [main/WARN]: Unknown recipe category: industrialforegoing:laser_drill_ore/industrialforegoing:laser_drill_ore/certus_quartz
[12:56:13] [main/WARN]: Unknown recipe category: industrialforegoing:stonework_generate/industrialforegoing:stonework_generate/andesite
[12:56:13] [main/WARN]: Unknown recipe category: appliedenergistics2:inscriber/appliedenergistics2:inscriber/calculation_processor
[12:56:13] [main/WARN]: Unknown recipe category: appliedenergistics2:entropy/appliedenergistics2:entropy/cool/grass_block_dirt
[12:56:13] [main/WARN]: Unknown recipe category: industrialforegoing:dissolution_chamber/industrialforegoing:dissolution_chamber/infinity_drill
[12:56:13] [main/WARN]: Unknown recipe category: industrialforegoing:laser_drill_ore/industrialforegoing:laser_drill_ore/iron
[12:56:13] [main/WARN]: Unknown recipe category: industrialforegoing:dissolution_chamber/industrialforegoing:dissolution_chamber/laser_lens6
[12:56:13] [main/WARN]: Unknown recipe category: cfm:grill_cooking/minecraft:cooked_salmon_from_grill_cooking
[12:56:13] [main/WARN]: Unknown recipe category: industrialforegoing:dissolution_chamber/industrialforegoing:dissolution_chamber/laser_lens13
[12:56:13] [main/WARN]: Unknown recipe category: industrialforegoing:dissolution_chamber/industrialforegoing:dissolution_chamber/range_addon6
[12:56:13] [main/WARN]: Unknown recipe category: industrialforegoing:fluid_extractor/industrialforegoing:fluid_extractor/birch
[12:56:13] [main/WARN]: Unknown recipe category: industrialforegoing:dissolution_chamber/industrialforegoing:dissolution_chamber/laser_lens11
[12:56:13] [main/WARN]: Unknown recipe category: vehicle:crafting/vehicle:craft_mini_bus
[12:56:13] [main/WARN]: Unknown recipe category: appliedenergistics2:entropy/appliedenergistics2:entropy/cool/lava_obsidian
[12:56:13] [main/WARN]: Unknown recipe category: appliedenergistics2:entropy/appliedenergistics2:entropy/heat/cobblestone_stone
[12:56:13] [main/WARN]: Unknown recipe category: industrialforegoing:dissolution_chamber/industrialforegoing:dissolution_chamber/range_addon10
[12:56:13] [main/WARN]: Unknown recipe category: industrialforegoing:dissolution_chamber/industrialforegoing:dissolution_chamber/laser_lens8
[12:56:13] [main/WARN]: Unknown recipe category: cgm:workbench/cgm:assault_rifle
[12:56:13] [main/WARN]: Unknown recipe category: vehicle:crafting/vehicle:craft_tractor
[12:56:13] [main/WARN]: Unknown recipe category: industrialforegoing:laser_drill_ore/industrialforegoing:laser_drill_ore/coal
[12:56:13] [main/WARN]: Unknown recipe category: industrialforegoing:dissolution_chamber/industrialforegoing:dissolution_chamber/supreme_machine_frame
[12:56:13] [main/WARN]: Unknown recipe category: industrialforegoing:laser_drill_ore/industrialforegoing:laser_drill_ore/osmium
[12:56:13] [main/WARN]: Unknown recipe category: industrialforegoing:laser_drill_ore/industrialforegoing:laser_drill_ore/tin
[12:56:13] [main/WARN]: Unknown recipe category: appliedenergistics2:grinder/appliedenergistics2:grinder/nether_quartz_dust
[12:56:13] [main/WARN]: Unknown recipe category: appliedenergistics2:grinder/appliedenergistics2:grinder/certus_quartz_dust_ore
[12:56:13] [main/WARN]: Unknown recipe category: industrialforegoing:fluid_extractor/industrialforegoing:fluid_extractor/acacia
[12:56:13] [main/WARN]: Unknown recipe category: industrialforegoing:dissolution_chamber/industrialforegoing:dissolution_chamber/efficiency_addon_1
[12:56:13] [main/WARN]: Unknown recipe category: appliedenergistics2:grinder/appliedenergistics2:grinder/flint
[12:56:13] [main/WARN]: Unknown recipe category: vehicle:crafting/vehicle:craft_shopping_cart
[12:56:13] [main/WARN]: Unknown recipe category: vehicle:crafting/vehicle:craft_off_roader
[12:56:13] [main/WARN]: Unknown recipe category: cgm:workbench/cgm:pistol
[12:56:13] [main/WARN]: Unknown recipe category: cfm:grill_cooking/minecraft:cooked_porkchop_from_grill_cooking
[12:56:13] [main/WARN]: Unknown recipe category: industrialforegoing:dissolution_chamber/industrialforegoing:dissolution_chamber/laser_lens2
[12:56:13] [main/WARN]: Unknown recipe category: industrialforegoing:dissolution_chamber/industrialforegoing:dissolution_chamber/infinity_launcher
[12:56:13] [main/WARN]: Unknown recipe category: industrialforegoing:dissolution_chamber/industrialforegoing:dissolution_chamber/range_addon0
[12:56:13] [main/WARN]: Unknown recipe category: cgm:workbench/cgm:shell
[12:56:13] [main/WARN]: Unknown recipe category: industrialforegoing:dissolution_chamber/industrialforegoing:dissolution_chamber/efficiency_addon_2
[12:56:13] [main/WARN]: Unknown recipe category: vehicle:crafting/vehicle:craft_moped
[12:56:13] [main/WARN]: Unknown recipe category: industrialforegoing:dissolution_chamber/industrialforegoing:dissolution_chamber/simple_machine_frame
[12:56:13] [main/WARN]: Unknown recipe category: industrialforegoing:dissolution_chamber/industrialforegoing:dissolution_chamber/xp_bottles
[12:56:13] [main/WARN]: Unknown recipe category: appliedenergistics2:grinder/appliedenergistics2:grinder/gold_dust_ingot
[12:56:13] [main/WARN]: Unknown recipe category: cgm:workbench/cgm:light_grip
[12:56:13] [main/WARN]: Unknown recipe category: industrialforegoing:dissolution_chamber/industrialforegoing:dissolution_chamber/laser_lens3
[12:56:13] [main/WARN]: Unknown recipe category: industrialforegoing:dissolution_chamber/industrialforegoing:dissolution_chamber/laser_lens14
[12:56:13] [main/WARN]: Unknown recipe category: appliedenergistics2:inscriber/appliedenergistics2:inscriber/engineering_processor_press
[12:56:13] [main/WARN]: Unknown recipe category: industrialforegoing:dissolution_chamber/industrialforegoing:dissolution_chamber/laser_lens1
[12:56:13] [main/WARN]: Unknown recipe category: industrialforegoing:dissolution_chamber/industrialforegoing:dissolution_chamber/laser_lens0
[12:56:13] [main/WARN]: Unknown recipe category: industrialforegoing:dissolution_chamber/industrialforegoing:dissolution_chamber/advanced_machine_frame
[12:56:13] [main/WARN]: Unknown recipe category: industrialforegoing:dissolution_chamber/industrialforegoing:dissolution_chamber/range_addon2
[12:56:13] [main/WARN]: Unknown recipe category: cfm:grill_cooking/minecraft:baked_potato_from_grill_cooking
[12:56:13] [main/WARN]: Unknown recipe category: vehicle:fluid_extractor/vehicle:extract_ender_pearl
[12:56:13] [main/WARN]: Unknown recipe category: cgm:workbench/cgm:light_stock
[12:56:13] [main/WARN]: Unknown recipe category: cgm:workbench/cgm:medium_scope
[12:56:13] [main/WARN]: Unknown recipe category: industrialforegoing:dissolution_chamber/industrialforegoing:dissolution_chamber/laser_lens15
[12:56:13] [main/WARN]: Unknown recipe category: appliedenergistics2:grinder/appliedenergistics2:grinder/iron_dust_ore
[12:56:13] [main/WARN]: Unknown recipe category: industrialforegoing:dissolution_chamber/industrialforegoing:dissolution_chamber/range_addon1
[12:56:13] [main/WARN]: Unknown recipe category: appliedenergistics2:grinder/appliedenergistics2:grinder/iron_dust_ingot
[12:56:13] [main/WARN]: Unknown recipe category: industrialforegoing:dissolution_chamber/industrialforegoing:dissolution_chamber/range_addon5
[12:56:13] [main/WARN]: Unknown recipe category: cgm:workbench/cgm:silencer
[12:56:13] [main/WARN]: Unknown recipe category: industrialforegoing:crusher/industrialforegoing:crusher/sand_silicon
[12:56:13] [main/WARN]: Unknown recipe category: vehicle:crafting/vehicle:craft_lawn_mower
[12:56:13] [main/WARN]: Unknown recipe category: vehicle:crafting/vehicle:craft_speed_boat
[12:56:13] [main/WARN]: Unknown recipe category: vehicle:crafting/vehicle:craft_smart_car
[12:56:13] [main/WARN]: Unknown recipe category: cgm:workbench/cgm:long_scope
[12:56:13] [main/WARN]: Unknown recipe category: cfm:grill_cooking/minecraft:cooked_beef_from_grill_cooking
[12:56:13] [main/WARN]: Unknown recipe category: appliedenergistics2:grinder/appliedenergistics2:grinder/certus_quartz_dust
[12:56:13] [main/WARN]: Unknown recipe category: industrialforegoing:dissolution_chamber/industrialforegoing:dissolution_chamber/dark_glass
[12:56:13] [main/WARN]: Unknown recipe category: industrialforegoing:fluid_extractor/industrialforegoing:fluid_extractor/spruce
[12:56:13] [main/WARN]: Unknown recipe category: industrialforegoing:stonework_generate/industrialforegoing:stonework_generate/obsidian
[12:56:13] [main/WARN]: Unknown recipe category: vehicle:fluid_extractor/vehicle:extract_blaze_rod
[12:56:13] [main/WARN]: Unknown recipe category: appliedenergistics2:grinder/appliedenergistics2:grinder/flour
[12:56:13] [main/WARN]: Unknown recipe category: appliedenergistics2:entropy/appliedenergistics2:entropy/cool/stone_bricks_cracked_stone_bricks
[12:56:13] [main/WARN]: Unknown recipe category: appliedenergistics2:entropy/appliedenergistics2:entropy/heat/ice_water
[12:56:13] [main/WARN]: Unknown recipe category: industrialforegoing:dissolution_chamber/industrialforegoing:dissolution_chamber/range_addon4
[12:56:13] [main/WARN]: Unknown recipe category: cgm:workbench/cgm:bazooka
[12:56:13] [main/WARN]: Unknown recipe category: industrialforegoing:laser_drill_ore/industrialforegoing:laser_drill_ore/lead
[12:56:13] [main/WARN]: Unknown recipe category: appliedenergistics2:entropy/appliedenergistics2:entropy/heat/snow_water
[12:56:13] [main/WARN]: Unknown recipe category: appliedenergistics2:inscriber/appliedenergistics2:inscriber/calculation_processor_press
[12:56:13] [main/WARN]: Unknown recipe category: appliedenergistics2:grinder/appliedenergistics2:grinder/sky_dust
[12:56:13] [main/WARN]: Unknown recipe category: industrialforegoing:laser_drill_ore/industrialforegoing:laser_drill_ore/lapis
[12:56:13] [main/WARN]: Unknown recipe category: industrialforegoing:dissolution_chamber/industrialforegoing:dissolution_chamber/pink_slime_ingot
[12:56:13] [main/WARN]: Unknown recipe category: industrialforegoing:dissolution_chamber/industrialforegoing:dissolution_chamber/range_addon7
[12:56:13] [main/WARN]: Unknown recipe category: cgm:workbench/cgm:mini_gun
[12:56:13] [main/WARN]: Unknown recipe category: cgm:workbench/cgm:rifle
[12:56:13] [main/WARN]: Unknown recipe category: vehicle:crafting/vehicle:craft_mini_bike
[12:56:13] [main/WARN]: Unknown recipe category: industrialforegoing:dissolution_chamber/industrialforegoing:dissolution_chamber/infinity_nuke
[12:56:13] [main/WARN]: Unknown recipe category: industrialforegoing:dissolution_chamber/industrialforegoing:dissolution_chamber/range_addon3
[12:56:13] [main/WARN]: Unknown recipe category: industrialforegoing:fluid_extractor/industrialforegoing:fluid_extractor/default
[12:56:13] [main/WARN]: Unknown recipe category: vehicle:crafting/vehicle:craft_jet_ski
[12:56:13] [main/WARN]: Unknown recipe category: industrialforegoing:dissolution_chamber/industrialforegoing:dissolution_chamber/mycelial_reactor
[12:56:13] [main/WARN]: Unknown recipe category: industrialforegoing:laser_drill_ore/industrialforegoing:laser_drill_ore/diamond
[12:56:13] [main/WARN]: Unknown recipe category: industrialforegoing:dissolution_chamber/industrialforegoing:dissolution_chamber/infinity_saw
[12:56:13] [main/WARN]: Unknown recipe category: appliedenergistics2:grinder/appliedenergistics2:grinder/fluix_dust
[12:56:13] [main/WARN]: Unknown recipe category: appliedenergistics2:entropy/appliedenergistics2:entropy/heat/water_air
[12:56:13] [main/WARN]: Unknown recipe category: cgm:workbench/cgm:basic_bullet
[12:56:13] [main/WARN]: Unknown recipe category: industrialforegoing:laser_drill_ore/industrialforegoing:laser_drill_ore/fluorite
[12:56:13] [main/WARN]: Unknown recipe category: industrialforegoing:laser_drill_ore/industrialforegoing:laser_drill_ore/glowstone
[12:56:13] [main/WARN]: Unknown recipe category: appliedenergistics2:entropy/appliedenergistics2:entropy/cool/stone_cobblestone
[12:56:13] [main/WARN]: Unknown recipe category: cgm:workbench/cgm:short_scope
[12:56:13] [main/WARN]: Unknown recipe category: industrialforegoing:dissolution_chamber/industrialforegoing:dissolution_chamber/mechanical_dirt
[12:56:13] [main/WARN]: Unknown recipe category: cgm:workbench/cgm:stun_grenade
[12:56:13] [main/WARN]: Unknown recipe category: industrialforegoing:laser_drill_fluid/industrialforegoing:laser_drill_fluid/lava
[12:56:13] [main/WARN]: Unknown recipe category: appliedenergistics2:inscriber/appliedenergistics2:inscriber/logic_processor_press
[12:56:13] [main/WARN]: Unknown recipe category: industrialforegoing:dissolution_chamber/industrialforegoing:dissolution_chamber/laser_lens10
[12:56:13] [main/WARN]: Unknown recipe category: appliedenergistics2:entropy/appliedenergistics2:entropy/cool/flowing_water_snowball
[12:56:13] [main/WARN]: Unknown recipe category: vehicle:fluid_mixer/vehicle:mix_fuelium
[12:56:13] [main/WARN]: Unknown recipe category: industrialforegoing:dissolution_chamber/industrialforegoing:dissolution_chamber/laser_lens12
[12:56:13] [main/WARN]: Unknown recipe category: industrialforegoing:laser_drill_ore/industrialforegoing:laser_drill_ore/ancient_debris
[12:56:13] [main/WARN]: Unknown recipe category: cgm:workbench/cgm:heavy_rifle
[12:56:13] [main/WARN]: Unknown recipe category: vehicle:crafting/vehicle:craft_go_kart
[12:56:13] [main/WARN]: Unknown recipe category: cgm:workbench/cgm:specialised_grip
[12:56:13] [main/WARN]: Unknown recipe category: appliedenergistics2:inscriber/appliedenergistics2:inscriber/silicon_print
[12:56:13] [main/WARN]: Unknown recipe category: vehicle:crafting/vehicle:craft_fluid_trailer
[12:56:13] [main/WARN]: Unknown recipe category: industrialforegoing:dissolution_chamber/industrialforegoing:dissolution_chamber/speed_addon_2
[12:56:13] [main/WARN]: Unknown recipe category: industrialforegoing:fluid_extractor/industrialforegoing:fluid_extractor/dark_oak
[12:56:13] [main/WARN]: Unknown recipe category: industrialforegoing:dissolution_chamber/industrialforegoing:dissolution_chamber/processing_addon_1
[12:56:13] [main/WARN]: Unknown recipe category: industrialforegoing:laser_drill_ore/industrialforegoing:laser_drill_ore/copper
[12:56:13] [main/WARN]: Unknown recipe category: industrialforegoing:crusher/industrialforegoing:crusher/gravel_sand
[12:56:13] [main/WARN]: Unknown recipe category: industrialforegoing:dissolution_chamber/industrialforegoing:dissolution_chamber/range_addon8
[12:56:13] [main/WARN]: Unknown recipe category: cgm:workbench/cgm:tactical_stock
[12:56:13] [main/WARN]: Unknown recipe category: industrialforegoing:dissolution_chamber/industrialforegoing:dissolution_chamber/range_addon11
[12:56:13] [main/WARN]: Unknown recipe category: industrialforegoing:stonework_generate/industrialforegoing:stonework_generate/diorite
[12:56:13] [main/WARN]: Unknown recipe category: industrialforegoing:laser_drill_fluid/industrialforegoing:laser_drill_fluid/ether_gas
[12:56:13] [main/WARN]: Unknown recipe category: industrialforegoing:stonework_generate/industrialforegoing:stonework_generate/netherrack
[12:56:13] [main/WARN]: Unknown recipe category: cfm:grill_cooking/minecraft:cooked_chicken_from_grill_cooking
[12:56:13] [main/WARN]: Unknown recipe category: industrialforegoing:laser_drill_ore/industrialforegoing:laser_drill_ore/gold
[12:56:13] [main/WARN]: Unknown recipe category: industrialforegoing:laser_drill_ore/industrialforegoing:laser_drill_ore/quartz
[12:56:13] [main/WARN]: Unknown recipe category: appliedenergistics2:inscriber/appliedenergistics2:inscriber/calculation_processor_print
[12:56:13] [main/WARN]: Unknown recipe category: cgm:workbench/cgm:grenade_launcher
[12:56:13] [main/WARN]: Unknown recipe category: cfm:freezer_solidify/minecraft:blue_ice_from_freezing
[12:56:13] [main/WARN]: Unknown recipe category: vehicle:crafting/vehicle:craft_dune_buggy
[12:56:13] [main/WARN]: Unknown recipe category: appliedenergistics2:grinder/appliedenergistics2:grinder/nether_quartz_dust_ore
[12:56:20] [main/WARN]: Unknown recipe category: cgm:workbench/cgm:advanced_bullet
[12:56:20] [main/WARN]: Unknown recipe category: industrialforegoing:dissolution_chamber/industrialforegoing:dissolution_chamber/laser_lens7
[12:56:20] [main/WARN]: Unknown recipe category: industrialforegoing:dissolution_chamber/industrialforegoing:dissolution_chamber/infinity_hammer
[12:56:20] [main/WARN]: Unknown recipe category: industrialforegoing:laser_drill_ore/industrialforegoing:laser_drill_ore/emerald
[12:56:20] [main/WARN]: Unknown recipe category: industrialforegoing:dissolution_chamber/industrialforegoing:dissolution_chamber/laser_lens4
[12:56:20] [main/WARN]: Unknown recipe category: appliedenergistics2:grinder/appliedenergistics2:grinder/bonemeal
[12:56:20] [main/WARN]: Unknown recipe category: cfm:freezer_solidify/minecraft:ice_from_freezing
[12:56:20] [main/WARN]: Unknown recipe category: industrialforegoing:laser_drill_ore/industrialforegoing:laser_drill_ore/redstone
[12:56:20] [main/WARN]: Unknown recipe category: vehicle:crafting/vehicle:craft_sports_plane
[12:56:20] [main/WARN]: Unknown recipe category: industrialforegoing:laser_drill_ore/industrialforegoing:laser_drill_ore/uranium
[12:56:20] [main/WARN]: Unknown recipe category: appliedenergistics2:inscriber/appliedenergistics2:inscriber/engineering_processor_print
[12:56:20] [main/WARN]: Unknown recipe category: cfm:grill_cooking/minecraft:cooked_rabbit_from_grill_cooking
[12:56:20] [main/WARN]: Unknown recipe category: cfm:grill_cooking/minecraft:cooked_cod_from_grill_cooking
[12:56:20] [main/WARN]: Unknown recipe category: appliedenergistics2:grinder/appliedenergistics2:grinder/ender_dust
[12:56:20] [main/WARN]: Unknown recipe category: vehicle:crafting/vehicle:craft_fertilizer
[12:56:20] [main/WARN]: Unknown recipe category: vehicle:crafting/vehicle:craft_aluminum_boat
[12:56:25] [main/INFO]: Started wikis recipes collecting...
[12:56:25] [main/INFO]: Wiki recipes collecting completed in : 0 ms
[12:56:25] [main/INFO]: Starting JEI...
[12:56:25] [main/INFO]: Registering item subtypes: jei:minecraft ...
[12:56:25] [main/INFO]: Registering item subtypes: jei:minecraft took 9.166 ms
[12:56:25] [main/INFO]: Registering item subtypes: cgm:crafting ...
[12:56:25] [main/INFO]: Registering item subtypes: cgm:crafting took 36.90 ?s
[12:56:25] [main/INFO]: Registering item subtypes: jei:debug ...
[12:56:25] [main/INFO]: Registering item subtypes: jei:debug took 21.70 ?s
[12:56:25] [main/INFO]: Registering item subtypes: cookingforblockheads:jei ...
[12:56:25] [main/INFO]: Registering item subtypes: cookingforblockheads:jei took 22.90 ?s
[12:56:25] [main/INFO]: Registering item subtypes: appliedenergistics2:core ...
[12:56:25] [main/INFO]: Registering item subtypes: appliedenergistics2:core took 6.273 ms
[12:56:25] [main/INFO]: Registering item subtypes: artifacts:main ...
[12:56:25] [main/INFO]: Registering item subtypes: artifacts:main took 21.90 ?s
[12:56:25] [main/INFO]: Registering item subtypes: compactmachines:main ...
[12:56:25] [main/INFO]: Registering item subtypes: compactmachines:main took 10.49 ms
[12:56:25] [main/INFO]: Registering item subtypes: sophisticatedbackpacks:default ...
[12:56:25] [main/INFO]: Registering item subtypes: sophisticatedbackpacks:default took 23.47 ms
[12:56:25] [main/INFO]: Registering item subtypes: darkutils:jei_support ...
[12:56:25] [main/INFO]: Registering item subtypes: darkutils:jei_support took 17.80 ?s
[12:56:25] [main/INFO]: Registering item subtypes: mekanismgenerators:jei_plugin ...
[12:56:25] [main/INFO]: Registering item subtypes: mekanismgenerators:jei_plugin took 199.3 ms
[12:56:25] [main/INFO]: Registering item subtypes: mekanism:jei_plugin ...
[12:56:26] [main/INFO]: Registering item subtypes: mekanism:jei_plugin took 647.2 ms
[12:56:26] [main/INFO]: Registering item subtypes: cofh_core:default ...
[12:56:26] [main/INFO]: Registering item subtypes: cofh_core:default took 13.90 ?s
[12:56:26] [main/INFO]: Registering item subtypes: industrialforegoing:default ...
[12:56:26] [main/INFO]: Registering item subtypes: industrialforegoing:default took 165.9 ?s
[12:56:26] [main/INFO]: Registering item subtypes: titanium:default ...
[12:56:26] [main/INFO]: Registering item subtypes: titanium:default took 19.10 ?s
[12:56:26] [main/INFO]: Registering item subtypes: lollipop:main ...
[12:56:26] [main/INFO]: Registering item subtypes: lollipop:main took 15.00 ?s
[12:56:26] [main/INFO]: Registering item subtypes: krate:main ...
[12:56:26] [main/INFO]: Registering item subtypes: krate:main took 18.70 ?s
[12:56:26] [main/INFO]: Registering item subtypes: create:jei_plugin ...
[12:56:26] [main/INFO]: Registering item subtypes: create:jei_plugin took 17.50 ?s
[12:56:26] [main/INFO]: Registering item subtypes: curios:curios ...
[12:56:26] [main/INFO]: Registering item subtypes: curios:curios took 11.80 ?s
[12:56:26] [main/INFO]: Registering item subtypes: securitycraft:securitycraft ...
[12:56:26] [main/INFO]: Registering item subtypes: securitycraft:securitycraft took 14.40 ?s
[12:56:26] [main/INFO]: Registering item subtypes: fluxnetworks:jei ...
[12:56:26] [main/INFO]: Registering item subtypes: fluxnetworks:jei took 11.60 ?s
[12:56:26] [main/INFO]: Registering item subtypes: mekanismtools:jei_plugin ...
[12:56:26] [main/INFO]: Registering item subtypes: mekanismtools:jei_plugin took 11.00 ?s
[12:56:26] [main/INFO]: Registering item subtypes: constructionwand:constructionwand ...
[12:56:26] [main/INFO]: Registering item subtypes: constructionwand:constructionwand took 11.00 ?s
[12:56:26] [main/INFO]: Registering item subtypes: ftblibrary:jei ...
[12:56:26] [main/INFO]: Registering item subtypes: ftblibrary:jei took 572.0 ?s
[12:56:26] [main/INFO]: Registering item subtypes: ftbquests:jei ...
[12:56:26] [main/INFO]: Registering item subtypes: ftbquests:jei took 458.6 ?s
[12:56:26] [main/INFO]: Registering item subtypes: trashcans:jei_plugin ...
[12:56:26] [main/INFO]: Registering item subtypes: trashcans:jei_plugin took 11.10 ?s
[12:56:26] [main/INFO]: Registering item subtypes: jei:internal ...
[12:56:26] [main/INFO]: Registering item subtypes: jei:internal took 10.90 ?s
[12:56:26] [main/INFO]: Registering fluid subtypes: jei:minecraft ...
[12:56:26] [main/INFO]: Registering fluid subtypes: jei:minecraft took 43.40 ?s
[12:56:26] [main/INFO]: Registering fluid subtypes: cgm:crafting ...
[12:56:26] [main/INFO]: Registering fluid subtypes: cgm:crafting took 11.20 ?s
[12:56:26] [main/INFO]: Registering fluid subtypes: jei:debug ...
[12:56:26] [main/INFO]: Registering fluid subtypes: jei:debug took 34.16 ms
[12:56:26] [main/INFO]: Registering fluid subtypes: cookingforblockheads:jei ...
[12:56:26] [main/INFO]: Registering fluid subtypes: cookingforblockheads:jei took 13.10 ?s
[12:56:26] [main/INFO]: Registering fluid subtypes: appliedenergistics2:core ...
[12:56:26] [main/INFO]: Registering fluid subtypes: appliedenergistics2:core took 11.10 ?s
[12:56:26] [main/INFO]: Registering fluid subtypes: artifacts:main ...
[12:56:26] [main/INFO]: Registering fluid subtypes: artifacts:main took 11.00 ?s
[12:56:26] [main/INFO]: Registering fluid subtypes: compactmachines:main ...
[12:56:26] [main/INFO]: Registering fluid subtypes: compactmachines:main took 10.90 ?s
[12:56:26] [main/INFO]: Registering fluid subtypes: sophisticatedbackpacks:default ...
[12:56:26] [main/INFO]: Registering fluid subtypes: sophisticatedbackpacks:default took 10.90 ?s
[12:56:26] [main/INFO]: Registering fluid subtypes: darkutils:jei_support ...
[12:56:26] [main/INFO]: Registering fluid subtypes: darkutils:jei_support took 11.70 ?s
[12:56:26] [main/INFO]: Registering fluid subtypes: mekanismgenerators:jei_plugin ...
[12:56:26] [main/INFO]: Registering fluid subtypes: mekanismgenerators:jei_plugin took 24.40 ?s
[12:56:26] [main/INFO]: Registering fluid subtypes: mekanism:jei_plugin ...
[12:56:26] [main/INFO]: Registering fluid subtypes: mekanism:jei_plugin took 12.10 ?s
[12:56:26] [main/INFO]: Registering fluid subtypes: cofh_core:default ...
[12:56:26] [main/INFO]: Registering fluid subtypes: cofh_core:default took 12.20 ?s
[12:56:26] [main/INFO]: Registering fluid subtypes: industrialforegoing:default ...
[12:56:26] [main/INFO]: Registering fluid subtypes: industrialforegoing:default took 12.70 ?s
[12:56:26] [main/INFO]: Registering fluid subtypes: titanium:default ...
[12:56:26] [main/INFO]: Registering fluid subtypes: titanium:default took 11.90 ?s
[12:56:26] [main/INFO]: Registering fluid subtypes: lollipop:main ...
[12:56:26] [main/INFO]: Registering fluid subtypes: lollipop:main took 11.60 ?s
[12:56:26] [main/INFO]: Registering fluid subtypes: krate:main ...
[12:56:26] [main/INFO]: Registering fluid subtypes: krate:main took 12.00 ?s
[12:56:26] [main/INFO]: Registering fluid subtypes: create:jei_plugin ...
[12:56:26] [main/INFO]: Registering fluid subtypes: create:jei_plugin took 54.02 ms
[12:56:26] [main/INFO]: Registering fluid subtypes: curios:curios ...
[12:56:26] [main/INFO]: Registering fluid subtypes: curios:curios took 12.50 ?s
[12:56:26] [main/INFO]: Registering fluid subtypes: securitycraft:securitycraft ...
[12:56:26] [main/INFO]: Registering fluid subtypes: securitycraft:securitycraft took 46.80 ?s
[12:56:26] [main/INFO]: Registering fluid subtypes: fluxnetworks:jei ...
[12:56:26] [main/INFO]: Registering fluid subtypes: fluxnetworks:jei took 13.20 ?s
[12:56:26] [main/INFO]: Registering fluid subtypes: mekanismtools:jei_plugin ...
[12:56:26] [main/INFO]: Registering fluid subtypes: mekanismtools:jei_plugin took 11.40 ?s
[12:56:26] [main/INFO]: Registering fluid subtypes: constructionwand:constructionwand ...
[12:56:26] [main/INFO]: Registering fluid subtypes: constructionwand:constructionwand took 23.80 ?s
[12:56:26] [main/INFO]: Registering fluid subtypes: ftblibrary:jei ...
[12:56:26] [main/INFO]: Registering fluid subtypes: ftblibrary:jei took 11.00 ?s
[12:56:26] [main/INFO]: Registering fluid subtypes: ftbquests:jei ...
[12:56:26] [main/INFO]: Registering fluid subtypes: ftbquests:jei took 11.00 ?s
[12:56:26] [main/INFO]: Registering fluid subtypes: trashcans:jei_plugin ...
[12:56:26] [main/INFO]: Registering fluid subtypes: trashcans:jei_plugin took 11.20 ?s
[12:56:26] [main/INFO]: Registering fluid subtypes: jei:internal ...
[12:56:26] [main/INFO]: Registering fluid subtypes: jei:internal took 11.20 ?s
[12:56:26] [main/INFO]: Registering ingredients: jei:minecraft ...
[12:56:27] [main/INFO]: Registering ingredients: jei:minecraft took 964.6 ms
[12:56:27] [main/INFO]: Registering ingredients: cgm:crafting ...
[12:56:27] [main/INFO]: Registering ingredients: cgm:crafting took 24.60 ?s
[12:56:27] [main/INFO]: Registering ingredients: jei:debug ...
[12:56:27] [main/INFO]: Registering ingredients: jei:debug took 120.4 ?s
[12:56:27] [main/INFO]: Registering ingredients: cookingforblockheads:jei ...
[12:56:27] [main/INFO]: Registering ingredients: cookingforblockheads:jei took 14.50 ?s
[12:56:27] [main/INFO]: Registering ingredients: appliedenergistics2:core ...
[12:56:27] [main/INFO]: Registering ingredients: appliedenergistics2:core took 15.50 ?s
[12:56:27] [main/INFO]: Registering ingredients: artifacts:main ...
[12:56:27] [main/INFO]: Registering ingredients: artifacts:main took 14.80 ?s
[12:56:27] [main/INFO]: Registering ingredients: compactmachines:main ...
[12:56:27] [main/INFO]: Registering ingredients: compactmachines:main took 15.80 ?s
[12:56:27] [main/INFO]: Registering ingredients: sophisticatedbackpacks:default ...
[12:56:27] [main/INFO]: Registering ingredients: sophisticatedbackpacks:default took 11.30 ?s
[12:56:27] [main/INFO]: Registering ingredients: darkutils:jei_support ...
[12:56:27] [main/INFO]: Registering ingredients: darkutils:jei_support took 11.40 ?s
[12:56:27] [main/INFO]: Registering ingredients: mekanismgenerators:jei_plugin ...
[12:56:27] [main/INFO]: Registering ingredients: mekanismgenerators:jei_plugin took 11.20 ?s
[12:56:27] [main/INFO]: Registering ingredients: mekanism:jei_plugin ...
[12:56:27] [main/INFO]: Registering ingredients: mekanism:jei_plugin took 94.15 ms
[12:56:27] [main/INFO]: Registering ingredients: cofh_core:default ...
[12:56:27] [main/INFO]: Registering ingredients: cofh_core:default took 14.40 ?s
[12:56:27] [main/INFO]: Registering ingredients: industrialforegoing:default ...
[12:56:27] [main/INFO]: Registering ingredients: industrialforegoing:default took 20.60 ?s
[12:56:27] [main/INFO]: Registering ingredients: titanium:default ...
[12:56:27] [main/INFO]: Registering ingredients: titanium:default took 12.80 ?s
[12:56:27] [main/INFO]: Registering ingredients: lollipop:main ...
[12:56:27] [main/INFO]: Registering ingredients: lollipop:main took 12.80 ?s
[12:56:27] [main/INFO]: Registering ingredients: krate:main ...
[12:56:27] [main/INFO]: Registering ingredients: krate:main took 11.30 ?s
[12:56:27] [main/INFO]: Registering ingredients: create:jei_plugin ...
[12:56:27] [main/INFO]: Registering ingredients: create:jei_plugin took 11.40 ?s
[12:56:27] [main/INFO]: Registering ingredients: curios:curios ...
[12:56:27] [main/INFO]: Registering ingredients: curios:curios took 11.30 ?s
[12:56:27] [main/INFO]: Registering ingredients: securitycraft:securitycraft ...
[12:56:27] [main/INFO]: Registering ingredients: securitycraft:securitycraft took 11.00 ?s
[12:56:27] [main/INFO]: Registering ingredients: fluxnetworks:jei ...
[12:56:27] [main/INFO]: Registering ingredients: fluxnetworks:jei took 14.20 ?s
[12:56:28] [main/INFO]: Registering ingredients: mekanismtools:jei_plugin ...
[12:56:28] [main/INFO]: Registering ingredients: mekanismtools:jei_plugin took 33.90 ?s
[12:56:28] [main/INFO]: Registering ingredients: constructionwand:constructionwand ...
[12:56:28] [main/INFO]: Registering ingredients: constructionwand:constructionwand took 19.30 ?s
[12:56:28] [main/INFO]: Registering ingredients: ftblibrary:jei ...
[12:56:28] [main/INFO]: Registering ingredients: ftblibrary:jei took 17.20 ?s
[12:56:28] [main/INFO]: Registering ingredients: ftbquests:jei ...
[12:56:28] [main/INFO]: Registering ingredients: ftbquests:jei took 18.60 ?s
[12:56:28] [main/INFO]: Registering ingredients: trashcans:jei_plugin ...
[12:56:28] [main/INFO]: Registering ingredients: trashcans:jei_plugin took 18.30 ?s
[12:56:28] [main/INFO]: Registering ingredients: jei:internal ...
[12:56:28] [main/INFO]: Registering ingredients: jei:internal took 18.20 ?s
[12:56:28] [main/INFO]: Registering categories: jei:minecraft ...
[12:56:28] [main/INFO]: Registering categories: jei:minecraft took 194.1 ms
[12:56:28] [main/INFO]: Registering categories: cgm:crafting ...
[12:56:28] [main/INFO]: Registering categories: cgm:crafting took 67.49 ms
[12:56:28] [main/INFO]: Registering categories: jei:debug ...
[12:56:28] [main/INFO]: Registering categories: jei:debug took 20.90 ?s
[12:56:28] [main/INFO]: Registering categories: cookingforblockheads:jei ...
[12:56:28] [main/INFO]: Registering categories: cookingforblockheads:jei took 36.06 ms
[12:56:28] [main/INFO]: Registering categories: appliedenergistics2:core ...
[12:56:28] [main/INFO]: Registering categories: appliedenergistics2:core took 231.2 ms
[12:56:28] [main/INFO]: Registering categories: artifacts:main ...
[12:56:28] [main/INFO]: Registering categories: artifacts:main took 29.10 ?s
[12:56:28] [main/INFO]: Registering categories: compactmachines:main ...
[12:56:28] [main/INFO]: Registering categories: compactmachines:main took 11.80 ?s
[12:56:28] [main/INFO]: Registering categories: sophisticatedbackpacks:default ...
[12:56:28] [main/INFO]: Registering categories: sophisticatedbackpacks:default took 11.60 ?s
[12:56:28] [main/INFO]: Registering categories: darkutils:jei_support ...
[12:56:28] [main/INFO]: Registering categories: darkutils:jei_support took 11.60 ?s
[12:56:28] [main/INFO]: Registering categories: mekanismgenerators:jei_plugin ...
[12:56:29] [main/INFO]: Registering categories: mekanismgenerators:jei_plugin took 266.6 ms
[12:56:29] [main/INFO]: Registering categories: mekanism:jei_plugin ...
[12:56:29] [main/INFO]: Registering categories: mekanism:jei_plugin took 491.0 ms
[12:56:29] [main/INFO]: Registering categories: cofh_core:default ...
[12:56:29] [main/INFO]: Registering categories: cofh_core:default took 18.30 ?s
[12:56:29] [main/INFO]: Registering categories: industrialforegoing:default ...
[12:56:29] [main/INFO]: Registering categories: industrialforegoing:default took 243.7 ms
[12:56:29] [main/INFO]: Registering categories: titanium:default ...
[12:56:29] [main/INFO]: Registering categories: titanium:default took 20.90 ?s
[12:56:29] [main/INFO]: Registering categories: lollipop:main ...
[12:56:29] [main/INFO]: Registering categories: lollipop:main took 11.50 ?s
[12:56:29] [main/INFO]: Registering categories: krate:main ...
[12:56:29] [main/INFO]: Registering categories: krate:main took 11.00 ?s
[12:56:29] [main/INFO]: Registering categories: create:jei_plugin ...
[12:56:29] [main/INFO]: Registering categories: create:jei_plugin took 68.42 ms
[12:56:29] [main/INFO]: Registering categories: curios:curios ...
[12:56:29] [main/INFO]: Registering categories: curios:curios took 18.90 ?s
[12:56:29] [main/INFO]: Registering categories: securitycraft:securitycraft ...
[12:56:29] [main/INFO]: Registering categories: securitycraft:securitycraft took 22.47 ms
[12:56:29] [main/INFO]: Registering categories: fluxnetworks:jei ...
[12:56:29] [main/INFO]: Registering categories: fluxnetworks:jei took 26.80 ms
[12:56:29] [main/INFO]: Registering categories: mekanismtools:jei_plugin ...
[12:56:29] [main/INFO]: Registering categories: mekanismtools:jei_plugin took 13.20 ?s
[12:56:29] [main/INFO]: Registering categories: constructionwand:constructionwand ...
[12:56:29] [main/INFO]: Registering categories: constructionwand:constructionwand took 13.30 ?s
[12:56:29] [main/INFO]: Registering categories: ftblibrary:jei ...
[12:56:29] [main/INFO]: Registering categories: ftblibrary:jei took 12.00 ?s
[12:56:29] [main/INFO]: Registering categories: ftbquests:jei ...
[12:56:29] [main/INFO]: Registering categories: ftbquests:jei took 16.00 ?s
[12:56:29] [main/INFO]: Registering categories: trashcans:jei_plugin ...
[12:56:29] [main/INFO]: Registering categories: trashcans:jei_plugin took 24.70 ?s
[12:56:29] [main/INFO]: Registering categories: jei:internal ...
[12:56:29] [main/INFO]: Registering categories: jei:internal took 2.628 ms
[12:56:29] [main/INFO]: Registering vanilla category extensions: jei:minecraft ...
[12:56:30] [main/INFO]: Registering vanilla category extensions: jei:minecraft took 97.88 ms
[12:56:30] [main/INFO]: Registering vanilla category extensions: cgm:crafting ...
[12:56:30] [main/INFO]: Registering vanilla category extensions: cgm:crafting took 15.50 ?s
[12:56:30] [main/INFO]: Registering vanilla category extensions: jei:debug ...
[12:56:30] [main/INFO]: Registering vanilla category extensions: jei:debug took 11.70 ?s
[12:56:30] [main/INFO]: Registering vanilla category extensions: cookingforblockheads:jei ...
[12:56:30] [main/INFO]: Registering vanilla category extensions: cookingforblockheads:jei took 11.20 ?s
[12:56:30] [main/INFO]: Registering vanilla category extensions: appliedenergistics2:core ...
[12:56:30] [main/INFO]: Registering vanilla category extensions: appliedenergistics2:core took 11.30 ?s
[12:56:30] [main/INFO]: Registering vanilla category extensions: artifacts:main ...
[12:56:30] [main/INFO]: Registering vanilla category extensions: artifacts:main took 11.70 ?s
[12:56:30] [main/INFO]: Registering vanilla category extensions: compactmachines:main ...
[12:56:30] [main/INFO]: Registering vanilla category extensions: compactmachines:main took 21.10 ?s
[12:56:30] [main/INFO]: Registering vanilla category extensions: sophisticatedbackpacks:default ...
[12:56:30] [main/INFO]: Registering vanilla category extensions: sophisticatedbackpacks:default took 16.40 ?s
[12:56:30] [main/INFO]: Registering vanilla category extensions: darkutils:jei_support ...
[12:56:30] [main/INFO]: Registering vanilla category extensions: darkutils:jei_support took 12.40 ?s
[12:56:30] [main/INFO]: Registering vanilla category extensions: mekanismgenerators:jei_plugin ...
[12:56:30] [main/INFO]: Registering vanilla category extensions: mekanismgenerators:jei_plugin took 11.70 ?s
[12:56:30] [main/INFO]: Registering vanilla category extensions: mekanism:jei_plugin ...
[12:56:30] [main/INFO]: Registering vanilla category extensions: mekanism:jei_plugin took 17.60 ?s
[12:56:30] [main/INFO]: Registering vanilla category extensions: cofh_core:default ...
[12:56:30] [main/INFO]: Registering vanilla category extensions: cofh_core:default took 52.00 ?s
[12:56:30] [main/INFO]: Registering vanilla category extensions: industrialforegoing:default ...
[12:56:30] [main/INFO]: Registering vanilla category extensions: industrialforegoing:default took 23.70 ?s
[12:56:30] [main/INFO]: Registering vanilla category extensions: titanium:default ...
[12:56:30] [main/INFO]: Registering vanilla category extensions: titanium:default took 17.20 ?s
[12:56:30] [main/INFO]: Registering vanilla category extensions: lollipop:main ...
[12:56:30] [main/INFO]: Registering vanilla category extensions: lollipop:main took 19.60 ?s
[12:56:30] [main/INFO]: Registering vanilla category extensions: krate:main ...
[12:56:30] [main/INFO]: Registering vanilla category extensions: krate:main took 51.30 ?s
[12:56:30] [main/INFO]: Registering vanilla category extensions: create:jei_plugin ...
[12:56:30] [main/INFO]: Registering vanilla category extensions: create:jei_plugin took 18.30 ?s
[12:56:30] [main/INFO]: Registering vanilla category extensions: curios:curios ...
[12:56:30] [main/INFO]: Registering vanilla category extensions: curios:curios took 15.90 ?s
[12:56:30] [main/INFO]: Registering vanilla category extensions: securitycraft:securitycraft ...
[12:56:30] [main/INFO]: Registering vanilla category extensions: securitycraft:securitycraft took 15.00 ?s
[12:56:30] [main/INFO]: Registering vanilla category extensions: fluxnetworks:jei ...
[12:56:30] [main/INFO]: Registering vanilla category extensions: fluxnetworks:jei took 15.00 ?s
[12:56:30] [main/INFO]: Registering vanilla category extensions: mekanismtools:jei_plugin ...
[12:56:30] [main/INFO]: Registering vanilla category extensions: mekanismtools:jei_plugin took 14.70 ?s
[12:56:30] [main/INFO]: Registering vanilla category extensions: constructionwand:constructionwand ...
[12:56:30] [main/INFO]: Registering vanilla category extensions: constructionwand:constructionwand took 17.10 ?s
[12:56:30] [main/INFO]: Registering vanilla category extensions: ftblibrary:jei ...
[12:56:30] [main/INFO]: Registering vanilla category extensions: ftblibrary:jei took 28.50 ?s
[12:56:30] [main/INFO]: Registering vanilla category extensions: ftbquests:jei ...
[12:56:30] [main/INFO]: Registering vanilla category extensions: ftbquests:jei took 18.00 ?s
[12:56:30] [main/INFO]: Registering vanilla category extensions: trashcans:jei_plugin ...
[12:56:30] [main/INFO]: Registering vanilla category extensions: trashcans:jei_plugin took 25.40 ?s
[12:56:30] [main/INFO]: Registering vanilla category extensions: jei:internal ...
[12:56:30] [main/INFO]: Registering vanilla category extensions: jei:internal took 15.20 ?s
[12:56:30] [main/INFO]: Registering recipes: jei:minecraft ...
[12:56:30] [main/INFO]: Registering recipes: jei:minecraft took 784.3 ms
[12:56:30] [main/INFO]: Registering recipes: cgm:crafting ...
[12:56:30] [main/INFO]: Registering recipes: cgm:crafting took 17.43 ms
[12:56:30] [main/INFO]: Registering recipes: jei:debug ...
[12:56:30] [main/INFO]: Registering recipes: jei:debug took 80.30 ?s
[12:56:30] [main/INFO]: Registering recipes: cookingforblockheads:jei ...
[12:56:30] [main/INFO]: Registering recipes: cookingforblockheads:jei took 361.6 ?s
[12:56:30] [main/INFO]: Registering recipes: appliedenergistics2:core ...
[12:56:30] [main/INFO]: Registering recipes: appliedenergistics2:core took 38.88 ms
[12:56:30] [main/INFO]: Registering recipes: artifacts:main ...
[12:56:30] [main/INFO]: Registering recipes: artifacts:main took 8.969 ms
[12:56:30] [main/INFO]: Registering recipes: compactmachines:main ...
[12:56:30] [main/INFO]: Registering recipes: compactmachines:main took 32.90 ?s
[12:56:30] [main/INFO]: Registering recipes: sophisticatedbackpacks:default ...
[12:56:30] [main/INFO]: Registering recipes: sophisticatedbackpacks:default took 70.01 ms
[12:56:30] [main/INFO]: Registering recipes: darkutils:jei_support ...
[12:56:30] [main/INFO]: Registering recipes: darkutils:jei_support took 8.747 ms
[12:56:31] [main/INFO]: Registering recipes: mekanismgenerators:jei_plugin ...
[12:56:31] [main/INFO]: Registering recipes: mekanismgenerators:jei_plugin took 39.96 ms
[12:56:31] [main/INFO]: Registering recipes: mekanism:jei_plugin ...
[12:56:31] [main/INFO]: Registering recipes: mekanism:jei_plugin took 220.5 ms
[12:56:31] [main/INFO]: Registering recipes: cofh_core:default ...
[12:56:31] [main/INFO]: Registering recipes: cofh_core:default took 16.00 ?s
[12:56:31] [main/INFO]: Registering recipes: industrialforegoing:default ...
[12:56:32] [main/INFO]: Registering recipes: industrialforegoing:default took 1.254 s
[12:56:32] [main/INFO]: Registering recipes: titanium:default ...
[12:56:32] [main/INFO]: Registering recipes: titanium:default took 20.70 ?s
[12:56:32] [main/INFO]: Registering recipes: lollipop:main ...
[12:56:32] [main/INFO]: Registering recipes: lollipop:main took 18.70 ?s
[12:56:32] [main/INFO]: Registering recipes: krate:main ...
[12:56:32] [main/INFO]: Registering recipes: krate:main took 1.062 ms
[12:56:32] [main/INFO]: Registering recipes: create:jei_plugin ...
[12:56:33] [main/INFO]: Registering recipes: create:jei_plugin took 1.270 s
[12:56:33] [main/INFO]: Registering recipes: curios:curios ...
[12:56:33] [main/INFO]: Registering recipes: curios:curios took 24.10 ?s
[12:56:33] [main/INFO]: Registering recipes: securitycraft:securitycraft ...
[12:56:33] [main/INFO]: Registering recipes: securitycraft:securitycraft took 3.354 ms
[12:56:33] [main/INFO]: Registering recipes: fluxnetworks:jei ...
[12:56:33] [main/INFO]: Registering recipes: fluxnetworks:jei took 335.0 ?s
[12:56:33] [main/INFO]: Registering recipes: mekanismtools:jei_plugin ...
[12:56:33] [main/INFO]: Registering recipes: mekanismtools:jei_plugin took 33.62 ms
[12:56:33] [main/INFO]: Registering recipes: constructionwand:constructionwand ...
[12:56:33] [main/INFO]: Registering recipes: constructionwand:constructionwand took 5.103 ms
[12:56:33] [main/INFO]: Registering recipes: ftblibrary:jei ...
[12:56:33] [main/INFO]: Registering recipes: ftblibrary:jei took 22.20 ?s
[12:56:33] [main/INFO]: Registering recipes: ftbquests:jei ...
[12:56:33] [main/INFO]: Registering recipes: ftbquests:jei took 21.40 ?s
[12:56:33] [main/INFO]: Registering recipes: trashcans:jei_plugin ...
[12:56:33] [main/INFO]: Registering recipes: trashcans:jei_plugin took 13.60 ?s
[12:56:33] [main/INFO]: Registering recipes: jei:internal ...
[12:56:33] [main/INFO]: Registering recipes: jei:internal took 14.10 ?s
[12:56:33] [main/INFO]: Registering recipes transfer handlers: jei:minecraft ...
[12:56:33] [main/INFO]: Registering recipes transfer handlers: jei:minecraft took 65.57 ms
[12:56:33] [main/INFO]: Registering recipes transfer handlers: cgm:crafting ...
[12:56:33] [main/INFO]: Registering recipes transfer handlers: cgm:crafting took 20.90 ?s
[12:56:33] [main/INFO]: Registering recipes transfer handlers: jei:debug ...
[12:56:33] [main/INFO]: Registering recipes transfer handlers: jei:debug took 20.30 ?s
[12:56:33] [main/INFO]: Registering recipes transfer handlers: cookingforblockheads:jei ...
[12:56:33] [main/INFO]: Registering recipes transfer handlers: cookingforblockheads:jei took 16.90 ?s
[12:56:33] [main/INFO]: Registering recipes transfer handlers: appliedenergistics2:core ...
[12:56:33] [main/INFO]: Registering recipes transfer handlers: appliedenergistics2:core took 42.18 ms
[12:56:33] [main/INFO]: Registering recipes transfer handlers: artifacts:main ...
[12:56:33] [main/INFO]: Registering recipes transfer handlers: artifacts:main took 15.00 ?s
[12:56:33] [main/INFO]: Registering recipes transfer handlers: compactmachines:main ...
[12:56:33] [main/INFO]: Registering recipes transfer handlers: compactmachines:main took 12.80 ?s
[12:56:33] [main/INFO]: Registering recipes transfer handlers: sophisticatedbackpacks:default ...
[12:56:34] [main/INFO]: Registering recipes transfer handlers: sophisticatedbackpacks:default took 53.78 ms
[12:56:34] [main/INFO]: Registering recipes transfer handlers: darkutils:jei_support ...
[12:56:34] [main/INFO]: Registering recipes transfer handlers: darkutils:jei_support took 19.70 ?s
[12:56:34] [main/INFO]: Registering recipes transfer handlers: mekanismgenerators:jei_plugin ...
[12:56:34] [main/INFO]: Registering recipes transfer handlers: mekanismgenerators:jei_plugin took 17.90 ?s
[12:56:34] [main/INFO]: Registering recipes transfer handlers: mekanism:jei_plugin ...
[12:56:34] [main/INFO]: Registering recipes transfer handlers: mekanism:jei_plugin took 118.6 ms
[12:56:34] [main/INFO]: Registering recipes transfer handlers: cofh_core:default ...
[12:56:34] [main/INFO]: Registering recipes transfer handlers: cofh_core:default took 13.50 ?s
[12:56:34] [main/INFO]: Registering recipes transfer handlers: industrialforegoing:default ...
[12:56:34] [main/INFO]: Registering recipes transfer handlers: industrialforegoing:default took 12.10 ?s
[12:56:34] [main/INFO]: Registering recipes transfer handlers: titanium:default ...
[12:56:34] [main/INFO]: Registering recipes transfer handlers: titanium:default took 11.50 ?s
[12:56:34] [main/INFO]: Registering recipes transfer handlers: lollipop:main ...
[12:56:34] [main/INFO]: Registering recipes transfer handlers: lollipop:main took 11.90 ?s
[12:56:34] [main/INFO]: Registering recipes transfer handlers: krate:main ...
[12:56:34] [main/INFO]: Registering recipes transfer handlers: krate:main took 12.80 ?s
[12:56:34] [main/INFO]: Registering recipes transfer handlers: create:jei_plugin ...
[12:56:34] [main/INFO]: Registering recipes transfer handlers: create:jei_plugin took 40.87 ms
[12:56:34] [main/INFO]: Registering recipes transfer handlers: curios:curios ...
[12:56:34] [main/INFO]: Registering recipes transfer handlers: curios:curios took 14.20 ?s
[12:56:34] [main/INFO]: Registering recipes transfer handlers: securitycraft:securitycraft ...
[12:56:34] [main/INFO]: Registering recipes transfer handlers: securitycraft:securitycraft took 13.10 ?s
[12:56:34] [main/INFO]: Registering recipes transfer handlers: fluxnetworks:jei ...
[12:56:34] [main/INFO]: Registering recipes transfer handlers: fluxnetworks:jei took 12.00 ?s
[12:56:34] [main/INFO]: Registering recipes transfer handlers: mekanismtools:jei_plugin ...
[12:56:34] [main/INFO]: Registering recipes transfer handlers: mekanismtools:jei_plugin took 11.70 ?s
[12:56:34] [main/INFO]: Registering recipes transfer handlers: constructionwand:constructionwand ...
[12:56:34] [main/INFO]: Registering recipes transfer handlers: constructionwand:constructionwand took 12.00 ?s
[12:56:34] [main/INFO]: Registering recipes transfer handlers: ftblibrary:jei ...
[12:56:34] [main/INFO]: Registering recipes transfer handlers: ftblibrary:jei took 11.70 ?s
[12:56:34] [main/INFO]: Registering recipes transfer handlers: ftbquests:jei ...
[12:56:34] [main/INFO]: Registering recipes transfer handlers: ftbquests:jei took 14.50 ?s
[12:56:34] [main/INFO]: Registering recipes transfer handlers: trashcans:jei_plugin ...
[12:56:34] [main/INFO]: Registering recipes transfer handlers: trashcans:jei_plugin took 12.90 ?s
[12:56:34] [main/INFO]: Registering recipes transfer handlers: jei:internal ...
[12:56:34] [main/INFO]: Registering recipes transfer handlers: jei:internal took 13.20 ?s
[12:56:34] [main/INFO]: Registering recipe catalysts: jei:minecraft ...
[12:56:34] [main/INFO]: Registering recipe catalysts: jei:minecraft took 422.4 ?s
[12:56:34] [main/INFO]: Registering recipe catalysts: cgm:crafting ...
[12:56:34] [main/INFO]: Registering recipe catalysts: cgm:crafting took 96.30 ?s
[12:56:34] [main/INFO]: Registering recipe catalysts: jei:debug ...
[12:56:34] [main/INFO]: Registering recipe catalysts: jei:debug took 23.70 ?s
[12:56:34] [main/INFO]: Registering recipe catalysts: cookingforblockheads:jei ...
[12:56:34] [main/INFO]: Registering recipe catalysts: cookingforblockheads:jei took 69.30 ?s
[12:56:34] [main/INFO]: Registering recipe catalysts: appliedenergistics2:core ...
[12:56:34] [main/INFO]: Registering recipe catalysts: appliedenergistics2:core took 148.1 ?s
[12:56:34] [main/INFO]: Registering recipe catalysts: artifacts:main ...
[12:56:34] [main/INFO]: Registering recipe catalysts: artifacts:main took 21.40 ?s
[12:56:34] [main/INFO]: Registering recipe catalysts: compactmachines:main ...
[12:56:34] [main/INFO]: Registering recipe catalysts: compactmachines:main took 17.50 ?s
[12:56:34] [main/INFO]: Registering recipe catalysts: sophisticatedbackpacks:default ...
[12:56:34] [main/INFO]: Registering recipe catalysts: sophisticatedbackpacks:default took 102.9 ?s
[12:56:34] [main/INFO]: Registering recipe catalysts: darkutils:jei_support ...
[12:56:34] [main/INFO]: Registering recipe catalysts: darkutils:jei_support took 16.60 ?s
[12:56:34] [main/INFO]: Registering recipe catalysts: mekanismgenerators:jei_plugin ...
[12:56:34] [main/INFO]: Registering recipe catalysts: mekanismgenerators:jei_plugin took 2.405 ms
[12:56:34] [main/INFO]: Registering recipe catalysts: mekanism:jei_plugin ...
[12:56:34] [main/INFO]: Registering recipe catalysts: mekanism:jei_plugin took 3.794 ms
[12:56:34] [main/INFO]: Registering recipe catalysts: cofh_core:default ...
[12:56:34] [main/INFO]: Registering recipe catalysts: cofh_core:default took 25.30 ?s
[12:56:34] [main/INFO]: Registering recipe catalysts: industrialforegoing:default ...
[12:56:34] [main/INFO]: Registering recipe catalysts: industrialforegoing:default took 780.7 ?s
[12:56:34] [main/INFO]: Registering recipe catalysts: titanium:default ...
[12:56:34] [main/INFO]: Registering recipe catalysts: titanium:default took 22.10 ?s
[12:56:34] [main/INFO]: Registering recipe catalysts: lollipop:main ...
[12:56:34] [main/INFO]: Registering recipe catalysts: lollipop:main took 17.20 ?s
[12:56:34] [main/INFO]: Registering recipe catalysts: krate:main ...
[12:56:34] [main/INFO]: Registering recipe catalysts: krate:main took 19.30 ?s
[12:56:34] [main/INFO]: Registering recipe catalysts: create:jei_plugin ...
[12:56:34] [main/INFO]: Registering recipe catalysts: create:jei_plugin took 23.32 ms
[12:56:34] [main/INFO]: Registering recipe catalysts: curios:curios ...
[12:56:34] [main/INFO]: Registering recipe catalysts: curios:curios took 23.80 ?s
[12:56:34] [main/INFO]: Registering recipe catalysts: securitycraft:securitycraft ...
[12:56:34] [main/INFO]: Registering recipe catalysts: securitycraft:securitycraft took 200.9 ?s
[12:56:34] [main/INFO]: Registering recipe catalysts: fluxnetworks:jei ...
[12:56:34] [main/INFO]: Registering recipe catalysts: fluxnetworks:jei took 907.7 ?s
[12:56:34] [main/INFO]: Registering recipe catalysts: mekanismtools:jei_plugin ...
[12:56:34] [main/INFO]: Registering recipe catalysts: mekanismtools:jei_plugin took 18.80 ?s
[12:56:34] [main/INFO]: Registering recipe catalysts: constructionwand:constructionwand ...
[12:56:34] [main/INFO]: Registering recipe catalysts: constructionwand:constructionwand took 19.90 ?s
[12:56:34] [main/INFO]: Registering recipe catalysts: ftblibrary:jei ...
[12:56:34] [main/INFO]: Registering recipe catalysts: ftblibrary:jei took 14.30 ?s
[12:56:34] [main/INFO]: Registering recipe catalysts: ftbquests:jei ...
[12:56:34] [main/INFO]: Registering recipe catalysts: ftbquests:jei took 15.70 ?s
[12:56:34] [main/INFO]: Registering recipe catalysts: trashcans:jei_plugin ...
[12:56:34] [main/INFO]: Registering recipe catalysts: trashcans:jei_plugin took 16.70 ?s
[12:56:34] [main/INFO]: Registering recipe catalysts: jei:internal ...
[12:56:34] [main/INFO]: Registering recipe catalysts: jei:internal took 55.40 ?s
[12:56:34] [main/INFO]: Registering gui handlers: jei:minecraft ...
[12:56:34] [main/INFO]: Registering gui handlers: jei:minecraft took 7.822 ms
[12:56:34] [main/INFO]: Registering gui handlers: cgm:crafting ...
[12:56:34] [main/INFO]: Registering gui handlers: cgm:crafting took 30.90 ?s
[12:56:34] [main/INFO]: Registering gui handlers: jei:debug ...
[12:56:34] [main/INFO]: Registering gui handlers: jei:debug took 27.30 ?s
[12:56:34] [main/INFO]: Registering gui handlers: cookingforblockheads:jei ...
[12:56:34] [main/INFO]: Registering gui handlers: cookingforblockheads:jei took 1.817 ms
[12:56:34] [main/INFO]: Registering gui handlers: appliedenergistics2:core ...
[12:56:34] [main/INFO]: Registering gui handlers: appliedenergistics2:core took 3.870 ms
[12:56:34] [main/INFO]: Registering gui handlers: artifacts:main ...
[12:56:34] [main/INFO]: Registering gui handlers: artifacts:main took 74.70 ?s
[12:56:34] [main/INFO]: Registering gui handlers: compactmachines:main ...
[12:56:34] [main/INFO]: Registering gui handlers: compactmachines:main took 18.00 ?s
[12:56:34] [main/INFO]: Registering gui handlers: sophisticatedbackpacks:default ...
[12:56:34] [main/INFO]: Registering gui handlers: sophisticatedbackpacks:default took 22.24 ms
[12:56:34] [main/INFO]: Registering gui handlers: darkutils:jei_support ...
[12:56:34] [main/INFO]: Registering gui handlers: darkutils:jei_support took 16.60 ?s
[12:56:34] [main/INFO]: Registering gui handlers: mekanismgenerators:jei_plugin ...
[12:56:34] [main/INFO]: Registering gui handlers: mekanismgenerators:jei_plugin took 52.20 ?s
[12:56:34] [main/INFO]: Registering gui handlers: mekanism:jei_plugin ...
[12:56:34] [main/INFO]: Registering gui handlers: mekanism:jei_plugin took 5.943 ms
[12:56:34] [main/INFO]: Registering gui handlers: cofh_core:default ...
[12:56:34] [main/INFO]: Registering gui handlers: cofh_core:default took 30.39 ms
[12:56:34] [main/INFO]: Registering gui handlers: industrialforegoing:default ...
[12:56:34] [main/INFO]: Registering gui handlers: industrialforegoing:default took 5.186 ms
[12:56:34] [main/INFO]: Registering gui handlers: titanium:default ...
[12:56:34] [main/INFO]: Registering gui handlers: titanium:default took 59.04 ms
[12:56:34] [main/INFO]: Registering gui handlers: lollipop:main ...
[12:56:34] [main/INFO]: Registering gui handlers: lollipop:main took 14.97 ms
[12:56:34] [main/INFO]: Registering gui handlers: krate:main ...
[12:56:34] [main/INFO]: Registering gui handlers: krate:main took 13.20 ?s
[12:56:34] [main/INFO]: Registering gui handlers: create:jei_plugin ...
[12:56:34] [main/INFO]: Registering gui handlers: create:jei_plugin took 50.04 ms
[12:56:34] [main/INFO]: Registering gui handlers: curios:curios ...
[12:56:34] [main/INFO]: Registering gui handlers: curios:curios took 42.82 ms
[12:56:34] [main/INFO]: Registering gui handlers: securitycraft:securitycraft ...
[12:56:34] [main/INFO]: Registering gui handlers: securitycraft:securitycraft took 1.712 ms
[12:56:34] [main/INFO]: Registering gui handlers: fluxnetworks:jei ...
[12:56:34] [main/INFO]: Registering gui handlers: fluxnetworks:jei took 12.10 ?s
[12:56:34] [main/INFO]: Registering gui handlers: mekanismtools:jei_plugin ...
[12:56:34] [main/INFO]: Registering gui handlers: mekanismtools:jei_plugin took 10.60 ?s
[12:56:34] [main/INFO]: Registering gui handlers: constructionwand:constructionwand ...
[12:56:34] [main/INFO]: Registering gui handlers: constructionwand:constructionwand took 10.80 ?s
[12:56:34] [main/INFO]: Registering gui handlers: ftblibrary:jei ...
[12:56:34] [main/INFO]: Registering gui handlers: ftblibrary:jei took 117.3 ?s
[12:56:34] [main/INFO]: Registering gui handlers: ftbquests:jei ...
[12:56:34] [main/INFO]: Registering gui handlers: ftbquests:jei took 13.40 ?s
[12:56:34] [main/INFO]: Registering gui handlers: trashcans:jei_plugin ...
[12:56:34] [main/INFO]: Registering gui handlers: trashcans:jei_plugin took 47.01 ms
[12:56:34] [main/INFO]: Registering gui handlers: jei:internal ...
[12:56:34] [main/INFO]: Registering gui handlers: jei:internal took 5.995 ms
[12:56:34] [main/INFO]: Registering advanced plugins: jei:minecraft ...
[12:56:34] [main/INFO]: Registering advanced plugins: jei:minecraft took 43.00 ?s
[12:56:34] [main/INFO]: Registering advanced plugins: cgm:crafting ...
[12:56:34] [main/INFO]: Registering advanced plugins: cgm:crafting took 10.50 ?s
[12:56:34] [main/INFO]: Registering advanced plugins: jei:debug ...
[12:56:34] [main/INFO]: Registering advanced plugins: jei:debug took 10.00 ?s
[12:56:34] [main/INFO]: Registering advanced plugins: cookingforblockheads:jei ...
[12:56:34] [main/INFO]: Registering advanced plugins: cookingforblockheads:jei took 10.20 ?s
[12:56:34] [main/INFO]: Registering advanced plugins: appliedenergistics2:core ...
[12:56:34] [main/INFO]: Added recipe manager plugin: class appeng.integration.modules.jei.FacadeRegistryPlugin
[12:56:34] [main/INFO]: Registering advanced plugins: appliedenergistics2:core took 1.474 ms
[12:56:34] [main/INFO]: Registering advanced plugins: artifacts:main ...
[12:56:34] [main/INFO]: Registering advanced plugins: artifacts:main took 10.60 ?s
[12:56:34] [main/INFO]: Registering advanced plugins: compactmachines:main ...
[12:56:34] [main/INFO]: Registering advanced plugins: compactmachines:main took 10.10 ?s
[12:56:34] [main/INFO]: Registering advanced plugins: sophisticatedbackpacks:default ...
[12:56:34] [main/INFO]: Registering advanced plugins: sophisticatedbackpacks:default took 28.70 ?s
[12:56:34] [main/INFO]: Registering advanced plugins: darkutils:jei_support ...
[12:56:34] [main/INFO]: Registering advanced plugins: darkutils:jei_support took 15.70 ?s
[12:56:34] [main/INFO]: Registering advanced plugins: mekanismgenerators:jei_plugin ...
[12:56:34] [main/INFO]: Registering advanced plugins: mekanismgenerators:jei_plugin took 14.60 ?s
[12:56:34] [main/INFO]: Registering advanced plugins: mekanism:jei_plugin ...
[12:56:34] [main/INFO]: Registering advanced plugins: mekanism:jei_plugin took 13.00 ?s
[12:56:34] [main/INFO]: Registering advanced plugins: cofh_core:default ...
[12:56:34] [main/INFO]: Registering advanced plugins: cofh_core:default took 11.80 ?s
[12:56:34] [main/INFO]: Registering advanced plugins: industrialforegoing:default ...
[12:56:34] [main/INFO]: Registering advanced plugins: industrialforegoing:default took 11.70 ?s
[12:56:34] [main/INFO]: Registering advanced plugins: titanium:default ...
[12:56:34] [main/INFO]: Registering advanced plugins: titanium:default took 11.50 ?s
[12:56:34] [main/INFO]: Registering advanced plugins: lollipop:main ...
[12:56:34] [main/INFO]: Registering advanced plugins: lollipop:main took 15.10 ?s
[12:56:34] [main/INFO]: Registering advanced plugins: krate:main ...
[12:56:34] [main/INFO]: Registering advanced plugins: krate:main took 17.50 ?s
[12:56:34] [main/INFO]: Registering advanced plugins: create:jei_plugin ...
[12:56:34] [main/INFO]: Registering advanced plugins: create:jei_plugin took 31.10 ?s
[12:56:34] [main/INFO]: Registering advanced plugins: curios:curios ...
[12:56:34] [main/INFO]: Registering advanced plugins: curios:curios took 21.60 ?s
[12:56:34] [main/INFO]: Registering advanced plugins: securitycraft:securitycraft ...
[12:56:34] [main/INFO]: Registering advanced plugins: securitycraft:securitycraft took 17.90 ?s
[12:56:34] [main/INFO]: Registering advanced plugins: fluxnetworks:jei ...
[12:56:34] [main/INFO]: Registering advanced plugins: fluxnetworks:jei took 10.80 ?s
[12:56:34] [main/INFO]: Registering advanced plugins: mekanismtools:jei_plugin ...
[12:56:34] [main/INFO]: Registering advanced plugins: mekanismtools:jei_plugin took 33.50 ?s
[12:56:34] [main/INFO]: Registering advanced plugins: constructionwand:constructionwand ...
[12:56:34] [main/INFO]: Registering advanced plugins: constructionwand:constructionwand took 11.80 ?s
[12:56:34] [main/INFO]: Registering advanced plugins: ftblibrary:jei ...
[12:56:34] [main/INFO]: Registering advanced plugins: ftblibrary:jei took 11.90 ?s
[12:56:34] [main/INFO]: Registering advanced plugins: ftbquests:jei ...
[12:56:34] [main/INFO]: Registering advanced plugins: ftbquests:jei took 13.20 ?s
[12:56:34] [main/INFO]: Registering advanced plugins: trashcans:jei_plugin ...
[12:56:34] [main/INFO]: Registering advanced plugins: trashcans:jei_plugin took 12.60 ?s
[12:56:34] [main/INFO]: Registering advanced plugins: jei:internal ...
[12:56:34] [main/INFO]: Registering advanced plugins: jei:internal took 44.40 ?s
[12:56:34] [main/INFO]: Building ingredient list...
[12:56:34] [main/INFO]: Building ingredient list took 9.763 ms
[12:56:34] [main/INFO]: Building ingredient filter...
[12:56:38] [main/INFO]: Building ingredient filter took 3.401 s
[12:56:38] [main/INFO]: Building bookmarks...
[12:56:38] [main/INFO]: Building bookmarks took 157.5 ms
[12:56:38] [main/INFO]: Building recipe registry...
[12:56:39] [main/INFO]: Building recipe registry took 1.013 s
[12:56:39] [main/INFO]: Building runtime...
[12:56:39] [main/INFO]: Building runtime took 146.2 ms
[12:56:39] [main/INFO]: Sending Runtime: jei:minecraft ...
[12:56:39] [main/INFO]: Sending Runtime: jei:minecraft took 55.60 ?s
[12:56:39] [main/INFO]: Sending Runtime: cgm:crafting ...
[12:56:39] [main/INFO]: Sending Runtime: cgm:crafting took 12.40 ?s
[12:56:39] [main/INFO]: Sending Runtime: jei:debug ...
[12:56:39] [main/INFO]: Sending Runtime: jei:debug took 31.00 ?s
[12:56:39] [main/INFO]: Sending Runtime: cookingforblockheads:jei ...
[12:56:39] [main/INFO]: Sending Runtime: cookingforblockheads:jei took 14.60 ?s
[12:56:39] [main/INFO]: Sending Runtime: appliedenergistics2:core ...
[12:56:39] [main/INFO]: Ingredients are being removed at runtime: 10 net.minecraft.item.ItemStack
[12:56:39] [main/ERROR]: Could not find any matching ingredients to remove: 1 FluidDummyItem[dummy_fluid_item] appliedenergistics2:dummy_fluid_item
[12:56:39] [main/INFO]: Sending Runtime: appliedenergistics2:core took 110.0 ms
[12:56:39] [main/INFO]: Sending Runtime: artifacts:main ...
[12:56:39] [main/INFO]: Sending Runtime: artifacts:main took 15.50 ?s
[12:56:39] [main/INFO]: Sending Runtime: compactmachines:main ...
[12:56:39] [main/INFO]: Sending Runtime: compactmachines:main took 14.00 ?s
[12:56:39] [main/INFO]: Sending Runtime: sophisticatedbackpacks:default ...
[12:56:39] [main/INFO]: Sending Runtime: sophisticatedbackpacks:default took 9.899 ?s
[12:56:39] [main/INFO]: Sending Runtime: darkutils:jei_support ...
[12:56:39] [main/INFO]: Sending Runtime: darkutils:jei_support took 10.70 ?s
[12:56:39] [main/INFO]: Sending Runtime: mekanismgenerators:jei_plugin ...
[12:56:39] [main/INFO]: Sending Runtime: mekanismgenerators:jei_plugin took 12.70 ?s
[12:56:39] [main/INFO]: Sending Runtime: mekanism:jei_plugin ...
[12:56:39] [main/INFO]: Sending Runtime: mekanism:jei_plugin took 9.700 ?s
[12:56:39] [main/INFO]: Sending Runtime: cofh_core:default ...
[12:56:39] [main/INFO]: Sending Runtime: cofh_core:default took 14.20 ?s
[12:56:39] [main/INFO]: Sending Runtime: industrialforegoing:default ...
[12:56:39] [main/INFO]: Sending Runtime: industrialforegoing:default took 18.90 ?s
[12:56:39] [main/INFO]: Sending Runtime: titanium:default ...
[12:56:39] [main/INFO]: Sending Runtime: titanium:default took 13.60 ?s
[12:56:39] [main/INFO]: Sending Runtime: lollipop:main ...
[12:56:39] [main/INFO]: Sending Runtime: lollipop:main took 34.20 ?s
[12:56:39] [main/INFO]: Sending Runtime: krate:main ...
[12:56:39] [main/INFO]: Sending Runtime: krate:main took 11.80 ?s
[12:56:39] [main/INFO]: Sending Runtime: create:jei_plugin ...
[12:56:39] [main/INFO]: Sending Runtime: create:jei_plugin took 11.90 ?s
[12:56:39] [main/INFO]: Sending Runtime: curios:curios ...
[12:56:39] [main/INFO]: Sending Runtime: curios:curios took 11.40 ?s
[12:56:39] [main/INFO]: Sending Runtime: securitycraft:securitycraft ...
[12:56:39] [main/INFO]: Sending Runtime: securitycraft:securitycraft took 11.80 ?s
[12:56:39] [main/INFO]: Sending Runtime: fluxnetworks:jei ...
[12:56:39] [main/INFO]: Sending Runtime: fluxnetworks:jei took 12.80 ?s
[12:56:39] [main/INFO]: Sending Runtime: mekanismtools:jei_plugin ...
[12:56:39] [main/INFO]: Sending Runtime: mekanismtools:jei_plugin took 17.10 ?s
[12:56:39] [main/INFO]: Sending Runtime: constructionwand:constructionwand ...
[12:56:39] [main/INFO]: Sending Runtime: constructionwand:constructionwand took 11.00 ?s
[12:56:39] [main/INFO]: Sending Runtime: ftblibrary:jei ...
[12:56:39] [main/INFO]: Sending Runtime: ftblibrary:jei took 30.20 ?s
[12:56:39] [main/INFO]: Sending Runtime: ftbquests:jei ...
[12:56:39] [main/INFO]: Sending Runtime: ftbquests:jei took 18.00 ?s
[12:56:39] [main/INFO]: Sending Runtime: trashcans:jei_plugin ...
[12:56:39] [main/INFO]: Sending Runtime: trashcans:jei_plugin took 11.50 ?s
[12:56:39] [main/INFO]: Sending Runtime: jei:internal ...
[12:56:39] [main/INFO]: Sending Runtime: jei:internal took 51.00 ?s
[12:56:39] [main/INFO]: Starting JEI took 14.50 s
[12:56:40] [main/INFO]: No shader config found.
[12:56:40] [main/WARN]: Unknown custom packet identifier: vehicle:play
[12:56:41] [main/INFO]: Loading FTB Chunks client data from world bce8cdb9-1ec1-4daa-a70b-6e424d422fcf
[12:56:41] [main/INFO]: Read 506 bytes, 1 objects
[12:56:42] [main/INFO]: Received config from the server: {"minecraft:hide_infestations":true}
[12:56:42] [main/INFO]: [CHAT] [SecurityCraft] Thanks for using SecurityCraft v1.8.23! Tip: Have a suggestion for the mod or found a bug? Join our Discord server (English only)! You'll also receive important updates and announcements regarding SecurityCraft. https://discord.gg/U8DvBAW
[12:56:42] [main/INFO]: Loaded 0 advancements
[12:56:47] [main/INFO]: Custom modded block handling enabled for biomesoplenty
[12:56:48] [Worker-Main-27/WARN]: Couldn't look up profile properties for com.mojang.authlib.GameProfile@1e1b9014[id=cb2a9bf2-9730-42ff-9575-79d48c089416,name=kaues,properties={},legacy=false]
com.mojang.authlib.exceptions.InvalidCredentialsException: Invalid arguments
	at com.mojang.authlib.yggdrasil.YggdrasilAuthenticationService.makeRequest(YggdrasilAuthenticationService.java:91) ~[authlib-2.0.28.12.jar:?]
	at com.mojang.authlib.yggdrasil.YggdrasilAuthenticationService.makeRequest(YggdrasilAuthenticationService.java:78) ~[authlib-2.0.28.12.jar:?]
	at com.mojang.authlib.yggdrasil.YggdrasilMinecraftSessionService.fillGameProfile(YggdrasilMinecraftSessionService.java:174) [authlib-2.0.28.12.jar:?]
	at com.mojang.authlib.yggdrasil.YggdrasilMinecraftSessionService$1.load(YggdrasilMinecraftSessionService.java:61) [authlib-2.0.28.12.jar:?]
	at com.mojang.authlib.yggdrasil.YggdrasilMinecraftSessionService$1.load(YggdrasilMinecraftSessionService.java:59) [authlib-2.0.28.12.jar:?]
	at com.google.common.cache.LocalCache$LoadingValueReference.loadFuture(LocalCache.java:3716) [guava-21.0.jar:?]
	at com.google.common.cache.LocalCache$Segment.loadSync(LocalCache.java:2424) [guava-21.0.jar:?]
	at com.google.common.cache.LocalCache$Segment.lockedGetOrLoad(LocalCache.java:2298) [guava-21.0.jar:?]
	at com.google.common.cache.LocalCache$Segment.get(LocalCache.java:2211) [guava-21.0.jar:?]
	at com.google.common.cache.LocalCache.get(LocalCache.java:4154) [guava-21.0.jar:?]
	at com.google.common.cache.LocalCache.getOrLoad(LocalCache.java:4158) [guava-21.0.jar:?]
	at com.google.common.cache.LocalCache$LocalLoadingCache.get(LocalCache.java:5147) [guava-21.0.jar:?]
	at com.google.common.cache.LocalCache$LocalLoadingCache.getUnchecked(LocalCache.java:5153) [guava-21.0.jar:?]
	at com.mojang.authlib.yggdrasil.YggdrasilMinecraftSessionService.fillProfileProperties(YggdrasilMinecraftSessionService.java:166) [authlib-2.0.28.12.jar:?]
	at net.minecraft.client.Minecraft.func_181037_M(Minecraft.java:2173) [?:?]
	at net.minecraft.client.resources.SkinManager.func_229293_a_(SourceFile:98) [?:?]
	at net.minecraft.client.resources.SkinManager$$Lambda$16182/75010786.run(Unknown Source) [?:?]
	at java.util.concurrent.ForkJoinTask$RunnableExecuteAction.exec(ForkJoinTask.java:1402) [?:1.8.0_51]
	at java.util.concurrent.ForkJoinTask.doExec(ForkJoinTask.java:289) [?:1.8.0_51]
	at java.util.concurrent.ForkJoinPool$WorkQueue.runTask(ForkJoinPool.java:1056) [?:1.8.0_51]
	at java.util.concurrent.ForkJoinPool.runWorker(ForkJoinPool.java:1689) [?:1.8.0_51]
	at java.util.concurrent.ForkJoinWorkerThread.run(ForkJoinWorkerThread.java:157) [?:1.8.0_51]
[12:56:53] [main/INFO]: Loaded 18 advancements
[12:56:54] [main/INFO]: [CHAT] eJourneyMap:f Press [bJf]
[12:56:54] [main/INFO]: 
[12:56:55] [main/WARN]: core (Initialized) Bad configField entry during updateFrom(): optionsManagerViewed=null
[12:56:57] [main/INFO]: Loaded 0 waypoints from C:\Users\kaues\AppData\Roaming\.minecraft\versions\Ender Tech\journeymap\data\sp\Novo mundo ~2~\waypoints
[12:56:57] [main/INFO]: Mapping started in C:\Users\kaues\AppData\Roaming\.minecraft\versions\Ender Tech\journeymap\data\sp\Novo mundo ~2~\overworld. Memory: 2219MB total, 617MB free 
[12:57:07] [main/INFO]: textures 'cape_test_272' was added, skin: false,cape: true, max waiting: 236 ,during : 59457 
[12:57:07] [main/INFO]: calculated cape performance:TEXTURE_136, middle time: 66.5
[12:57:12] [main/INFO]: textures 'elitra_test_272' was added, skin: false,cape: true, max waiting: 204 ,during : 63759 
[12:57:12] [main/INFO]: can use texture size:TEXTURE_136, middle time: 28.6
[12:58:13] [Server thread/WARN]: Can't keep up! Is the server overloaded? Running 2019ms or 40 ticks behind
[12:58:28] [main/WARN]: Optifine is detected. JEI's fast item rendering is being disabled to prevent rendering issues.
[12:58:57] [main/WARN]: Unable to play empty soundEvent: minecraft:entity.salmon.ambient
[12:59:05] [main/WARN]: Unable to play empty soundEvent: minecraft:entity.cod.ambient
[12:59:06] [main/INFO]: Loaded 35 advancements
[12:59:25] [Server thread/WARN]: Can't keep up! Is the server overloaded? Running 2014ms or 40 ticks behind
[12:59:52] [main/INFO]: Loaded 39 advancements
[12:59:58] [main/WARN]: TileDrawStep.updateRegionTexture was slow: 222.8986 (Warning limit reached)
[12:59:59] [main/WARN]: TileDrawStep.updateRegionTexture: Avg:     0,38ms, Min:        0ms, Max:     441,53ms, Total:          2 sec, Count:     6616, Canceled:        0, Slow:       10
[13:01:13] [Server thread/WARN]: Can't keep up! Is the server overloaded? Running 8220ms or 164 ticks behind
[13:02:00] [Server thread/WARN]: Can't keep up! Is the server overloaded? Running 2021ms or 40 ticks behind
[13:02:22] [Server thread/WARN]: Can't keep up! Is the server overloaded? Running 7272ms or 145 ticks behind
[13:03:17] [Server thread/WARN]: Can't keep up! Is the server overloaded? Running 2024ms or 40 ticks behind
[13:03:21] [main/WARN]: Unable to play empty soundEvent: minecraft:entity.tropical_fish.ambient
[13:03:38] [Server thread/WARN]: Can't keep up! Is the server overloaded? Running 5499ms or 109 ticks behind
[13:04:43] [Server thread/WARN]: Can't keep up! Is the server overloaded? Running 2201ms or 44 ticks behind
[13:04:51] [Server thread/INFO]: kaues conquistou a proeza [Caador de monstros]
[13:04:52] [main/INFO]: [CHAT] kaues conquistou a proeza [Caador de monstros]
[13:04:52] [main/INFO]: Loaded 58 advancements
[13:04:53] [main/INFO]: Loaded 71 advancements
[13:04:54] [main/INFO]: Loaded 71 advancements
[13:05:03] [Server thread/WARN]: Can't keep up! Is the server overloaded? Running 4872ms or 97 ticks behind
[13:05:23] [Server thread/WARN]: Can't keep up! Is the server overloaded? Running 5104ms or 102 ticks behind
[13:05:43] [Server thread/WARN]: Can't keep up! Is the server overloaded? Running 4691ms or 93 ticks behind
[13:06:51] [Server thread/WARN]: Can't keep up! Is the server overloaded? Running 3871ms or 77 ticks behind
[13:07:37] [Server thread/INFO]: kaues conquistou a proeza [Amateur Archaeologist]
[13:07:37] [main/INFO]: [CHAT] kaues conquistou a proeza [Amateur Archaeologist]
[13:07:37] [main/INFO]: Loaded 71 advancements
[13:08:13] [Server thread/WARN]: Can't keep up! Is the server overloaded? Running 4179ms or 83 ticks behind
[13:08:15] [Server thread/INFO]: [kaues: O modo de jogo foi definido para Modo Sobrevivncia]
[13:08:15] [main/INFO]: [CHAT] O modo de jogo foi definido para Modo Sobrevivncia
[13:08:38] [main/WARN]: Can't bind texture: java.util.ConcurrentModificationException
[13:08:40] [Server thread/WARN]: Can't keep up! Is the server overloaded? Running 12010ms or 240 ticks behind
[13:09:08] [main/INFO]: [CHAT] O modo de jogo foi definido para 
[13:09:08] [Server thread/INFO]: [kaues: O modo de jogo foi definido para Modo Criativo]
[13:09:12] [Server thread/WARN]: Can't keep up! Is the server overloaded? Running 3691ms or 73 ticks behind
[13:11:39] [Server thread/WARN]: Can't keep up! Is the server overloaded? Running 2005ms or 40 ticks behind
[13:11:58] [main/INFO]: Loaded 73 advancements
[13:11:58] [Server thread/WARN]: Can't keep up! Is the server overloaded? Running 4024ms or 80 ticks behind
[13:11:59] [main/INFO]: Loaded 73 advancements
[13:12:02] [Server thread/INFO]: [kaues: O modo de jogo foi definido para Modo Sobrevivncia]
[13:12:02] [main/INFO]: [CHAT] O modo de jogo foi definido para Modo Sobrevivncia
[13:12:27] [Server thread/WARN]: Can't keep up! Is the server overloaded? Running 9949ms or 198 ticks behind
[13:12:46] [Server thread/WARN]: Can't keep up! Is the server overloaded? Running 2085ms or 41 ticks behind
[13:13:28] [Server thread/INFO]: [kaues: O ponto de renascimento do mundo foi definido para 28, 64, -932 [0.0]]
[13:13:28] [main/INFO]: [CHAT] O ponto de renascimento do mundo foi definido para 28, 64, -932 [0.0]
[13:13:30] [Server thread/WARN]: Can't keep up! Is the server overloaded? Running 2298ms or 45 ticks behind
[13:13:40] [Server thread/INFO]: [kaues: O modo de jogo foi definido para Modo Criativo]
[13:13:40] [main/INFO]: [CHAT] O modo de jogo foi definido para Modo Criativo
[13:13:47] [Server thread/WARN]: Can't keep up! Is the server overloaded? Running 2682ms or 53 ticks behind
[13:15:35] [Server thread/WARN]: Can't keep up! Is the server overloaded? Running 73828ms or 1476 ticks behind
[13:15:55] [Server thread/WARN]: Can't keep up! Is the server overloaded? Running 5321ms or 106 ticks behind
[13:16:19] [Server thread/WARN]: Can't keep up! Is the server overloaded? Running 2300ms or 46 ticks behind
[13:16:26] [main/INFO]: Mapping halted in C:\Users\kaues\AppData\Roaming\.minecraft\versions\Ender Tech\journeymap\data\sp\Novo mundo ~2~\minecraft:overworld
[13:16:28] [Server thread/INFO]: Saving and pausing game...
[13:16:29] [Server thread/INFO]: Saving chunks for level 'ServerLevel[Novo mundo]'/minecraft:overworld
[13:16:29] [main/INFO]: No shader config found.
[13:16:33] [main/WARN]: Unknown custom packet identifier: vehicle:play
[13:16:35] [Server thread/INFO]: Saving chunks for level 'ServerLevel[Novo mundo]'/minecraft:the_nether
[13:16:35] [Server thread/INFO]: Saving chunks for level 'ServerLevel[Novo mundo]'/minecraft:the_end
[13:16:35] [Server thread/INFO]: Saving chunks for level 'ServerLevel[Novo mundo]'/compactmachines:compact_world
[13:16:35] [Server thread/INFO]: Saving chunks for level 'ServerLevel[Novo mundo]'/allthemodium:mining
[13:16:35] [Server thread/INFO]: Saving chunks for level 'ServerLevel[Novo mundo]'/mining_dimension:mining
[13:16:35] [Server thread/INFO]: Saving chunks for level 'ServerLevel[Novo mundo]'/mahoutsukai:reality_marble
[13:16:35] [Server thread/INFO]: Saving chunks for level 'ServerLevel[Novo mundo]'/allthemodium:the_other
[13:16:45] [Worker-Cape-61/ERROR]: Couldn't download http texture: java.lang.RuntimeException: Timeout 5000
[13:16:47] [main/WARN]: core (Initialized) Bad configField entry during updateFrom(): optionsManagerViewed=null
[13:16:48] [main/INFO]: Loaded 0 waypoints from C:\Users\kaues\AppData\Roaming\.minecraft\versions\Ender Tech\journeymap\data\sp\Novo mundo ~2~\waypoints
[13:16:50] [Server thread/WARN]: Can't keep up! Is the server overloaded? Running 16533ms or 330 ticks behind
[13:16:58] [main/INFO]: Mapping started in C:\Users\kaues\AppData\Roaming\.minecraft\versions\Ender Tech\journeymap\data\sp\Novo mundo ~2~\compactmachines~compact_world. Memory: 2700MB total, 35MB free 
[13:19:15] [Server thread/WARN]: Can't keep up! Is the server overloaded? Running 3878ms or 77 ticks behind
[13:22:34] [Server thread/WARN]: Can't keep up! Is the server overloaded? Running 5847ms or 116 ticks behind
[13:22:35] [main/INFO]: Loaded 74 advancements
[13:23:15] [Server thread/INFO]: [kaues: O modo de jogo foi definido para Modo Sobrevivncia]
[13:23:15] [main/INFO]: [CHAT] O modo de jogo foi definido para Modo Sobrevivncia
[13:23:37] [Server thread/WARN]: Can't keep up! Is the server overloaded? Running 14151ms or 283 ticks behind
[13:24:02] [Server thread/WARN]: Can't keep up! Is the server overloaded? Running 6169ms or 123 ticks behind
[13:24:49] [Server thread/WARN]: Can't keep up! Is the server overloaded? Running 4221ms or 84 ticks behind
[13:25:10] [Server thread/WARN]: Can't keep up! Is the server overloaded? Running 5737ms or 114 ticks behind
[13:25:52] [Server thread/WARN]: Can't keep up! Is the server overloaded? Running 3763ms or 75 ticks behind
[13:27:03] [Server thread/INFO]: [kaues: O modo de jogo foi definido para Modo Criativo]
[13:27:03] [main/INFO]: [CHAT] O modo de jogo foi definido para Modo Criativo
[13:27:12] [Server thread/INFO]: [kaues: O modo de jogo foi definido para Modo Sobrevivncia]
[13:27:12] [main/INFO]: [CHAT] O modo de jogo foi definido para Modo Sobrevivncia
[13:28:00] [Server thread/INFO]: [kaues: kaues recebeu 1 [Infinity Wand]]
[13:28:00] [main/INFO]: [CHAT] kaues recebeu 1 [Infinity Wand]
[13:28:23] [Server thread/INFO]: [kaues: O modo de jogo foi definido para Modo Criativo]
[13:28:23] [main/INFO]: [CHAT] O modo de jogo foi definido para Modo Criativo
[13:28:27] [Server thread/INFO]: [kaues: O modo de jogo foi definido para Modo Sobrevivncia]
[13:28:27] [main/INFO]: [CHAT] O modo de jogo foi definido para Modo Sobrevivncia
[13:28:47] [Server thread/INFO]: Saving and pausing game...
[13:28:47] [Server thread/INFO]: Saving chunks for level 'ServerLevel[Novo mundo]'/minecraft:overworld
[13:28:48] [Server thread/INFO]: Saving chunks for level 'ServerLevel[Novo mundo]'/minecraft:the_nether
[13:28:48] [Server thread/INFO]: Saving chunks for level 'ServerLevel[Novo mundo]'/minecraft:the_end
[13:28:48] [Server thread/INFO]: Saving chunks for level 'ServerLevel[Novo mundo]'/compactmachines:compact_world
[13:28:48] [Server thread/INFO]: Saving chunks for level 'ServerLevel[Novo mundo]'/allthemodium:mining
[13:28:48] [Server thread/INFO]: Saving chunks for level 'ServerLevel[Novo mundo]'/mining_dimension:mining
[13:28:48] [Server thread/INFO]: Saving chunks for level 'ServerLevel[Novo mundo]'/mahoutsukai:reality_marble
[13:28:48] [Server thread/INFO]: Saving chunks for level 'ServerLevel[Novo mundo]'/allthemodium:the_other
[13:29:04] [main/INFO]: Reloading ResourceManager: Default, Mod Resources
[13:29:05] [main/INFO]: [OptiFine] *** Reloading textures ***
[13:29:05] [main/INFO]: [OptiFine] Resource packs: Mod Resources
[13:29:07] [Worker-Main-115/INFO]: [OptiFine] Multitexture: false
[13:29:19] [Worker-Main-116/INFO]: [OptiFine] Multitexture: false
[13:30:14] [Worker-Main-117/WARN]: Exception loading blockstate definition: industrialforegoing:blockstates/sludge_block.json: java.io.FileNotFoundException: industrialforegoing:blockstates/sludge_block.json
[13:30:14] [Worker-Main-117/WARN]: Exception loading blockstate definition: 'industrialforegoing:blockstates/sludge_block.json' missing model for variant: 'industrialforegoing:sludge_block#level=9'
[13:30:14] [Worker-Main-117/WARN]: Exception loading blockstate definition: 'industrialforegoing:blockstates/sludge_block.json' missing model for variant: 'industrialforegoing:sludge_block#level=8'
[13:30:14] [Worker-Main-117/WARN]: Exception loading blockstate definition: 'industrialforegoing:blockstates/sludge_block.json' missing model for variant: 'industrialforegoing:sludge_block#level=10'
[13:30:14] [Worker-Main-117/WARN]: Exception loading blockstate definition: 'industrialforegoing:blockstates/sludge_block.json' missing model for variant: 'industrialforegoing:sludge_block#level=11'
[13:30:14] [Worker-Main-117/WARN]: Exception loading blockstate definition: 'industrialforegoing:blockstates/sludge_block.json' missing model for variant: 'industrialforegoing:sludge_block#level=12'
[13:30:14] [Worker-Main-117/WARN]: Exception loading blockstate definition: 'industrialforegoing:blockstates/sludge_block.json' missing model for variant: 'industrialforegoing:sludge_block#level=13'
[13:30:14] [Worker-Main-117/WARN]: Exception loading blockstate definition: 'industrialforegoing:blockstates/sludge_block.json' missing model for variant: 'industrialforegoing:sludge_block#level=14'
[13:30:14] [Worker-Main-117/WARN]: Exception loading blockstate definition: 'industrialforegoing:blockstates/sludge_block.json' missing model for variant: 'industrialforegoing:sludge_block#level=15'
[13:30:14] [Worker-Main-117/WARN]: Exception loading blockstate definition: 'industrialforegoing:blockstates/sludge_block.json' missing model for variant: 'industrialforegoing:sludge_block#level=7'
[13:30:14] [Worker-Main-117/WARN]: Exception loading blockstate definition: 'industrialforegoing:blockstates/sludge_block.json' missing model for variant: 'industrialforegoing:sludge_block#level=6'
[13:30:14] [Worker-Main-117/WARN]: Exception loading blockstate definition: 'industrialforegoing:blockstates/sludge_block.json' missing model for variant: 'industrialforegoing:sludge_block#level=5'
[13:30:14] [Worker-Main-117/WARN]: Exception loading blockstate definition: 'industrialforegoing:blockstates/sludge_block.json' missing model for variant: 'industrialforegoing:sludge_block#level=4'
[13:30:14] [Worker-Main-117/WARN]: Exception loading blockstate definition: 'industrialforegoing:blockstates/sludge_block.json' missing model for variant: 'industrialforegoing:sludge_block#level=3'
[13:30:14] [Worker-Main-117/WARN]: Exception loading blockstate definition: 'industrialforegoing:blockstates/sludge_block.json' missing model for variant: 'industrialforegoing:sludge_block#level=2'
[13:30:15] [Worker-Main-117/WARN]: Exception loading blockstate definition: 'industrialforegoing:blockstates/sludge_block.json' missing model for variant: 'industrialforegoing:sludge_block#level=1'
[13:30:15] [Worker-Main-117/WARN]: Exception loading blockstate definition: 'industrialforegoing:blockstates/sludge_block.json' missing model for variant: 'industrialforegoing:sludge_block#level=0'
[13:30:15] [Worker-Main-117/WARN]: Exception loading blockstate definition: industrialforegoing:blockstates/ether_gas_block.json: java.io.FileNotFoundException: industrialforegoing:blockstates/ether_gas_block.json
[13:30:15] [Worker-Main-117/WARN]: Exception loading blockstate definition: 'industrialforegoing:blockstates/ether_gas_block.json' missing model for variant: 'industrialforegoing:ether_gas_block#level=6'
[13:30:15] [Worker-Main-117/WARN]: Exception loading blockstate definition: 'industrialforegoing:blockstates/ether_gas_block.json' missing model for variant: 'industrialforegoing:ether_gas_block#level=7'
[13:30:15] [Worker-Main-117/WARN]: Exception loading blockstate definition: 'industrialforegoing:blockstates/ether_gas_block.json' missing model for variant: 'industrialforegoing:ether_gas_block#level=8'
[13:30:15] [Worker-Main-117/WARN]: Exception loading blockstate definition: 'industrialforegoing:blockstates/ether_gas_block.json' missing model for variant: 'industrialforegoing:ether_gas_block#level=9'
[13:30:15] [Worker-Main-117/WARN]: Exception loading blockstate definition: 'industrialforegoing:blockstates/ether_gas_block.json' missing model for variant: 'industrialforegoing:ether_gas_block#level=2'
[13:30:15] [Worker-Main-117/WARN]: Exception loading blockstate definition: 'industrialforegoing:blockstates/ether_gas_block.json' missing model for variant: 'industrialforegoing:ether_gas_block#level=3'
[13:30:15] [Worker-Main-117/WARN]: Exception loading blockstate definition: 'industrialforegoing:blockstates/ether_gas_block.json' missing model for variant: 'industrialforegoing:ether_gas_block#level=4'
[13:30:15] [Worker-Main-117/WARN]: Exception loading blockstate definition: 'industrialforegoing:blockstates/ether_gas_block.json' missing model for variant: 'industrialforegoing:ether_gas_block#level=5'
[13:30:15] [Worker-Main-117/WARN]: Exception loading blockstate definition: 'industrialforegoing:blockstates/ether_gas_block.json' missing model for variant: 'industrialforegoing:ether_gas_block#level=15'
[13:30:15] [Worker-Main-117/WARN]: Exception loading blockstate definition: 'industrialforegoing:blockstates/ether_gas_block.json' missing model for variant: 'industrialforegoing:ether_gas_block#level=12'
[13:30:15] [Worker-Main-117/WARN]: Exception loading blockstate definition: 'industrialforegoing:blockstates/ether_gas_block.json' missing model for variant: 'industrialforegoing:ether_gas_block#level=11'
[13:30:16] [Worker-Main-117/WARN]: Exception loading blockstate definition: 'industrialforegoing:blockstates/ether_gas_block.json' missing model for variant: 'industrialforegoing:ether_gas_block#level=14'
[13:30:16] [Worker-Main-117/WARN]: Exception loading blockstate definition: 'industrialforegoing:blockstates/ether_gas_block.json' missing model for variant: 'industrialforegoing:ether_gas_block#level=13'
[13:30:16] [Worker-Main-117/WARN]: Exception loading blockstate definition: 'industrialforegoing:blockstates/ether_gas_block.json' missing model for variant: 'industrialforegoing:ether_gas_block#level=10'
[13:30:16] [Worker-Main-117/WARN]: Exception loading blockstate definition: 'industrialforegoing:blockstates/ether_gas_block.json' missing model for variant: 'industrialforegoing:ether_gas_block#level=0'
[13:30:16] [Worker-Main-117/WARN]: Exception loading blockstate definition: 'industrialforegoing:blockstates/ether_gas_block.json' missing model for variant: 'industrialforegoing:ether_gas_block#level=1'
[13:30:16] [Worker-Main-117/WARN]: Exception loading blockstate definition: industrialforegoing:blockstates/biofuel_block.json: java.io.FileNotFoundException: industrialforegoing:blockstates/biofuel_block.json
[13:30:16] [Worker-Main-117/WARN]: Exception loading blockstate definition: 'industrialforegoing:blockstates/biofuel_block.json' missing model for variant: 'industrialforegoing:biofuel_block#level=15'
[13:30:16] [Worker-Main-117/WARN]: Exception loading blockstate definition: 'industrialforegoing:blockstates/biofuel_block.json' missing model for variant: 'industrialforegoing:biofuel_block#level=14'
[13:30:16] [Worker-Main-117/WARN]: Exception loading blockstate definition: 'industrialforegoing:blockstates/biofuel_block.json' missing model for variant: 'industrialforegoing:biofuel_block#level=13'
[13:30:16] [Worker-Main-117/WARN]: Exception loading blockstate definition: 'industrialforegoing:blockstates/biofuel_block.json' missing model for variant: 'industrialforegoing:biofuel_block#level=12'
[13:30:16] [Worker-Main-117/WARN]: Exception loading blockstate definition: 'industrialforegoing:blockstates/biofuel_block.json' missing model for variant: 'industrialforegoing:biofuel_block#level=11'
[13:30:16] [Worker-Main-117/WARN]: Exception loading blockstate definition: 'industrialforegoing:blockstates/biofuel_block.json' missing model for variant: 'industrialforegoing:biofuel_block#level=10'
[13:30:16] [Worker-Main-117/WARN]: Exception loading blockstate definition: 'industrialforegoing:blockstates/biofuel_block.json' missing model for variant: 'industrialforegoing:biofuel_block#level=8'
[13:30:16] [Worker-Main-117/WARN]: Exception loading blockstate definition: 'industrialforegoing:blockstates/biofuel_block.json' missing model for variant: 'industrialforegoing:biofuel_block#level=9'
[13:30:16] [Worker-Main-117/WARN]: Exception loading blockstate definition: 'industrialforegoing:blockstates/biofuel_block.json' missing model for variant: 'industrialforegoing:biofuel_block#level=6'
[13:30:16] [Worker-Main-117/WARN]: Exception loading blockstate definition: 'industrialforegoing:blockstates/biofuel_block.json' missing model for variant: 'industrialforegoing:biofuel_block#level=7'
[13:30:16] [Worker-Main-117/WARN]: Exception loading blockstate definition: 'industrialforegoing:blockstates/biofuel_block.json' missing model for variant: 'industrialforegoing:biofuel_block#level=4'
[13:30:16] [Worker-Main-117/WARN]: Exception loading blockstate definition: 'industrialforegoing:blockstates/biofuel_block.json' missing model for variant: 'industrialforegoing:biofuel_block#level=5'
[13:30:16] [Worker-Main-117/WARN]: Exception loading blockstate definition: 'industrialforegoing:blockstates/biofuel_block.json' missing model for variant: 'industrialforegoing:biofuel_block#level=2'
[13:30:16] [Worker-Main-117/WARN]: Exception loading blockstate definition: 'industrialforegoing:blockstates/biofuel_block.json' missing model for variant: 'industrialforegoing:biofuel_block#level=3'
[13:30:16] [Worker-Main-117/WARN]: Exception loading blockstate definition: 'industrialforegoing:blockstates/biofuel_block.json' missing model for variant: 'industrialforegoing:biofuel_block#level=0'
[13:30:16] [Worker-Main-117/WARN]: Exception loading blockstate definition: 'industrialforegoing:blockstates/biofuel_block.json' missing model for variant: 'industrialforegoing:biofuel_block#level=1'
[13:30:16] [Worker-Main-117/WARN]: Exception loading blockstate definition: industrialforegoing:blockstates/essence_block.json: java.io.FileNotFoundException: industrialforegoing:blockstates/essence_block.json
[13:30:16] [Worker-Main-117/WARN]: Exception loading blockstate definition: 'industrialforegoing:blockstates/essence_block.json' missing model for variant: 'industrialforegoing:essence_block#level=10'
[13:30:16] [Worker-Main-117/WARN]: Exception loading blockstate definition: 'industrialforegoing:blockstates/essence_block.json' missing model for variant: 'industrialforegoing:essence_block#level=1'
[13:30:16] [Worker-Main-117/WARN]: Exception loading blockstate definition: 'industrialforegoing:blockstates/essence_block.json' missing model for variant: 'industrialforegoing:essence_block#level=0'
[13:30:16] [Worker-Main-117/WARN]: Exception loading blockstate definition: 'industrialforegoing:blockstates/essence_block.json' missing model for variant: 'industrialforegoing:essence_block#level=7'
[13:30:16] [Worker-Main-117/WARN]: Exception loading blockstate definition: 'industrialforegoing:blockstates/essence_block.json' missing model for variant: 'industrialforegoing:essence_block#level=6'
[13:30:16] [Worker-Main-117/WARN]: Exception loading blockstate definition: 'industrialforegoing:blockstates/essence_block.json' missing model for variant: 'industrialforegoing:essence_block#level=9'
[13:30:16] [Worker-Main-117/WARN]: Exception loading blockstate definition: 'industrialforegoing:blockstates/essence_block.json' missing model for variant: 'industrialforegoing:essence_block#level=8'
[13:30:16] [Worker-Main-117/WARN]: Exception loading blockstate definition: 'industrialforegoing:blockstates/essence_block.json' missing model for variant: 'industrialforegoing:essence_block#level=3'
[13:30:16] [Worker-Main-117/WARN]: Exception loading blockstate definition: 'industrialforegoing:blockstates/essence_block.json' missing model for variant: 'industrialforegoing:essence_block#level=2'
[13:30:16] [Worker-Main-117/WARN]: Exception loading blockstate definition: 'industrialforegoing:blockstates/essence_block.json' missing model for variant: 'industrialforegoing:essence_block#level=5'
[13:30:16] [Worker-Main-117/WARN]: Exception loading blockstate definition: 'industrialforegoing:blockstates/essence_block.json' missing model for variant: 'industrialforegoing:essence_block#level=4'
[13:30:16] [Worker-Main-117/WARN]: Exception loading blockstate definition: 'industrialforegoing:blockstates/essence_block.json' missing model for variant: 'industrialforegoing:essence_block#level=15'
[13:30:16] [Worker-Main-117/WARN]: Exception loading blockstate definition: 'industrialforegoing:blockstates/essence_block.json' missing model for variant: 'industrialforegoing:essence_block#level=12'
[13:30:16] [Worker-Main-117/WARN]: Exception loading blockstate definition: 'industrialforegoing:blockstates/essence_block.json' missing model for variant: 'industrialforegoing:essence_block#level=11'
[13:30:16] [Worker-Main-117/WARN]: Exception loading blockstate definition: 'industrialforegoing:blockstates/essence_block.json' missing model for variant: 'industrialforegoing:essence_block#level=14'
[13:30:16] [Worker-Main-117/WARN]: Exception loading blockstate definition: 'industrialforegoing:blockstates/essence_block.json' missing model for variant: 'industrialforegoing:essence_block#level=13'
[13:30:16] [Worker-Main-117/WARN]: Exception loading blockstate definition: industrialforegoing:blockstates/pink_slime_block.json: java.io.FileNotFoundException: industrialforegoing:blockstates/pink_slime_block.json
[13:30:16] [Worker-Main-117/WARN]: Exception loading blockstate definition: 'industrialforegoing:blockstates/pink_slime_block.json' missing model for variant: 'industrialforegoing:pink_slime_block#level=7'
[13:30:16] [Worker-Main-117/WARN]: Exception loading blockstate definition: 'industrialforegoing:blockstates/pink_slime_block.json' missing model for variant: 'industrialforegoing:pink_slime_block#level=8'
[13:30:16] [Worker-Main-117/WARN]: Exception loading blockstate definition: 'industrialforegoing:blockstates/pink_slime_block.json' missing model for variant: 'industrialforegoing:pink_slime_block#level=5'
[13:30:16] [Worker-Main-117/WARN]: Exception loading blockstate definition: 'industrialforegoing:blockstates/pink_slime_block.json' missing model for variant: 'industrialforegoing:pink_slime_block#level=6'
[13:30:16] [Worker-Main-117/WARN]: Exception loading blockstate definition: 'industrialforegoing:blockstates/pink_slime_block.json' missing model for variant: 'industrialforegoing:pink_slime_block#level=3'
[13:30:16] [Worker-Main-117/WARN]: Exception loading blockstate definition: 'industrialforegoing:blockstates/pink_slime_block.json' missing model for variant: 'industrialforegoing:pink_slime_block#level=4'
[13:30:16] [Worker-Main-117/WARN]: Exception loading blockstate definition: 'industrialforegoing:blockstates/pink_slime_block.json' missing model for variant: 'industrialforegoing:pink_slime_block#level=1'
[13:30:16] [Worker-Main-117/WARN]: Exception loading blockstate definition: 'industrialforegoing:blockstates/pink_slime_block.json' missing model for variant: 'industrialforegoing:pink_slime_block#level=2'
[13:30:17] [Worker-Main-117/WARN]: Exception loading blockstate definition: 'industrialforegoing:blockstates/pink_slime_block.json' missing model for variant: 'industrialforegoing:pink_slime_block#level=14'
[13:30:17] [Worker-Main-117/WARN]: Exception loading blockstate definition: 'industrialforegoing:blockstates/pink_slime_block.json' missing model for variant: 'industrialforegoing:pink_slime_block#level=15'
[13:30:17] [Worker-Main-117/WARN]: Exception loading blockstate definition: 'industrialforegoing:blockstates/pink_slime_block.json' missing model for variant: 'industrialforegoing:pink_slime_block#level=12'
[13:30:17] [Worker-Main-117/WARN]: Exception loading blockstate definition: 'industrialforegoing:blockstates/pink_slime_block.json' missing model for variant: 'industrialforegoing:pink_slime_block#level=13'
[13:30:17] [Worker-Main-117/WARN]: Exception loading blockstate definition: 'industrialforegoing:blockstates/pink_slime_block.json' missing model for variant: 'industrialforegoing:pink_slime_block#level=9'
[13:30:17] [Worker-Main-117/WARN]: Exception loading blockstate definition: 'industrialforegoing:blockstates/pink_slime_block.json' missing model for variant: 'industrialforegoing:pink_slime_block#level=10'
[13:30:17] [Worker-Main-117/WARN]: Exception loading blockstate definition: 'industrialforegoing:blockstates/pink_slime_block.json' missing model for variant: 'industrialforegoing:pink_slime_block#level=11'
[13:30:17] [Worker-Main-117/WARN]: Exception loading blockstate definition: 'industrialforegoing:blockstates/pink_slime_block.json' missing model for variant: 'industrialforegoing:pink_slime_block#level=0'
[13:30:17] [Worker-Main-117/WARN]: Exception loading blockstate definition: industrialforegoing:blockstates/latex_block.json: java.io.FileNotFoundException: industrialforegoing:blockstates/latex_block.json
[13:30:17] [Worker-Main-117/WARN]: Exception loading blockstate definition: 'industrialforegoing:blockstates/latex_block.json' missing model for variant: 'industrialforegoing:latex_block#level=6'
[13:30:17] [Worker-Main-117/WARN]: Exception loading blockstate definition: 'industrialforegoing:blockstates/latex_block.json' missing model for variant: 'industrialforegoing:latex_block#level=7'
[13:30:17] [Worker-Main-117/WARN]: Exception loading blockstate definition: 'industrialforegoing:blockstates/latex_block.json' missing model for variant: 'industrialforegoing:latex_block#level=4'
[13:30:17] [Worker-Main-117/WARN]: Exception loading blockstate definition: 'industrialforegoing:blockstates/latex_block.json' missing model for variant: 'industrialforegoing:latex_block#level=5'
[13:30:17] [Worker-Main-117/WARN]: Exception loading blockstate definition: 'industrialforegoing:blockstates/latex_block.json' missing model for variant: 'industrialforegoing:latex_block#level=8'
[13:30:17] [Worker-Main-117/WARN]: Exception loading blockstate definition: 'industrialforegoing:blockstates/latex_block.json' missing model for variant: 'industrialforegoing:latex_block#level=9'
[13:30:17] [Worker-Main-117/WARN]: Exception loading blockstate definition: 'industrialforegoing:blockstates/latex_block.json' missing model for variant: 'industrialforegoing:latex_block#level=15'
[13:30:17] [Worker-Main-117/WARN]: Exception loading blockstate definition: 'industrialforegoing:blockstates/latex_block.json' missing model for variant: 'industrialforegoing:latex_block#level=13'
[13:30:17] [Worker-Main-117/WARN]: Exception loading blockstate definition: 'industrialforegoing:blockstates/latex_block.json' missing model for variant: 'industrialforegoing:latex_block#level=14'
[13:30:17] [Worker-Main-117/WARN]: Exception loading blockstate definition: 'industrialforegoing:blockstates/latex_block.json' missing model for variant: 'industrialforegoing:latex_block#level=11'
[13:30:17] [Worker-Main-117/WARN]: Exception loading blockstate definition: 'industrialforegoing:blockstates/latex_block.json' missing model for variant: 'industrialforegoing:latex_block#level=12'
[13:30:17] [Worker-Main-117/WARN]: Exception loading blockstate definition: 'industrialforegoing:blockstates/latex_block.json' missing model for variant: 'industrialforegoing:latex_block#level=10'
[13:30:17] [Worker-Main-117/WARN]: Exception loading blockstate definition: 'industrialforegoing:blockstates/latex_block.json' missing model for variant: 'industrialforegoing:latex_block#level=2'
[13:30:17] [Worker-Main-117/WARN]: Exception loading blockstate definition: 'industrialforegoing:blockstates/latex_block.json' missing model for variant: 'industrialforegoing:latex_block#level=3'
[13:30:17] [Worker-Main-117/WARN]: Exception loading blockstate definition: 'industrialforegoing:blockstates/latex_block.json' missing model for variant: 'industrialforegoing:latex_block#level=0'
[13:30:17] [Worker-Main-117/WARN]: Exception loading blockstate definition: 'industrialforegoing:blockstates/latex_block.json' missing model for variant: 'industrialforegoing:latex_block#level=1'
[13:30:17] [Worker-Main-117/WARN]: Exception loading blockstate definition: industrialforegoing:blockstates/meat_block.json: java.io.FileNotFoundException: industrialforegoing:blockstates/meat_block.json
[13:30:17] [Worker-Main-117/WARN]: Exception loading blockstate definition: 'industrialforegoing:blockstates/meat_block.json' missing model for variant: 'industrialforegoing:meat_block#level=1'
[13:30:17] [Worker-Main-117/WARN]: Exception loading blockstate definition: 'industrialforegoing:blockstates/meat_block.json' missing model for variant: 'industrialforegoing:meat_block#level=2'
[13:30:17] [Worker-Main-117/WARN]: Exception loading blockstate definition: 'industrialforegoing:blockstates/meat_block.json' missing model for variant: 'industrialforegoing:meat_block#level=3'
[13:30:17] [Worker-Main-117/WARN]: Exception loading blockstate definition: 'industrialforegoing:blockstates/meat_block.json' missing model for variant: 'industrialforegoing:meat_block#level=4'
[13:30:17] [Worker-Main-117/WARN]: Exception loading blockstate definition: 'industrialforegoing:blockstates/meat_block.json' missing model for variant: 'industrialforegoing:meat_block#level=15'
[13:30:17] [Worker-Main-117/WARN]: Exception loading blockstate definition: 'industrialforegoing:blockstates/meat_block.json' missing model for variant: 'industrialforegoing:meat_block#level=14'
[13:30:17] [Worker-Main-117/WARN]: Exception loading blockstate definition: 'industrialforegoing:blockstates/meat_block.json' missing model for variant: 'industrialforegoing:meat_block#level=0'
[13:30:17] [Worker-Main-117/WARN]: Exception loading blockstate definition: 'industrialforegoing:blockstates/meat_block.json' missing model for variant: 'industrialforegoing:meat_block#level=9'
[13:30:17] [Worker-Main-117/WARN]: Exception loading blockstate definition: 'industrialforegoing:blockstates/meat_block.json' missing model for variant: 'industrialforegoing:meat_block#level=11'
[13:30:17] [Worker-Main-117/WARN]: Exception loading blockstate definition: 'industrialforegoing:blockstates/meat_block.json' missing model for variant: 'industrialforegoing:meat_block#level=10'
[13:30:17] [Worker-Main-117/WARN]: Exception loading blockstate definition: 'industrialforegoing:blockstates/meat_block.json' missing model for variant: 'industrialforegoing:meat_block#level=13'
[13:30:17] [Worker-Main-117/WARN]: Exception loading blockstate definition: 'industrialforegoing:blockstates/meat_block.json' missing model for variant: 'industrialforegoing:meat_block#level=12'
[13:30:17] [Worker-Main-117/WARN]: Exception loading blockstate definition: 'industrialforegoing:blockstates/meat_block.json' missing model for variant: 'industrialforegoing:meat_block#level=5'
[13:30:17] [Worker-Main-117/WARN]: Exception loading blockstate definition: 'industrialforegoing:blockstates/meat_block.json' missing model for variant: 'industrialforegoing:meat_block#level=6'
[13:30:17] [Worker-Main-117/WARN]: Exception loading blockstate definition: 'industrialforegoing:blockstates/meat_block.json' missing model for variant: 'industrialforegoing:meat_block#level=7'
[13:30:17] [Worker-Main-117/WARN]: Exception loading blockstate definition: 'industrialforegoing:blockstates/meat_block.json' missing model for variant: 'industrialforegoing:meat_block#level=8'
[13:30:17] [Worker-Main-117/WARN]: Exception loading blockstate definition: industrialforegoing:blockstates/raw_ore_meat_block.json: java.io.FileNotFoundException: industrialforegoing:blockstates/raw_ore_meat_block.json
[13:30:17] [Worker-Main-117/WARN]: Exception loading blockstate definition: 'industrialforegoing:blockstates/raw_ore_meat_block.json' missing model for variant: 'industrialforegoing:raw_ore_meat_block#level=10'
[13:30:17] [Worker-Main-117/WARN]: Exception loading blockstate definition: 'industrialforegoing:blockstates/raw_ore_meat_block.json' missing model for variant: 'industrialforegoing:raw_ore_meat_block#level=11'
[13:30:17] [Worker-Main-117/WARN]: Exception loading blockstate definition: 'industrialforegoing:blockstates/raw_ore_meat_block.json' missing model for variant: 'industrialforegoing:raw_ore_meat_block#level=12'
[13:30:17] [Worker-Main-117/WARN]: Exception loading blockstate definition: 'industrialforegoing:blockstates/raw_ore_meat_block.json' missing model for variant: 'industrialforegoing:raw_ore_meat_block#level=13'
[13:30:17] [Worker-Main-117/WARN]: Exception loading blockstate definition: 'industrialforegoing:blockstates/raw_ore_meat_block.json' missing model for variant: 'industrialforegoing:raw_ore_meat_block#level=14'
[13:30:17] [Worker-Main-117/WARN]: Exception loading blockstate definition: 'industrialforegoing:blockstates/raw_ore_meat_block.json' missing model for variant: 'industrialforegoing:raw_ore_meat_block#level=15'
[13:30:17] [Worker-Main-117/WARN]: Exception loading blockstate definition: 'industrialforegoing:blockstates/raw_ore_meat_block.json' missing model for variant: 'industrialforegoing:raw_ore_meat_block#level=0'
[13:30:17] [Worker-Main-117/WARN]: Exception loading blockstate definition: 'industrialforegoing:blockstates/raw_ore_meat_block.json' missing model for variant: 'industrialforegoing:raw_ore_meat_block#level=8'
[13:30:17] [Worker-Main-117/WARN]: Exception loading blockstate definition: 'industrialforegoing:blockstates/raw_ore_meat_block.json' missing model for variant: 'industrialforegoing:raw_ore_meat_block#level=7'
[13:30:17] [Worker-Main-117/WARN]: Exception loading blockstate definition: 'industrialforegoing:blockstates/raw_ore_meat_block.json' missing model for variant: 'industrialforegoing:raw_ore_meat_block#level=6'
[13:30:17] [Worker-Main-117/WARN]: Exception loading blockstate definition: 'industrialforegoing:blockstates/raw_ore_meat_block.json' missing model for variant: 'industrialforegoing:raw_ore_meat_block#level=5'
[13:30:17] [Worker-Main-117/WARN]: Exception loading blockstate definition: 'industrialforegoing:blockstates/raw_ore_meat_block.json' missing model for variant: 'industrialforegoing:raw_ore_meat_block#level=4'
[13:30:17] [Worker-Main-117/WARN]: Exception loading blockstate definition: 'industrialforegoing:blockstates/raw_ore_meat_block.json' missing model for variant: 'industrialforegoing:raw_ore_meat_block#level=3'
[13:30:17] [Worker-Main-117/WARN]: Exception loading blockstate definition: 'industrialforegoing:blockstates/raw_ore_meat_block.json' missing model for variant: 'industrialforegoing:raw_ore_meat_block#level=2'
[13:30:17] [Worker-Main-117/WARN]: Exception loading blockstate definition: 'industrialforegoing:blockstates/raw_ore_meat_block.json' missing model for variant: 'industrialforegoing:raw_ore_meat_block#level=1'
[13:30:17] [Worker-Main-117/WARN]: Exception loading blockstate definition: 'industrialforegoing:blockstates/raw_ore_meat_block.json' missing model for variant: 'industrialforegoing:raw_ore_meat_block#level=9'
[13:30:17] [Worker-Main-117/WARN]: Exception loading blockstate definition: industrialforegoing:blockstates/fermented_ore_meat_block.json: java.io.FileNotFoundException: industrialforegoing:blockstates/fermented_ore_meat_block.json
[13:30:17] [Worker-Main-117/WARN]: Exception loading blockstate definition: 'industrialforegoing:blockstates/fermented_ore_meat_block.json' missing model for variant: 'industrialforegoing:fermented_ore_meat_block#level=14'
[13:30:17] [Worker-Main-117/WARN]: Exception loading blockstate definition: 'industrialforegoing:blockstates/fermented_ore_meat_block.json' missing model for variant: 'industrialforegoing:fermented_ore_meat_block#level=15'
[13:30:17] [Worker-Main-117/WARN]: Exception loading blockstate definition: 'industrialforegoing:blockstates/fermented_ore_meat_block.json' missing model for variant: 'industrialforegoing:fermented_ore_meat_block#level=12'
[13:30:17] [Worker-Main-117/WARN]: Exception loading blockstate definition: 'industrialforegoing:blockstates/fermented_ore_meat_block.json' missing model for variant: 'industrialforegoing:fermented_ore_meat_block#level=9'
[13:30:17] [Worker-Main-117/WARN]: Exception loading blockstate definition: 'industrialforegoing:blockstates/fermented_ore_meat_block.json' missing model for variant: 'industrialforegoing:fermented_ore_meat_block#level=13'
[13:30:17] [Worker-Main-117/WARN]: Exception loading blockstate definition: 'industrialforegoing:blockstates/fermented_ore_meat_block.json' missing model for variant: 'industrialforegoing:fermented_ore_meat_block#level=10'
[13:30:17] [Worker-Main-117/WARN]: Exception loading blockstate definition: 'industrialforegoing:blockstates/fermented_ore_meat_block.json' missing model for variant: 'industrialforegoing:fermented_ore_meat_block#level=11'
[13:30:17] [Worker-Main-117/WARN]: Exception loading blockstate definition: 'industrialforegoing:blockstates/fermented_ore_meat_block.json' missing model for variant: 'industrialforegoing:fermented_ore_meat_block#level=6'
[13:30:17] [Worker-Main-117/WARN]: Exception loading blockstate definition: 'industrialforegoing:blockstates/fermented_ore_meat_block.json' missing model for variant: 'industrialforegoing:fermented_ore_meat_block#level=5'
[13:30:17] [Worker-Main-117/WARN]: Exception loading blockstate definition: 'industrialforegoing:blockstates/fermented_ore_meat_block.json' missing model for variant: 'industrialforegoing:fermented_ore_meat_block#level=8'
[13:30:17] [Worker-Main-117/WARN]: Exception loading blockstate definition: 'industrialforegoing:blockstates/fermented_ore_meat_block.json' missing model for variant: 'industrialforegoing:fermented_ore_meat_block#level=7'
[13:30:17] [Worker-Main-117/WARN]: Exception loading blockstate definition: 'industrialforegoing:blockstates/fermented_ore_meat_block.json' missing model for variant: 'industrialforegoing:fermented_ore_meat_block#level=2'
[13:30:17] [Worker-Main-117/WARN]: Exception loading blockstate definition: 'industrialforegoing:blockstates/fermented_ore_meat_block.json' missing model for variant: 'industrialforegoing:fermented_ore_meat_block#level=1'
[13:30:17] [Worker-Main-117/WARN]: Exception loading blockstate definition: 'industrialforegoing:blockstates/fermented_ore_meat_block.json' missing model for variant: 'industrialforegoing:fermented_ore_meat_block#level=4'
[13:30:17] [Worker-Main-117/WARN]: Exception loading blockstate definition: 'industrialforegoing:blockstates/fermented_ore_meat_block.json' missing model for variant: 'industrialforegoing:fermented_ore_meat_block#level=3'
[13:30:17] [Worker-Main-117/WARN]: Exception loading blockstate definition: 'industrialforegoing:blockstates/fermented_ore_meat_block.json' missing model for variant: 'industrialforegoing:fermented_ore_meat_block#level=0'
[13:30:17] [Worker-Main-117/WARN]: Exception loading blockstate definition: industrialforegoing:blockstates/machine_frame_pity.json: java.io.FileNotFoundException: industrialforegoing:blockstates/machine_frame_pity.json
[13:30:17] [Worker-Main-117/WARN]: Exception loading blockstate definition: 'industrialforegoing:blockstates/machine_frame_pity.json' missing model for variant: 'industrialforegoing:machine_frame_pity#'
[13:30:17] [Worker-Main-117/WARN]: Exception loading blockstate definition: industrialforegoing:blockstates/machine_frame_simple.json: java.io.FileNotFoundException: industrialforegoing:blockstates/machine_frame_simple.json
[13:30:17] [Worker-Main-117/WARN]: Exception loading blockstate definition: 'industrialforegoing:blockstates/machine_frame_simple.json' missing model for variant: 'industrialforegoing:machine_frame_simple#'
[13:30:17] [Worker-Main-117/WARN]: Exception loading blockstate definition: industrialforegoing:blockstates/machine_frame_advanced.json: java.io.FileNotFoundException: industrialforegoing:blockstates/machine_frame_advanced.json
[13:30:17] [Worker-Main-117/WARN]: Exception loading blockstate definition: 'industrialforegoing:blockstates/machine_frame_advanced.json' missing model for variant: 'industrialforegoing:machine_frame_advanced#'
[13:30:17] [Worker-Main-117/WARN]: Exception loading blockstate definition: industrialforegoing:blockstates/machine_frame_supreme.json: java.io.FileNotFoundException: industrialforegoing:blockstates/machine_frame_supreme.json
[13:30:17] [Worker-Main-117/WARN]: Exception loading blockstate definition: 'industrialforegoing:blockstates/machine_frame_supreme.json' missing model for variant: 'industrialforegoing:machine_frame_supreme#'
[13:30:17] [Worker-Main-117/WARN]: Exception loading blockstate definition: industrialforegoing:blockstates/sewage_block.json: java.io.FileNotFoundException: industrialforegoing:blockstates/sewage_block.json
[13:30:17] [Worker-Main-117/WARN]: Exception loading blockstate definition: 'industrialforegoing:blockstates/sewage_block.json' missing model for variant: 'industrialforegoing:sewage_block#level=10'
[13:30:17] [Worker-Main-117/WARN]: Exception loading blockstate definition: 'industrialforegoing:blockstates/sewage_block.json' missing model for variant: 'industrialforegoing:sewage_block#level=12'
[13:30:17] [Worker-Main-117/WARN]: Exception loading blockstate definition: 'industrialforegoing:blockstates/sewage_block.json' missing model for variant: 'industrialforegoing:sewage_block#level=11'
[13:30:17] [Worker-Main-117/WARN]: Exception loading blockstate definition: 'industrialforegoing:blockstates/sewage_block.json' missing model for variant: 'industrialforegoing:sewage_block#level=14'
[13:30:17] [Worker-Main-117/WARN]: Exception loading blockstate definition: 'industrialforegoing:blockstates/sewage_block.json' missing model for variant: 'industrialforegoing:sewage_block#level=13'
[13:30:17] [Worker-Main-117/WARN]: Exception loading blockstate definition: 'industrialforegoing:blockstates/sewage_block.json' missing model for variant: 'industrialforegoing:sewage_block#level=15'
[13:30:17] [Worker-Main-117/WARN]: Exception loading blockstate definition: 'industrialforegoing:blockstates/sewage_block.json' missing model for variant: 'industrialforegoing:sewage_block#level=5'
[13:30:18] [Worker-Main-117/WARN]: Exception loading blockstate definition: 'industrialforegoing:blockstates/sewage_block.json' missing model for variant: 'industrialforegoing:sewage_block#level=4'
[13:30:18] [Worker-Main-117/WARN]: Exception loading blockstate definition: 'industrialforegoing:blockstates/sewage_block.json' missing model for variant: 'industrialforegoing:sewage_block#level=7'
[13:30:18] [Worker-Main-117/WARN]: Exception loading blockstate definition: 'industrialforegoing:blockstates/sewage_block.json' missing model for variant: 'industrialforegoing:sewage_block#level=6'
[13:30:18] [Worker-Main-117/WARN]: Exception loading blockstate definition: 'industrialforegoing:blockstates/sewage_block.json' missing model for variant: 'industrialforegoing:sewage_block#level=9'
[13:30:18] [Worker-Main-117/WARN]: Exception loading blockstate definition: 'industrialforegoing:blockstates/sewage_block.json' missing model for variant: 'industrialforegoing:sewage_block#level=8'
[13:30:18] [Worker-Main-117/WARN]: Exception loading blockstate definition: 'industrialforegoing:blockstates/sewage_block.json' missing model for variant: 'industrialforegoing:sewage_block#level=1'
[13:30:18] [Worker-Main-117/WARN]: Exception loading blockstate definition: 'industrialforegoing:blockstates/sewage_block.json' missing model for variant: 'industrialforegoing:sewage_block#level=0'
[13:30:18] [Worker-Main-117/WARN]: Exception loading blockstate definition: 'industrialforegoing:blockstates/sewage_block.json' missing model for variant: 'industrialforegoing:sewage_block#level=3'
[13:30:18] [Worker-Main-117/WARN]: Exception loading blockstate definition: 'industrialforegoing:blockstates/sewage_block.json' missing model for variant: 'industrialforegoing:sewage_block#level=2'
[13:30:25] [Worker-Main-117/WARN]: Exception loading blockstate definition: allthemodium:blockstates/vapor_allthemodium_block.json: java.io.FileNotFoundException: allthemodium:blockstates/vapor_allthemodium_block.json
[13:30:25] [Worker-Main-117/WARN]: Exception loading blockstate definition: 'allthemodium:blockstates/vapor_allthemodium_block.json' missing model for variant: 'allthemodium:vapor_allthemodium_block#level=11'
[13:30:25] [Worker-Main-117/WARN]: Exception loading blockstate definition: 'allthemodium:blockstates/vapor_allthemodium_block.json' missing model for variant: 'allthemodium:vapor_allthemodium_block#level=12'
[13:30:25] [Worker-Main-117/WARN]: Exception loading blockstate definition: 'allthemodium:blockstates/vapor_allthemodium_block.json' missing model for variant: 'allthemodium:vapor_allthemodium_block#level=13'
[13:30:25] [Worker-Main-117/WARN]: Exception loading blockstate definition: 'allthemodium:blockstates/vapor_allthemodium_block.json' missing model for variant: 'allthemodium:vapor_allthemodium_block#level=14'
[13:30:25] [Worker-Main-117/WARN]: Exception loading blockstate definition: 'allthemodium:blockstates/vapor_allthemodium_block.json' missing model for variant: 'allthemodium:vapor_allthemodium_block#level=10'
[13:30:25] [Worker-Main-117/WARN]: Exception loading blockstate definition: 'allthemodium:blockstates/vapor_allthemodium_block.json' missing model for variant: 'allthemodium:vapor_allthemodium_block#level=15'
[13:30:25] [Worker-Main-117/WARN]: Exception loading blockstate definition: 'allthemodium:blockstates/vapor_allthemodium_block.json' missing model for variant: 'allthemodium:vapor_allthemodium_block#level=9'
[13:30:25] [Worker-Main-117/WARN]: Exception loading blockstate definition: 'allthemodium:blockstates/vapor_allthemodium_block.json' missing model for variant: 'allthemodium:vapor_allthemodium_block#level=8'
[13:30:25] [Worker-Main-117/WARN]: Exception loading blockstate definition: 'allthemodium:blockstates/vapor_allthemodium_block.json' missing model for variant: 'allthemodium:vapor_allthemodium_block#level=7'
[13:30:25] [Worker-Main-117/WARN]: Exception loading blockstate definition: 'allthemodium:blockstates/vapor_allthemodium_block.json' missing model for variant: 'allthemodium:vapor_allthemodium_block#level=6'
[13:30:25] [Worker-Main-117/WARN]: Exception loading blockstate definition: 'allthemodium:blockstates/vapor_allthemodium_block.json' missing model for variant: 'allthemodium:vapor_allthemodium_block#level=1'
[13:30:25] [Worker-Main-117/WARN]: Exception loading blockstate definition: 'allthemodium:blockstates/vapor_allthemodium_block.json' missing model for variant: 'allthemodium:vapor_allthemodium_block#level=0'
[13:30:25] [Worker-Main-117/WARN]: Exception loading blockstate definition: 'allthemodium:blockstates/vapor_allthemodium_block.json' missing model for variant: 'allthemodium:vapor_allthemodium_block#level=5'
[13:30:25] [Worker-Main-117/WARN]: Exception loading blockstate definition: 'allthemodium:blockstates/vapor_allthemodium_block.json' missing model for variant: 'allthemodium:vapor_allthemodium_block#level=4'
[13:30:25] [Worker-Main-117/WARN]: Exception loading blockstate definition: 'allthemodium:blockstates/vapor_allthemodium_block.json' missing model for variant: 'allthemodium:vapor_allthemodium_block#level=3'
[13:30:25] [Worker-Main-117/WARN]: Exception loading blockstate definition: 'allthemodium:blockstates/vapor_allthemodium_block.json' missing model for variant: 'allthemodium:vapor_allthemodium_block#level=2'
[13:30:25] [Worker-Main-117/WARN]: Exception loading blockstate definition: allthemodium:blockstates/vapor_vibranium_block.json: java.io.FileNotFoundException: allthemodium:blockstates/vapor_vibranium_block.json
[13:30:25] [Worker-Main-117/WARN]: Exception loading blockstate definition: 'allthemodium:blockstates/vapor_vibranium_block.json' missing model for variant: 'allthemodium:vapor_vibranium_block#level=8'
[13:30:25] [Worker-Main-117/WARN]: Exception loading blockstate definition: 'allthemodium:blockstates/vapor_vibranium_block.json' missing model for variant: 'allthemodium:vapor_vibranium_block#level=9'
[13:30:25] [Worker-Main-117/WARN]: Exception loading blockstate definition: 'allthemodium:blockstates/vapor_vibranium_block.json' missing model for variant: 'allthemodium:vapor_vibranium_block#level=6'
[13:30:25] [Worker-Main-117/WARN]: Exception loading blockstate definition: 'allthemodium:blockstates/vapor_vibranium_block.json' missing model for variant: 'allthemodium:vapor_vibranium_block#level=7'
[13:30:25] [Worker-Main-117/WARN]: Exception loading blockstate definition: 'allthemodium:blockstates/vapor_vibranium_block.json' missing model for variant: 'allthemodium:vapor_vibranium_block#level=4'
[13:30:25] [Worker-Main-117/WARN]: Exception loading blockstate definition: 'allthemodium:blockstates/vapor_vibranium_block.json' missing model for variant: 'allthemodium:vapor_vibranium_block#level=5'
[13:30:25] [Worker-Main-117/WARN]: Exception loading blockstate definition: 'allthemodium:blockstates/vapor_vibranium_block.json' missing model for variant: 'allthemodium:vapor_vibranium_block#level=2'
[13:30:25] [Worker-Main-117/WARN]: Exception loading blockstate definition: 'allthemodium:blockstates/vapor_vibranium_block.json' missing model for variant: 'allthemodium:vapor_vibranium_block#level=3'
[13:30:25] [Worker-Main-117/WARN]: Exception loading blockstate definition: 'allthemodium:blockstates/vapor_vibranium_block.json' missing model for variant: 'allthemodium:vapor_vibranium_block#level=15'
[13:30:25] [Worker-Main-117/WARN]: Exception loading blockstate definition: 'allthemodium:blockstates/vapor_vibranium_block.json' missing model for variant: 'allthemodium:vapor_vibranium_block#level=13'
[13:30:25] [Worker-Main-117/WARN]: Exception loading blockstate definition: 'allthemodium:blockstates/vapor_vibranium_block.json' missing model for variant: 'allthemodium:vapor_vibranium_block#level=14'
[13:30:25] [Worker-Main-117/WARN]: Exception loading blockstate definition: 'allthemodium:blockstates/vapor_vibranium_block.json' missing model for variant: 'allthemodium:vapor_vibranium_block#level=11'
[13:30:25] [Worker-Main-117/WARN]: Exception loading blockstate definition: 'allthemodium:blockstates/vapor_vibranium_block.json' missing model for variant: 'allthemodium:vapor_vibranium_block#level=12'
[13:30:25] [Worker-Main-117/WARN]: Exception loading blockstate definition: 'allthemodium:blockstates/vapor_vibranium_block.json' missing model for variant: 'allthemodium:vapor_vibranium_block#level=10'
[13:30:25] [Worker-Main-117/WARN]: Exception loading blockstate definition: 'allthemodium:blockstates/vapor_vibranium_block.json' missing model for variant: 'allthemodium:vapor_vibranium_block#level=0'
[13:30:25] [Worker-Main-117/WARN]: Exception loading blockstate definition: 'allthemodium:blockstates/vapor_vibranium_block.json' missing model for variant: 'allthemodium:vapor_vibranium_block#level=1'
[13:30:25] [Worker-Main-117/WARN]: Exception loading blockstate definition: allthemodium:blockstates/vapor_unobtainium_block.json: java.io.FileNotFoundException: allthemodium:blockstates/vapor_unobtainium_block.json
[13:30:25] [Worker-Main-117/WARN]: Exception loading blockstate definition: 'allthemodium:blockstates/vapor_unobtainium_block.json' missing model for variant: 'allthemodium:vapor_unobtainium_block#level=10'
[13:30:25] [Worker-Main-117/WARN]: Exception loading blockstate definition: 'allthemodium:blockstates/vapor_unobtainium_block.json' missing model for variant: 'allthemodium:vapor_unobtainium_block#level=11'
[13:30:25] [Worker-Main-117/WARN]: Exception loading blockstate definition: 'allthemodium:blockstates/vapor_unobtainium_block.json' missing model for variant: 'allthemodium:vapor_unobtainium_block#level=12'
[13:30:25] [Worker-Main-117/WARN]: Exception loading blockstate definition: 'allthemodium:blockstates/vapor_unobtainium_block.json' missing model for variant: 'allthemodium:vapor_unobtainium_block#level=0'
[13:30:25] [Worker-Main-117/WARN]: Exception loading blockstate definition: 'allthemodium:blockstates/vapor_unobtainium_block.json' missing model for variant: 'allthemodium:vapor_unobtainium_block#level=1'
[13:30:25] [Worker-Main-117/WARN]: Exception loading blockstate definition: 'allthemodium:blockstates/vapor_unobtainium_block.json' missing model for variant: 'allthemodium:vapor_unobtainium_block#level=2'
[13:30:25] [Worker-Main-117/WARN]: Exception loading blockstate definition: 'allthemodium:blockstates/vapor_unobtainium_block.json' missing model for variant: 'allthemodium:vapor_unobtainium_block#level=3'
[13:30:25] [Worker-Main-117/WARN]: Exception loading blockstate definition: 'allthemodium:blockstates/vapor_unobtainium_block.json' missing model for variant: 'allthemodium:vapor_unobtainium_block#level=4'
[13:30:25] [Worker-Main-117/WARN]: Exception loading blockstate definition: 'allthemodium:blockstates/vapor_unobtainium_block.json' missing model for variant: 'allthemodium:vapor_unobtainium_block#level=5'
[13:30:25] [Worker-Main-117/WARN]: Exception loading blockstate definition: 'allthemodium:blockstates/vapor_unobtainium_block.json' missing model for variant: 'allthemodium:vapor_unobtainium_block#level=6'
[13:30:25] [Worker-Main-117/WARN]: Exception loading blockstate definition: 'allthemodium:blockstates/vapor_unobtainium_block.json' missing model for variant: 'allthemodium:vapor_unobtainium_block#level=7'
[13:30:25] [Worker-Main-117/WARN]: Exception loading blockstate definition: 'allthemodium:blockstates/vapor_unobtainium_block.json' missing model for variant: 'allthemodium:vapor_unobtainium_block#level=8'
[13:30:25] [Worker-Main-117/WARN]: Exception loading blockstate definition: 'allthemodium:blockstates/vapor_unobtainium_block.json' missing model for variant: 'allthemodium:vapor_unobtainium_block#level=9'
[13:30:25] [Worker-Main-117/WARN]: Exception loading blockstate definition: 'allthemodium:blockstates/vapor_unobtainium_block.json' missing model for variant: 'allthemodium:vapor_unobtainium_block#level=13'
[13:30:25] [Worker-Main-117/WARN]: Exception loading blockstate definition: 'allthemodium:blockstates/vapor_unobtainium_block.json' missing model for variant: 'allthemodium:vapor_unobtainium_block#level=14'
[13:30:25] [Worker-Main-117/WARN]: Exception loading blockstate definition: 'allthemodium:blockstates/vapor_unobtainium_block.json' missing model for variant: 'allthemodium:vapor_unobtainium_block#level=15'
[13:30:33] [Worker-Main-117/WARN]: Exception loading blockstate definition: 'vehicle:blockstates/vehicle_crate.json' missing model for variant: 'vehicle:vehicle_crate#facing=west'
[13:30:33] [Worker-Main-117/WARN]: Exception loading blockstate definition: 'vehicle:blockstates/vehicle_crate.json' missing model for variant: 'vehicle:vehicle_crate#facing=north'
[13:30:33] [Worker-Main-117/WARN]: Exception loading blockstate definition: 'vehicle:blockstates/vehicle_crate.json' missing model for variant: 'vehicle:vehicle_crate#facing=south'
[13:30:33] [Worker-Main-117/WARN]: Exception loading blockstate definition: 'vehicle:blockstates/vehicle_crate.json' missing model for variant: 'vehicle:vehicle_crate#facing=east'
[13:30:33] [Worker-Main-117/WARN]: Exception loading blockstate definition: 'vehicle:blockstates/vehicle_crate.json' in resourcepack: 'Mod Resources': Missing model, expected to find a string
[13:30:47] [Worker-Main-117/WARN]: Unable to load model: 'industrialforegoing:item_transporter_type#inventory' referenced from: industrialforegoing:item_transporter_type#inventory: {}
[13:30:47] [Worker-Main-117/WARN]: java.io.FileNotFoundException: industrialforegoing:models/item/item_transporter_type.json
[13:30:47] [Worker-Main-117/WARN]: Unable to load model: 'industrialforegoing:fluid_transporter_type#inventory' referenced from: industrialforegoing:fluid_transporter_type#inventory: {}
[13:30:47] [Worker-Main-117/WARN]: java.io.FileNotFoundException: industrialforegoing:models/item/fluid_transporter_type.json
[13:30:47] [Worker-Main-117/WARN]: Unable to load model: 'industrialforegoing:world_transporter_type#inventory' referenced from: industrialforegoing:world_transporter_type#inventory: {}
[13:30:47] [Worker-Main-117/WARN]: java.io.FileNotFoundException: industrialforegoing:models/item/world_transporter_type.json
[13:30:47] [Worker-Main-117/WARN]: Unable to load model: 'industrialforegoing:transporter#inventory' referenced from: industrialforegoing:transporter#inventory: {}
[13:30:47] [Worker-Main-117/WARN]: java.io.FileNotFoundException: industrialforegoing:models/item/transporter.json
[13:30:49] [Worker-Main-117/WARN]: [OptiFine] Unknown resource pack file: mod_resources
[13:30:49] [Worker-Main-117/WARN]: [OptiFine] Unknown resource pack file: mod_resources
[13:30:49] [Worker-Main-117/WARN]: [OptiFine] Unknown resource pack file: mod_resources
[13:30:49] [Worker-Main-117/WARN]: [OptiFine] Unknown resource pack file: mod_resources
[13:30:58] [Worker-Main-117/WARN]: Unable to resolve texture reference: #missing in industrialforegoing:item/infinity_launcher_empty
[13:30:58] [Worker-Main-117/WARN]: Unable to resolve texture reference: #missing in industrialforegoing:item/infinity_launcher_full
[13:30:58] [Worker-Main-117/WARN]: Unable to resolve texture reference: #missing in vehicle:vehicle/dirt_bike_body
[13:30:58] [Worker-Main-117/WARN]: Unable to resolve texture reference: #missing in industrialforegoing:item/infinity_backpack
[13:30:58] [Worker-Main-117/INFO]: [OptiFine] Multitexture: false
[13:30:58] [Worker-Main-117/WARN]: [OptiFine] Unknown resource pack file: mod_resources
[13:30:58] [Worker-Main-117/INFO]: [OptiFine] Multipass connected textures: false
[13:30:59] [Worker-Main-117/INFO]: [OptiFine] ConnectedTextures: optifine/ctm/default/00_glass_white/glass_pane_white.properties
[13:31:00] [Worker-Main-117/INFO]: [OptiFine] ConnectedTextures: optifine/ctm/default/00_glass_white/glass_white.properties
[13:31:00] [Worker-Main-117/INFO]: [OptiFine] ConnectedTextures: optifine/ctm/default/01_glass_orange/glass_orange.properties
[13:31:00] [Worker-Main-117/INFO]: [OptiFine] ConnectedTextures: optifine/ctm/default/01_glass_orange/glass_pane_orange.properties
[13:31:01] [Worker-Main-117/INFO]: [OptiFine] ConnectedTextures: optifine/ctm/default/02_glass_magenta/glass_magenta.properties
[13:31:01] [Worker-Main-117/INFO]: [OptiFine] ConnectedTextures: optifine/ctm/default/02_glass_magenta/glass_pane_magenta.properties
[13:31:01] [Worker-Main-117/INFO]: [OptiFine] ConnectedTextures: optifine/ctm/default/03_glass_light_blue/glass_light_blue.properties
[13:31:02] [Worker-Main-117/INFO]: [OptiFine] ConnectedTextures: optifine/ctm/default/03_glass_light_blue/glass_pane_light_blue.properties
[13:31:02] [Worker-Main-117/INFO]: [OptiFine] ConnectedTextures: optifine/ctm/default/04_glass_yellow/glass_pane_yellow.properties
[13:31:03] [Worker-Main-117/INFO]: [OptiFine] ConnectedTextures: optifine/ctm/default/04_glass_yellow/glass_yellow.properties
[13:31:03] [Worker-Main-117/INFO]: [OptiFine] ConnectedTextures: optifine/ctm/default/05_glass_lime/glass_lime.properties
[13:31:03] [Worker-Main-117/INFO]: [OptiFine] ConnectedTextures: optifine/ctm/default/05_glass_lime/glass_pane_lime.properties
[13:31:03] [Worker-Main-117/INFO]: [OptiFine] ConnectedTextures: optifine/ctm/default/06_glass_pink/glass_pane_pink.properties
[13:31:04] [Worker-Main-117/INFO]: [OptiFine] ConnectedTextures: optifine/ctm/default/06_glass_pink/glass_pink.properties
[13:31:04] [Worker-Main-117/INFO]: [OptiFine] ConnectedTextures: optifine/ctm/default/07_glass_gray/glass_gray.properties
[13:31:04] [Worker-Main-117/INFO]: [OptiFine] ConnectedTextures: optifine/ctm/default/07_glass_gray/glass_pane_gray.properties
[13:31:04] [Worker-Main-117/INFO]: [OptiFine] ConnectedTextures: optifine/ctm/default/08_glass_light_gray/glass_light_gray.properties
[13:31:05] [Worker-Main-117/INFO]: [OptiFine] ConnectedTextures: optifine/ctm/default/08_glass_light_gray/glass_pane_light_gray.properties
[13:31:05] [Worker-Main-117/INFO]: [OptiFine] ConnectedTextures: optifine/ctm/default/09_glass_cyan/glass_cyan.properties
[13:31:05] [Worker-Main-117/INFO]: [OptiFine] ConnectedTextures: optifine/ctm/default/09_glass_cyan/glass_pane_cyan.properties
[13:31:05] [Worker-Main-117/INFO]: [OptiFine] ConnectedTextures: optifine/ctm/default/10_glass_purple/glass_pane_purple.properties
[13:31:06] [Worker-Main-117/INFO]: [OptiFine] ConnectedTextures: optifine/ctm/default/10_glass_purple/glass_purple.properties
[13:31:06] [Worker-Main-117/INFO]: [OptiFine] ConnectedTextures: optifine/ctm/default/11_glass_blue/glass_blue.properties
[13:31:07] [Worker-Main-117/INFO]: [OptiFine] ConnectedTextures: optifine/ctm/default/11_glass_blue/glass_pane_blue.properties
[13:31:07] [Worker-Main-117/INFO]: [OptiFine] ConnectedTextures: optifine/ctm/default/12_glass_brown/glass_brown.properties
[13:31:07] [Worker-Main-117/INFO]: [OptiFine] ConnectedTextures: optifine/ctm/default/12_glass_brown/glass_pane_brown.properties
[13:31:08] [Worker-Main-117/INFO]: [OptiFine] ConnectedTextures: optifine/ctm/default/13_glass_green/glass_green.properties
[13:31:08] [Worker-Main-117/INFO]: [OptiFine] ConnectedTextures: optifine/ctm/default/13_glass_green/glass_pane_green.properties
[13:31:09] [Worker-Main-117/INFO]: [OptiFine] ConnectedTextures: optifine/ctm/default/14_glass_red/glass_pane_red.properties
[13:31:09] [Worker-Main-117/INFO]: [OptiFine] ConnectedTextures: optifine/ctm/default/14_glass_red/glass_red.properties
[13:31:09] [Worker-Main-117/INFO]: [OptiFine] ConnectedTextures: optifine/ctm/default/15_glass_black/glass_black.properties
[13:31:10] [Worker-Main-117/INFO]: [OptiFine] ConnectedTextures: optifine/ctm/default/15_glass_black/glass_pane_black.properties
[13:31:10] [Worker-Main-117/INFO]: [OptiFine] ConnectedTextures: optifine/ctm/default/20_glass/glass.properties
[13:31:10] [Worker-Main-117/INFO]: [OptiFine] ConnectedTextures: optifine/ctm/default/20_glass/glass_pane.properties
[13:31:11] [Worker-Main-117/INFO]: [OptiFine] ConnectedTextures: optifine/ctm/default/30_bookshelf/bookshelf.properties
[13:31:11] [Worker-Main-117/INFO]: [OptiFine] ConnectedTextures: optifine/ctm/default/40_sandstone/sandstone.properties
[13:31:11] [Worker-Main-117/INFO]: [OptiFine] ConnectedTextures: optifine/ctm/default/41_red_sandstone/red_sandstone.properties
[13:31:11] [Worker-Main-117/INFO]: [OptiFine] Multipass connected textures: false
[13:31:11] [Worker-Main-117/INFO]: [OptiFine] BetterGrass: Parsing default configuration optifine/bettergrass.properties
[13:32:22] [Worker-Main-117/INFO]: [OptiFine] Mipmap levels: 4
[13:32:24] [Worker-Main-115/INFO]: [OptiFine] Scaled non power of 2: jei:gui/icons/recipe_transfer, 7 -> 14
[13:32:25] [Worker-Main-115/INFO]: [OptiFine] Multitexture: false
[13:32:25] [Worker-Main-119/INFO]: [OptiFine] Multitexture: false
[13:32:25] [Worker-Main-120/INFO]: [OptiFine] Multitexture: false
[13:32:34] [Worker-Main-117/INFO]: [OptiFine] Multitexture: false
[13:32:34] [Worker-Main-117/INFO]: [OptiFine] Sprite size: 64
[13:32:34] [Worker-Main-117/INFO]: [OptiFine] Mipmap levels: 6
[13:32:34] [Worker-Main-117/INFO]: [OptiFine] Scaled too small texture: industrialforegoing:blocks/fluids/latex_flow, 32 -> 64
[13:32:34] [Worker-Main-117/INFO]: [OptiFine] Scaled too small texture: industrialforegoing:blocks/fluids/latex_still, 16 -> 64
[13:32:35] [Worker-Main-117/INFO]: [OptiFine] Multitexture: false
[13:32:35] [Worker-Main-117/INFO]: [OptiFine] Sprite size: 64
[13:32:35] [Worker-Main-117/INFO]: [OptiFine] Mipmap levels: 6
[13:32:35] [Worker-Main-117/INFO]: [OptiFine] Scaled too small texture: industrialforegoing:blocks/fluids/latex_flow, 32 -> 64
[13:32:35] [Worker-Main-117/INFO]: [OptiFine] Scaled too small texture: industrialforegoing:blocks/fluids/latex_still, 16 -> 64
[13:32:35] [Worker-Main-117/INFO]: [OptiFine] Multitexture: false
[13:32:36] [Worker-Main-117/INFO]: [OptiFine] Sprite size: 64
[13:32:36] [Worker-Main-117/INFO]: [OptiFine] Mipmap levels: 6
[13:32:36] [Worker-Main-117/INFO]: [OptiFine] Scaled too small texture: industrialforegoing:blocks/fluids/latex_flow, 32 -> 64
[13:32:36] [Worker-Main-117/INFO]: [OptiFine] Scaled too small texture: industrialforegoing:blocks/fluids/latex_still, 16 -> 64
[13:32:36] [Worker-Main-117/INFO]: [OptiFine] Multitexture: false
[13:32:36] [Worker-Main-117/INFO]: [OptiFine] Sprite size: 64
[13:32:36] [Worker-Main-117/INFO]: [OptiFine] Mipmap levels: 6
[13:32:36] [Worker-Main-117/INFO]: [OptiFine] Scaled too small texture: industrialforegoing:blocks/fluids/latex_flow, 32 -> 64
[13:32:36] [Worker-Main-117/INFO]: [OptiFine] Scaled too small texture: industrialforegoing:blocks/fluids/latex_still, 16 -> 64
[13:32:36] [Worker-Main-117/INFO]: [OptiFine] Multitexture: false
[13:32:36] [Worker-Main-117/INFO]: [OptiFine] Sprite size: 64
[13:32:36] [Worker-Main-117/INFO]: [OptiFine] Mipmap levels: 6
[13:32:36] [Worker-Main-117/INFO]: [OptiFine] Scaled too small texture: industrialforegoing:blocks/fluids/latex_flow, 32 -> 64
[13:32:36] [Worker-Main-117/INFO]: [OptiFine] Scaled too small texture: industrialforegoing:blocks/fluids/latex_still, 16 -> 64
[13:32:36] [Worker-Main-117/INFO]: [OptiFine] Multitexture: false
[13:32:36] [Worker-Main-117/INFO]: [OptiFine] Sprite size: 64
[13:32:36] [Worker-Main-117/INFO]: [OptiFine] Mipmap levels: 6
[13:32:36] [Worker-Main-117/INFO]: [OptiFine] Scaled too small texture: industrialforegoing:blocks/fluids/latex_flow, 32 -> 64
[13:32:36] [Worker-Main-117/INFO]: [OptiFine] Scaled too small texture: industrialforegoing:blocks/fluids/latex_still, 16 -> 64
[13:32:44] [main/INFO]: No shader config found.
[13:33:05] [main/INFO]: Loading context 'create:context/contraption'
[13:33:06] [main/ERROR]: Shader compilation log for create:rotating.vert: No errors.

[13:33:06] [main/ERROR]: Source for shader 'create:rotating.vert':
   1: #version 110
   2: #define DEBUG_RAINBOW
   3: 
   4: #define PI 3.1415926538
   5: 
   6: #if defined(USE_FOG)
   7: varying float FragDistance;
   8: #endif
   9: 
  10: varying vec3 BoxCoord;
  11: 
  12: uniform vec3 uLightBoxSize;
  13: uniform vec3 uLightBoxMin;
  14: uniform mat4 uModel;
  15: 
  16: uniform float uTime;
  17: uniform mat4 uViewProjection;
  18: uniform vec3 uCameraPos;
  19: 
  20: void FLWFinalizeWorldPos(inout vec4 worldPos) {
  21:     worldPos = uModel * worldPos;
  22: 
  23:     BoxCoord = (worldPos.xyz - uLightBoxMin) / uLightBoxSize;
  24: 
  25:     #if defined(USE_FOG)
  26:     FragDistance = length(worldPos.xyz);
  27:     #endif
  28: 
  29:     gl_Position = uViewProjection * worldPos;
  30: }
  31: 
  32: void FLWFinalizeNormal(inout vec3 normal) {
  33:     mat3 m;
  34:     m[0] = uModel[0].xyz;
  35:     m[1] = uModel[1].xyz;
  36:     m[2] = uModel[2].xyz;
  37:     normal = m * normal;
  38: }
  39: 
  40: 
  41: 
  42: mat4 rotate(vec3 axis, float angle) {
  43:     float s = sin(angle);
  44:     float c = cos(angle);
  45:     float oc = 1. - c;
  46: 
  47:     vec3 sa = axis * s;
  48: 
  49:     mat4 mr = mat4(1.);
  50:     mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
  51:     mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
  52:     mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);
  53: 
  54:     return mr;
  55: }
  56: 
  57: mat4 rotation(vec3 rot) {
  58:     return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
  59: }
  60: 
  61: mat3 modelToNormal(mat4 mat) {
  62:     // Discard the edges. This won't be accurate for scaled or skewed matrices,
  63:     // but we don't have to work with those often.
  64:     mat3 m;
  65:     m[0] = mat[0].xyz;
  66:     m[1] = mat[1].xyz;
  67:     m[2] = mat[2].xyz;
  68:     return m;
  69: }
  70: 
  71: float diffuse(vec3 normal) {
  72:     vec3 n2 = normal * normal * vec3(.6, .25, .8);
  73:     return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
  74: }
  75: 
  76: 
  77: struct Rotating {
  78:     vec2 light;
  79:     vec4 color;
  80:     vec3 pos;
  81:     float speed;
  82:     float offset;
  83:     vec3 axis;
  84: };
  85: 
  86: 
  87: struct Vertex {
  88:     vec3 pos;
  89:     vec3 normal;
  90:     vec2 texCoords;
  91: };
  92: 
  93: struct BlockFrag {
  94:     vec2 texCoords;
  95:     vec4 color;
  96:     float diffuse;
  97:     vec2 light;
  98: };
  99: 
 100: mat4 kineticRotation(float offset, float speed, vec3 axis) {
 101:     float degrees = offset + uTime * speed * 3./10.;
 102:     float angle = fract(degrees / 360.) * PI * 2.;
 103: 
 104:     return rotate(axis, angle);
 105: }
 106: 
 107: BlockFrag FLWMain(Vertex v, Rotating instance) {
 108:     mat4 spin = kineticRotation(instance.offset, instance.speed, instance.axis);
 109: 
 110:     vec4 worldPos = spin * vec4(v.pos - .5, 1.);
 111:     worldPos += vec4(instance.pos + .5, 0.);
 112: 
 113:     vec3 norm = modelToNormal(spin) * v.normal;
 114: 
 115:     FLWFinalizeWorldPos(worldPos);
 116:     FLWFinalizeNormal(norm);
 117: 
 118:     BlockFrag b;
 119:     b.diffuse = diffuse(norm);
 120:     b.texCoords = v.texCoords;
 121:     b.light = instance.light;
 122: 
 123:     #if defined(DEBUG_RAINBOW)
 124:     b.color = instance.color;
 125:     #elif defined(DEBUG_NORMAL)
 126:     b.color = vec4(norm, 1.);
 127:     #else
 128:     b.color = vec4(1.);
 129:     #endif
 130: 
 131:     return b;
 132: }
 133: attribute vec3 a_v_pos;
 134: attribute vec3 a_v_normal;
 135: attribute vec2 a_v_texCoords;
 136: 
 137: attribute vec2 a_i_light;
 138: attribute vec4 a_i_color;
 139: attribute vec3 a_i_pos;
 140: attribute float a_i_speed;
 141: attribute float a_i_offset;
 142: attribute vec3 a_i_axis;
 143: 
 144: 
 145: varying vec2 v2f_texCoords;
 146: varying vec4 v2f_color;
 147: varying float v2f_diffuse;
 148: varying vec2 v2f_light;
 149: 
 150: 
 151: void main() {
 152:     Vertex v;
 153:     v.pos = a_v_pos;
 154: v.normal = a_v_normal;
 155: v.texCoords = a_v_texCoords;
 156: 
 157: 
 158:     Rotating i;
 159:     i.light = a_i_light;
 160: i.color = a_i_color;
 161: i.pos = a_i_pos;
 162: i.speed = a_i_speed;
 163: i.offset = a_i_offset;
 164: i.axis = a_i_axis;
 165: 
 166: 
 167:     BlockFrag o = FLWMain(v, i);
 168: 
 169:     v2f_texCoords = o.texCoords;
 170: v2f_color = o.color;
 171: v2f_diffuse = o.diffuse;
 172: v2f_light = o.light;
 173: 
 174: }

[13:33:06] [main/ERROR]: Shader compilation log for flywheel:block.frag: No errors.

[13:33:06] [main/ERROR]: Source for shader 'flywheel:block.frag':
   1: #version 110
   2: #define DEBUG_RAINBOW
   3: 
   4: #if defined(USE_FOG)
   5: varying float FragDistance;
   6: uniform vec4 uFogColor;
   7: #endif
   8: 
   9: #if defined(USE_FOG_LINEAR)
  10: uniform vec2 uFogRange;
  11: 
  12: float FLWFogFactor() {
  13:     return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
  14: }
  15:     #endif
  16: 
  17:     #if defined(USE_FOG_EXP2)
  18: uniform float uFogDensity;
  19: 
  20: float FLWFogFactor() {
  21:     float dist = FragDistance * uFogDensity;
  22:     return 1. / exp2(dist * dist);
  23: }
  24:     #endif
  25: // Adjust the [0,1] normalized lightmap value based on the texture matrix from LightTexture#enableLightmap
  26: vec2 shiftLight(vec2 lm) {
  27:     return lm * 0.99609375 + 0.03125;// * 255/256 + 1/32
  28: }
  29: 
  30: varying vec3 BoxCoord;
  31: varying vec2 BoxLight;
  32: uniform sampler3D uLightVolume;
  33: 
  34: uniform sampler2D uBlockAtlas;
  35: uniform sampler2D uLightMap;
  36: 
  37: vec4 FLWBlockTexture(vec2 texCoords) {
  38:     return texture2D(uBlockAtlas, texCoords);
  39: }
  40: 
  41: void FLWFinalizeColor(vec4 color) {
  42:     #if defined(USE_FOG)
  43:     float a = color.a;
  44:     float fog = clamp(FLWFogFactor(), 0., 1.);
  45: 
  46:     color = mix(uFogColor, color, fog);
  47:     color.a = a;
  48:     #endif
  49: 
  50:     gl_FragColor = color;
  51: }
  52: 
  53: vec4 FLWLight(vec2 lightCoords) {
  54:     lightCoords = max(lightCoords, texture3D(uLightVolume, BoxCoord).rg);
  55: 
  56:     return texture2D(uLightMap, shiftLight(lightCoords));
  57: }
  58: 
  59: 
  60: 
  61: struct BlockFrag {
  62:     vec2 texCoords;
  63:     vec4 color;
  64:     float diffuse;
  65:     vec2 light;
  66: };
  67: 
  68: void FLWMain(BlockFrag r) {
  69:     vec4 tex = FLWBlockTexture(r.texCoords);
  70: 
  71:     vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;
  72: 
  73: //    flw_WorldPos = ;
  74: //    flw_Normal = ;
  75: //    flw_Albedo = tex.rgb;
  76: //    flw_Alpha = tex.a;
  77: //    flw_LightMap = r.light;
  78: //    flw_Tint = r.color;
  79:     FLWFinalizeColor(color);
  80: }
  81: 
  82: varying vec2 v2f_texCoords;
  83: varying vec4 v2f_color;
  84: varying float v2f_diffuse;
  85: varying vec2 v2f_light;
  86: 
  87: 
  88: //vec3 flw_WorldPos;
  89: //vec3 flw_Normal;
  90: //vec3 flw_Albedo;
  91: //float flw_Alpha;
  92: //vec2 flw_LightMap;
  93: //vec4 flw_Tint;
  94: 
  95: void main() {
  96:     BlockFrag f;
  97:     f.texCoords = v2f_texCoords;
  98: f.color = v2f_color;
  99: f.diffuse = v2f_diffuse;
 100: f.light = v2f_light;
 101: 
 102: 
 103:     FLWMain(f);
 104: }

[13:33:07] [main/ERROR]: Shader compilation log for create:rotating.vert: No errors.

[13:33:07] [main/ERROR]: Source for shader 'create:rotating.vert':
   1: #version 110
   2: #define DEBUG_NORMAL
   3: 
   4: #define PI 3.1415926538
   5: 
   6: #if defined(USE_FOG)
   7: varying float FragDistance;
   8: #endif
   9: 
  10: varying vec3 BoxCoord;
  11: 
  12: uniform vec3 uLightBoxSize;
  13: uniform vec3 uLightBoxMin;
  14: uniform mat4 uModel;
  15: 
  16: uniform float uTime;
  17: uniform mat4 uViewProjection;
  18: uniform vec3 uCameraPos;
  19: 
  20: void FLWFinalizeWorldPos(inout vec4 worldPos) {
  21:     worldPos = uModel * worldPos;
  22: 
  23:     BoxCoord = (worldPos.xyz - uLightBoxMin) / uLightBoxSize;
  24: 
  25:     #if defined(USE_FOG)
  26:     FragDistance = length(worldPos.xyz);
  27:     #endif
  28: 
  29:     gl_Position = uViewProjection * worldPos;
  30: }
  31: 
  32: void FLWFinalizeNormal(inout vec3 normal) {
  33:     mat3 m;
  34:     m[0] = uModel[0].xyz;
  35:     m[1] = uModel[1].xyz;
  36:     m[2] = uModel[2].xyz;
  37:     normal = m * normal;
  38: }
  39: 
  40: 
  41: 
  42: mat4 rotate(vec3 axis, float angle) {
  43:     float s = sin(angle);
  44:     float c = cos(angle);
  45:     float oc = 1. - c;
  46: 
  47:     vec3 sa = axis * s;
  48: 
  49:     mat4 mr = mat4(1.);
  50:     mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
  51:     mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
  52:     mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);
  53: 
  54:     return mr;
  55: }
  56: 
  57: mat4 rotation(vec3 rot) {
  58:     return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
  59: }
  60: 
  61: mat3 modelToNormal(mat4 mat) {
  62:     // Discard the edges. This won't be accurate for scaled or skewed matrices,
  63:     // but we don't have to work with those often.
  64:     mat3 m;
  65:     m[0] = mat[0].xyz;
  66:     m[1] = mat[1].xyz;
  67:     m[2] = mat[2].xyz;
  68:     return m;
  69: }
  70: 
  71: float diffuse(vec3 normal) {
  72:     vec3 n2 = normal * normal * vec3(.6, .25, .8);
  73:     return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
  74: }
  75: 
  76: 
  77: struct Rotating {
  78:     vec2 light;
  79:     vec4 color;
  80:     vec3 pos;
  81:     float speed;
  82:     float offset;
  83:     vec3 axis;
  84: };
  85: 
  86: 
  87: struct Vertex {
  88:     vec3 pos;
  89:     vec3 normal;
  90:     vec2 texCoords;
  91: };
  92: 
  93: struct BlockFrag {
  94:     vec2 texCoords;
  95:     vec4 color;
  96:     float diffuse;
  97:     vec2 light;
  98: };
  99: 
 100: mat4 kineticRotation(float offset, float speed, vec3 axis) {
 101:     float degrees = offset + uTime * speed * 3./10.;
 102:     float angle = fract(degrees / 360.) * PI * 2.;
 103: 
 104:     return rotate(axis, angle);
 105: }
 106: 
 107: BlockFrag FLWMain(Vertex v, Rotating instance) {
 108:     mat4 spin = kineticRotation(instance.offset, instance.speed, instance.axis);
 109: 
 110:     vec4 worldPos = spin * vec4(v.pos - .5, 1.);
 111:     worldPos += vec4(instance.pos + .5, 0.);
 112: 
 113:     vec3 norm = modelToNormal(spin) * v.normal;
 114: 
 115:     FLWFinalizeWorldPos(worldPos);
 116:     FLWFinalizeNormal(norm);
 117: 
 118:     BlockFrag b;
 119:     b.diffuse = diffuse(norm);
 120:     b.texCoords = v.texCoords;
 121:     b.light = instance.light;
 122: 
 123:     #if defined(DEBUG_RAINBOW)
 124:     b.color = instance.color;
 125:     #elif defined(DEBUG_NORMAL)
 126:     b.color = vec4(norm, 1.);
 127:     #else
 128:     b.color = vec4(1.);
 129:     #endif
 130: 
 131:     return b;
 132: }
 133: attribute vec3 a_v_pos;
 134: attribute vec3 a_v_normal;
 135: attribute vec2 a_v_texCoords;
 136: 
 137: attribute vec2 a_i_light;
 138: attribute vec4 a_i_color;
 139: attribute vec3 a_i_pos;
 140: attribute float a_i_speed;
 141: attribute float a_i_offset;
 142: attribute vec3 a_i_axis;
 143: 
 144: 
 145: varying vec2 v2f_texCoords;
 146: varying vec4 v2f_color;
 147: varying float v2f_diffuse;
 148: varying vec2 v2f_light;
 149: 
 150: 
 151: void main() {
 152:     Vertex v;
 153:     v.pos = a_v_pos;
 154: v.normal = a_v_normal;
 155: v.texCoords = a_v_texCoords;
 156: 
 157: 
 158:     Rotating i;
 159:     i.light = a_i_light;
 160: i.color = a_i_color;
 161: i.pos = a_i_pos;
 162: i.speed = a_i_speed;
 163: i.offset = a_i_offset;
 164: i.axis = a_i_axis;
 165: 
 166: 
 167:     BlockFrag o = FLWMain(v, i);
 168: 
 169:     v2f_texCoords = o.texCoords;
 170: v2f_color = o.color;
 171: v2f_diffuse = o.diffuse;
 172: v2f_light = o.light;
 173: 
 174: }

[13:33:07] [main/ERROR]: Shader compilation log for flywheel:block.frag: No errors.

[13:33:07] [main/ERROR]: Source for shader 'flywheel:block.frag':
   1: #version 110
   2: #define DEBUG_NORMAL
   3: 
   4: #if defined(USE_FOG)
   5: varying float FragDistance;
   6: uniform vec4 uFogColor;
   7: #endif
   8: 
   9: #if defined(USE_FOG_LINEAR)
  10: uniform vec2 uFogRange;
  11: 
  12: float FLWFogFactor() {
  13:     return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
  14: }
  15:     #endif
  16: 
  17:     #if defined(USE_FOG_EXP2)
  18: uniform float uFogDensity;
  19: 
  20: float FLWFogFactor() {
  21:     float dist = FragDistance * uFogDensity;
  22:     return 1. / exp2(dist * dist);
  23: }
  24:     #endif
  25: // Adjust the [0,1] normalized lightmap value based on the texture matrix from LightTexture#enableLightmap
  26: vec2 shiftLight(vec2 lm) {
  27:     return lm * 0.99609375 + 0.03125;// * 255/256 + 1/32
  28: }
  29: 
  30: varying vec3 BoxCoord;
  31: varying vec2 BoxLight;
  32: uniform sampler3D uLightVolume;
  33: 
  34: uniform sampler2D uBlockAtlas;
  35: uniform sampler2D uLightMap;
  36: 
  37: vec4 FLWBlockTexture(vec2 texCoords) {
  38:     return texture2D(uBlockAtlas, texCoords);
  39: }
  40: 
  41: void FLWFinalizeColor(vec4 color) {
  42:     #if defined(USE_FOG)
  43:     float a = color.a;
  44:     float fog = clamp(FLWFogFactor(), 0., 1.);
  45: 
  46:     color = mix(uFogColor, color, fog);
  47:     color.a = a;
  48:     #endif
  49: 
  50:     gl_FragColor = color;
  51: }
  52: 
  53: vec4 FLWLight(vec2 lightCoords) {
  54:     lightCoords = max(lightCoords, texture3D(uLightVolume, BoxCoord).rg);
  55: 
  56:     return texture2D(uLightMap, shiftLight(lightCoords));
  57: }
  58: 
  59: 
  60: 
  61: struct BlockFrag {
  62:     vec2 texCoords;
  63:     vec4 color;
  64:     float diffuse;
  65:     vec2 light;
  66: };
  67: 
  68: void FLWMain(BlockFrag r) {
  69:     vec4 tex = FLWBlockTexture(r.texCoords);
  70: 
  71:     vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;
  72: 
  73: //    flw_WorldPos = ;
  74: //    flw_Normal = ;
  75: //    flw_Albedo = tex.rgb;
  76: //    flw_Alpha = tex.a;
  77: //    flw_LightMap = r.light;
  78: //    flw_Tint = r.color;
  79:     FLWFinalizeColor(color);
  80: }
  81: 
  82: varying vec2 v2f_texCoords;
  83: varying vec4 v2f_color;
  84: varying float v2f_diffuse;
  85: varying vec2 v2f_light;
  86: 
  87: 
  88: //vec3 flw_WorldPos;
  89: //vec3 flw_Normal;
  90: //vec3 flw_Albedo;
  91: //float flw_Alpha;
  92: //vec2 flw_LightMap;
  93: //vec4 flw_Tint;
  94: 
  95: void main() {
  96:     BlockFrag f;
  97:     f.texCoords = v2f_texCoords;
  98: f.color = v2f_color;
  99: f.diffuse = v2f_diffuse;
 100: f.light = v2f_light;
 101: 
 102: 
 103:     FLWMain(f);
 104: }

[13:33:07] [main/ERROR]: Shader compilation log for create:rotating.vert: No errors.

[13:33:07] [main/ERROR]: Source for shader 'create:rotating.vert':
   1: #version 110
   2: #define USE_FOG
   3: #define USE_FOG_LINEAR
   4: 
   5: #define PI 3.1415926538
   6: 
   7: #if defined(USE_FOG)
   8: varying float FragDistance;
   9: #endif
  10: 
  11: varying vec3 BoxCoord;
  12: 
  13: uniform vec3 uLightBoxSize;
  14: uniform vec3 uLightBoxMin;
  15: uniform mat4 uModel;
  16: 
  17: uniform float uTime;
  18: uniform mat4 uViewProjection;
  19: uniform vec3 uCameraPos;
  20: 
  21: void FLWFinalizeWorldPos(inout vec4 worldPos) {
  22:     worldPos = uModel * worldPos;
  23: 
  24:     BoxCoord = (worldPos.xyz - uLightBoxMin) / uLightBoxSize;
  25: 
  26:     #if defined(USE_FOG)
  27:     FragDistance = length(worldPos.xyz);
  28:     #endif
  29: 
  30:     gl_Position = uViewProjection * worldPos;
  31: }
  32: 
  33: void FLWFinalizeNormal(inout vec3 normal) {
  34:     mat3 m;
  35:     m[0] = uModel[0].xyz;
  36:     m[1] = uModel[1].xyz;
  37:     m[2] = uModel[2].xyz;
  38:     normal = m * normal;
  39: }
  40: 
  41: 
  42: 
  43: mat4 rotate(vec3 axis, float angle) {
  44:     float s = sin(angle);
  45:     float c = cos(angle);
  46:     float oc = 1. - c;
  47: 
  48:     vec3 sa = axis * s;
  49: 
  50:     mat4 mr = mat4(1.);
  51:     mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
  52:     mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
  53:     mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);
  54: 
  55:     return mr;
  56: }
  57: 
  58: mat4 rotation(vec3 rot) {
  59:     return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
  60: }
  61: 
  62: mat3 modelToNormal(mat4 mat) {
  63:     // Discard the edges. This won't be accurate for scaled or skewed matrices,
  64:     // but we don't have to work with those often.
  65:     mat3 m;
  66:     m[0] = mat[0].xyz;
  67:     m[1] = mat[1].xyz;
  68:     m[2] = mat[2].xyz;
  69:     return m;
  70: }
  71: 
  72: float diffuse(vec3 normal) {
  73:     vec3 n2 = normal * normal * vec3(.6, .25, .8);
  74:     return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
  75: }
  76: 
  77: 
  78: struct Rotating {
  79:     vec2 light;
  80:     vec4 color;
  81:     vec3 pos;
  82:     float speed;
  83:     float offset;
  84:     vec3 axis;
  85: };
  86: 
  87: 
  88: struct Vertex {
  89:     vec3 pos;
  90:     vec3 normal;
  91:     vec2 texCoords;
  92: };
  93: 
  94: struct BlockFrag {
  95:     vec2 texCoords;
  96:     vec4 color;
  97:     float diffuse;
  98:     vec2 light;
  99: };
 100: 
 101: mat4 kineticRotation(float offset, float speed, vec3 axis) {
 102:     float degrees = offset + uTime * speed * 3./10.;
 103:     float angle = fract(degrees / 360.) * PI * 2.;
 104: 
 105:     return rotate(axis, angle);
 106: }
 107: 
 108: BlockFrag FLWMain(Vertex v, Rotating instance) {
 109:     mat4 spin = kineticRotation(instance.offset, instance.speed, instance.axis);
 110: 
 111:     vec4 worldPos = spin * vec4(v.pos - .5, 1.);
 112:     worldPos += vec4(instance.pos + .5, 0.);
 113: 
 114:     vec3 norm = modelToNormal(spin) * v.normal;
 115: 
 116:     FLWFinalizeWorldPos(worldPos);
 117:     FLWFinalizeNormal(norm);
 118: 
 119:     BlockFrag b;
 120:     b.diffuse = diffuse(norm);
 121:     b.texCoords = v.texCoords;
 122:     b.light = instance.light;
 123: 
 124:     #if defined(DEBUG_RAINBOW)
 125:     b.color = instance.color;
 126:     #elif defined(DEBUG_NORMAL)
 127:     b.color = vec4(norm, 1.);
 128:     #else
 129:     b.color = vec4(1.);
 130:     #endif
 131: 
 132:     return b;
 133: }
 134: attribute vec3 a_v_pos;
 135: attribute vec3 a_v_normal;
 136: attribute vec2 a_v_texCoords;
 137: 
 138: attribute vec2 a_i_light;
 139: attribute vec4 a_i_color;
 140: attribute vec3 a_i_pos;
 141: attribute float a_i_speed;
 142: attribute float a_i_offset;
 143: attribute vec3 a_i_axis;
 144: 
 145: 
 146: varying vec2 v2f_texCoords;
 147: varying vec4 v2f_color;
 148: varying float v2f_diffuse;
 149: varying vec2 v2f_light;
 150: 
 151: 
 152: void main() {
 153:     Vertex v;
 154:     v.pos = a_v_pos;
 155: v.normal = a_v_normal;
 156: v.texCoords = a_v_texCoords;
 157: 
 158: 
 159:     Rotating i;
 160:     i.light = a_i_light;
 161: i.color = a_i_color;
 162: i.pos = a_i_pos;
 163: i.speed = a_i_speed;
 164: i.offset = a_i_offset;
 165: i.axis = a_i_axis;
 166: 
 167: 
 168:     BlockFrag o = FLWMain(v, i);
 169: 
 170:     v2f_texCoords = o.texCoords;
 171: v2f_color = o.color;
 172: v2f_diffuse = o.diffuse;
 173: v2f_light = o.light;
 174: 
 175: }

[13:33:07] [main/ERROR]: Shader compilation log for flywheel:block.frag: No errors.

[13:33:07] [main/ERROR]: Source for shader 'flywheel:block.frag':
   1: #version 110
   2: #define USE_FOG
   3: #define USE_FOG_LINEAR
   4: 
   5: #if defined(USE_FOG)
   6: varying float FragDistance;
   7: uniform vec4 uFogColor;
   8: #endif
   9: 
  10: #if defined(USE_FOG_LINEAR)
  11: uniform vec2 uFogRange;
  12: 
  13: float FLWFogFactor() {
  14:     return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
  15: }
  16:     #endif
  17: 
  18:     #if defined(USE_FOG_EXP2)
  19: uniform float uFogDensity;
  20: 
  21: float FLWFogFactor() {
  22:     float dist = FragDistance * uFogDensity;
  23:     return 1. / exp2(dist * dist);
  24: }
  25:     #endif
  26: // Adjust the [0,1] normalized lightmap value based on the texture matrix from LightTexture#enableLightmap
  27: vec2 shiftLight(vec2 lm) {
  28:     return lm * 0.99609375 + 0.03125;// * 255/256 + 1/32
  29: }
  30: 
  31: varying vec3 BoxCoord;
  32: varying vec2 BoxLight;
  33: uniform sampler3D uLightVolume;
  34: 
  35: uniform sampler2D uBlockAtlas;
  36: uniform sampler2D uLightMap;
  37: 
  38: vec4 FLWBlockTexture(vec2 texCoords) {
  39:     return texture2D(uBlockAtlas, texCoords);
  40: }
  41: 
  42: void FLWFinalizeColor(vec4 color) {
  43:     #if defined(USE_FOG)
  44:     float a = color.a;
  45:     float fog = clamp(FLWFogFactor(), 0., 1.);
  46: 
  47:     color = mix(uFogColor, color, fog);
  48:     color.a = a;
  49:     #endif
  50: 
  51:     gl_FragColor = color;
  52: }
  53: 
  54: vec4 FLWLight(vec2 lightCoords) {
  55:     lightCoords = max(lightCoords, texture3D(uLightVolume, BoxCoord).rg);
  56: 
  57:     return texture2D(uLightMap, shiftLight(lightCoords));
  58: }
  59: 
  60: 
  61: 
  62: struct BlockFrag {
  63:     vec2 texCoords;
  64:     vec4 color;
  65:     float diffuse;
  66:     vec2 light;
  67: };
  68: 
  69: void FLWMain(BlockFrag r) {
  70:     vec4 tex = FLWBlockTexture(r.texCoords);
  71: 
  72:     vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;
  73: 
  74: //    flw_WorldPos = ;
  75: //    flw_Normal = ;
  76: //    flw_Albedo = tex.rgb;
  77: //    flw_Alpha = tex.a;
  78: //    flw_LightMap = r.light;
  79: //    flw_Tint = r.color;
  80:     FLWFinalizeColor(color);
  81: }
  82: 
  83: varying vec2 v2f_texCoords;
  84: varying vec4 v2f_color;
  85: varying float v2f_diffuse;
  86: varying vec2 v2f_light;
  87: 
  88: 
  89: //vec3 flw_WorldPos;
  90: //vec3 flw_Normal;
  91: //vec3 flw_Albedo;
  92: //float flw_Alpha;
  93: //vec2 flw_LightMap;
  94: //vec4 flw_Tint;
  95: 
  96: void main() {
  97:     BlockFrag f;
  98:     f.texCoords = v2f_texCoords;
  99: f.color = v2f_color;
 100: f.diffuse = v2f_diffuse;
 101: f.light = v2f_light;
 102: 
 103: 
 104:     FLWMain(f);
 105: }

[13:33:07] [main/ERROR]: Shader compilation log for create:rotating.vert: No errors.

[13:33:07] [main/ERROR]: Source for shader 'create:rotating.vert':
   1: #version 110
   2: #define USE_FOG
   3: #define USE_FOG_EXP2
   4: 
   5: #define PI 3.1415926538
   6: 
   7: #if defined(USE_FOG)
   8: varying float FragDistance;
   9: #endif
  10: 
  11: varying vec3 BoxCoord;
  12: 
  13: uniform vec3 uLightBoxSize;
  14: uniform vec3 uLightBoxMin;
  15: uniform mat4 uModel;
  16: 
  17: uniform float uTime;
  18: uniform mat4 uViewProjection;
  19: uniform vec3 uCameraPos;
  20: 
  21: void FLWFinalizeWorldPos(inout vec4 worldPos) {
  22:     worldPos = uModel * worldPos;
  23: 
  24:     BoxCoord = (worldPos.xyz - uLightBoxMin) / uLightBoxSize;
  25: 
  26:     #if defined(USE_FOG)
  27:     FragDistance = length(worldPos.xyz);
  28:     #endif
  29: 
  30:     gl_Position = uViewProjection * worldPos;
  31: }
  32: 
  33: void FLWFinalizeNormal(inout vec3 normal) {
  34:     mat3 m;
  35:     m[0] = uModel[0].xyz;
  36:     m[1] = uModel[1].xyz;
  37:     m[2] = uModel[2].xyz;
  38:     normal = m * normal;
  39: }
  40: 
  41: 
  42: 
  43: mat4 rotate(vec3 axis, float angle) {
  44:     float s = sin(angle);
  45:     float c = cos(angle);
  46:     float oc = 1. - c;
  47: 
  48:     vec3 sa = axis * s;
  49: 
  50:     mat4 mr = mat4(1.);
  51:     mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
  52:     mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
  53:     mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);
  54: 
  55:     return mr;
  56: }
  57: 
  58: mat4 rotation(vec3 rot) {
  59:     return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
  60: }
  61: 
  62: mat3 modelToNormal(mat4 mat) {
  63:     // Discard the edges. This won't be accurate for scaled or skewed matrices,
  64:     // but we don't have to work with those often.
  65:     mat3 m;
  66:     m[0] = mat[0].xyz;
  67:     m[1] = mat[1].xyz;
  68:     m[2] = mat[2].xyz;
  69:     return m;
  70: }
  71: 
  72: float diffuse(vec3 normal) {
  73:     vec3 n2 = normal * normal * vec3(.6, .25, .8);
  74:     return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
  75: }
  76: 
  77: 
  78: struct Rotating {
  79:     vec2 light;
  80:     vec4 color;
  81:     vec3 pos;
  82:     float speed;
  83:     float offset;
  84:     vec3 axis;
  85: };
  86: 
  87: 
  88: struct Vertex {
  89:     vec3 pos;
  90:     vec3 normal;
  91:     vec2 texCoords;
  92: };
  93: 
  94: struct BlockFrag {
  95:     vec2 texCoords;
  96:     vec4 color;
  97:     float diffuse;
  98:     vec2 light;
  99: };
 100: 
 101: mat4 kineticRotation(float offset, float speed, vec3 axis) {
 102:     float degrees = offset + uTime * speed * 3./10.;
 103:     float angle = fract(degrees / 360.) * PI * 2.;
 104: 
 105:     return rotate(axis, angle);
 106: }
 107: 
 108: BlockFrag FLWMain(Vertex v, Rotating instance) {
 109:     mat4 spin = kineticRotation(instance.offset, instance.speed, instance.axis);
 110: 
 111:     vec4 worldPos = spin * vec4(v.pos - .5, 1.);
 112:     worldPos += vec4(instance.pos + .5, 0.);
 113: 
 114:     vec3 norm = modelToNormal(spin) * v.normal;
 115: 
 116:     FLWFinalizeWorldPos(worldPos);
 117:     FLWFinalizeNormal(norm);
 118: 
 119:     BlockFrag b;
 120:     b.diffuse = diffuse(norm);
 121:     b.texCoords = v.texCoords;
 122:     b.light = instance.light;
 123: 
 124:     #if defined(DEBUG_RAINBOW)
 125:     b.color = instance.color;
 126:     #elif defined(DEBUG_NORMAL)
 127:     b.color = vec4(norm, 1.);
 128:     #else
 129:     b.color = vec4(1.);
 130:     #endif
 131: 
 132:     return b;
 133: }
 134: attribute vec3 a_v_pos;
 135: attribute vec3 a_v_normal;
 136: attribute vec2 a_v_texCoords;
 137: 
 138: attribute vec2 a_i_light;
 139: attribute vec4 a_i_color;
 140: attribute vec3 a_i_pos;
 141: attribute float a_i_speed;
 142: attribute float a_i_offset;
 143: attribute vec3 a_i_axis;
 144: 
 145: 
 146: varying vec2 v2f_texCoords;
 147: varying vec4 v2f_color;
 148: varying float v2f_diffuse;
 149: varying vec2 v2f_light;
 150: 
 151: 
 152: void main() {
 153:     Vertex v;
 154:     v.pos = a_v_pos;
 155: v.normal = a_v_normal;
 156: v.texCoords = a_v_texCoords;
 157: 
 158: 
 159:     Rotating i;
 160:     i.light = a_i_light;
 161: i.color = a_i_color;
 162: i.pos = a_i_pos;
 163: i.speed = a_i_speed;
 164: i.offset = a_i_offset;
 165: i.axis = a_i_axis;
 166: 
 167: 
 168:     BlockFrag o = FLWMain(v, i);
 169: 
 170:     v2f_texCoords = o.texCoords;
 171: v2f_color = o.color;
 172: v2f_diffuse = o.diffuse;
 173: v2f_light = o.light;
 174: 
 175: }

[13:33:07] [main/ERROR]: Shader compilation log for flywheel:block.frag: No errors.

[13:33:07] [main/ERROR]: Source for shader 'flywheel:block.frag':
   1: #version 110
   2: #define USE_FOG
   3: #define USE_FOG_EXP2
   4: 
   5: #if defined(USE_FOG)
   6: varying float FragDistance;
   7: uniform vec4 uFogColor;
   8: #endif
   9: 
  10: #if defined(USE_FOG_LINEAR)
  11: uniform vec2 uFogRange;
  12: 
  13: float FLWFogFactor() {
  14:     return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
  15: }
  16:     #endif
  17: 
  18:     #if defined(USE_FOG_EXP2)
  19: uniform float uFogDensity;
  20: 
  21: float FLWFogFactor() {
  22:     float dist = FragDistance * uFogDensity;
  23:     return 1. / exp2(dist * dist);
  24: }
  25:     #endif
  26: // Adjust the [0,1] normalized lightmap value based on the texture matrix from LightTexture#enableLightmap
  27: vec2 shiftLight(vec2 lm) {
  28:     return lm * 0.99609375 + 0.03125;// * 255/256 + 1/32
  29: }
  30: 
  31: varying vec3 BoxCoord;
  32: varying vec2 BoxLight;
  33: uniform sampler3D uLightVolume;
  34: 
  35: uniform sampler2D uBlockAtlas;
  36: uniform sampler2D uLightMap;
  37: 
  38: vec4 FLWBlockTexture(vec2 texCoords) {
  39:     return texture2D(uBlockAtlas, texCoords);
  40: }
  41: 
  42: void FLWFinalizeColor(vec4 color) {
  43:     #if defined(USE_FOG)
  44:     float a = color.a;
  45:     float fog = clamp(FLWFogFactor(), 0., 1.);
  46: 
  47:     color = mix(uFogColor, color, fog);
  48:     color.a = a;
  49:     #endif
  50: 
  51:     gl_FragColor = color;
  52: }
  53: 
  54: vec4 FLWLight(vec2 lightCoords) {
  55:     lightCoords = max(lightCoords, texture3D(uLightVolume, BoxCoord).rg);
  56: 
  57:     return texture2D(uLightMap, shiftLight(lightCoords));
  58: }
  59: 
  60: 
  61: 
  62: struct BlockFrag {
  63:     vec2 texCoords;
  64:     vec4 color;
  65:     float diffuse;
  66:     vec2 light;
  67: };
  68: 
  69: void FLWMain(BlockFrag r) {
  70:     vec4 tex = FLWBlockTexture(r.texCoords);
  71: 
  72:     vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;
  73: 
  74: //    flw_WorldPos = ;
  75: //    flw_Normal = ;
  76: //    flw_Albedo = tex.rgb;
  77: //    flw_Alpha = tex.a;
  78: //    flw_LightMap = r.light;
  79: //    flw_Tint = r.color;
  80:     FLWFinalizeColor(color);
  81: }
  82: 
  83: varying vec2 v2f_texCoords;
  84: varying vec4 v2f_color;
  85: varying float v2f_diffuse;
  86: varying vec2 v2f_light;
  87: 
  88: 
  89: //vec3 flw_WorldPos;
  90: //vec3 flw_Normal;
  91: //vec3 flw_Albedo;
  92: //float flw_Alpha;
  93: //vec2 flw_LightMap;
  94: //vec4 flw_Tint;
  95: 
  96: void main() {
  97:     BlockFrag f;
  98:     f.texCoords = v2f_texCoords;
  99: f.color = v2f_color;
 100: f.diffuse = v2f_diffuse;
 101: f.light = v2f_light;
 102: 
 103: 
 104:     FLWMain(f);
 105: }

[13:33:07] [main/ERROR]: Shader compilation log for create:rotating.vert: No errors.

[13:33:07] [main/ERROR]: Source for shader 'create:rotating.vert':
   1: #version 110
   2: 
   3: #define PI 3.1415926538
   4: 
   5: #if defined(USE_FOG)
   6: varying float FragDistance;
   7: #endif
   8: 
   9: varying vec3 BoxCoord;
  10: 
  11: uniform vec3 uLightBoxSize;
  12: uniform vec3 uLightBoxMin;
  13: uniform mat4 uModel;
  14: 
  15: uniform float uTime;
  16: uniform mat4 uViewProjection;
  17: uniform vec3 uCameraPos;
  18: 
  19: void FLWFinalizeWorldPos(inout vec4 worldPos) {
  20:     worldPos = uModel * worldPos;
  21: 
  22:     BoxCoord = (worldPos.xyz - uLightBoxMin) / uLightBoxSize;
  23: 
  24:     #if defined(USE_FOG)
  25:     FragDistance = length(worldPos.xyz);
  26:     #endif
  27: 
  28:     gl_Position = uViewProjection * worldPos;
  29: }
  30: 
  31: void FLWFinalizeNormal(inout vec3 normal) {
  32:     mat3 m;
  33:     m[0] = uModel[0].xyz;
  34:     m[1] = uModel[1].xyz;
  35:     m[2] = uModel[2].xyz;
  36:     normal = m * normal;
  37: }
  38: 
  39: 
  40: 
  41: mat4 rotate(vec3 axis, float angle) {
  42:     float s = sin(angle);
  43:     float c = cos(angle);
  44:     float oc = 1. - c;
  45: 
  46:     vec3 sa = axis * s;
  47: 
  48:     mat4 mr = mat4(1.);
  49:     mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
  50:     mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
  51:     mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);
  52: 
  53:     return mr;
  54: }
  55: 
  56: mat4 rotation(vec3 rot) {
  57:     return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
  58: }
  59: 
  60: mat3 modelToNormal(mat4 mat) {
  61:     // Discard the edges. This won't be accurate for scaled or skewed matrices,
  62:     // but we don't have to work with those often.
  63:     mat3 m;
  64:     m[0] = mat[0].xyz;
  65:     m[1] = mat[1].xyz;
  66:     m[2] = mat[2].xyz;
  67:     return m;
  68: }
  69: 
  70: float diffuse(vec3 normal) {
  71:     vec3 n2 = normal * normal * vec3(.6, .25, .8);
  72:     return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
  73: }
  74: 
  75: 
  76: struct Rotating {
  77:     vec2 light;
  78:     vec4 color;
  79:     vec3 pos;
  80:     float speed;
  81:     float offset;
  82:     vec3 axis;
  83: };
  84: 
  85: 
  86: struct Vertex {
  87:     vec3 pos;
  88:     vec3 normal;
  89:     vec2 texCoords;
  90: };
  91: 
  92: struct BlockFrag {
  93:     vec2 texCoords;
  94:     vec4 color;
  95:     float diffuse;
  96:     vec2 light;
  97: };
  98: 
  99: mat4 kineticRotation(float offset, float speed, vec3 axis) {
 100:     float degrees = offset + uTime * speed * 3./10.;
 101:     float angle = fract(degrees / 360.) * PI * 2.;
 102: 
 103:     return rotate(axis, angle);
 104: }
 105: 
 106: BlockFrag FLWMain(Vertex v, Rotating instance) {
 107:     mat4 spin = kineticRotation(instance.offset, instance.speed, instance.axis);
 108: 
 109:     vec4 worldPos = spin * vec4(v.pos - .5, 1.);
 110:     worldPos += vec4(instance.pos + .5, 0.);
 111: 
 112:     vec3 norm = modelToNormal(spin) * v.normal;
 113: 
 114:     FLWFinalizeWorldPos(worldPos);
 115:     FLWFinalizeNormal(norm);
 116: 
 117:     BlockFrag b;
 118:     b.diffuse = diffuse(norm);
 119:     b.texCoords = v.texCoords;
 120:     b.light = instance.light;
 121: 
 122:     #if defined(DEBUG_RAINBOW)
 123:     b.color = instance.color;
 124:     #elif defined(DEBUG_NORMAL)
 125:     b.color = vec4(norm, 1.);
 126:     #else
 127:     b.color = vec4(1.);
 128:     #endif
 129: 
 130:     return b;
 131: }
 132: attribute vec3 a_v_pos;
 133: attribute vec3 a_v_normal;
 134: attribute vec2 a_v_texCoords;
 135: 
 136: attribute vec2 a_i_light;
 137: attribute vec4 a_i_color;
 138: attribute vec3 a_i_pos;
 139: attribute float a_i_speed;
 140: attribute float a_i_offset;
 141: attribute vec3 a_i_axis;
 142: 
 143: 
 144: varying vec2 v2f_texCoords;
 145: varying vec4 v2f_color;
 146: varying float v2f_diffuse;
 147: varying vec2 v2f_light;
 148: 
 149: 
 150: void main() {
 151:     Vertex v;
 152:     v.pos = a_v_pos;
 153: v.normal = a_v_normal;
 154: v.texCoords = a_v_texCoords;
 155: 
 156: 
 157:     Rotating i;
 158:     i.light = a_i_light;
 159: i.color = a_i_color;
 160: i.pos = a_i_pos;
 161: i.speed = a_i_speed;
 162: i.offset = a_i_offset;
 163: i.axis = a_i_axis;
 164: 
 165: 
 166:     BlockFrag o = FLWMain(v, i);
 167: 
 168:     v2f_texCoords = o.texCoords;
 169: v2f_color = o.color;
 170: v2f_diffuse = o.diffuse;
 171: v2f_light = o.light;
 172: 
 173: }

[13:33:07] [main/ERROR]: Shader compilation log for flywheel:block.frag: No errors.

[13:33:07] [main/ERROR]: Source for shader 'flywheel:block.frag':
   1: #version 110
   2: 
   3: #if defined(USE_FOG)
   4: varying float FragDistance;
   5: uniform vec4 uFogColor;
   6: #endif
   7: 
   8: #if defined(USE_FOG_LINEAR)
   9: uniform vec2 uFogRange;
  10: 
  11: float FLWFogFactor() {
  12:     return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
  13: }
  14:     #endif
  15: 
  16:     #if defined(USE_FOG_EXP2)
  17: uniform float uFogDensity;
  18: 
  19: float FLWFogFactor() {
  20:     float dist = FragDistance * uFogDensity;
  21:     return 1. / exp2(dist * dist);
  22: }
  23:     #endif
  24: // Adjust the [0,1] normalized lightmap value based on the texture matrix from LightTexture#enableLightmap
  25: vec2 shiftLight(vec2 lm) {
  26:     return lm * 0.99609375 + 0.03125;// * 255/256 + 1/32
  27: }
  28: 
  29: varying vec3 BoxCoord;
  30: varying vec2 BoxLight;
  31: uniform sampler3D uLightVolume;
  32: 
  33: uniform sampler2D uBlockAtlas;
  34: uniform sampler2D uLightMap;
  35: 
  36: vec4 FLWBlockTexture(vec2 texCoords) {
  37:     return texture2D(uBlockAtlas, texCoords);
  38: }
  39: 
  40: void FLWFinalizeColor(vec4 color) {
  41:     #if defined(USE_FOG)
  42:     float a = color.a;
  43:     float fog = clamp(FLWFogFactor(), 0., 1.);
  44: 
  45:     color = mix(uFogColor, color, fog);
  46:     color.a = a;
  47:     #endif
  48: 
  49:     gl_FragColor = color;
  50: }
  51: 
  52: vec4 FLWLight(vec2 lightCoords) {
  53:     lightCoords = max(lightCoords, texture3D(uLightVolume, BoxCoord).rg);
  54: 
  55:     return texture2D(uLightMap, shiftLight(lightCoords));
  56: }
  57: 
  58: 
  59: 
  60: struct BlockFrag {
  61:     vec2 texCoords;
  62:     vec4 color;
  63:     float diffuse;
  64:     vec2 light;
  65: };
  66: 
  67: void FLWMain(BlockFrag r) {
  68:     vec4 tex = FLWBlockTexture(r.texCoords);
  69: 
  70:     vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;
  71: 
  72: //    flw_WorldPos = ;
  73: //    flw_Normal = ;
  74: //    flw_Albedo = tex.rgb;
  75: //    flw_Alpha = tex.a;
  76: //    flw_LightMap = r.light;
  77: //    flw_Tint = r.color;
  78:     FLWFinalizeColor(color);
  79: }
  80: 
  81: varying vec2 v2f_texCoords;
  82: varying vec4 v2f_color;
  83: varying float v2f_diffuse;
  84: varying vec2 v2f_light;
  85: 
  86: 
  87: //vec3 flw_WorldPos;
  88: //vec3 flw_Normal;
  89: //vec3 flw_Albedo;
  90: //float flw_Alpha;
  91: //vec2 flw_LightMap;
  92: //vec4 flw_Tint;
  93: 
  94: void main() {
  95:     BlockFrag f;
  96:     f.texCoords = v2f_texCoords;
  97: f.color = v2f_color;
  98: f.diffuse = v2f_diffuse;
  99: f.light = v2f_light;
 100: 
 101: 
 102:     FLWMain(f);
 103: }

[13:33:07] [main/ERROR]: Shader compilation log for create:contraption_actor.vert: No errors.

[13:33:07] [main/ERROR]: Source for shader 'create:contraption_actor.vert':
   1: #version 110
   2: #define DEBUG_NORMAL
   3: 
   4: #define PI 3.1415926538
   5: 
   6: #if defined(USE_FOG)
   7: varying float FragDistance;
   8: #endif
   9: 
  10: varying vec3 BoxCoord;
  11: 
  12: uniform vec3 uLightBoxSize;
  13: uniform vec3 uLightBoxMin;
  14: uniform mat4 uModel;
  15: 
  16: uniform float uTime;
  17: uniform mat4 uViewProjection;
  18: uniform vec3 uCameraPos;
  19: 
  20: void FLWFinalizeWorldPos(inout vec4 worldPos) {
  21:     worldPos = uModel * worldPos;
  22: 
  23:     BoxCoord = (worldPos.xyz - uLightBoxMin) / uLightBoxSize;
  24: 
  25:     #if defined(USE_FOG)
  26:     FragDistance = length(worldPos.xyz);
  27:     #endif
  28: 
  29:     gl_Position = uViewProjection * worldPos;
  30: }
  31: 
  32: void FLWFinalizeNormal(inout vec3 normal) {
  33:     mat3 m;
  34:     m[0] = uModel[0].xyz;
  35:     m[1] = uModel[1].xyz;
  36:     m[2] = uModel[2].xyz;
  37:     normal = m * normal;
  38: }
  39: 
  40: 
  41: 
  42: mat4 rotate(vec3 axis, float angle) {
  43:     float s = sin(angle);
  44:     float c = cos(angle);
  45:     float oc = 1. - c;
  46: 
  47:     vec3 sa = axis * s;
  48: 
  49:     mat4 mr = mat4(1.);
  50:     mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
  51:     mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
  52:     mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);
  53: 
  54:     return mr;
  55: }
  56: 
  57: mat4 rotation(vec3 rot) {
  58:     return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
  59: }
  60: 
  61: mat3 modelToNormal(mat4 mat) {
  62:     // Discard the edges. This won't be accurate for scaled or skewed matrices,
  63:     // but we don't have to work with those often.
  64:     mat3 m;
  65:     m[0] = mat[0].xyz;
  66:     m[1] = mat[1].xyz;
  67:     m[2] = mat[2].xyz;
  68:     return m;
  69: }
  70: 
  71: #define PIOVER2 1.5707963268
  72: 
  73: vec4 quat(vec3 axis, float angle) {
  74:     float halfAngle = angle * PIOVER2 / 180.0;
  75:     vec2 cs = sin(vec2(PIOVER2 - halfAngle, halfAngle)); // compute sin and cos in one instruction
  76:     return vec4(axis.xyz * cs.y,  cs.x);
  77: }
  78: 
  79: vec4 quatMult(vec4 q1, vec4 q2) {
  80:     // disgustingly vectorized quaternion multiplication
  81:     vec4 a = q1.w * q2.xyzw;
  82:     vec4 b = q1.x * q2.wzxy * vec4(1., -1., 1., -1.);
  83:     vec4 c = q1.y * q2.zwxy * vec4(1., 1., -1., -1.);
  84:     vec4 d = q1.z * q2.yxwz * vec4(-1., 1., 1., -1.);
  85: 
  86:     return a + b + c + d;
  87: }
  88: 
  89: vec3 rotateVertexByQuat(vec3 v, vec4 q) {
  90:     vec3 i = q.xyz;
  91:     return v + 2.0 * cross(i, cross(i, v) + q.w * v);
  92: }
  93: 
  94: vec3 rotateAbout(vec3 v, vec3 axis, float angle) {
  95:     return rotateVertexByQuat(v, quat(axis, angle));
  96: }
  97: 
  98: float diffuse(vec3 normal) {
  99:     vec3 n2 = normal * normal * vec3(.6, .25, .8);
 100:     return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
 101: }
 102: 
 103: 
 104: struct Actor {
 105:     vec3 pos;
 106:     vec2 light;
 107:     float offset;
 108:     vec3 axis;
 109:     vec4 rotation;
 110:     vec3 rotationCenter;
 111:     float speed;
 112: };
 113: 
 114: 
 115: struct Vertex {
 116:     vec3 pos;
 117:     vec3 normal;
 118:     vec2 texCoords;
 119: };
 120: 
 121: struct BlockFrag {
 122:     vec2 texCoords;
 123:     vec4 color;
 124:     float diffuse;
 125:     vec2 light;
 126: };
 127: 
 128: BlockFrag FLWMain(Vertex v, Actor instance) {
 129:     float degrees = instance.offset + uTime * instance.speed / 20.;
 130:     //float angle = fract(degrees / 360.) * PI * 2.;
 131: 
 132:     vec4 kineticRot = quat(instance.axis, degrees);
 133:     vec3 rotated = rotateVertexByQuat(v.pos - instance.rotationCenter, kineticRot) + instance.rotationCenter;
 134: 
 135:     vec4 worldPos = vec4(rotateVertexByQuat(rotated - .5, instance.rotation) + instance.pos + .5, 1.);
 136:     vec3 norm = rotateVertexByQuat(rotateVertexByQuat(v.normal, kineticRot), instance.rotation);
 137: 
 138:     FLWFinalizeWorldPos(worldPos);
 139:     FLWFinalizeNormal(norm);
 140: 
 141:     BlockFrag b;
 142:     b.diffuse = diffuse(norm);
 143:     b.texCoords = v.texCoords;
 144:     b.light = instance.light;
 145: 
 146:     #if defined(DEBUG_NORMAL)
 147:     b.color = vec4(norm, 1.);
 148:     #else
 149:     b.color = vec4(1.);
 150:     #endif
 151: 
 152:     return b;
 153: }
 154: attribute vec3 a_v_pos;
 155: attribute vec3 a_v_normal;
 156: attribute vec2 a_v_texCoords;
 157: 
 158: attribute vec3 a_i_pos;
 159: attribute vec2 a_i_light;
 160: attribute float a_i_offset;
 161: attribute vec3 a_i_axis;
 162: attribute vec4 a_i_rotation;
 163: attribute vec3 a_i_rotationCenter;
 164: attribute float a_i_speed;
 165: 
 166: 
 167: varying vec2 v2f_texCoords;
 168: varying vec4 v2f_color;
 169: varying float v2f_diffuse;
 170: varying vec2 v2f_light;
 171: 
 172: 
 173: void main() {
 174:     Vertex v;
 175:     v.pos = a_v_pos;
 176: v.normal = a_v_normal;
 177: v.texCoords = a_v_texCoords;
 178: 
 179: 
 180:     Actor i;
 181:     i.pos = a_i_pos;
 182: i.light = a_i_light;
 183: i.offset = a_i_offset;
 184: i.axis = a_i_axis;
 185: i.rotation = a_i_rotation;
 186: i.rotationCenter = a_i_rotationCenter;
 187: i.speed = a_i_speed;
 188: 
 189: 
 190:     BlockFrag o = FLWMain(v, i);
 191: 
 192:     v2f_texCoords = o.texCoords;
 193: v2f_color = o.color;
 194: v2f_diffuse = o.diffuse;
 195: v2f_light = o.light;
 196: 
 197: }

[13:33:07] [main/ERROR]: Shader compilation log for flywheel:block.frag: No errors.

[13:33:07] [main/ERROR]: Source for shader 'flywheel:block.frag':
   1: #version 110
   2: #define DEBUG_NORMAL
   3: 
   4: #if defined(USE_FOG)
   5: varying float FragDistance;
   6: uniform vec4 uFogColor;
   7: #endif
   8: 
   9: #if defined(USE_FOG_LINEAR)
  10: uniform vec2 uFogRange;
  11: 
  12: float FLWFogFactor() {
  13:     return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
  14: }
  15:     #endif
  16: 
  17:     #if defined(USE_FOG_EXP2)
  18: uniform float uFogDensity;
  19: 
  20: float FLWFogFactor() {
  21:     float dist = FragDistance * uFogDensity;
  22:     return 1. / exp2(dist * dist);
  23: }
  24:     #endif
  25: // Adjust the [0,1] normalized lightmap value based on the texture matrix from LightTexture#enableLightmap
  26: vec2 shiftLight(vec2 lm) {
  27:     return lm * 0.99609375 + 0.03125;// * 255/256 + 1/32
  28: }
  29: 
  30: varying vec3 BoxCoord;
  31: varying vec2 BoxLight;
  32: uniform sampler3D uLightVolume;
  33: 
  34: uniform sampler2D uBlockAtlas;
  35: uniform sampler2D uLightMap;
  36: 
  37: vec4 FLWBlockTexture(vec2 texCoords) {
  38:     return texture2D(uBlockAtlas, texCoords);
  39: }
  40: 
  41: void FLWFinalizeColor(vec4 color) {
  42:     #if defined(USE_FOG)
  43:     float a = color.a;
  44:     float fog = clamp(FLWFogFactor(), 0., 1.);
  45: 
  46:     color = mix(uFogColor, color, fog);
  47:     color.a = a;
  48:     #endif
  49: 
  50:     gl_FragColor = color;
  51: }
  52: 
  53: vec4 FLWLight(vec2 lightCoords) {
  54:     lightCoords = max(lightCoords, texture3D(uLightVolume, BoxCoord).rg);
  55: 
  56:     return texture2D(uLightMap, shiftLight(lightCoords));
  57: }
  58: 
  59: 
  60: 
  61: struct BlockFrag {
  62:     vec2 texCoords;
  63:     vec4 color;
  64:     float diffuse;
  65:     vec2 light;
  66: };
  67: 
  68: void FLWMain(BlockFrag r) {
  69:     vec4 tex = FLWBlockTexture(r.texCoords);
  70: 
  71:     vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;
  72: 
  73: //    flw_WorldPos = ;
  74: //    flw_Normal = ;
  75: //    flw_Albedo = tex.rgb;
  76: //    flw_Alpha = tex.a;
  77: //    flw_LightMap = r.light;
  78: //    flw_Tint = r.color;
  79:     FLWFinalizeColor(color);
  80: }
  81: 
  82: varying vec2 v2f_texCoords;
  83: varying vec4 v2f_color;
  84: varying float v2f_diffuse;
  85: varying vec2 v2f_light;
  86: 
  87: 
  88: //vec3 flw_WorldPos;
  89: //vec3 flw_Normal;
  90: //vec3 flw_Albedo;
  91: //float flw_Alpha;
  92: //vec2 flw_LightMap;
  93: //vec4 flw_Tint;
  94: 
  95: void main() {
  96:     BlockFrag f;
  97:     f.texCoords = v2f_texCoords;
  98: f.color = v2f_color;
  99: f.diffuse = v2f_diffuse;
 100: f.light = v2f_light;
 101: 
 102: 
 103:     FLWMain(f);
 104: }

[13:33:07] [main/ERROR]: Shader compilation log for create:contraption_actor.vert: No errors.

[13:33:07] [main/ERROR]: Source for shader 'create:contraption_actor.vert':
   1: #version 110
   2: #define USE_FOG
   3: #define USE_FOG_LINEAR
   4: 
   5: #define PI 3.1415926538
   6: 
   7: #if defined(USE_FOG)
   8: varying float FragDistance;
   9: #endif
  10: 
  11: varying vec3 BoxCoord;
  12: 
  13: uniform vec3 uLightBoxSize;
  14: uniform vec3 uLightBoxMin;
  15: uniform mat4 uModel;
  16: 
  17: uniform float uTime;
  18: uniform mat4 uViewProjection;
  19: uniform vec3 uCameraPos;
  20: 
  21: void FLWFinalizeWorldPos(inout vec4 worldPos) {
  22:     worldPos = uModel * worldPos;
  23: 
  24:     BoxCoord = (worldPos.xyz - uLightBoxMin) / uLightBoxSize;
  25: 
  26:     #if defined(USE_FOG)
  27:     FragDistance = length(worldPos.xyz);
  28:     #endif
  29: 
  30:     gl_Position = uViewProjection * worldPos;
  31: }
  32: 
  33: void FLWFinalizeNormal(inout vec3 normal) {
  34:     mat3 m;
  35:     m[0] = uModel[0].xyz;
  36:     m[1] = uModel[1].xyz;
  37:     m[2] = uModel[2].xyz;
  38:     normal = m * normal;
  39: }
  40: 
  41: 
  42: 
  43: mat4 rotate(vec3 axis, float angle) {
  44:     float s = sin(angle);
  45:     float c = cos(angle);
  46:     float oc = 1. - c;
  47: 
  48:     vec3 sa = axis * s;
  49: 
  50:     mat4 mr = mat4(1.);
  51:     mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
  52:     mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
  53:     mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);
  54: 
  55:     return mr;
  56: }
  57: 
  58: mat4 rotation(vec3 rot) {
  59:     return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
  60: }
  61: 
  62: mat3 modelToNormal(mat4 mat) {
  63:     // Discard the edges. This won't be accurate for scaled or skewed matrices,
  64:     // but we don't have to work with those often.
  65:     mat3 m;
  66:     m[0] = mat[0].xyz;
  67:     m[1] = mat[1].xyz;
  68:     m[2] = mat[2].xyz;
  69:     return m;
  70: }
  71: 
  72: #define PIOVER2 1.5707963268
  73: 
  74: vec4 quat(vec3 axis, float angle) {
  75:     float halfAngle = angle * PIOVER2 / 180.0;
  76:     vec2 cs = sin(vec2(PIOVER2 - halfAngle, halfAngle)); // compute sin and cos in one instruction
  77:     return vec4(axis.xyz * cs.y,  cs.x);
  78: }
  79: 
  80: vec4 quatMult(vec4 q1, vec4 q2) {
  81:     // disgustingly vectorized quaternion multiplication
  82:     vec4 a = q1.w * q2.xyzw;
  83:     vec4 b = q1.x * q2.wzxy * vec4(1., -1., 1., -1.);
  84:     vec4 c = q1.y * q2.zwxy * vec4(1., 1., -1., -1.);
  85:     vec4 d = q1.z * q2.yxwz * vec4(-1., 1., 1., -1.);
  86: 
  87:     return a + b + c + d;
  88: }
  89: 
  90: vec3 rotateVertexByQuat(vec3 v, vec4 q) {
  91:     vec3 i = q.xyz;
  92:     return v + 2.0 * cross(i, cross(i, v) + q.w * v);
  93: }
  94: 
  95: vec3 rotateAbout(vec3 v, vec3 axis, float angle) {
  96:     return rotateVertexByQuat(v, quat(axis, angle));
  97: }
  98: 
  99: float diffuse(vec3 normal) {
 100:     vec3 n2 = normal * normal * vec3(.6, .25, .8);
 101:     return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
 102: }
 103: 
 104: 
 105: struct Actor {
 106:     vec3 pos;
 107:     vec2 light;
 108:     float offset;
 109:     vec3 axis;
 110:     vec4 rotation;
 111:     vec3 rotationCenter;
 112:     float speed;
 113: };
 114: 
 115: 
 116: struct Vertex {
 117:     vec3 pos;
 118:     vec3 normal;
 119:     vec2 texCoords;
 120: };
 121: 
 122: struct BlockFrag {
 123:     vec2 texCoords;
 124:     vec4 color;
 125:     float diffuse;
 126:     vec2 light;
 127: };
 128: 
 129: BlockFrag FLWMain(Vertex v, Actor instance) {
 130:     float degrees = instance.offset + uTime * instance.speed / 20.;
 131:     //float angle = fract(degrees / 360.) * PI * 2.;
 132: 
 133:     vec4 kineticRot = quat(instance.axis, degrees);
 134:     vec3 rotated = rotateVertexByQuat(v.pos - instance.rotationCenter, kineticRot) + instance.rotationCenter;
 135: 
 136:     vec4 worldPos = vec4(rotateVertexByQuat(rotated - .5, instance.rotation) + instance.pos + .5, 1.);
 137:     vec3 norm = rotateVertexByQuat(rotateVertexByQuat(v.normal, kineticRot), instance.rotation);
 138: 
 139:     FLWFinalizeWorldPos(worldPos);
 140:     FLWFinalizeNormal(norm);
 141: 
 142:     BlockFrag b;
 143:     b.diffuse = diffuse(norm);
 144:     b.texCoords = v.texCoords;
 145:     b.light = instance.light;
 146: 
 147:     #if defined(DEBUG_NORMAL)
 148:     b.color = vec4(norm, 1.);
 149:     #else
 150:     b.color = vec4(1.);
 151:     #endif
 152: 
 153:     return b;
 154: }
 155: attribute vec3 a_v_pos;
 156: attribute vec3 a_v_normal;
 157: attribute vec2 a_v_texCoords;
 158: 
 159: attribute vec3 a_i_pos;
 160: attribute vec2 a_i_light;
 161: attribute float a_i_offset;
 162: attribute vec3 a_i_axis;
 163: attribute vec4 a_i_rotation;
 164: attribute vec3 a_i_rotationCenter;
 165: attribute float a_i_speed;
 166: 
 167: 
 168: varying vec2 v2f_texCoords;
 169: varying vec4 v2f_color;
 170: varying float v2f_diffuse;
 171: varying vec2 v2f_light;
 172: 
 173: 
 174: void main() {
 175:     Vertex v;
 176:     v.pos = a_v_pos;
 177: v.normal = a_v_normal;
 178: v.texCoords = a_v_texCoords;
 179: 
 180: 
 181:     Actor i;
 182:     i.pos = a_i_pos;
 183: i.light = a_i_light;
 184: i.offset = a_i_offset;
 185: i.axis = a_i_axis;
 186: i.rotation = a_i_rotation;
 187: i.rotationCenter = a_i_rotationCenter;
 188: i.speed = a_i_speed;
 189: 
 190: 
 191:     BlockFrag o = FLWMain(v, i);
 192: 
 193:     v2f_texCoords = o.texCoords;
 194: v2f_color = o.color;
 195: v2f_diffuse = o.diffuse;
 196: v2f_light = o.light;
 197: 
 198: }

[13:33:07] [main/ERROR]: Shader compilation log for flywheel:block.frag: No errors.

[13:33:07] [main/ERROR]: Source for shader 'flywheel:block.frag':
   1: #version 110
   2: #define USE_FOG
   3: #define USE_FOG_LINEAR
   4: 
   5: #if defined(USE_FOG)
   6: varying float FragDistance;
   7: uniform vec4 uFogColor;
   8: #endif
   9: 
  10: #if defined(USE_FOG_LINEAR)
  11: uniform vec2 uFogRange;
  12: 
  13: float FLWFogFactor() {
  14:     return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
  15: }
  16:     #endif
  17: 
  18:     #if defined(USE_FOG_EXP2)
  19: uniform float uFogDensity;
  20: 
  21: float FLWFogFactor() {
  22:     float dist = FragDistance * uFogDensity;
  23:     return 1. / exp2(dist * dist);
  24: }
  25:     #endif
  26: // Adjust the [0,1] normalized lightmap value based on the texture matrix from LightTexture#enableLightmap
  27: vec2 shiftLight(vec2 lm) {
  28:     return lm * 0.99609375 + 0.03125;// * 255/256 + 1/32
  29: }
  30: 
  31: varying vec3 BoxCoord;
  32: varying vec2 BoxLight;
  33: uniform sampler3D uLightVolume;
  34: 
  35: uniform sampler2D uBlockAtlas;
  36: uniform sampler2D uLightMap;
  37: 
  38: vec4 FLWBlockTexture(vec2 texCoords) {
  39:     return texture2D(uBlockAtlas, texCoords);
  40: }
  41: 
  42: void FLWFinalizeColor(vec4 color) {
  43:     #if defined(USE_FOG)
  44:     float a = color.a;
  45:     float fog = clamp(FLWFogFactor(), 0., 1.);
  46: 
  47:     color = mix(uFogColor, color, fog);
  48:     color.a = a;
  49:     #endif
  50: 
  51:     gl_FragColor = color;
  52: }
  53: 
  54: vec4 FLWLight(vec2 lightCoords) {
  55:     lightCoords = max(lightCoords, texture3D(uLightVolume, BoxCoord).rg);
  56: 
  57:     return texture2D(uLightMap, shiftLight(lightCoords));
  58: }
  59: 
  60: 
  61: 
  62: struct BlockFrag {
  63:     vec2 texCoords;
  64:     vec4 color;
  65:     float diffuse;
  66:     vec2 light;
  67: };
  68: 
  69: void FLWMain(BlockFrag r) {
  70:     vec4 tex = FLWBlockTexture(r.texCoords);
  71: 
  72:     vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;
  73: 
  74: //    flw_WorldPos = ;
  75: //    flw_Normal = ;
  76: //    flw_Albedo = tex.rgb;
  77: //    flw_Alpha = tex.a;
  78: //    flw_LightMap = r.light;
  79: //    flw_Tint = r.color;
  80:     FLWFinalizeColor(color);
  81: }
  82: 
  83: varying vec2 v2f_texCoords;
  84: varying vec4 v2f_color;
  85: varying float v2f_diffuse;
  86: varying vec2 v2f_light;
  87: 
  88: 
  89: //vec3 flw_WorldPos;
  90: //vec3 flw_Normal;
  91: //vec3 flw_Albedo;
  92: //float flw_Alpha;
  93: //vec2 flw_LightMap;
  94: //vec4 flw_Tint;
  95: 
  96: void main() {
  97:     BlockFrag f;
  98:     f.texCoords = v2f_texCoords;
  99: f.color = v2f_color;
 100: f.diffuse = v2f_diffuse;
 101: f.light = v2f_light;
 102: 
 103: 
 104:     FLWMain(f);
 105: }

[13:33:07] [main/ERROR]: Shader compilation log for create:contraption_actor.vert: No errors.

[13:33:07] [main/ERROR]: Source for shader 'create:contraption_actor.vert':
   1: #version 110
   2: #define USE_FOG
   3: #define USE_FOG_EXP2
   4: 
   5: #define PI 3.1415926538
   6: 
   7: #if defined(USE_FOG)
   8: varying float FragDistance;
   9: #endif
  10: 
  11: varying vec3 BoxCoord;
  12: 
  13: uniform vec3 uLightBoxSize;
  14: uniform vec3 uLightBoxMin;
  15: uniform mat4 uModel;
  16: 
  17: uniform float uTime;
  18: uniform mat4 uViewProjection;
  19: uniform vec3 uCameraPos;
  20: 
  21: void FLWFinalizeWorldPos(inout vec4 worldPos) {
  22:     worldPos = uModel * worldPos;
  23: 
  24:     BoxCoord = (worldPos.xyz - uLightBoxMin) / uLightBoxSize;
  25: 
  26:     #if defined(USE_FOG)
  27:     FragDistance = length(worldPos.xyz);
  28:     #endif
  29: 
  30:     gl_Position = uViewProjection * worldPos;
  31: }
  32: 
  33: void FLWFinalizeNormal(inout vec3 normal) {
  34:     mat3 m;
  35:     m[0] = uModel[0].xyz;
  36:     m[1] = uModel[1].xyz;
  37:     m[2] = uModel[2].xyz;
  38:     normal = m * normal;
  39: }
  40: 
  41: 
  42: 
  43: mat4 rotate(vec3 axis, float angle) {
  44:     float s = sin(angle);
  45:     float c = cos(angle);
  46:     float oc = 1. - c;
  47: 
  48:     vec3 sa = axis * s;
  49: 
  50:     mat4 mr = mat4(1.);
  51:     mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
  52:     mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
  53:     mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);
  54: 
  55:     return mr;
  56: }
  57: 
  58: mat4 rotation(vec3 rot) {
  59:     return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
  60: }
  61: 
  62: mat3 modelToNormal(mat4 mat) {
  63:     // Discard the edges. This won't be accurate for scaled or skewed matrices,
  64:     // but we don't have to work with those often.
  65:     mat3 m;
  66:     m[0] = mat[0].xyz;
  67:     m[1] = mat[1].xyz;
  68:     m[2] = mat[2].xyz;
  69:     return m;
  70: }
  71: 
  72: #define PIOVER2 1.5707963268
  73: 
  74: vec4 quat(vec3 axis, float angle) {
  75:     float halfAngle = angle * PIOVER2 / 180.0;
  76:     vec2 cs = sin(vec2(PIOVER2 - halfAngle, halfAngle)); // compute sin and cos in one instruction
  77:     return vec4(axis.xyz * cs.y,  cs.x);
  78: }
  79: 
  80: vec4 quatMult(vec4 q1, vec4 q2) {
  81:     // disgustingly vectorized quaternion multiplication
  82:     vec4 a = q1.w * q2.xyzw;
  83:     vec4 b = q1.x * q2.wzxy * vec4(1., -1., 1., -1.);
  84:     vec4 c = q1.y * q2.zwxy * vec4(1., 1., -1., -1.);
  85:     vec4 d = q1.z * q2.yxwz * vec4(-1., 1., 1., -1.);
  86: 
  87:     return a + b + c + d;
  88: }
  89: 
  90: vec3 rotateVertexByQuat(vec3 v, vec4 q) {
  91:     vec3 i = q.xyz;
  92:     return v + 2.0 * cross(i, cross(i, v) + q.w * v);
  93: }
  94: 
  95: vec3 rotateAbout(vec3 v, vec3 axis, float angle) {
  96:     return rotateVertexByQuat(v, quat(axis, angle));
  97: }
  98: 
  99: float diffuse(vec3 normal) {
 100:     vec3 n2 = normal * normal * vec3(.6, .25, .8);
 101:     return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
 102: }
 103: 
 104: 
 105: struct Actor {
 106:     vec3 pos;
 107:     vec2 light;
 108:     float offset;
 109:     vec3 axis;
 110:     vec4 rotation;
 111:     vec3 rotationCenter;
 112:     float speed;
 113: };
 114: 
 115: 
 116: struct Vertex {
 117:     vec3 pos;
 118:     vec3 normal;
 119:     vec2 texCoords;
 120: };
 121: 
 122: struct BlockFrag {
 123:     vec2 texCoords;
 124:     vec4 color;
 125:     float diffuse;
 126:     vec2 light;
 127: };
 128: 
 129: BlockFrag FLWMain(Vertex v, Actor instance) {
 130:     float degrees = instance.offset + uTime * instance.speed / 20.;
 131:     //float angle = fract(degrees / 360.) * PI * 2.;
 132: 
 133:     vec4 kineticRot = quat(instance.axis, degrees);
 134:     vec3 rotated = rotateVertexByQuat(v.pos - instance.rotationCenter, kineticRot) + instance.rotationCenter;
 135: 
 136:     vec4 worldPos = vec4(rotateVertexByQuat(rotated - .5, instance.rotation) + instance.pos + .5, 1.);
 137:     vec3 norm = rotateVertexByQuat(rotateVertexByQuat(v.normal, kineticRot), instance.rotation);
 138: 
 139:     FLWFinalizeWorldPos(worldPos);
 140:     FLWFinalizeNormal(norm);
 141: 
 142:     BlockFrag b;
 143:     b.diffuse = diffuse(norm);
 144:     b.texCoords = v.texCoords;
 145:     b.light = instance.light;
 146: 
 147:     #if defined(DEBUG_NORMAL)
 148:     b.color = vec4(norm, 1.);
 149:     #else
 150:     b.color = vec4(1.);
 151:     #endif
 152: 
 153:     return b;
 154: }
 155: attribute vec3 a_v_pos;
 156: attribute vec3 a_v_normal;
 157: attribute vec2 a_v_texCoords;
 158: 
 159: attribute vec3 a_i_pos;
 160: attribute vec2 a_i_light;
 161: attribute float a_i_offset;
 162: attribute vec3 a_i_axis;
 163: attribute vec4 a_i_rotation;
 164: attribute vec3 a_i_rotationCenter;
 165: attribute float a_i_speed;
 166: 
 167: 
 168: varying vec2 v2f_texCoords;
 169: varying vec4 v2f_color;
 170: varying float v2f_diffuse;
 171: varying vec2 v2f_light;
 172: 
 173: 
 174: void main() {
 175:     Vertex v;
 176:     v.pos = a_v_pos;
 177: v.normal = a_v_normal;
 178: v.texCoords = a_v_texCoords;
 179: 
 180: 
 181:     Actor i;
 182:     i.pos = a_i_pos;
 183: i.light = a_i_light;
 184: i.offset = a_i_offset;
 185: i.axis = a_i_axis;
 186: i.rotation = a_i_rotation;
 187: i.rotationCenter = a_i_rotationCenter;
 188: i.speed = a_i_speed;
 189: 
 190: 
 191:     BlockFrag o = FLWMain(v, i);
 192: 
 193:     v2f_texCoords = o.texCoords;
 194: v2f_color = o.color;
 195: v2f_diffuse = o.diffuse;
 196: v2f_light = o.light;
 197: 
 198: }

[13:33:07] [main/ERROR]: Shader compilation log for flywheel:block.frag: No errors.

[13:33:07] [main/ERROR]: Source for shader 'flywheel:block.frag':
   1: #version 110
   2: #define USE_FOG
   3: #define USE_FOG_EXP2
   4: 
   5: #if defined(USE_FOG)
   6: varying float FragDistance;
   7: uniform vec4 uFogColor;
   8: #endif
   9: 
  10: #if defined(USE_FOG_LINEAR)
  11: uniform vec2 uFogRange;
  12: 
  13: float FLWFogFactor() {
  14:     return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
  15: }
  16:     #endif
  17: 
  18:     #if defined(USE_FOG_EXP2)
  19: uniform float uFogDensity;
  20: 
  21: float FLWFogFactor() {
  22:     float dist = FragDistance * uFogDensity;
  23:     return 1. / exp2(dist * dist);
  24: }
  25:     #endif
  26: // Adjust the [0,1] normalized lightmap value based on the texture matrix from LightTexture#enableLightmap
  27: vec2 shiftLight(vec2 lm) {
  28:     return lm * 0.99609375 + 0.03125;// * 255/256 + 1/32
  29: }
  30: 
  31: varying vec3 BoxCoord;
  32: varying vec2 BoxLight;
  33: uniform sampler3D uLightVolume;
  34: 
  35: uniform sampler2D uBlockAtlas;
  36: uniform sampler2D uLightMap;
  37: 
  38: vec4 FLWBlockTexture(vec2 texCoords) {
  39:     return texture2D(uBlockAtlas, texCoords);
  40: }
  41: 
  42: void FLWFinalizeColor(vec4 color) {
  43:     #if defined(USE_FOG)
  44:     float a = color.a;
  45:     float fog = clamp(FLWFogFactor(), 0., 1.);
  46: 
  47:     color = mix(uFogColor, color, fog);
  48:     color.a = a;
  49:     #endif
  50: 
  51:     gl_FragColor = color;
  52: }
  53: 
  54: vec4 FLWLight(vec2 lightCoords) {
  55:     lightCoords = max(lightCoords, texture3D(uLightVolume, BoxCoord).rg);
  56: 
  57:     return texture2D(uLightMap, shiftLight(lightCoords));
  58: }
  59: 
  60: 
  61: 
  62: struct BlockFrag {
  63:     vec2 texCoords;
  64:     vec4 color;
  65:     float diffuse;
  66:     vec2 light;
  67: };
  68: 
  69: void FLWMain(BlockFrag r) {
  70:     vec4 tex = FLWBlockTexture(r.texCoords);
  71: 
  72:     vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;
  73: 
  74: //    flw_WorldPos = ;
  75: //    flw_Normal = ;
  76: //    flw_Albedo = tex.rgb;
  77: //    flw_Alpha = tex.a;
  78: //    flw_LightMap = r.light;
  79: //    flw_Tint = r.color;
  80:     FLWFinalizeColor(color);
  81: }
  82: 
  83: varying vec2 v2f_texCoords;
  84: varying vec4 v2f_color;
  85: varying float v2f_diffuse;
  86: varying vec2 v2f_light;
  87: 
  88: 
  89: //vec3 flw_WorldPos;
  90: //vec3 flw_Normal;
  91: //vec3 flw_Albedo;
  92: //float flw_Alpha;
  93: //vec2 flw_LightMap;
  94: //vec4 flw_Tint;
  95: 
  96: void main() {
  97:     BlockFrag f;
  98:     f.texCoords = v2f_texCoords;
  99: f.color = v2f_color;
 100: f.diffuse = v2f_diffuse;
 101: f.light = v2f_light;
 102: 
 103: 
 104:     FLWMain(f);
 105: }

[13:33:08] [main/ERROR]: Shader compilation log for create:contraption_actor.vert: No errors.

[13:33:08] [main/ERROR]: Source for shader 'create:contraption_actor.vert':
   1: #version 110
   2: 
   3: #define PI 3.1415926538
   4: 
   5: #if defined(USE_FOG)
   6: varying float FragDistance;
   7: #endif
   8: 
   9: varying vec3 BoxCoord;
  10: 
  11: uniform vec3 uLightBoxSize;
  12: uniform vec3 uLightBoxMin;
  13: uniform mat4 uModel;
  14: 
  15: uniform float uTime;
  16: uniform mat4 uViewProjection;
  17: uniform vec3 uCameraPos;
  18: 
  19: void FLWFinalizeWorldPos(inout vec4 worldPos) {
  20:     worldPos = uModel * worldPos;
  21: 
  22:     BoxCoord = (worldPos.xyz - uLightBoxMin) / uLightBoxSize;
  23: 
  24:     #if defined(USE_FOG)
  25:     FragDistance = length(worldPos.xyz);
  26:     #endif
  27: 
  28:     gl_Position = uViewProjection * worldPos;
  29: }
  30: 
  31: void FLWFinalizeNormal(inout vec3 normal) {
  32:     mat3 m;
  33:     m[0] = uModel[0].xyz;
  34:     m[1] = uModel[1].xyz;
  35:     m[2] = uModel[2].xyz;
  36:     normal = m * normal;
  37: }
  38: 
  39: 
  40: 
  41: mat4 rotate(vec3 axis, float angle) {
  42:     float s = sin(angle);
  43:     float c = cos(angle);
  44:     float oc = 1. - c;
  45: 
  46:     vec3 sa = axis * s;
  47: 
  48:     mat4 mr = mat4(1.);
  49:     mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
  50:     mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
  51:     mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);
  52: 
  53:     return mr;
  54: }
  55: 
  56: mat4 rotation(vec3 rot) {
  57:     return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
  58: }
  59: 
  60: mat3 modelToNormal(mat4 mat) {
  61:     // Discard the edges. This won't be accurate for scaled or skewed matrices,
  62:     // but we don't have to work with those often.
  63:     mat3 m;
  64:     m[0] = mat[0].xyz;
  65:     m[1] = mat[1].xyz;
  66:     m[2] = mat[2].xyz;
  67:     return m;
  68: }
  69: 
  70: #define PIOVER2 1.5707963268
  71: 
  72: vec4 quat(vec3 axis, float angle) {
  73:     float halfAngle = angle * PIOVER2 / 180.0;
  74:     vec2 cs = sin(vec2(PIOVER2 - halfAngle, halfAngle)); // compute sin and cos in one instruction
  75:     return vec4(axis.xyz * cs.y,  cs.x);
  76: }
  77: 
  78: vec4 quatMult(vec4 q1, vec4 q2) {
  79:     // disgustingly vectorized quaternion multiplication
  80:     vec4 a = q1.w * q2.xyzw;
  81:     vec4 b = q1.x * q2.wzxy * vec4(1., -1., 1., -1.);
  82:     vec4 c = q1.y * q2.zwxy * vec4(1., 1., -1., -1.);
  83:     vec4 d = q1.z * q2.yxwz * vec4(-1., 1., 1., -1.);
  84: 
  85:     return a + b + c + d;
  86: }
  87: 
  88: vec3 rotateVertexByQuat(vec3 v, vec4 q) {
  89:     vec3 i = q.xyz;
  90:     return v + 2.0 * cross(i, cross(i, v) + q.w * v);
  91: }
  92: 
  93: vec3 rotateAbout(vec3 v, vec3 axis, float angle) {
  94:     return rotateVertexByQuat(v, quat(axis, angle));
  95: }
  96: 
  97: float diffuse(vec3 normal) {
  98:     vec3 n2 = normal * normal * vec3(.6, .25, .8);
  99:     return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
 100: }
 101: 
 102: 
 103: struct Actor {
 104:     vec3 pos;
 105:     vec2 light;
 106:     float offset;
 107:     vec3 axis;
 108:     vec4 rotation;
 109:     vec3 rotationCenter;
 110:     float speed;
 111: };
 112: 
 113: 
 114: struct Vertex {
 115:     vec3 pos;
 116:     vec3 normal;
 117:     vec2 texCoords;
 118: };
 119: 
 120: struct BlockFrag {
 121:     vec2 texCoords;
 122:     vec4 color;
 123:     float diffuse;
 124:     vec2 light;
 125: };
 126: 
 127: BlockFrag FLWMain(Vertex v, Actor instance) {
 128:     float degrees = instance.offset + uTime * instance.speed / 20.;
 129:     //float angle = fract(degrees / 360.) * PI * 2.;
 130: 
 131:     vec4 kineticRot = quat(instance.axis, degrees);
 132:     vec3 rotated = rotateVertexByQuat(v.pos - instance.rotationCenter, kineticRot) + instance.rotationCenter;
 133: 
 134:     vec4 worldPos = vec4(rotateVertexByQuat(rotated - .5, instance.rotation) + instance.pos + .5, 1.);
 135:     vec3 norm = rotateVertexByQuat(rotateVertexByQuat(v.normal, kineticRot), instance.rotation);
 136: 
 137:     FLWFinalizeWorldPos(worldPos);
 138:     FLWFinalizeNormal(norm);
 139: 
 140:     BlockFrag b;
 141:     b.diffuse = diffuse(norm);
 142:     b.texCoords = v.texCoords;
 143:     b.light = instance.light;
 144: 
 145:     #if defined(DEBUG_NORMAL)
 146:     b.color = vec4(norm, 1.);
 147:     #else
 148:     b.color = vec4(1.);
 149:     #endif
 150: 
 151:     return b;
 152: }
 153: attribute vec3 a_v_pos;
 154: attribute vec3 a_v_normal;
 155: attribute vec2 a_v_texCoords;
 156: 
 157: attribute vec3 a_i_pos;
 158: attribute vec2 a_i_light;
 159: attribute float a_i_offset;
 160: attribute vec3 a_i_axis;
 161: attribute vec4 a_i_rotation;
 162: attribute vec3 a_i_rotationCenter;
 163: attribute float a_i_speed;
 164: 
 165: 
 166: varying vec2 v2f_texCoords;
 167: varying vec4 v2f_color;
 168: varying float v2f_diffuse;
 169: varying vec2 v2f_light;
 170: 
 171: 
 172: void main() {
 173:     Vertex v;
 174:     v.pos = a_v_pos;
 175: v.normal = a_v_normal;
 176: v.texCoords = a_v_texCoords;
 177: 
 178: 
 179:     Actor i;
 180:     i.pos = a_i_pos;
 181: i.light = a_i_light;
 182: i.offset = a_i_offset;
 183: i.axis = a_i_axis;
 184: i.rotation = a_i_rotation;
 185: i.rotationCenter = a_i_rotationCenter;
 186: i.speed = a_i_speed;
 187: 
 188: 
 189:     BlockFrag o = FLWMain(v, i);
 190: 
 191:     v2f_texCoords = o.texCoords;
 192: v2f_color = o.color;
 193: v2f_diffuse = o.diffuse;
 194: v2f_light = o.light;
 195: 
 196: }

[13:33:08] [main/ERROR]: Shader compilation log for flywheel:block.frag: No errors.

[13:33:08] [main/ERROR]: Source for shader 'flywheel:block.frag':
   1: #version 110
   2: 
   3: #if defined(USE_FOG)
   4: varying float FragDistance;
   5: uniform vec4 uFogColor;
   6: #endif
   7: 
   8: #if defined(USE_FOG_LINEAR)
   9: uniform vec2 uFogRange;
  10: 
  11: float FLWFogFactor() {
  12:     return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
  13: }
  14:     #endif
  15: 
  16:     #if defined(USE_FOG_EXP2)
  17: uniform float uFogDensity;
  18: 
  19: float FLWFogFactor() {
  20:     float dist = FragDistance * uFogDensity;
  21:     return 1. / exp2(dist * dist);
  22: }
  23:     #endif
  24: // Adjust the [0,1] normalized lightmap value based on the texture matrix from LightTexture#enableLightmap
  25: vec2 shiftLight(vec2 lm) {
  26:     return lm * 0.99609375 + 0.03125;// * 255/256 + 1/32
  27: }
  28: 
  29: varying vec3 BoxCoord;
  30: varying vec2 BoxLight;
  31: uniform sampler3D uLightVolume;
  32: 
  33: uniform sampler2D uBlockAtlas;
  34: uniform sampler2D uLightMap;
  35: 
  36: vec4 FLWBlockTexture(vec2 texCoords) {
  37:     return texture2D(uBlockAtlas, texCoords);
  38: }
  39: 
  40: void FLWFinalizeColor(vec4 color) {
  41:     #if defined(USE_FOG)
  42:     float a = color.a;
  43:     float fog = clamp(FLWFogFactor(), 0., 1.);
  44: 
  45:     color = mix(uFogColor, color, fog);
  46:     color.a = a;
  47:     #endif
  48: 
  49:     gl_FragColor = color;
  50: }
  51: 
  52: vec4 FLWLight(vec2 lightCoords) {
  53:     lightCoords = max(lightCoords, texture3D(uLightVolume, BoxCoord).rg);
  54: 
  55:     return texture2D(uLightMap, shiftLight(lightCoords));
  56: }
  57: 
  58: 
  59: 
  60: struct BlockFrag {
  61:     vec2 texCoords;
  62:     vec4 color;
  63:     float diffuse;
  64:     vec2 light;
  65: };
  66: 
  67: void FLWMain(BlockFrag r) {
  68:     vec4 tex = FLWBlockTexture(r.texCoords);
  69: 
  70:     vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;
  71: 
  72: //    flw_WorldPos = ;
  73: //    flw_Normal = ;
  74: //    flw_Albedo = tex.rgb;
  75: //    flw_Alpha = tex.a;
  76: //    flw_LightMap = r.light;
  77: //    flw_Tint = r.color;
  78:     FLWFinalizeColor(color);
  79: }
  80: 
  81: varying vec2 v2f_texCoords;
  82: varying vec4 v2f_color;
  83: varying float v2f_diffuse;
  84: varying vec2 v2f_light;
  85: 
  86: 
  87: //vec3 flw_WorldPos;
  88: //vec3 flw_Normal;
  89: //vec3 flw_Albedo;
  90: //float flw_Alpha;
  91: //vec2 flw_LightMap;
  92: //vec4 flw_Tint;
  93: 
  94: void main() {
  95:     BlockFrag f;
  96:     f.texCoords = v2f_texCoords;
  97: f.color = v2f_color;
  98: f.diffuse = v2f_diffuse;
  99: f.light = v2f_light;
 100: 
 101: 
 102:     FLWMain(f);
 103: }

[13:33:08] [main/ERROR]: Shader compilation log for create:flap.vert: No errors.

[13:33:08] [main/ERROR]: Source for shader 'create:flap.vert':
   1: #version 110
   2: #define DEBUG_NORMAL
   3: 
   4: #define PI 3.1415926538
   5: 
   6: #if defined(USE_FOG)
   7: varying float FragDistance;
   8: #endif
   9: 
  10: varying vec3 BoxCoord;
  11: 
  12: uniform vec3 uLightBoxSize;
  13: uniform vec3 uLightBoxMin;
  14: uniform mat4 uModel;
  15: 
  16: uniform float uTime;
  17: uniform mat4 uViewProjection;
  18: uniform vec3 uCameraPos;
  19: 
  20: void FLWFinalizeWorldPos(inout vec4 worldPos) {
  21:     worldPos = uModel * worldPos;
  22: 
  23:     BoxCoord = (worldPos.xyz - uLightBoxMin) / uLightBoxSize;
  24: 
  25:     #if defined(USE_FOG)
  26:     FragDistance = length(worldPos.xyz);
  27:     #endif
  28: 
  29:     gl_Position = uViewProjection * worldPos;
  30: }
  31: 
  32: void FLWFinalizeNormal(inout vec3 normal) {
  33:     mat3 m;
  34:     m[0] = uModel[0].xyz;
  35:     m[1] = uModel[1].xyz;
  36:     m[2] = uModel[2].xyz;
  37:     normal = m * normal;
  38: }
  39: 
  40: 
  41: 
  42: mat4 rotate(vec3 axis, float angle) {
  43:     float s = sin(angle);
  44:     float c = cos(angle);
  45:     float oc = 1. - c;
  46: 
  47:     vec3 sa = axis * s;
  48: 
  49:     mat4 mr = mat4(1.);
  50:     mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
  51:     mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
  52:     mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);
  53: 
  54:     return mr;
  55: }
  56: 
  57: mat4 rotation(vec3 rot) {
  58:     return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
  59: }
  60: 
  61: mat3 modelToNormal(mat4 mat) {
  62:     // Discard the edges. This won't be accurate for scaled or skewed matrices,
  63:     // but we don't have to work with those often.
  64:     mat3 m;
  65:     m[0] = mat[0].xyz;
  66:     m[1] = mat[1].xyz;
  67:     m[2] = mat[2].xyz;
  68:     return m;
  69: }
  70: 
  71: #define PIOVER2 1.5707963268
  72: 
  73: vec4 quat(vec3 axis, float angle) {
  74:     float halfAngle = angle * PIOVER2 / 180.0;
  75:     vec2 cs = sin(vec2(PIOVER2 - halfAngle, halfAngle)); // compute sin and cos in one instruction
  76:     return vec4(axis.xyz * cs.y,  cs.x);
  77: }
  78: 
  79: vec4 quatMult(vec4 q1, vec4 q2) {
  80:     // disgustingly vectorized quaternion multiplication
  81:     vec4 a = q1.w * q2.xyzw;
  82:     vec4 b = q1.x * q2.wzxy * vec4(1., -1., 1., -1.);
  83:     vec4 c = q1.y * q2.zwxy * vec4(1., 1., -1., -1.);
  84:     vec4 d = q1.z * q2.yxwz * vec4(-1., 1., 1., -1.);
  85: 
  86:     return a + b + c + d;
  87: }
  88: 
  89: vec3 rotateVertexByQuat(vec3 v, vec4 q) {
  90:     vec3 i = q.xyz;
  91:     return v + 2.0 * cross(i, cross(i, v) + q.w * v);
  92: }
  93: 
  94: vec3 rotateAbout(vec3 v, vec3 axis, float angle) {
  95:     return rotateVertexByQuat(v, quat(axis, angle));
  96: }
  97: 
  98: float diffuse(vec3 normal) {
  99:     vec3 n2 = normal * normal * vec3(.6, .25, .8);
 100:     return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
 101: }
 102: 
 103: 
 104: struct Flap {
 105:     vec3 instancePos;
 106:     vec2 light;
 107:     vec3 segmentOffset;
 108:     vec3 pivot;
 109:     float horizontalAngle;
 110:     float intensity;
 111:     float flapScale;
 112:     float flapness;
 113: };
 114: 
 115: 
 116: struct Vertex {
 117:     vec3 pos;
 118:     vec3 normal;
 119:     vec2 texCoords;
 120: };
 121: 
 122: struct BlockFrag {
 123:     vec2 texCoords;
 124:     vec4 color;
 125:     float diffuse;
 126:     vec2 light;
 127: };
 128: 
 129: 
 130: float toRad(float degrees) {
 131:     return fract(degrees / 360.) * PI * 2.;
 132: }
 133: 
 134: float getFlapAngle(float flapness, float intensity, float scale) {
 135:     float absFlap = abs(flapness);
 136: 
 137:     float angle = sin((1. - absFlap) * PI * intensity) * 30. * flapness * scale;
 138: 
 139:     float halfAngle = angle * 0.5;
 140: 
 141:     float which = step(0., flapness);// 0 if negative, 1 if positive
 142:     float degrees = which * halfAngle + (1. - which) * angle;// branchless conditional multiply
 143: 
 144:     return degrees;
 145: }
 146: 
 147: BlockFrag FLWMain(Vertex v, Flap flap) {
 148:     float flapAngle = getFlapAngle(flap.flapness, flap.intensity, flap.flapScale);
 149: 
 150:     vec4 orientation = quat(vec3(0., 1., 0.), -flap.horizontalAngle);
 151:     vec4 flapRotation = quat(vec3(1., 0., 0.), flapAngle);
 152: 
 153:     vec3 rotated = rotateVertexByQuat(v.pos - flap.pivot, flapRotation) + flap.pivot + flap.segmentOffset;
 154:     rotated = rotateVertexByQuat(rotated - .5, orientation) + flap.instancePos + .5;
 155: 
 156:     vec4 worldPos = vec4(rotated, 1.);
 157:     vec3 norm = rotateVertexByQuat(rotateVertexByQuat(v.normal, flapRotation), orientation);
 158: 
 159:     FLWFinalizeWorldPos(worldPos);
 160:     FLWFinalizeNormal(norm);
 161: 
 162:     BlockFrag b;
 163:     b.diffuse = diffuse(norm);
 164:     b.texCoords = v.texCoords;
 165:     b.light = flap.light;
 166:     #if defined(DEBUG_NORMAL)
 167:     b.color = vec4(norm, 1.);
 168:     #else
 169:     b.color = vec4(1.);
 170:     #endif
 171:     return b;
 172: }
 173: attribute vec3 a_v_pos;
 174: attribute vec3 a_v_normal;
 175: attribute vec2 a_v_texCoords;
 176: 
 177: attribute vec3 a_i_instancePos;
 178: attribute vec2 a_i_light;
 179: attribute vec3 a_i_segmentOffset;
 180: attribute vec3 a_i_pivot;
 181: attribute float a_i_horizontalAngle;
 182: attribute float a_i_intensity;
 183: attribute float a_i_flapScale;
 184: attribute float a_i_flapness;
 185: 
 186: 
 187: varying vec2 v2f_texCoords;
 188: varying vec4 v2f_color;
 189: varying float v2f_diffuse;
 190: varying vec2 v2f_light;
 191: 
 192: 
 193: void main() {
 194:     Vertex v;
 195:     v.pos = a_v_pos;
 196: v.normal = a_v_normal;
 197: v.texCoords = a_v_texCoords;
 198: 
 199: 
 200:     Flap i;
 201:     i.instancePos = a_i_instancePos;
 202: i.light = a_i_light;
 203: i.segmentOffset = a_i_segmentOffset;
 204: i.pivot = a_i_pivot;
 205: i.horizontalAngle = a_i_horizontalAngle;
 206: i.intensity = a_i_intensity;
 207: i.flapScale = a_i_flapScale;
 208: i.flapness = a_i_flapness;
 209: 
 210: 
 211:     BlockFrag o = FLWMain(v, i);
 212: 
 213:     v2f_texCoords = o.texCoords;
 214: v2f_color = o.color;
 215: v2f_diffuse = o.diffuse;
 216: v2f_light = o.light;
 217: 
 218: }

[13:33:08] [main/ERROR]: Shader compilation log for flywheel:block.frag: No errors.

[13:33:08] [main/ERROR]: Source for shader 'flywheel:block.frag':
   1: #version 110
   2: #define DEBUG_NORMAL
   3: 
   4: #if defined(USE_FOG)
   5: varying float FragDistance;
   6: uniform vec4 uFogColor;
   7: #endif
   8: 
   9: #if defined(USE_FOG_LINEAR)
  10: uniform vec2 uFogRange;
  11: 
  12: float FLWFogFactor() {
  13:     return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
  14: }
  15:     #endif
  16: 
  17:     #if defined(USE_FOG_EXP2)
  18: uniform float uFogDensity;
  19: 
  20: float FLWFogFactor() {
  21:     float dist = FragDistance * uFogDensity;
  22:     return 1. / exp2(dist * dist);
  23: }
  24:     #endif
  25: // Adjust the [0,1] normalized lightmap value based on the texture matrix from LightTexture#enableLightmap
  26: vec2 shiftLight(vec2 lm) {
  27:     return lm * 0.99609375 + 0.03125;// * 255/256 + 1/32
  28: }
  29: 
  30: varying vec3 BoxCoord;
  31: varying vec2 BoxLight;
  32: uniform sampler3D uLightVolume;
  33: 
  34: uniform sampler2D uBlockAtlas;
  35: uniform sampler2D uLightMap;
  36: 
  37: vec4 FLWBlockTexture(vec2 texCoords) {
  38:     return texture2D(uBlockAtlas, texCoords);
  39: }
  40: 
  41: void FLWFinalizeColor(vec4 color) {
  42:     #if defined(USE_FOG)
  43:     float a = color.a;
  44:     float fog = clamp(FLWFogFactor(), 0., 1.);
  45: 
  46:     color = mix(uFogColor, color, fog);
  47:     color.a = a;
  48:     #endif
  49: 
  50:     gl_FragColor = color;
  51: }
  52: 
  53: vec4 FLWLight(vec2 lightCoords) {
  54:     lightCoords = max(lightCoords, texture3D(uLightVolume, BoxCoord).rg);
  55: 
  56:     return texture2D(uLightMap, shiftLight(lightCoords));
  57: }
  58: 
  59: 
  60: 
  61: struct BlockFrag {
  62:     vec2 texCoords;
  63:     vec4 color;
  64:     float diffuse;
  65:     vec2 light;
  66: };
  67: 
  68: void FLWMain(BlockFrag r) {
  69:     vec4 tex = FLWBlockTexture(r.texCoords);
  70: 
  71:     vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;
  72: 
  73: //    flw_WorldPos = ;
  74: //    flw_Normal = ;
  75: //    flw_Albedo = tex.rgb;
  76: //    flw_Alpha = tex.a;
  77: //    flw_LightMap = r.light;
  78: //    flw_Tint = r.color;
  79:     FLWFinalizeColor(color);
  80: }
  81: 
  82: varying vec2 v2f_texCoords;
  83: varying vec4 v2f_color;
  84: varying float v2f_diffuse;
  85: varying vec2 v2f_light;
  86: 
  87: 
  88: //vec3 flw_WorldPos;
  89: //vec3 flw_Normal;
  90: //vec3 flw_Albedo;
  91: //float flw_Alpha;
  92: //vec2 flw_LightMap;
  93: //vec4 flw_Tint;
  94: 
  95: void main() {
  96:     BlockFrag f;
  97:     f.texCoords = v2f_texCoords;
  98: f.color = v2f_color;
  99: f.diffuse = v2f_diffuse;
 100: f.light = v2f_light;
 101: 
 102: 
 103:     FLWMain(f);
 104: }

[13:33:08] [main/ERROR]: Shader compilation log for create:flap.vert: No errors.

[13:33:08] [main/ERROR]: Source for shader 'create:flap.vert':
   1: #version 110
   2: #define USE_FOG
   3: #define USE_FOG_LINEAR
   4: 
   5: #define PI 3.1415926538
   6: 
   7: #if defined(USE_FOG)
   8: varying float FragDistance;
   9: #endif
  10: 
  11: varying vec3 BoxCoord;
  12: 
  13: uniform vec3 uLightBoxSize;
  14: uniform vec3 uLightBoxMin;
  15: uniform mat4 uModel;
  16: 
  17: uniform float uTime;
  18: uniform mat4 uViewProjection;
  19: uniform vec3 uCameraPos;
  20: 
  21: void FLWFinalizeWorldPos(inout vec4 worldPos) {
  22:     worldPos = uModel * worldPos;
  23: 
  24:     BoxCoord = (worldPos.xyz - uLightBoxMin) / uLightBoxSize;
  25: 
  26:     #if defined(USE_FOG)
  27:     FragDistance = length(worldPos.xyz);
  28:     #endif
  29: 
  30:     gl_Position = uViewProjection * worldPos;
  31: }
  32: 
  33: void FLWFinalizeNormal(inout vec3 normal) {
  34:     mat3 m;
  35:     m[0] = uModel[0].xyz;
  36:     m[1] = uModel[1].xyz;
  37:     m[2] = uModel[2].xyz;
  38:     normal = m * normal;
  39: }
  40: 
  41: 
  42: 
  43: mat4 rotate(vec3 axis, float angle) {
  44:     float s = sin(angle);
  45:     float c = cos(angle);
  46:     float oc = 1. - c;
  47: 
  48:     vec3 sa = axis * s;
  49: 
  50:     mat4 mr = mat4(1.);
  51:     mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
  52:     mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
  53:     mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);
  54: 
  55:     return mr;
  56: }
  57: 
  58: mat4 rotation(vec3 rot) {
  59:     return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
  60: }
  61: 
  62: mat3 modelToNormal(mat4 mat) {
  63:     // Discard the edges. This won't be accurate for scaled or skewed matrices,
  64:     // but we don't have to work with those often.
  65:     mat3 m;
  66:     m[0] = mat[0].xyz;
  67:     m[1] = mat[1].xyz;
  68:     m[2] = mat[2].xyz;
  69:     return m;
  70: }
  71: 
  72: #define PIOVER2 1.5707963268
  73: 
  74: vec4 quat(vec3 axis, float angle) {
  75:     float halfAngle = angle * PIOVER2 / 180.0;
  76:     vec2 cs = sin(vec2(PIOVER2 - halfAngle, halfAngle)); // compute sin and cos in one instruction
  77:     return vec4(axis.xyz * cs.y,  cs.x);
  78: }
  79: 
  80: vec4 quatMult(vec4 q1, vec4 q2) {
  81:     // disgustingly vectorized quaternion multiplication
  82:     vec4 a = q1.w * q2.xyzw;
  83:     vec4 b = q1.x * q2.wzxy * vec4(1., -1., 1., -1.);
  84:     vec4 c = q1.y * q2.zwxy * vec4(1., 1., -1., -1.);
  85:     vec4 d = q1.z * q2.yxwz * vec4(-1., 1., 1., -1.);
  86: 
  87:     return a + b + c + d;
  88: }
  89: 
  90: vec3 rotateVertexByQuat(vec3 v, vec4 q) {
  91:     vec3 i = q.xyz;
  92:     return v + 2.0 * cross(i, cross(i, v) + q.w * v);
  93: }
  94: 
  95: vec3 rotateAbout(vec3 v, vec3 axis, float angle) {
  96:     return rotateVertexByQuat(v, quat(axis, angle));
  97: }
  98: 
  99: float diffuse(vec3 normal) {
 100:     vec3 n2 = normal * normal * vec3(.6, .25, .8);
 101:     return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
 102: }
 103: 
 104: 
 105: struct Flap {
 106:     vec3 instancePos;
 107:     vec2 light;
 108:     vec3 segmentOffset;
 109:     vec3 pivot;
 110:     float horizontalAngle;
 111:     float intensity;
 112:     float flapScale;
 113:     float flapness;
 114: };
 115: 
 116: 
 117: struct Vertex {
 118:     vec3 pos;
 119:     vec3 normal;
 120:     vec2 texCoords;
 121: };
 122: 
 123: struct BlockFrag {
 124:     vec2 texCoords;
 125:     vec4 color;
 126:     float diffuse;
 127:     vec2 light;
 128: };
 129: 
 130: 
 131: float toRad(float degrees) {
 132:     return fract(degrees / 360.) * PI * 2.;
 133: }
 134: 
 135: float getFlapAngle(float flapness, float intensity, float scale) {
 136:     float absFlap = abs(flapness);
 137: 
 138:     float angle = sin((1. - absFlap) * PI * intensity) * 30. * flapness * scale;
 139: 
 140:     float halfAngle = angle * 0.5;
 141: 
 142:     float which = step(0., flapness);// 0 if negative, 1 if positive
 143:     float degrees = which * halfAngle + (1. - which) * angle;// branchless conditional multiply
 144: 
 145:     return degrees;
 146: }
 147: 
 148: BlockFrag FLWMain(Vertex v, Flap flap) {
 149:     float flapAngle = getFlapAngle(flap.flapness, flap.intensity, flap.flapScale);
 150: 
 151:     vec4 orientation = quat(vec3(0., 1., 0.), -flap.horizontalAngle);
 152:     vec4 flapRotation = quat(vec3(1., 0., 0.), flapAngle);
 153: 
 154:     vec3 rotated = rotateVertexByQuat(v.pos - flap.pivot, flapRotation) + flap.pivot + flap.segmentOffset;
 155:     rotated = rotateVertexByQuat(rotated - .5, orientation) + flap.instancePos + .5;
 156: 
 157:     vec4 worldPos = vec4(rotated, 1.);
 158:     vec3 norm = rotateVertexByQuat(rotateVertexByQuat(v.normal, flapRotation), orientation);
 159: 
 160:     FLWFinalizeWorldPos(worldPos);
 161:     FLWFinalizeNormal(norm);
 162: 
 163:     BlockFrag b;
 164:     b.diffuse = diffuse(norm);
 165:     b.texCoords = v.texCoords;
 166:     b.light = flap.light;
 167:     #if defined(DEBUG_NORMAL)
 168:     b.color = vec4(norm, 1.);
 169:     #else
 170:     b.color = vec4(1.);
 171:     #endif
 172:     return b;
 173: }
 174: attribute vec3 a_v_pos;
 175: attribute vec3 a_v_normal;
 176: attribute vec2 a_v_texCoords;
 177: 
 178: attribute vec3 a_i_instancePos;
 179: attribute vec2 a_i_light;
 180: attribute vec3 a_i_segmentOffset;
 181: attribute vec3 a_i_pivot;
 182: attribute float a_i_horizontalAngle;
 183: attribute float a_i_intensity;
 184: attribute float a_i_flapScale;
 185: attribute float a_i_flapness;
 186: 
 187: 
 188: varying vec2 v2f_texCoords;
 189: varying vec4 v2f_color;
 190: varying float v2f_diffuse;
 191: varying vec2 v2f_light;
 192: 
 193: 
 194: void main() {
 195:     Vertex v;
 196:     v.pos = a_v_pos;
 197: v.normal = a_v_normal;
 198: v.texCoords = a_v_texCoords;
 199: 
 200: 
 201:     Flap i;
 202:     i.instancePos = a_i_instancePos;
 203: i.light = a_i_light;
 204: i.segmentOffset = a_i_segmentOffset;
 205: i.pivot = a_i_pivot;
 206: i.horizontalAngle = a_i_horizontalAngle;
 207: i.intensity = a_i_intensity;
 208: i.flapScale = a_i_flapScale;
 209: i.flapness = a_i_flapness;
 210: 
 211: 
 212:     BlockFrag o = FLWMain(v, i);
 213: 
 214:     v2f_texCoords = o.texCoords;
 215: v2f_color = o.color;
 216: v2f_diffuse = o.diffuse;
 217: v2f_light = o.light;
 218: 
 219: }

[13:33:08] [main/ERROR]: Shader compilation log for flywheel:block.frag: No errors.

[13:33:08] [main/ERROR]: Source for shader 'flywheel:block.frag':
   1: #version 110
   2: #define USE_FOG
   3: #define USE_FOG_LINEAR
   4: 
   5: #if defined(USE_FOG)
   6: varying float FragDistance;
   7: uniform vec4 uFogColor;
   8: #endif
   9: 
  10: #if defined(USE_FOG_LINEAR)
  11: uniform vec2 uFogRange;
  12: 
  13: float FLWFogFactor() {
  14:     return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
  15: }
  16:     #endif
  17: 
  18:     #if defined(USE_FOG_EXP2)
  19: uniform float uFogDensity;
  20: 
  21: float FLWFogFactor() {
  22:     float dist = FragDistance * uFogDensity;
  23:     return 1. / exp2(dist * dist);
  24: }
  25:     #endif
  26: // Adjust the [0,1] normalized lightmap value based on the texture matrix from LightTexture#enableLightmap
  27: vec2 shiftLight(vec2 lm) {
  28:     return lm * 0.99609375 + 0.03125;// * 255/256 + 1/32
  29: }
  30: 
  31: varying vec3 BoxCoord;
  32: varying vec2 BoxLight;
  33: uniform sampler3D uLightVolume;
  34: 
  35: uniform sampler2D uBlockAtlas;
  36: uniform sampler2D uLightMap;
  37: 
  38: vec4 FLWBlockTexture(vec2 texCoords) {
  39:     return texture2D(uBlockAtlas, texCoords);
  40: }
  41: 
  42: void FLWFinalizeColor(vec4 color) {
  43:     #if defined(USE_FOG)
  44:     float a = color.a;
  45:     float fog = clamp(FLWFogFactor(), 0., 1.);
  46: 
  47:     color = mix(uFogColor, color, fog);
  48:     color.a = a;
  49:     #endif
  50: 
  51:     gl_FragColor = color;
  52: }
  53: 
  54: vec4 FLWLight(vec2 lightCoords) {
  55:     lightCoords = max(lightCoords, texture3D(uLightVolume, BoxCoord).rg);
  56: 
  57:     return texture2D(uLightMap, shiftLight(lightCoords));
  58: }
  59: 
  60: 
  61: 
  62: struct BlockFrag {
  63:     vec2 texCoords;
  64:     vec4 color;
  65:     float diffuse;
  66:     vec2 light;
  67: };
  68: 
  69: void FLWMain(BlockFrag r) {
  70:     vec4 tex = FLWBlockTexture(r.texCoords);
  71: 
  72:     vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;
  73: 
  74: //    flw_WorldPos = ;
  75: //    flw_Normal = ;
  76: //    flw_Albedo = tex.rgb;
  77: //    flw_Alpha = tex.a;
  78: //    flw_LightMap = r.light;
  79: //    flw_Tint = r.color;
  80:     FLWFinalizeColor(color);
  81: }
  82: 
  83: varying vec2 v2f_texCoords;
  84: varying vec4 v2f_color;
  85: varying float v2f_diffuse;
  86: varying vec2 v2f_light;
  87: 
  88: 
  89: //vec3 flw_WorldPos;
  90: //vec3 flw_Normal;
  91: //vec3 flw_Albedo;
  92: //float flw_Alpha;
  93: //vec2 flw_LightMap;
  94: //vec4 flw_Tint;
  95: 
  96: void main() {
  97:     BlockFrag f;
  98:     f.texCoords = v2f_texCoords;
  99: f.color = v2f_color;
 100: f.diffuse = v2f_diffuse;
 101: f.light = v2f_light;
 102: 
 103: 
 104:     FLWMain(f);
 105: }

[13:33:08] [main/ERROR]: Shader compilation log for create:flap.vert: No errors.

[13:33:08] [main/ERROR]: Source for shader 'create:flap.vert':
   1: #version 110
   2: #define USE_FOG
   3: #define USE_FOG_EXP2
   4: 
   5: #define PI 3.1415926538
   6: 
   7: #if defined(USE_FOG)
   8: varying float FragDistance;
   9: #endif
  10: 
  11: varying vec3 BoxCoord;
  12: 
  13: uniform vec3 uLightBoxSize;
  14: uniform vec3 uLightBoxMin;
  15: uniform mat4 uModel;
  16: 
  17: uniform float uTime;
  18: uniform mat4 uViewProjection;
  19: uniform vec3 uCameraPos;
  20: 
  21: void FLWFinalizeWorldPos(inout vec4 worldPos) {
  22:     worldPos = uModel * worldPos;
  23: 
  24:     BoxCoord = (worldPos.xyz - uLightBoxMin) / uLightBoxSize;
  25: 
  26:     #if defined(USE_FOG)
  27:     FragDistance = length(worldPos.xyz);
  28:     #endif
  29: 
  30:     gl_Position = uViewProjection * worldPos;
  31: }
  32: 
  33: void FLWFinalizeNormal(inout vec3 normal) {
  34:     mat3 m;
  35:     m[0] = uModel[0].xyz;
  36:     m[1] = uModel[1].xyz;
  37:     m[2] = uModel[2].xyz;
  38:     normal = m * normal;
  39: }
  40: 
  41: 
  42: 
  43: mat4 rotate(vec3 axis, float angle) {
  44:     float s = sin(angle);
  45:     float c = cos(angle);
  46:     float oc = 1. - c;
  47: 
  48:     vec3 sa = axis * s;
  49: 
  50:     mat4 mr = mat4(1.);
  51:     mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
  52:     mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
  53:     mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);
  54: 
  55:     return mr;
  56: }
  57: 
  58: mat4 rotation(vec3 rot) {
  59:     return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
  60: }
  61: 
  62: mat3 modelToNormal(mat4 mat) {
  63:     // Discard the edges. This won't be accurate for scaled or skewed matrices,
  64:     // but we don't have to work with those often.
  65:     mat3 m;
  66:     m[0] = mat[0].xyz;
  67:     m[1] = mat[1].xyz;
  68:     m[2] = mat[2].xyz;
  69:     return m;
  70: }
  71: 
  72: #define PIOVER2 1.5707963268
  73: 
  74: vec4 quat(vec3 axis, float angle) {
  75:     float halfAngle = angle * PIOVER2 / 180.0;
  76:     vec2 cs = sin(vec2(PIOVER2 - halfAngle, halfAngle)); // compute sin and cos in one instruction
  77:     return vec4(axis.xyz * cs.y,  cs.x);
  78: }
  79: 
  80: vec4 quatMult(vec4 q1, vec4 q2) {
  81:     // disgustingly vectorized quaternion multiplication
  82:     vec4 a = q1.w * q2.xyzw;
  83:     vec4 b = q1.x * q2.wzxy * vec4(1., -1., 1., -1.);
  84:     vec4 c = q1.y * q2.zwxy * vec4(1., 1., -1., -1.);
  85:     vec4 d = q1.z * q2.yxwz * vec4(-1., 1., 1., -1.);
  86: 
  87:     return a + b + c + d;
  88: }
  89: 
  90: vec3 rotateVertexByQuat(vec3 v, vec4 q) {
  91:     vec3 i = q.xyz;
  92:     return v + 2.0 * cross(i, cross(i, v) + q.w * v);
  93: }
  94: 
  95: vec3 rotateAbout(vec3 v, vec3 axis, float angle) {
  96:     return rotateVertexByQuat(v, quat(axis, angle));
  97: }
  98: 
  99: float diffuse(vec3 normal) {
 100:     vec3 n2 = normal * normal * vec3(.6, .25, .8);
 101:     return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
 102: }
 103: 
 104: 
 105: struct Flap {
 106:     vec3 instancePos;
 107:     vec2 light;
 108:     vec3 segmentOffset;
 109:     vec3 pivot;
 110:     float horizontalAngle;
 111:     float intensity;
 112:     float flapScale;
 113:     float flapness;
 114: };
 115: 
 116: 
 117: struct Vertex {
 118:     vec3 pos;
 119:     vec3 normal;
 120:     vec2 texCoords;
 121: };
 122: 
 123: struct BlockFrag {
 124:     vec2 texCoords;
 125:     vec4 color;
 126:     float diffuse;
 127:     vec2 light;
 128: };
 129: 
 130: 
 131: float toRad(float degrees) {
 132:     return fract(degrees / 360.) * PI * 2.;
 133: }
 134: 
 135: float getFlapAngle(float flapness, float intensity, float scale) {
 136:     float absFlap = abs(flapness);
 137: 
 138:     float angle = sin((1. - absFlap) * PI * intensity) * 30. * flapness * scale;
 139: 
 140:     float halfAngle = angle * 0.5;
 141: 
 142:     float which = step(0., flapness);// 0 if negative, 1 if positive
 143:     float degrees = which * halfAngle + (1. - which) * angle;// branchless conditional multiply
 144: 
 145:     return degrees;
 146: }
 147: 
 148: BlockFrag FLWMain(Vertex v, Flap flap) {
 149:     float flapAngle = getFlapAngle(flap.flapness, flap.intensity, flap.flapScale);
 150: 
 151:     vec4 orientation = quat(vec3(0., 1., 0.), -flap.horizontalAngle);
 152:     vec4 flapRotation = quat(vec3(1., 0., 0.), flapAngle);
 153: 
 154:     vec3 rotated = rotateVertexByQuat(v.pos - flap.pivot, flapRotation) + flap.pivot + flap.segmentOffset;
 155:     rotated = rotateVertexByQuat(rotated - .5, orientation) + flap.instancePos + .5;
 156: 
 157:     vec4 worldPos = vec4(rotated, 1.);
 158:     vec3 norm = rotateVertexByQuat(rotateVertexByQuat(v.normal, flapRotation), orientation);
 159: 
 160:     FLWFinalizeWorldPos(worldPos);
 161:     FLWFinalizeNormal(norm);
 162: 
 163:     BlockFrag b;
 164:     b.diffuse = diffuse(norm);
 165:     b.texCoords = v.texCoords;
 166:     b.light = flap.light;
 167:     #if defined(DEBUG_NORMAL)
 168:     b.color = vec4(norm, 1.);
 169:     #else
 170:     b.color = vec4(1.);
 171:     #endif
 172:     return b;
 173: }
 174: attribute vec3 a_v_pos;
 175: attribute vec3 a_v_normal;
 176: attribute vec2 a_v_texCoords;
 177: 
 178: attribute vec3 a_i_instancePos;
 179: attribute vec2 a_i_light;
 180: attribute vec3 a_i_segmentOffset;
 181: attribute vec3 a_i_pivot;
 182: attribute float a_i_horizontalAngle;
 183: attribute float a_i_intensity;
 184: attribute float a_i_flapScale;
 185: attribute float a_i_flapness;
 186: 
 187: 
 188: varying vec2 v2f_texCoords;
 189: varying vec4 v2f_color;
 190: varying float v2f_diffuse;
 191: varying vec2 v2f_light;
 192: 
 193: 
 194: void main() {
 195:     Vertex v;
 196:     v.pos = a_v_pos;
 197: v.normal = a_v_normal;
 198: v.texCoords = a_v_texCoords;
 199: 
 200: 
 201:     Flap i;
 202:     i.instancePos = a_i_instancePos;
 203: i.light = a_i_light;
 204: i.segmentOffset = a_i_segmentOffset;
 205: i.pivot = a_i_pivot;
 206: i.horizontalAngle = a_i_horizontalAngle;
 207: i.intensity = a_i_intensity;
 208: i.flapScale = a_i_flapScale;
 209: i.flapness = a_i_flapness;
 210: 
 211: 
 212:     BlockFrag o = FLWMain(v, i);
 213: 
 214:     v2f_texCoords = o.texCoords;
 215: v2f_color = o.color;
 216: v2f_diffuse = o.diffuse;
 217: v2f_light = o.light;
 218: 
 219: }

[13:33:08] [main/ERROR]: Shader compilation log for flywheel:block.frag: No errors.

[13:33:08] [main/ERROR]: Source for shader 'flywheel:block.frag':
   1: #version 110
   2: #define USE_FOG
   3: #define USE_FOG_EXP2
   4: 
   5: #if defined(USE_FOG)
   6: varying float FragDistance;
   7: uniform vec4 uFogColor;
   8: #endif
   9: 
  10: #if defined(USE_FOG_LINEAR)
  11: uniform vec2 uFogRange;
  12: 
  13: float FLWFogFactor() {
  14:     return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
  15: }
  16:     #endif
  17: 
  18:     #if defined(USE_FOG_EXP2)
  19: uniform float uFogDensity;
  20: 
  21: float FLWFogFactor() {
  22:     float dist = FragDistance * uFogDensity;
  23:     return 1. / exp2(dist * dist);
  24: }
  25:     #endif
  26: // Adjust the [0,1] normalized lightmap value based on the texture matrix from LightTexture#enableLightmap
  27: vec2 shiftLight(vec2 lm) {
  28:     return lm * 0.99609375 + 0.03125;// * 255/256 + 1/32
  29: }
  30: 
  31: varying vec3 BoxCoord;
  32: varying vec2 BoxLight;
  33: uniform sampler3D uLightVolume;
  34: 
  35: uniform sampler2D uBlockAtlas;
  36: uniform sampler2D uLightMap;
  37: 
  38: vec4 FLWBlockTexture(vec2 texCoords) {
  39:     return texture2D(uBlockAtlas, texCoords);
  40: }
  41: 
  42: void FLWFinalizeColor(vec4 color) {
  43:     #if defined(USE_FOG)
  44:     float a = color.a;
  45:     float fog = clamp(FLWFogFactor(), 0., 1.);
  46: 
  47:     color = mix(uFogColor, color, fog);
  48:     color.a = a;
  49:     #endif
  50: 
  51:     gl_FragColor = color;
  52: }
  53: 
  54: vec4 FLWLight(vec2 lightCoords) {
  55:     lightCoords = max(lightCoords, texture3D(uLightVolume, BoxCoord).rg);
  56: 
  57:     return texture2D(uLightMap, shiftLight(lightCoords));
  58: }
  59: 
  60: 
  61: 
  62: struct BlockFrag {
  63:     vec2 texCoords;
  64:     vec4 color;
  65:     float diffuse;
  66:     vec2 light;
  67: };
  68: 
  69: void FLWMain(BlockFrag r) {
  70:     vec4 tex = FLWBlockTexture(r.texCoords);
  71: 
  72:     vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;
  73: 
  74: //    flw_WorldPos = ;
  75: //    flw_Normal = ;
  76: //    flw_Albedo = tex.rgb;
  77: //    flw_Alpha = tex.a;
  78: //    flw_LightMap = r.light;
  79: //    flw_Tint = r.color;
  80:     FLWFinalizeColor(color);
  81: }
  82: 
  83: varying vec2 v2f_texCoords;
  84: varying vec4 v2f_color;
  85: varying float v2f_diffuse;
  86: varying vec2 v2f_light;
  87: 
  88: 
  89: //vec3 flw_WorldPos;
  90: //vec3 flw_Normal;
  91: //vec3 flw_Albedo;
  92: //float flw_Alpha;
  93: //vec2 flw_LightMap;
  94: //vec4 flw_Tint;
  95: 
  96: void main() {
  97:     BlockFrag f;
  98:     f.texCoords = v2f_texCoords;
  99: f.color = v2f_color;
 100: f.diffuse = v2f_diffuse;
 101: f.light = v2f_light;
 102: 
 103: 
 104:     FLWMain(f);
 105: }

[13:33:08] [main/ERROR]: Shader compilation log for create:flap.vert: No errors.

[13:33:08] [main/ERROR]: Source for shader 'create:flap.vert':
   1: #version 110
   2: 
   3: #define PI 3.1415926538
   4: 
   5: #if defined(USE_FOG)
   6: varying float FragDistance;
   7: #endif
   8: 
   9: varying vec3 BoxCoord;
  10: 
  11: uniform vec3 uLightBoxSize;
  12: uniform vec3 uLightBoxMin;
  13: uniform mat4 uModel;
  14: 
  15: uniform float uTime;
  16: uniform mat4 uViewProjection;
  17: uniform vec3 uCameraPos;
  18: 
  19: void FLWFinalizeWorldPos(inout vec4 worldPos) {
  20:     worldPos = uModel * worldPos;
  21: 
  22:     BoxCoord = (worldPos.xyz - uLightBoxMin) / uLightBoxSize;
  23: 
  24:     #if defined(USE_FOG)
  25:     FragDistance = length(worldPos.xyz);
  26:     #endif
  27: 
  28:     gl_Position = uViewProjection * worldPos;
  29: }
  30: 
  31: void FLWFinalizeNormal(inout vec3 normal) {
  32:     mat3 m;
  33:     m[0] = uModel[0].xyz;
  34:     m[1] = uModel[1].xyz;
  35:     m[2] = uModel[2].xyz;
  36:     normal = m * normal;
  37: }
  38: 
  39: 
  40: 
  41: mat4 rotate(vec3 axis, float angle) {
  42:     float s = sin(angle);
  43:     float c = cos(angle);
  44:     float oc = 1. - c;
  45: 
  46:     vec3 sa = axis * s;
  47: 
  48:     mat4 mr = mat4(1.);
  49:     mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
  50:     mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
  51:     mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);
  52: 
  53:     return mr;
  54: }
  55: 
  56: mat4 rotation(vec3 rot) {
  57:     return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
  58: }
  59: 
  60: mat3 modelToNormal(mat4 mat) {
  61:     // Discard the edges. This won't be accurate for scaled or skewed matrices,
  62:     // but we don't have to work with those often.
  63:     mat3 m;
  64:     m[0] = mat[0].xyz;
  65:     m[1] = mat[1].xyz;
  66:     m[2] = mat[2].xyz;
  67:     return m;
  68: }
  69: 
  70: #define PIOVER2 1.5707963268
  71: 
  72: vec4 quat(vec3 axis, float angle) {
  73:     float halfAngle = angle * PIOVER2 / 180.0;
  74:     vec2 cs = sin(vec2(PIOVER2 - halfAngle, halfAngle)); // compute sin and cos in one instruction
  75:     return vec4(axis.xyz * cs.y,  cs.x);
  76: }
  77: 
  78: vec4 quatMult(vec4 q1, vec4 q2) {
  79:     // disgustingly vectorized quaternion multiplication
  80:     vec4 a = q1.w * q2.xyzw;
  81:     vec4 b = q1.x * q2.wzxy * vec4(1., -1., 1., -1.);
  82:     vec4 c = q1.y * q2.zwxy * vec4(1., 1., -1., -1.);
  83:     vec4 d = q1.z * q2.yxwz * vec4(-1., 1., 1., -1.);
  84: 
  85:     return a + b + c + d;
  86: }
  87: 
  88: vec3 rotateVertexByQuat(vec3 v, vec4 q) {
  89:     vec3 i = q.xyz;
  90:     return v + 2.0 * cross(i, cross(i, v) + q.w * v);
  91: }
  92: 
  93: vec3 rotateAbout(vec3 v, vec3 axis, float angle) {
  94:     return rotateVertexByQuat(v, quat(axis, angle));
  95: }
  96: 
  97: float diffuse(vec3 normal) {
  98:     vec3 n2 = normal * normal * vec3(.6, .25, .8);
  99:     return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
 100: }
 101: 
 102: 
 103: struct Flap {
 104:     vec3 instancePos;
 105:     vec2 light;
 106:     vec3 segmentOffset;
 107:     vec3 pivot;
 108:     float horizontalAngle;
 109:     float intensity;
 110:     float flapScale;
 111:     float flapness;
 112: };
 113: 
 114: 
 115: struct Vertex {
 116:     vec3 pos;
 117:     vec3 normal;
 118:     vec2 texCoords;
 119: };
 120: 
 121: struct BlockFrag {
 122:     vec2 texCoords;
 123:     vec4 color;
 124:     float diffuse;
 125:     vec2 light;
 126: };
 127: 
 128: 
 129: float toRad(float degrees) {
 130:     return fract(degrees / 360.) * PI * 2.;
 131: }
 132: 
 133: float getFlapAngle(float flapness, float intensity, float scale) {
 134:     float absFlap = abs(flapness);
 135: 
 136:     float angle = sin((1. - absFlap) * PI * intensity) * 30. * flapness * scale;
 137: 
 138:     float halfAngle = angle * 0.5;
 139: 
 140:     float which = step(0., flapness);// 0 if negative, 1 if positive
 141:     float degrees = which * halfAngle + (1. - which) * angle;// branchless conditional multiply
 142: 
 143:     return degrees;
 144: }
 145: 
 146: BlockFrag FLWMain(Vertex v, Flap flap) {
 147:     float flapAngle = getFlapAngle(flap.flapness, flap.intensity, flap.flapScale);
 148: 
 149:     vec4 orientation = quat(vec3(0., 1., 0.), -flap.horizontalAngle);
 150:     vec4 flapRotation = quat(vec3(1., 0., 0.), flapAngle);
 151: 
 152:     vec3 rotated = rotateVertexByQuat(v.pos - flap.pivot, flapRotation) + flap.pivot + flap.segmentOffset;
 153:     rotated = rotateVertexByQuat(rotated - .5, orientation) + flap.instancePos + .5;
 154: 
 155:     vec4 worldPos = vec4(rotated, 1.);
 156:     vec3 norm = rotateVertexByQuat(rotateVertexByQuat(v.normal, flapRotation), orientation);
 157: 
 158:     FLWFinalizeWorldPos(worldPos);
 159:     FLWFinalizeNormal(norm);
 160: 
 161:     BlockFrag b;
 162:     b.diffuse = diffuse(norm);
 163:     b.texCoords = v.texCoords;
 164:     b.light = flap.light;
 165:     #if defined(DEBUG_NORMAL)
 166:     b.color = vec4(norm, 1.);
 167:     #else
 168:     b.color = vec4(1.);
 169:     #endif
 170:     return b;
 171: }
 172: attribute vec3 a_v_pos;
 173: attribute vec3 a_v_normal;
 174: attribute vec2 a_v_texCoords;
 175: 
 176: attribute vec3 a_i_instancePos;
 177: attribute vec2 a_i_light;
 178: attribute vec3 a_i_segmentOffset;
 179: attribute vec3 a_i_pivot;
 180: attribute float a_i_horizontalAngle;
 181: attribute float a_i_intensity;
 182: attribute float a_i_flapScale;
 183: attribute float a_i_flapness;
 184: 
 185: 
 186: varying vec2 v2f_texCoords;
 187: varying vec4 v2f_color;
 188: varying float v2f_diffuse;
 189: varying vec2 v2f_light;
 190: 
 191: 
 192: void main() {
 193:     Vertex v;
 194:     v.pos = a_v_pos;
 195: v.normal = a_v_normal;
 196: v.texCoords = a_v_texCoords;
 197: 
 198: 
 199:     Flap i;
 200:     i.instancePos = a_i_instancePos;
 201: i.light = a_i_light;
 202: i.segmentOffset = a_i_segmentOffset;
 203: i.pivot = a_i_pivot;
 204: i.horizontalAngle = a_i_horizontalAngle;
 205: i.intensity = a_i_intensity;
 206: i.flapScale = a_i_flapScale;
 207: i.flapness = a_i_flapness;
 208: 
 209: 
 210:     BlockFrag o = FLWMain(v, i);
 211: 
 212:     v2f_texCoords = o.texCoords;
 213: v2f_color = o.color;
 214: v2f_diffuse = o.diffuse;
 215: v2f_light = o.light;
 216: 
 217: }

[13:33:08] [main/ERROR]: Shader compilation log for flywheel:block.frag: No errors.

[13:33:08] [main/ERROR]: Source for shader 'flywheel:block.frag':
   1: #version 110
   2: 
   3: #if defined(USE_FOG)
   4: varying float FragDistance;
   5: uniform vec4 uFogColor;
   6: #endif
   7: 
   8: #if defined(USE_FOG_LINEAR)
   9: uniform vec2 uFogRange;
  10: 
  11: float FLWFogFactor() {
  12:     return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
  13: }
  14:     #endif
  15: 
  16:     #if defined(USE_FOG_EXP2)
  17: uniform float uFogDensity;
  18: 
  19: float FLWFogFactor() {
  20:     float dist = FragDistance * uFogDensity;
  21:     return 1. / exp2(dist * dist);
  22: }
  23:     #endif
  24: // Adjust the [0,1] normalized lightmap value based on the texture matrix from LightTexture#enableLightmap
  25: vec2 shiftLight(vec2 lm) {
  26:     return lm * 0.99609375 + 0.03125;// * 255/256 + 1/32
  27: }
  28: 
  29: varying vec3 BoxCoord;
  30: varying vec2 BoxLight;
  31: uniform sampler3D uLightVolume;
  32: 
  33: uniform sampler2D uBlockAtlas;
  34: uniform sampler2D uLightMap;
  35: 
  36: vec4 FLWBlockTexture(vec2 texCoords) {
  37:     return texture2D(uBlockAtlas, texCoords);
  38: }
  39: 
  40: void FLWFinalizeColor(vec4 color) {
  41:     #if defined(USE_FOG)
  42:     float a = color.a;
  43:     float fog = clamp(FLWFogFactor(), 0., 1.);
  44: 
  45:     color = mix(uFogColor, color, fog);
  46:     color.a = a;
  47:     #endif
  48: 
  49:     gl_FragColor = color;
  50: }
  51: 
  52: vec4 FLWLight(vec2 lightCoords) {
  53:     lightCoords = max(lightCoords, texture3D(uLightVolume, BoxCoord).rg);
  54: 
  55:     return texture2D(uLightMap, shiftLight(lightCoords));
  56: }
  57: 
  58: 
  59: 
  60: struct BlockFrag {
  61:     vec2 texCoords;
  62:     vec4 color;
  63:     float diffuse;
  64:     vec2 light;
  65: };
  66: 
  67: void FLWMain(BlockFrag r) {
  68:     vec4 tex = FLWBlockTexture(r.texCoords);
  69: 
  70:     vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;
  71: 
  72: //    flw_WorldPos = ;
  73: //    flw_Normal = ;
  74: //    flw_Albedo = tex.rgb;
  75: //    flw_Alpha = tex.a;
  76: //    flw_LightMap = r.light;
  77: //    flw_Tint = r.color;
  78:     FLWFinalizeColor(color);
  79: }
  80: 
  81: varying vec2 v2f_texCoords;
  82: varying vec4 v2f_color;
  83: varying float v2f_diffuse;
  84: varying vec2 v2f_light;
  85: 
  86: 
  87: //vec3 flw_WorldPos;
  88: //vec3 flw_Normal;
  89: //vec3 flw_Albedo;
  90: //float flw_Alpha;
  91: //vec2 flw_LightMap;
  92: //vec4 flw_Tint;
  93: 
  94: void main() {
  95:     BlockFrag f;
  96:     f.texCoords = v2f_texCoords;
  97: f.color = v2f_color;
  98: f.diffuse = v2f_diffuse;
  99: f.light = v2f_light;
 100: 
 101: 
 102:     FLWMain(f);
 103: }

[13:33:08] [main/ERROR]: Shader compilation log for create:belt.vert: No errors.

[13:33:08] [main/ERROR]: Source for shader 'create:belt.vert':
   1: #version 110
   2: #define DEBUG_RAINBOW
   3: 
   4: #define PI 3.1415926538
   5: 
   6: #if defined(USE_FOG)
   7: varying float FragDistance;
   8: #endif
   9: 
  10: varying vec3 BoxCoord;
  11: 
  12: uniform vec3 uLightBoxSize;
  13: uniform vec3 uLightBoxMin;
  14: uniform mat4 uModel;
  15: 
  16: uniform float uTime;
  17: uniform mat4 uViewProjection;
  18: uniform vec3 uCameraPos;
  19: 
  20: void FLWFinalizeWorldPos(inout vec4 worldPos) {
  21:     worldPos = uModel * worldPos;
  22: 
  23:     BoxCoord = (worldPos.xyz - uLightBoxMin) / uLightBoxSize;
  24: 
  25:     #if defined(USE_FOG)
  26:     FragDistance = length(worldPos.xyz);
  27:     #endif
  28: 
  29:     gl_Position = uViewProjection * worldPos;
  30: }
  31: 
  32: void FLWFinalizeNormal(inout vec3 normal) {
  33:     mat3 m;
  34:     m[0] = uModel[0].xyz;
  35:     m[1] = uModel[1].xyz;
  36:     m[2] = uModel[2].xyz;
  37:     normal = m * normal;
  38: }
  39: 
  40: 
  41: 
  42: #define PIOVER2 1.5707963268
  43: 
  44: vec4 quat(vec3 axis, float angle) {
  45:     float halfAngle = angle * PIOVER2 / 180.0;
  46:     vec2 cs = sin(vec2(PIOVER2 - halfAngle, halfAngle)); // compute sin and cos in one instruction
  47:     return vec4(axis.xyz * cs.y,  cs.x);
  48: }
  49: 
  50: vec4 quatMult(vec4 q1, vec4 q2) {
  51:     // disgustingly vectorized quaternion multiplication
  52:     vec4 a = q1.w * q2.xyzw;
  53:     vec4 b = q1.x * q2.wzxy * vec4(1., -1., 1., -1.);
  54:     vec4 c = q1.y * q2.zwxy * vec4(1., 1., -1., -1.);
  55:     vec4 d = q1.z * q2.yxwz * vec4(-1., 1., 1., -1.);
  56: 
  57:     return a + b + c + d;
  58: }
  59: 
  60: vec3 rotateVertexByQuat(vec3 v, vec4 q) {
  61:     vec3 i = q.xyz;
  62:     return v + 2.0 * cross(i, cross(i, v) + q.w * v);
  63: }
  64: 
  65: vec3 rotateAbout(vec3 v, vec3 axis, float angle) {
  66:     return rotateVertexByQuat(v, quat(axis, angle));
  67: }
  68: 
  69: mat4 rotate(vec3 axis, float angle) {
  70:     float s = sin(angle);
  71:     float c = cos(angle);
  72:     float oc = 1. - c;
  73: 
  74:     vec3 sa = axis * s;
  75: 
  76:     mat4 mr = mat4(1.);
  77:     mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
  78:     mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
  79:     mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);
  80: 
  81:     return mr;
  82: }
  83: 
  84: mat4 rotation(vec3 rot) {
  85:     return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
  86: }
  87: 
  88: mat3 modelToNormal(mat4 mat) {
  89:     // Discard the edges. This won't be accurate for scaled or skewed matrices,
  90:     // but we don't have to work with those often.
  91:     mat3 m;
  92:     m[0] = mat[0].xyz;
  93:     m[1] = mat[1].xyz;
  94:     m[2] = mat[2].xyz;
  95:     return m;
  96: }
  97: 
  98: float diffuse(vec3 normal) {
  99:     vec3 n2 = normal * normal * vec3(.6, .25, .8);
 100:     return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
 101: }
 102: 
 103: 
 104: struct Belt {
 105:     vec2 light;
 106:     vec4 color;
 107:     vec3 pos;
 108:     float speed;
 109:     float offset;
 110:     vec4 rotation;
 111:     vec2 sourceTexture;
 112:     vec4 scrollTexture;
 113:     float scrollMult;
 114: };
 115: 
 116: 
 117: struct Vertex {
 118:     vec3 pos;
 119:     vec3 normal;
 120:     vec2 texCoords;
 121: };
 122: 
 123: struct BlockFrag {
 124:     vec2 texCoords;
 125:     vec4 color;
 126:     float diffuse;
 127:     vec2 light;
 128: };
 129: 
 130: BlockFrag FLWMain(Vertex v, Belt instance) {
 131:     vec3 rotated = rotateVertexByQuat(v.pos - .5, instance.rotation) + instance.pos + .5;
 132: 
 133:     vec4 worldPos = vec4(rotated, 1.);
 134: 
 135:     vec3 norm = rotateVertexByQuat(v.normal, instance.rotation);
 136: 
 137:     FLWFinalizeWorldPos(worldPos);
 138:     FLWFinalizeNormal(norm);
 139: 
 140:     float scrollSize = instance.scrollTexture.w - instance.scrollTexture.y;
 141:     float scroll = fract(instance.speed * uTime / (31.5 * 16.) + instance.offset) * scrollSize * instance.scrollMult;
 142: 
 143:     BlockFrag b;
 144:     b.diffuse = diffuse(norm);
 145:     b.texCoords = v.texCoords - instance.sourceTexture + instance.scrollTexture.xy + vec2(0, scroll);
 146:     b.light = instance.light;
 147: 
 148:     #if defined(DEBUG_RAINBOW)
 149:     b.color = instance.color;
 150:     #elif defined(DEBUG_NORMAL)
 151:     b.color = vec4(norm, 1.);
 152:     #else
 153:     b.color = vec4(1.);
 154:     #endif
 155: 
 156:     return b;
 157: }
 158: attribute vec3 a_v_pos;
 159: attribute vec3 a_v_normal;
 160: attribute vec2 a_v_texCoords;
 161: 
 162: attribute vec2 a_i_light;
 163: attribute vec4 a_i_color;
 164: attribute vec3 a_i_pos;
 165: attribute float a_i_speed;
 166: attribute float a_i_offset;
 167: attribute vec4 a_i_rotation;
 168: attribute vec2 a_i_sourceTexture;
 169: attribute vec4 a_i_scrollTexture;
 170: attribute float a_i_scrollMult;
 171: 
 172: 
 173: varying vec2 v2f_texCoords;
 174: varying vec4 v2f_color;
 175: varying float v2f_diffuse;
 176: varying vec2 v2f_light;
 177: 
 178: 
 179: void main() {
 180:     Vertex v;
 181:     v.pos = a_v_pos;
 182: v.normal = a_v_normal;
 183: v.texCoords = a_v_texCoords;
 184: 
 185: 
 186:     Belt i;
 187:     i.light = a_i_light;
 188: i.color = a_i_color;
 189: i.pos = a_i_pos;
 190: i.speed = a_i_speed;
 191: i.offset = a_i_offset;
 192: i.rotation = a_i_rotation;
 193: i.sourceTexture = a_i_sourceTexture;
 194: i.scrollTexture = a_i_scrollTexture;
 195: i.scrollMult = a_i_scrollMult;
 196: 
 197: 
 198:     BlockFrag o = FLWMain(v, i);
 199: 
 200:     v2f_texCoords = o.texCoords;
 201: v2f_color = o.color;
 202: v2f_diffuse = o.diffuse;
 203: v2f_light = o.light;
 204: 
 205: }

[13:33:08] [main/ERROR]: Shader compilation log for flywheel:block.frag: No errors.

[13:33:08] [main/ERROR]: Source for shader 'flywheel:block.frag':
   1: #version 110
   2: #define DEBUG_RAINBOW
   3: 
   4: #if defined(USE_FOG)
   5: varying float FragDistance;
   6: uniform vec4 uFogColor;
   7: #endif
   8: 
   9: #if defined(USE_FOG_LINEAR)
  10: uniform vec2 uFogRange;
  11: 
  12: float FLWFogFactor() {
  13:     return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
  14: }
  15:     #endif
  16: 
  17:     #if defined(USE_FOG_EXP2)
  18: uniform float uFogDensity;
  19: 
  20: float FLWFogFactor() {
  21:     float dist = FragDistance * uFogDensity;
  22:     return 1. / exp2(dist * dist);
  23: }
  24:     #endif
  25: // Adjust the [0,1] normalized lightmap value based on the texture matrix from LightTexture#enableLightmap
  26: vec2 shiftLight(vec2 lm) {
  27:     return lm * 0.99609375 + 0.03125;// * 255/256 + 1/32
  28: }
  29: 
  30: varying vec3 BoxCoord;
  31: varying vec2 BoxLight;
  32: uniform sampler3D uLightVolume;
  33: 
  34: uniform sampler2D uBlockAtlas;
  35: uniform sampler2D uLightMap;
  36: 
  37: vec4 FLWBlockTexture(vec2 texCoords) {
  38:     return texture2D(uBlockAtlas, texCoords);
  39: }
  40: 
  41: void FLWFinalizeColor(vec4 color) {
  42:     #if defined(USE_FOG)
  43:     float a = color.a;
  44:     float fog = clamp(FLWFogFactor(), 0., 1.);
  45: 
  46:     color = mix(uFogColor, color, fog);
  47:     color.a = a;
  48:     #endif
  49: 
  50:     gl_FragColor = color;
  51: }
  52: 
  53: vec4 FLWLight(vec2 lightCoords) {
  54:     lightCoords = max(lightCoords, texture3D(uLightVolume, BoxCoord).rg);
  55: 
  56:     return texture2D(uLightMap, shiftLight(lightCoords));
  57: }
  58: 
  59: 
  60: 
  61: struct BlockFrag {
  62:     vec2 texCoords;
  63:     vec4 color;
  64:     float diffuse;
  65:     vec2 light;
  66: };
  67: 
  68: void FLWMain(BlockFrag r) {
  69:     vec4 tex = FLWBlockTexture(r.texCoords);
  70: 
  71:     vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;
  72: 
  73: //    flw_WorldPos = ;
  74: //    flw_Normal = ;
  75: //    flw_Albedo = tex.rgb;
  76: //    flw_Alpha = tex.a;
  77: //    flw_LightMap = r.light;
  78: //    flw_Tint = r.color;
  79:     FLWFinalizeColor(color);
  80: }
  81: 
  82: varying vec2 v2f_texCoords;
  83: varying vec4 v2f_color;
  84: varying float v2f_diffuse;
  85: varying vec2 v2f_light;
  86: 
  87: 
  88: //vec3 flw_WorldPos;
  89: //vec3 flw_Normal;
  90: //vec3 flw_Albedo;
  91: //float flw_Alpha;
  92: //vec2 flw_LightMap;
  93: //vec4 flw_Tint;
  94: 
  95: void main() {
  96:     BlockFrag f;
  97:     f.texCoords = v2f_texCoords;
  98: f.color = v2f_color;
  99: f.diffuse = v2f_diffuse;
 100: f.light = v2f_light;
 101: 
 102: 
 103:     FLWMain(f);
 104: }

[13:33:08] [main/ERROR]: Shader compilation log for create:belt.vert: No errors.

[13:33:08] [main/ERROR]: Source for shader 'create:belt.vert':
   1: #version 110
   2: #define DEBUG_NORMAL
   3: 
   4: #define PI 3.1415926538
   5: 
   6: #if defined(USE_FOG)
   7: varying float FragDistance;
   8: #endif
   9: 
  10: varying vec3 BoxCoord;
  11: 
  12: uniform vec3 uLightBoxSize;
  13: uniform vec3 uLightBoxMin;
  14: uniform mat4 uModel;
  15: 
  16: uniform float uTime;
  17: uniform mat4 uViewProjection;
  18: uniform vec3 uCameraPos;
  19: 
  20: void FLWFinalizeWorldPos(inout vec4 worldPos) {
  21:     worldPos = uModel * worldPos;
  22: 
  23:     BoxCoord = (worldPos.xyz - uLightBoxMin) / uLightBoxSize;
  24: 
  25:     #if defined(USE_FOG)
  26:     FragDistance = length(worldPos.xyz);
  27:     #endif
  28: 
  29:     gl_Position = uViewProjection * worldPos;
  30: }
  31: 
  32: void FLWFinalizeNormal(inout vec3 normal) {
  33:     mat3 m;
  34:     m[0] = uModel[0].xyz;
  35:     m[1] = uModel[1].xyz;
  36:     m[2] = uModel[2].xyz;
  37:     normal = m * normal;
  38: }
  39: 
  40: 
  41: 
  42: #define PIOVER2 1.5707963268
  43: 
  44: vec4 quat(vec3 axis, float angle) {
  45:     float halfAngle = angle * PIOVER2 / 180.0;
  46:     vec2 cs = sin(vec2(PIOVER2 - halfAngle, halfAngle)); // compute sin and cos in one instruction
  47:     return vec4(axis.xyz * cs.y,  cs.x);
  48: }
  49: 
  50: vec4 quatMult(vec4 q1, vec4 q2) {
  51:     // disgustingly vectorized quaternion multiplication
  52:     vec4 a = q1.w * q2.xyzw;
  53:     vec4 b = q1.x * q2.wzxy * vec4(1., -1., 1., -1.);
  54:     vec4 c = q1.y * q2.zwxy * vec4(1., 1., -1., -1.);
  55:     vec4 d = q1.z * q2.yxwz * vec4(-1., 1., 1., -1.);
  56: 
  57:     return a + b + c + d;
  58: }
  59: 
  60: vec3 rotateVertexByQuat(vec3 v, vec4 q) {
  61:     vec3 i = q.xyz;
  62:     return v + 2.0 * cross(i, cross(i, v) + q.w * v);
  63: }
  64: 
  65: vec3 rotateAbout(vec3 v, vec3 axis, float angle) {
  66:     return rotateVertexByQuat(v, quat(axis, angle));
  67: }
  68: 
  69: mat4 rotate(vec3 axis, float angle) {
  70:     float s = sin(angle);
  71:     float c = cos(angle);
  72:     float oc = 1. - c;
  73: 
  74:     vec3 sa = axis * s;
  75: 
  76:     mat4 mr = mat4(1.);
  77:     mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
  78:     mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
  79:     mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);
  80: 
  81:     return mr;
  82: }
  83: 
  84: mat4 rotation(vec3 rot) {
  85:     return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
  86: }
  87: 
  88: mat3 modelToNormal(mat4 mat) {
  89:     // Discard the edges. This won't be accurate for scaled or skewed matrices,
  90:     // but we don't have to work with those often.
  91:     mat3 m;
  92:     m[0] = mat[0].xyz;
  93:     m[1] = mat[1].xyz;
  94:     m[2] = mat[2].xyz;
  95:     return m;
  96: }
  97: 
  98: float diffuse(vec3 normal) {
  99:     vec3 n2 = normal * normal * vec3(.6, .25, .8);
 100:     return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
 101: }
 102: 
 103: 
 104: struct Belt {
 105:     vec2 light;
 106:     vec4 color;
 107:     vec3 pos;
 108:     float speed;
 109:     float offset;
 110:     vec4 rotation;
 111:     vec2 sourceTexture;
 112:     vec4 scrollTexture;
 113:     float scrollMult;
 114: };
 115: 
 116: 
 117: struct Vertex {
 118:     vec3 pos;
 119:     vec3 normal;
 120:     vec2 texCoords;
 121: };
 122: 
 123: struct BlockFrag {
 124:     vec2 texCoords;
 125:     vec4 color;
 126:     float diffuse;
 127:     vec2 light;
 128: };
 129: 
 130: BlockFrag FLWMain(Vertex v, Belt instance) {
 131:     vec3 rotated = rotateVertexByQuat(v.pos - .5, instance.rotation) + instance.pos + .5;
 132: 
 133:     vec4 worldPos = vec4(rotated, 1.);
 134: 
 135:     vec3 norm = rotateVertexByQuat(v.normal, instance.rotation);
 136: 
 137:     FLWFinalizeWorldPos(worldPos);
 138:     FLWFinalizeNormal(norm);
 139: 
 140:     float scrollSize = instance.scrollTexture.w - instance.scrollTexture.y;
 141:     float scroll = fract(instance.speed * uTime / (31.5 * 16.) + instance.offset) * scrollSize * instance.scrollMult;
 142: 
 143:     BlockFrag b;
 144:     b.diffuse = diffuse(norm);
 145:     b.texCoords = v.texCoords - instance.sourceTexture + instance.scrollTexture.xy + vec2(0, scroll);
 146:     b.light = instance.light;
 147: 
 148:     #if defined(DEBUG_RAINBOW)
 149:     b.color = instance.color;
 150:     #elif defined(DEBUG_NORMAL)
 151:     b.color = vec4(norm, 1.);
 152:     #else
 153:     b.color = vec4(1.);
 154:     #endif
 155: 
 156:     return b;
 157: }
 158: attribute vec3 a_v_pos;
 159: attribute vec3 a_v_normal;
 160: attribute vec2 a_v_texCoords;
 161: 
 162: attribute vec2 a_i_light;
 163: attribute vec4 a_i_color;
 164: attribute vec3 a_i_pos;
 165: attribute float a_i_speed;
 166: attribute float a_i_offset;
 167: attribute vec4 a_i_rotation;
 168: attribute vec2 a_i_sourceTexture;
 169: attribute vec4 a_i_scrollTexture;
 170: attribute float a_i_scrollMult;
 171: 
 172: 
 173: varying vec2 v2f_texCoords;
 174: varying vec4 v2f_color;
 175: varying float v2f_diffuse;
 176: varying vec2 v2f_light;
 177: 
 178: 
 179: void main() {
 180:     Vertex v;
 181:     v.pos = a_v_pos;
 182: v.normal = a_v_normal;
 183: v.texCoords = a_v_texCoords;
 184: 
 185: 
 186:     Belt i;
 187:     i.light = a_i_light;
 188: i.color = a_i_color;
 189: i.pos = a_i_pos;
 190: i.speed = a_i_speed;
 191: i.offset = a_i_offset;
 192: i.rotation = a_i_rotation;
 193: i.sourceTexture = a_i_sourceTexture;
 194: i.scrollTexture = a_i_scrollTexture;
 195: i.scrollMult = a_i_scrollMult;
 196: 
 197: 
 198:     BlockFrag o = FLWMain(v, i);
 199: 
 200:     v2f_texCoords = o.texCoords;
 201: v2f_color = o.color;
 202: v2f_diffuse = o.diffuse;
 203: v2f_light = o.light;
 204: 
 205: }

[13:33:09] [main/ERROR]: Shader compilation log for flywheel:block.frag: No errors.

[13:33:09] [main/ERROR]: Source for shader 'flywheel:block.frag':
   1: #version 110
   2: #define DEBUG_NORMAL
   3: 
   4: #if defined(USE_FOG)
   5: varying float FragDistance;
   6: uniform vec4 uFogColor;
   7: #endif
   8: 
   9: #if defined(USE_FOG_LINEAR)
  10: uniform vec2 uFogRange;
  11: 
  12: float FLWFogFactor() {
  13:     return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
  14: }
  15:     #endif
  16: 
  17:     #if defined(USE_FOG_EXP2)
  18: uniform float uFogDensity;
  19: 
  20: float FLWFogFactor() {
  21:     float dist = FragDistance * uFogDensity;
  22:     return 1. / exp2(dist * dist);
  23: }
  24:     #endif
  25: // Adjust the [0,1] normalized lightmap value based on the texture matrix from LightTexture#enableLightmap
  26: vec2 shiftLight(vec2 lm) {
  27:     return lm * 0.99609375 + 0.03125;// * 255/256 + 1/32
  28: }
  29: 
  30: varying vec3 BoxCoord;
  31: varying vec2 BoxLight;
  32: uniform sampler3D uLightVolume;
  33: 
  34: uniform sampler2D uBlockAtlas;
  35: uniform sampler2D uLightMap;
  36: 
  37: vec4 FLWBlockTexture(vec2 texCoords) {
  38:     return texture2D(uBlockAtlas, texCoords);
  39: }
  40: 
  41: void FLWFinalizeColor(vec4 color) {
  42:     #if defined(USE_FOG)
  43:     float a = color.a;
  44:     float fog = clamp(FLWFogFactor(), 0., 1.);
  45: 
  46:     color = mix(uFogColor, color, fog);
  47:     color.a = a;
  48:     #endif
  49: 
  50:     gl_FragColor = color;
  51: }
  52: 
  53: vec4 FLWLight(vec2 lightCoords) {
  54:     lightCoords = max(lightCoords, texture3D(uLightVolume, BoxCoord).rg);
  55: 
  56:     return texture2D(uLightMap, shiftLight(lightCoords));
  57: }
  58: 
  59: 
  60: 
  61: struct BlockFrag {
  62:     vec2 texCoords;
  63:     vec4 color;
  64:     float diffuse;
  65:     vec2 light;
  66: };
  67: 
  68: void FLWMain(BlockFrag r) {
  69:     vec4 tex = FLWBlockTexture(r.texCoords);
  70: 
  71:     vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;
  72: 
  73: //    flw_WorldPos = ;
  74: //    flw_Normal = ;
  75: //    flw_Albedo = tex.rgb;
  76: //    flw_Alpha = tex.a;
  77: //    flw_LightMap = r.light;
  78: //    flw_Tint = r.color;
  79:     FLWFinalizeColor(color);
  80: }
  81: 
  82: varying vec2 v2f_texCoords;
  83: varying vec4 v2f_color;
  84: varying float v2f_diffuse;
  85: varying vec2 v2f_light;
  86: 
  87: 
  88: //vec3 flw_WorldPos;
  89: //vec3 flw_Normal;
  90: //vec3 flw_Albedo;
  91: //float flw_Alpha;
  92: //vec2 flw_LightMap;
  93: //vec4 flw_Tint;
  94: 
  95: void main() {
  96:     BlockFrag f;
  97:     f.texCoords = v2f_texCoords;
  98: f.color = v2f_color;
  99: f.diffuse = v2f_diffuse;
 100: f.light = v2f_light;
 101: 
 102: 
 103:     FLWMain(f);
 104: }

[13:33:09] [main/ERROR]: Shader compilation log for create:belt.vert: No errors.

[13:33:09] [main/ERROR]: Source for shader 'create:belt.vert':
   1: #version 110
   2: #define USE_FOG
   3: #define USE_FOG_LINEAR
   4: 
   5: #define PI 3.1415926538
   6: 
   7: #if defined(USE_FOG)
   8: varying float FragDistance;
   9: #endif
  10: 
  11: varying vec3 BoxCoord;
  12: 
  13: uniform vec3 uLightBoxSize;
  14: uniform vec3 uLightBoxMin;
  15: uniform mat4 uModel;
  16: 
  17: uniform float uTime;
  18: uniform mat4 uViewProjection;
  19: uniform vec3 uCameraPos;
  20: 
  21: void FLWFinalizeWorldPos(inout vec4 worldPos) {
  22:     worldPos = uModel * worldPos;
  23: 
  24:     BoxCoord = (worldPos.xyz - uLightBoxMin) / uLightBoxSize;
  25: 
  26:     #if defined(USE_FOG)
  27:     FragDistance = length(worldPos.xyz);
  28:     #endif
  29: 
  30:     gl_Position = uViewProjection * worldPos;
  31: }
  32: 
  33: void FLWFinalizeNormal(inout vec3 normal) {
  34:     mat3 m;
  35:     m[0] = uModel[0].xyz;
  36:     m[1] = uModel[1].xyz;
  37:     m[2] = uModel[2].xyz;
  38:     normal = m * normal;
  39: }
  40: 
  41: 
  42: 
  43: #define PIOVER2 1.5707963268
  44: 
  45: vec4 quat(vec3 axis, float angle) {
  46:     float halfAngle = angle * PIOVER2 / 180.0;
  47:     vec2 cs = sin(vec2(PIOVER2 - halfAngle, halfAngle)); // compute sin and cos in one instruction
  48:     return vec4(axis.xyz * cs.y,  cs.x);
  49: }
  50: 
  51: vec4 quatMult(vec4 q1, vec4 q2) {
  52:     // disgustingly vectorized quaternion multiplication
  53:     vec4 a = q1.w * q2.xyzw;
  54:     vec4 b = q1.x * q2.wzxy * vec4(1., -1., 1., -1.);
  55:     vec4 c = q1.y * q2.zwxy * vec4(1., 1., -1., -1.);
  56:     vec4 d = q1.z * q2.yxwz * vec4(-1., 1., 1., -1.);
  57: 
  58:     return a + b + c + d;
  59: }
  60: 
  61: vec3 rotateVertexByQuat(vec3 v, vec4 q) {
  62:     vec3 i = q.xyz;
  63:     return v + 2.0 * cross(i, cross(i, v) + q.w * v);
  64: }
  65: 
  66: vec3 rotateAbout(vec3 v, vec3 axis, float angle) {
  67:     return rotateVertexByQuat(v, quat(axis, angle));
  68: }
  69: 
  70: mat4 rotate(vec3 axis, float angle) {
  71:     float s = sin(angle);
  72:     float c = cos(angle);
  73:     float oc = 1. - c;
  74: 
  75:     vec3 sa = axis * s;
  76: 
  77:     mat4 mr = mat4(1.);
  78:     mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
  79:     mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
  80:     mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);
  81: 
  82:     return mr;
  83: }
  84: 
  85: mat4 rotation(vec3 rot) {
  86:     return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
  87: }
  88: 
  89: mat3 modelToNormal(mat4 mat) {
  90:     // Discard the edges. This won't be accurate for scaled or skewed matrices,
  91:     // but we don't have to work with those often.
  92:     mat3 m;
  93:     m[0] = mat[0].xyz;
  94:     m[1] = mat[1].xyz;
  95:     m[2] = mat[2].xyz;
  96:     return m;
  97: }
  98: 
  99: float diffuse(vec3 normal) {
 100:     vec3 n2 = normal * normal * vec3(.6, .25, .8);
 101:     return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
 102: }
 103: 
 104: 
 105: struct Belt {
 106:     vec2 light;
 107:     vec4 color;
 108:     vec3 pos;
 109:     float speed;
 110:     float offset;
 111:     vec4 rotation;
 112:     vec2 sourceTexture;
 113:     vec4 scrollTexture;
 114:     float scrollMult;
 115: };
 116: 
 117: 
 118: struct Vertex {
 119:     vec3 pos;
 120:     vec3 normal;
 121:     vec2 texCoords;
 122: };
 123: 
 124: struct BlockFrag {
 125:     vec2 texCoords;
 126:     vec4 color;
 127:     float diffuse;
 128:     vec2 light;
 129: };
 130: 
 131: BlockFrag FLWMain(Vertex v, Belt instance) {
 132:     vec3 rotated = rotateVertexByQuat(v.pos - .5, instance.rotation) + instance.pos + .5;
 133: 
 134:     vec4 worldPos = vec4(rotated, 1.);
 135: 
 136:     vec3 norm = rotateVertexByQuat(v.normal, instance.rotation);
 137: 
 138:     FLWFinalizeWorldPos(worldPos);
 139:     FLWFinalizeNormal(norm);
 140: 
 141:     float scrollSize = instance.scrollTexture.w - instance.scrollTexture.y;
 142:     float scroll = fract(instance.speed * uTime / (31.5 * 16.) + instance.offset) * scrollSize * instance.scrollMult;
 143: 
 144:     BlockFrag b;
 145:     b.diffuse = diffuse(norm);
 146:     b.texCoords = v.texCoords - instance.sourceTexture + instance.scrollTexture.xy + vec2(0, scroll);
 147:     b.light = instance.light;
 148: 
 149:     #if defined(DEBUG_RAINBOW)
 150:     b.color = instance.color;
 151:     #elif defined(DEBUG_NORMAL)
 152:     b.color = vec4(norm, 1.);
 153:     #else
 154:     b.color = vec4(1.);
 155:     #endif
 156: 
 157:     return b;
 158: }
 159: attribute vec3 a_v_pos;
 160: attribute vec3 a_v_normal;
 161: attribute vec2 a_v_texCoords;
 162: 
 163: attribute vec2 a_i_light;
 164: attribute vec4 a_i_color;
 165: attribute vec3 a_i_pos;
 166: attribute float a_i_speed;
 167: attribute float a_i_offset;
 168: attribute vec4 a_i_rotation;
 169: attribute vec2 a_i_sourceTexture;
 170: attribute vec4 a_i_scrollTexture;
 171: attribute float a_i_scrollMult;
 172: 
 173: 
 174: varying vec2 v2f_texCoords;
 175: varying vec4 v2f_color;
 176: varying float v2f_diffuse;
 177: varying vec2 v2f_light;
 178: 
 179: 
 180: void main() {
 181:     Vertex v;
 182:     v.pos = a_v_pos;
 183: v.normal = a_v_normal;
 184: v.texCoords = a_v_texCoords;
 185: 
 186: 
 187:     Belt i;
 188:     i.light = a_i_light;
 189: i.color = a_i_color;
 190: i.pos = a_i_pos;
 191: i.speed = a_i_speed;
 192: i.offset = a_i_offset;
 193: i.rotation = a_i_rotation;
 194: i.sourceTexture = a_i_sourceTexture;
 195: i.scrollTexture = a_i_scrollTexture;
 196: i.scrollMult = a_i_scrollMult;
 197: 
 198: 
 199:     BlockFrag o = FLWMain(v, i);
 200: 
 201:     v2f_texCoords = o.texCoords;
 202: v2f_color = o.color;
 203: v2f_diffuse = o.diffuse;
 204: v2f_light = o.light;
 205: 
 206: }

[13:33:09] [main/ERROR]: Shader compilation log for flywheel:block.frag: No errors.

[13:33:09] [main/ERROR]: Source for shader 'flywheel:block.frag':
   1: #version 110
   2: #define USE_FOG
   3: #define USE_FOG_LINEAR
   4: 
   5: #if defined(USE_FOG)
   6: varying float FragDistance;
   7: uniform vec4 uFogColor;
   8: #endif
   9: 
  10: #if defined(USE_FOG_LINEAR)
  11: uniform vec2 uFogRange;
  12: 
  13: float FLWFogFactor() {
  14:     return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
  15: }
  16:     #endif
  17: 
  18:     #if defined(USE_FOG_EXP2)
  19: uniform float uFogDensity;
  20: 
  21: float FLWFogFactor() {
  22:     float dist = FragDistance * uFogDensity;
  23:     return 1. / exp2(dist * dist);
  24: }
  25:     #endif
  26: // Adjust the [0,1] normalized lightmap value based on the texture matrix from LightTexture#enableLightmap
  27: vec2 shiftLight(vec2 lm) {
  28:     return lm * 0.99609375 + 0.03125;// * 255/256 + 1/32
  29: }
  30: 
  31: varying vec3 BoxCoord;
  32: varying vec2 BoxLight;
  33: uniform sampler3D uLightVolume;
  34: 
  35: uniform sampler2D uBlockAtlas;
  36: uniform sampler2D uLightMap;
  37: 
  38: vec4 FLWBlockTexture(vec2 texCoords) {
  39:     return texture2D(uBlockAtlas, texCoords);
  40: }
  41: 
  42: void FLWFinalizeColor(vec4 color) {
  43:     #if defined(USE_FOG)
  44:     float a = color.a;
  45:     float fog = clamp(FLWFogFactor(), 0., 1.);
  46: 
  47:     color = mix(uFogColor, color, fog);
  48:     color.a = a;
  49:     #endif
  50: 
  51:     gl_FragColor = color;
  52: }
  53: 
  54: vec4 FLWLight(vec2 lightCoords) {
  55:     lightCoords = max(lightCoords, texture3D(uLightVolume, BoxCoord).rg);
  56: 
  57:     return texture2D(uLightMap, shiftLight(lightCoords));
  58: }
  59: 
  60: 
  61: 
  62: struct BlockFrag {
  63:     vec2 texCoords;
  64:     vec4 color;
  65:     float diffuse;
  66:     vec2 light;
  67: };
  68: 
  69: void FLWMain(BlockFrag r) {
  70:     vec4 tex = FLWBlockTexture(r.texCoords);
  71: 
  72:     vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;
  73: 
  74: //    flw_WorldPos = ;
  75: //    flw_Normal = ;
  76: //    flw_Albedo = tex.rgb;
  77: //    flw_Alpha = tex.a;
  78: //    flw_LightMap = r.light;
  79: //    flw_Tint = r.color;
  80:     FLWFinalizeColor(color);
  81: }
  82: 
  83: varying vec2 v2f_texCoords;
  84: varying vec4 v2f_color;
  85: varying float v2f_diffuse;
  86: varying vec2 v2f_light;
  87: 
  88: 
  89: //vec3 flw_WorldPos;
  90: //vec3 flw_Normal;
  91: //vec3 flw_Albedo;
  92: //float flw_Alpha;
  93: //vec2 flw_LightMap;
  94: //vec4 flw_Tint;
  95: 
  96: void main() {
  97:     BlockFrag f;
  98:     f.texCoords = v2f_texCoords;
  99: f.color = v2f_color;
 100: f.diffuse = v2f_diffuse;
 101: f.light = v2f_light;
 102: 
 103: 
 104:     FLWMain(f);
 105: }

[13:33:09] [main/ERROR]: Shader compilation log for create:belt.vert: No errors.

[13:33:09] [main/ERROR]: Source for shader 'create:belt.vert':
   1: #version 110
   2: #define USE_FOG
   3: #define USE_FOG_EXP2
   4: 
   5: #define PI 3.1415926538
   6: 
   7: #if defined(USE_FOG)
   8: varying float FragDistance;
   9: #endif
  10: 
  11: varying vec3 BoxCoord;
  12: 
  13: uniform vec3 uLightBoxSize;
  14: uniform vec3 uLightBoxMin;
  15: uniform mat4 uModel;
  16: 
  17: uniform float uTime;
  18: uniform mat4 uViewProjection;
  19: uniform vec3 uCameraPos;
  20: 
  21: void FLWFinalizeWorldPos(inout vec4 worldPos) {
  22:     worldPos = uModel * worldPos;
  23: 
  24:     BoxCoord = (worldPos.xyz - uLightBoxMin) / uLightBoxSize;
  25: 
  26:     #if defined(USE_FOG)
  27:     FragDistance = length(worldPos.xyz);
  28:     #endif
  29: 
  30:     gl_Position = uViewProjection * worldPos;
  31: }
  32: 
  33: void FLWFinalizeNormal(inout vec3 normal) {
  34:     mat3 m;
  35:     m[0] = uModel[0].xyz;
  36:     m[1] = uModel[1].xyz;
  37:     m[2] = uModel[2].xyz;
  38:     normal = m * normal;
  39: }
  40: 
  41: 
  42: 
  43: #define PIOVER2 1.5707963268
  44: 
  45: vec4 quat(vec3 axis, float angle) {
  46:     float halfAngle = angle * PIOVER2 / 180.0;
  47:     vec2 cs = sin(vec2(PIOVER2 - halfAngle, halfAngle)); // compute sin and cos in one instruction
  48:     return vec4(axis.xyz * cs.y,  cs.x);
  49: }
  50: 
  51: vec4 quatMult(vec4 q1, vec4 q2) {
  52:     // disgustingly vectorized quaternion multiplication
  53:     vec4 a = q1.w * q2.xyzw;
  54:     vec4 b = q1.x * q2.wzxy * vec4(1., -1., 1., -1.);
  55:     vec4 c = q1.y * q2.zwxy * vec4(1., 1., -1., -1.);
  56:     vec4 d = q1.z * q2.yxwz * vec4(-1., 1., 1., -1.);
  57: 
  58:     return a + b + c + d;
  59: }
  60: 
  61: vec3 rotateVertexByQuat(vec3 v, vec4 q) {
  62:     vec3 i = q.xyz;
  63:     return v + 2.0 * cross(i, cross(i, v) + q.w * v);
  64: }
  65: 
  66: vec3 rotateAbout(vec3 v, vec3 axis, float angle) {
  67:     return rotateVertexByQuat(v, quat(axis, angle));
  68: }
  69: 
  70: mat4 rotate(vec3 axis, float angle) {
  71:     float s = sin(angle);
  72:     float c = cos(angle);
  73:     float oc = 1. - c;
  74: 
  75:     vec3 sa = axis * s;
  76: 
  77:     mat4 mr = mat4(1.);
  78:     mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
  79:     mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
  80:     mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);
  81: 
  82:     return mr;
  83: }
  84: 
  85: mat4 rotation(vec3 rot) {
  86:     return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
  87: }
  88: 
  89: mat3 modelToNormal(mat4 mat) {
  90:     // Discard the edges. This won't be accurate for scaled or skewed matrices,
  91:     // but we don't have to work with those often.
  92:     mat3 m;
  93:     m[0] = mat[0].xyz;
  94:     m[1] = mat[1].xyz;
  95:     m[2] = mat[2].xyz;
  96:     return m;
  97: }
  98: 
  99: float diffuse(vec3 normal) {
 100:     vec3 n2 = normal * normal * vec3(.6, .25, .8);
 101:     return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
 102: }
 103: 
 104: 
 105: struct Belt {
 106:     vec2 light;
 107:     vec4 color;
 108:     vec3 pos;
 109:     float speed;
 110:     float offset;
 111:     vec4 rotation;
 112:     vec2 sourceTexture;
 113:     vec4 scrollTexture;
 114:     float scrollMult;
 115: };
 116: 
 117: 
 118: struct Vertex {
 119:     vec3 pos;
 120:     vec3 normal;
 121:     vec2 texCoords;
 122: };
 123: 
 124: struct BlockFrag {
 125:     vec2 texCoords;
 126:     vec4 color;
 127:     float diffuse;
 128:     vec2 light;
 129: };
 130: 
 131: BlockFrag FLWMain(Vertex v, Belt instance) {
 132:     vec3 rotated = rotateVertexByQuat(v.pos - .5, instance.rotation) + instance.pos + .5;
 133: 
 134:     vec4 worldPos = vec4(rotated, 1.);
 135: 
 136:     vec3 norm = rotateVertexByQuat(v.normal, instance.rotation);
 137: 
 138:     FLWFinalizeWorldPos(worldPos);
 139:     FLWFinalizeNormal(norm);
 140: 
 141:     float scrollSize = instance.scrollTexture.w - instance.scrollTexture.y;
 142:     float scroll = fract(instance.speed * uTime / (31.5 * 16.) + instance.offset) * scrollSize * instance.scrollMult;
 143: 
 144:     BlockFrag b;
 145:     b.diffuse = diffuse(norm);
 146:     b.texCoords = v.texCoords - instance.sourceTexture + instance.scrollTexture.xy + vec2(0, scroll);
 147:     b.light = instance.light;
 148: 
 149:     #if defined(DEBUG_RAINBOW)
 150:     b.color = instance.color;
 151:     #elif defined(DEBUG_NORMAL)
 152:     b.color = vec4(norm, 1.);
 153:     #else
 154:     b.color = vec4(1.);
 155:     #endif
 156: 
 157:     return b;
 158: }
 159: attribute vec3 a_v_pos;
 160: attribute vec3 a_v_normal;
 161: attribute vec2 a_v_texCoords;
 162: 
 163: attribute vec2 a_i_light;
 164: attribute vec4 a_i_color;
 165: attribute vec3 a_i_pos;
 166: attribute float a_i_speed;
 167: attribute float a_i_offset;
 168: attribute vec4 a_i_rotation;
 169: attribute vec2 a_i_sourceTexture;
 170: attribute vec4 a_i_scrollTexture;
 171: attribute float a_i_scrollMult;
 172: 
 173: 
 174: varying vec2 v2f_texCoords;
 175: varying vec4 v2f_color;
 176: varying float v2f_diffuse;
 177: varying vec2 v2f_light;
 178: 
 179: 
 180: void main() {
 181:     Vertex v;
 182:     v.pos = a_v_pos;
 183: v.normal = a_v_normal;
 184: v.texCoords = a_v_texCoords;
 185: 
 186: 
 187:     Belt i;
 188:     i.light = a_i_light;
 189: i.color = a_i_color;
 190: i.pos = a_i_pos;
 191: i.speed = a_i_speed;
 192: i.offset = a_i_offset;
 193: i.rotation = a_i_rotation;
 194: i.sourceTexture = a_i_sourceTexture;
 195: i.scrollTexture = a_i_scrollTexture;
 196: i.scrollMult = a_i_scrollMult;
 197: 
 198: 
 199:     BlockFrag o = FLWMain(v, i);
 200: 
 201:     v2f_texCoords = o.texCoords;
 202: v2f_color = o.color;
 203: v2f_diffuse = o.diffuse;
 204: v2f_light = o.light;
 205: 
 206: }

[13:33:09] [main/ERROR]: Shader compilation log for flywheel:block.frag: No errors.

[13:33:09] [main/ERROR]: Source for shader 'flywheel:block.frag':
   1: #version 110
   2: #define USE_FOG
   3: #define USE_FOG_EXP2
   4: 
   5: #if defined(USE_FOG)
   6: varying float FragDistance;
   7: uniform vec4 uFogColor;
   8: #endif
   9: 
  10: #if defined(USE_FOG_LINEAR)
  11: uniform vec2 uFogRange;
  12: 
  13: float FLWFogFactor() {
  14:     return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
  15: }
  16:     #endif
  17: 
  18:     #if defined(USE_FOG_EXP2)
  19: uniform float uFogDensity;
  20: 
  21: float FLWFogFactor() {
  22:     float dist = FragDistance * uFogDensity;
  23:     return 1. / exp2(dist * dist);
  24: }
  25:     #endif
  26: // Adjust the [0,1] normalized lightmap value based on the texture matrix from LightTexture#enableLightmap
  27: vec2 shiftLight(vec2 lm) {
  28:     return lm * 0.99609375 + 0.03125;// * 255/256 + 1/32
  29: }
  30: 
  31: varying vec3 BoxCoord;
  32: varying vec2 BoxLight;
  33: uniform sampler3D uLightVolume;
  34: 
  35: uniform sampler2D uBlockAtlas;
  36: uniform sampler2D uLightMap;
  37: 
  38: vec4 FLWBlockTexture(vec2 texCoords) {
  39:     return texture2D(uBlockAtlas, texCoords);
  40: }
  41: 
  42: void FLWFinalizeColor(vec4 color) {
  43:     #if defined(USE_FOG)
  44:     float a = color.a;
  45:     float fog = clamp(FLWFogFactor(), 0., 1.);
  46: 
  47:     color = mix(uFogColor, color, fog);
  48:     color.a = a;
  49:     #endif
  50: 
  51:     gl_FragColor = color;
  52: }
  53: 
  54: vec4 FLWLight(vec2 lightCoords) {
  55:     lightCoords = max(lightCoords, texture3D(uLightVolume, BoxCoord).rg);
  56: 
  57:     return texture2D(uLightMap, shiftLight(lightCoords));
  58: }
  59: 
  60: 
  61: 
  62: struct BlockFrag {
  63:     vec2 texCoords;
  64:     vec4 color;
  65:     float diffuse;
  66:     vec2 light;
  67: };
  68: 
  69: void FLWMain(BlockFrag r) {
  70:     vec4 tex = FLWBlockTexture(r.texCoords);
  71: 
  72:     vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;
  73: 
  74: //    flw_WorldPos = ;
  75: //    flw_Normal = ;
  76: //    flw_Albedo = tex.rgb;
  77: //    flw_Alpha = tex.a;
  78: //    flw_LightMap = r.light;
  79: //    flw_Tint = r.color;
  80:     FLWFinalizeColor(color);
  81: }
  82: 
  83: varying vec2 v2f_texCoords;
  84: varying vec4 v2f_color;
  85: varying float v2f_diffuse;
  86: varying vec2 v2f_light;
  87: 
  88: 
  89: //vec3 flw_WorldPos;
  90: //vec3 flw_Normal;
  91: //vec3 flw_Albedo;
  92: //float flw_Alpha;
  93: //vec2 flw_LightMap;
  94: //vec4 flw_Tint;
  95: 
  96: void main() {
  97:     BlockFrag f;
  98:     f.texCoords = v2f_texCoords;
  99: f.color = v2f_color;
 100: f.diffuse = v2f_diffuse;
 101: f.light = v2f_light;
 102: 
 103: 
 104:     FLWMain(f);
 105: }

[13:33:09] [main/ERROR]: Shader compilation log for create:belt.vert: No errors.

[13:33:09] [main/ERROR]: Source for shader 'create:belt.vert':
   1: #version 110
   2: 
   3: #define PI 3.1415926538
   4: 
   5: #if defined(USE_FOG)
   6: varying float FragDistance;
   7: #endif
   8: 
   9: varying vec3 BoxCoord;
  10: 
  11: uniform vec3 uLightBoxSize;
  12: uniform vec3 uLightBoxMin;
  13: uniform mat4 uModel;
  14: 
  15: uniform float uTime;
  16: uniform mat4 uViewProjection;
  17: uniform vec3 uCameraPos;
  18: 
  19: void FLWFinalizeWorldPos(inout vec4 worldPos) {
  20:     worldPos = uModel * worldPos;
  21: 
  22:     BoxCoord = (worldPos.xyz - uLightBoxMin) / uLightBoxSize;
  23: 
  24:     #if defined(USE_FOG)
  25:     FragDistance = length(worldPos.xyz);
  26:     #endif
  27: 
  28:     gl_Position = uViewProjection * worldPos;
  29: }
  30: 
  31: void FLWFinalizeNormal(inout vec3 normal) {
  32:     mat3 m;
  33:     m[0] = uModel[0].xyz;
  34:     m[1] = uModel[1].xyz;
  35:     m[2] = uModel[2].xyz;
  36:     normal = m * normal;
  37: }
  38: 
  39: 
  40: 
  41: #define PIOVER2 1.5707963268
  42: 
  43: vec4 quat(vec3 axis, float angle) {
  44:     float halfAngle = angle * PIOVER2 / 180.0;
  45:     vec2 cs = sin(vec2(PIOVER2 - halfAngle, halfAngle)); // compute sin and cos in one instruction
  46:     return vec4(axis.xyz * cs.y,  cs.x);
  47: }
  48: 
  49: vec4 quatMult(vec4 q1, vec4 q2) {
  50:     // disgustingly vectorized quaternion multiplication
  51:     vec4 a = q1.w * q2.xyzw;
  52:     vec4 b = q1.x * q2.wzxy * vec4(1., -1., 1., -1.);
  53:     vec4 c = q1.y * q2.zwxy * vec4(1., 1., -1., -1.);
  54:     vec4 d = q1.z * q2.yxwz * vec4(-1., 1., 1., -1.);
  55: 
  56:     return a + b + c + d;
  57: }
  58: 
  59: vec3 rotateVertexByQuat(vec3 v, vec4 q) {
  60:     vec3 i = q.xyz;
  61:     return v + 2.0 * cross(i, cross(i, v) + q.w * v);
  62: }
  63: 
  64: vec3 rotateAbout(vec3 v, vec3 axis, float angle) {
  65:     return rotateVertexByQuat(v, quat(axis, angle));
  66: }
  67: 
  68: mat4 rotate(vec3 axis, float angle) {
  69:     float s = sin(angle);
  70:     float c = cos(angle);
  71:     float oc = 1. - c;
  72: 
  73:     vec3 sa = axis * s;
  74: 
  75:     mat4 mr = mat4(1.);
  76:     mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
  77:     mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
  78:     mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);
  79: 
  80:     return mr;
  81: }
  82: 
  83: mat4 rotation(vec3 rot) {
  84:     return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
  85: }
  86: 
  87: mat3 modelToNormal(mat4 mat) {
  88:     // Discard the edges. This won't be accurate for scaled or skewed matrices,
  89:     // but we don't have to work with those often.
  90:     mat3 m;
  91:     m[0] = mat[0].xyz;
  92:     m[1] = mat[1].xyz;
  93:     m[2] = mat[2].xyz;
  94:     return m;
  95: }
  96: 
  97: float diffuse(vec3 normal) {
  98:     vec3 n2 = normal * normal * vec3(.6, .25, .8);
  99:     return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
 100: }
 101: 
 102: 
 103: struct Belt {
 104:     vec2 light;
 105:     vec4 color;
 106:     vec3 pos;
 107:     float speed;
 108:     float offset;
 109:     vec4 rotation;
 110:     vec2 sourceTexture;
 111:     vec4 scrollTexture;
 112:     float scrollMult;
 113: };
 114: 
 115: 
 116: struct Vertex {
 117:     vec3 pos;
 118:     vec3 normal;
 119:     vec2 texCoords;
 120: };
 121: 
 122: struct BlockFrag {
 123:     vec2 texCoords;
 124:     vec4 color;
 125:     float diffuse;
 126:     vec2 light;
 127: };
 128: 
 129: BlockFrag FLWMain(Vertex v, Belt instance) {
 130:     vec3 rotated = rotateVertexByQuat(v.pos - .5, instance.rotation) + instance.pos + .5;
 131: 
 132:     vec4 worldPos = vec4(rotated, 1.);
 133: 
 134:     vec3 norm = rotateVertexByQuat(v.normal, instance.rotation);
 135: 
 136:     FLWFinalizeWorldPos(worldPos);
 137:     FLWFinalizeNormal(norm);
 138: 
 139:     float scrollSize = instance.scrollTexture.w - instance.scrollTexture.y;
 140:     float scroll = fract(instance.speed * uTime / (31.5 * 16.) + instance.offset) * scrollSize * instance.scrollMult;
 141: 
 142:     BlockFrag b;
 143:     b.diffuse = diffuse(norm);
 144:     b.texCoords = v.texCoords - instance.sourceTexture + instance.scrollTexture.xy + vec2(0, scroll);
 145:     b.light = instance.light;
 146: 
 147:     #if defined(DEBUG_RAINBOW)
 148:     b.color = instance.color;
 149:     #elif defined(DEBUG_NORMAL)
 150:     b.color = vec4(norm, 1.);
 151:     #else
 152:     b.color = vec4(1.);
 153:     #endif
 154: 
 155:     return b;
 156: }
 157: attribute vec3 a_v_pos;
 158: attribute vec3 a_v_normal;
 159: attribute vec2 a_v_texCoords;
 160: 
 161: attribute vec2 a_i_light;
 162: attribute vec4 a_i_color;
 163: attribute vec3 a_i_pos;
 164: attribute float a_i_speed;
 165: attribute float a_i_offset;
 166: attribute vec4 a_i_rotation;
 167: attribute vec2 a_i_sourceTexture;
 168: attribute vec4 a_i_scrollTexture;
 169: attribute float a_i_scrollMult;
 170: 
 171: 
 172: varying vec2 v2f_texCoords;
 173: varying vec4 v2f_color;
 174: varying float v2f_diffuse;
 175: varying vec2 v2f_light;
 176: 
 177: 
 178: void main() {
 179:     Vertex v;
 180:     v.pos = a_v_pos;
 181: v.normal = a_v_normal;
 182: v.texCoords = a_v_texCoords;
 183: 
 184: 
 185:     Belt i;
 186:     i.light = a_i_light;
 187: i.color = a_i_color;
 188: i.pos = a_i_pos;
 189: i.speed = a_i_speed;
 190: i.offset = a_i_offset;
 191: i.rotation = a_i_rotation;
 192: i.sourceTexture = a_i_sourceTexture;
 193: i.scrollTexture = a_i_scrollTexture;
 194: i.scrollMult = a_i_scrollMult;
 195: 
 196: 
 197:     BlockFrag o = FLWMain(v, i);
 198: 
 199:     v2f_texCoords = o.texCoords;
 200: v2f_color = o.color;
 201: v2f_diffuse = o.diffuse;
 202: v2f_light = o.light;
 203: 
 204: }

[13:33:09] [main/ERROR]: Shader compilation log for flywheel:block.frag: No errors.

[13:33:09] [main/ERROR]: Source for shader 'flywheel:block.frag':
   1: #version 110
   2: 
   3: #if defined(USE_FOG)
   4: varying float FragDistance;
   5: uniform vec4 uFogColor;
   6: #endif
   7: 
   8: #if defined(USE_FOG_LINEAR)
   9: uniform vec2 uFogRange;
  10: 
  11: float FLWFogFactor() {
  12:     return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
  13: }
  14:     #endif
  15: 
  16:     #if defined(USE_FOG_EXP2)
  17: uniform float uFogDensity;
  18: 
  19: float FLWFogFactor() {
  20:     float dist = FragDistance * uFogDensity;
  21:     return 1. / exp2(dist * dist);
  22: }
  23:     #endif
  24: // Adjust the [0,1] normalized lightmap value based on the texture matrix from LightTexture#enableLightmap
  25: vec2 shiftLight(vec2 lm) {
  26:     return lm * 0.99609375 + 0.03125;// * 255/256 + 1/32
  27: }
  28: 
  29: varying vec3 BoxCoord;
  30: varying vec2 BoxLight;
  31: uniform sampler3D uLightVolume;
  32: 
  33: uniform sampler2D uBlockAtlas;
  34: uniform sampler2D uLightMap;
  35: 
  36: vec4 FLWBlockTexture(vec2 texCoords) {
  37:     return texture2D(uBlockAtlas, texCoords);
  38: }
  39: 
  40: void FLWFinalizeColor(vec4 color) {
  41:     #if defined(USE_FOG)
  42:     float a = color.a;
  43:     float fog = clamp(FLWFogFactor(), 0., 1.);
  44: 
  45:     color = mix(uFogColor, color, fog);
  46:     color.a = a;
  47:     #endif
  48: 
  49:     gl_FragColor = color;
  50: }
  51: 
  52: vec4 FLWLight(vec2 lightCoords) {
  53:     lightCoords = max(lightCoords, texture3D(uLightVolume, BoxCoord).rg);
  54: 
  55:     return texture2D(uLightMap, shiftLight(lightCoords));
  56: }
  57: 
  58: 
  59: 
  60: struct BlockFrag {
  61:     vec2 texCoords;
  62:     vec4 color;
  63:     float diffuse;
  64:     vec2 light;
  65: };
  66: 
  67: void FLWMain(BlockFrag r) {
  68:     vec4 tex = FLWBlockTexture(r.texCoords);
  69: 
  70:     vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;
  71: 
  72: //    flw_WorldPos = ;
  73: //    flw_Normal = ;
  74: //    flw_Albedo = tex.rgb;
  75: //    flw_Alpha = tex.a;
  76: //    flw_LightMap = r.light;
  77: //    flw_Tint = r.color;
  78:     FLWFinalizeColor(color);
  79: }
  80: 
  81: varying vec2 v2f_texCoords;
  82: varying vec4 v2f_color;
  83: varying float v2f_diffuse;
  84: varying vec2 v2f_light;
  85: 
  86: 
  87: //vec3 flw_WorldPos;
  88: //vec3 flw_Normal;
  89: //vec3 flw_Albedo;
  90: //float flw_Alpha;
  91: //vec2 flw_LightMap;
  92: //vec4 flw_Tint;
  93: 
  94: void main() {
  95:     BlockFrag f;
  96:     f.texCoords = v2f_texCoords;
  97: f.color = v2f_color;
  98: f.diffuse = v2f_diffuse;
  99: f.light = v2f_light;
 100: 
 101: 
 102:     FLWMain(f);
 103: }

[13:33:09] [main/ERROR]: Shader compilation log for flywheel:oriented.vert: No errors.

[13:33:09] [main/ERROR]: Source for shader 'flywheel:oriented.vert':
   1: #version 110
   2: #define DEBUG_NORMAL
   3: 
   4: #if defined(USE_FOG)
   5: varying float FragDistance;
   6: #endif
   7: 
   8: varying vec3 BoxCoord;
   9: 
  10: uniform vec3 uLightBoxSize;
  11: uniform vec3 uLightBoxMin;
  12: uniform mat4 uModel;
  13: 
  14: uniform float uTime;
  15: uniform mat4 uViewProjection;
  16: uniform vec3 uCameraPos;
  17: 
  18: void FLWFinalizeWorldPos(inout vec4 worldPos) {
  19:     worldPos = uModel * worldPos;
  20: 
  21:     BoxCoord = (worldPos.xyz - uLightBoxMin) / uLightBoxSize;
  22: 
  23:     #if defined(USE_FOG)
  24:     FragDistance = length(worldPos.xyz);
  25:     #endif
  26: 
  27:     gl_Position = uViewProjection * worldPos;
  28: }
  29: 
  30: void FLWFinalizeNormal(inout vec3 normal) {
  31:     mat3 m;
  32:     m[0] = uModel[0].xyz;
  33:     m[1] = uModel[1].xyz;
  34:     m[2] = uModel[2].xyz;
  35:     normal = m * normal;
  36: }
  37: 
  38: 
  39: 
  40: mat4 rotate(vec3 axis, float angle) {
  41:     float s = sin(angle);
  42:     float c = cos(angle);
  43:     float oc = 1. - c;
  44: 
  45:     vec3 sa = axis * s;
  46: 
  47:     mat4 mr = mat4(1.);
  48:     mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
  49:     mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
  50:     mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);
  51: 
  52:     return mr;
  53: }
  54: 
  55: mat4 rotation(vec3 rot) {
  56:     return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
  57: }
  58: 
  59: mat3 modelToNormal(mat4 mat) {
  60:     // Discard the edges. This won't be accurate for scaled or skewed matrices,
  61:     // but we don't have to work with those often.
  62:     mat3 m;
  63:     m[0] = mat[0].xyz;
  64:     m[1] = mat[1].xyz;
  65:     m[2] = mat[2].xyz;
  66:     return m;
  67: }
  68: 
  69: #define PIOVER2 1.5707963268
  70: 
  71: vec4 quat(vec3 axis, float angle) {
  72:     float halfAngle = angle * PIOVER2 / 180.0;
  73:     vec2 cs = sin(vec2(PIOVER2 - halfAngle, halfAngle)); // compute sin and cos in one instruction
  74:     return vec4(axis.xyz * cs.y,  cs.x);
  75: }
  76: 
  77: vec4 quatMult(vec4 q1, vec4 q2) {
  78:     // disgustingly vectorized quaternion multiplication
  79:     vec4 a = q1.w * q2.xyzw;
  80:     vec4 b = q1.x * q2.wzxy * vec4(1., -1., 1., -1.);
  81:     vec4 c = q1.y * q2.zwxy * vec4(1., 1., -1., -1.);
  82:     vec4 d = q1.z * q2.yxwz * vec4(-1., 1., 1., -1.);
  83: 
  84:     return a + b + c + d;
  85: }
  86: 
  87: vec3 rotateVertexByQuat(vec3 v, vec4 q) {
  88:     vec3 i = q.xyz;
  89:     return v + 2.0 * cross(i, cross(i, v) + q.w * v);
  90: }
  91: 
  92: vec3 rotateAbout(vec3 v, vec3 axis, float angle) {
  93:     return rotateVertexByQuat(v, quat(axis, angle));
  94: }
  95: 
  96: float diffuse(vec3 normal) {
  97:     vec3 n2 = normal * normal * vec3(.6, .25, .8);
  98:     return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
  99: }
 100: 
 101: 
 102: struct Oriented {
 103:     vec2 light;
 104:     vec4 color;
 105:     vec3 pos;
 106:     vec3 pivot;
 107:     vec4 rotation;
 108: };
 109: 
 110: 
 111: struct Vertex {
 112:     vec3 pos;
 113:     vec3 normal;
 114:     vec2 texCoords;
 115: };
 116: 
 117: struct BlockFrag {
 118:     vec2 texCoords;
 119:     vec4 color;
 120:     float diffuse;
 121:     vec2 light;
 122: };
 123: 
 124: BlockFrag FLWMain(Vertex v, Oriented o) {
 125:     vec4 worldPos = vec4(rotateVertexByQuat(v.pos - o.pivot, o.rotation) + o.pivot + o.pos, 1.);
 126: 
 127:     vec3 norm = rotateVertexByQuat(v.normal, o.rotation);
 128: 
 129:     FLWFinalizeWorldPos(worldPos);
 130:     FLWFinalizeNormal(norm);
 131: 
 132:     BlockFrag b;
 133:     b.diffuse = diffuse(norm);
 134:     b.texCoords = v.texCoords;
 135:     b.light = o.light;
 136:     #if defined(DEBUG_NORMAL)
 137:     b.color = vec4(norm, 1.);
 138:     #else
 139:     b.color = o.color;
 140:     #endif
 141:     return b;
 142: }
 143: attribute vec3 a_v_pos;
 144: attribute vec3 a_v_normal;
 145: attribute vec2 a_v_texCoords;
 146: 
 147: attribute vec2 a_i_light;
 148: attribute vec4 a_i_color;
 149: attribute vec3 a_i_pos;
 150: attribute vec3 a_i_pivot;
 151: attribute vec4 a_i_rotation;
 152: 
 153: 
 154: varying vec2 v2f_texCoords;
 155: varying vec4 v2f_color;
 156: varying float v2f_diffuse;
 157: varying vec2 v2f_light;
 158: 
 159: 
 160: void main() {
 161:     Vertex v;
 162:     v.pos = a_v_pos;
 163: v.normal = a_v_normal;
 164: v.texCoords = a_v_texCoords;
 165: 
 166: 
 167:     Oriented i;
 168:     i.light = a_i_light;
 169: i.color = a_i_color;
 170: i.pos = a_i_pos;
 171: i.pivot = a_i_pivot;
 172: i.rotation = a_i_rotation;
 173: 
 174: 
 175:     BlockFrag o = FLWMain(v, i);
 176: 
 177:     v2f_texCoords = o.texCoords;
 178: v2f_color = o.color;
 179: v2f_diffuse = o.diffuse;
 180: v2f_light = o.light;
 181: 
 182: }

[13:33:09] [main/ERROR]: Shader compilation log for flywheel:block.frag: No errors.

[13:33:09] [main/ERROR]: Source for shader 'flywheel:block.frag':
   1: #version 110
   2: #define DEBUG_NORMAL
   3: 
   4: #if defined(USE_FOG)
   5: varying float FragDistance;
   6: uniform vec4 uFogColor;
   7: #endif
   8: 
   9: #if defined(USE_FOG_LINEAR)
  10: uniform vec2 uFogRange;
  11: 
  12: float FLWFogFactor() {
  13:     return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
  14: }
  15:     #endif
  16: 
  17:     #if defined(USE_FOG_EXP2)
  18: uniform float uFogDensity;
  19: 
  20: float FLWFogFactor() {
  21:     float dist = FragDistance * uFogDensity;
  22:     return 1. / exp2(dist * dist);
  23: }
  24:     #endif
  25: // Adjust the [0,1] normalized lightmap value based on the texture matrix from LightTexture#enableLightmap
  26: vec2 shiftLight(vec2 lm) {
  27:     return lm * 0.99609375 + 0.03125;// * 255/256 + 1/32
  28: }
  29: 
  30: varying vec3 BoxCoord;
  31: varying vec2 BoxLight;
  32: uniform sampler3D uLightVolume;
  33: 
  34: uniform sampler2D uBlockAtlas;
  35: uniform sampler2D uLightMap;
  36: 
  37: vec4 FLWBlockTexture(vec2 texCoords) {
  38:     return texture2D(uBlockAtlas, texCoords);
  39: }
  40: 
  41: void FLWFinalizeColor(vec4 color) {
  42:     #if defined(USE_FOG)
  43:     float a = color.a;
  44:     float fog = clamp(FLWFogFactor(), 0., 1.);
  45: 
  46:     color = mix(uFogColor, color, fog);
  47:     color.a = a;
  48:     #endif
  49: 
  50:     gl_FragColor = color;
  51: }
  52: 
  53: vec4 FLWLight(vec2 lightCoords) {
  54:     lightCoords = max(lightCoords, texture3D(uLightVolume, BoxCoord).rg);
  55: 
  56:     return texture2D(uLightMap, shiftLight(lightCoords));
  57: }
  58: 
  59: 
  60: 
  61: struct BlockFrag {
  62:     vec2 texCoords;
  63:     vec4 color;
  64:     float diffuse;
  65:     vec2 light;
  66: };
  67: 
  68: void FLWMain(BlockFrag r) {
  69:     vec4 tex = FLWBlockTexture(r.texCoords);
  70: 
  71:     vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;
  72: 
  73: //    flw_WorldPos = ;
  74: //    flw_Normal = ;
  75: //    flw_Albedo = tex.rgb;
  76: //    flw_Alpha = tex.a;
  77: //    flw_LightMap = r.light;
  78: //    flw_Tint = r.color;
  79:     FLWFinalizeColor(color);
  80: }
  81: 
  82: varying vec2 v2f_texCoords;
  83: varying vec4 v2f_color;
  84: varying float v2f_diffuse;
  85: varying vec2 v2f_light;
  86: 
  87: 
  88: //vec3 flw_WorldPos;
  89: //vec3 flw_Normal;
  90: //vec3 flw_Albedo;
  91: //float flw_Alpha;
  92: //vec2 flw_LightMap;
  93: //vec4 flw_Tint;
  94: 
  95: void main() {
  96:     BlockFrag f;
  97:     f.texCoords = v2f_texCoords;
  98: f.color = v2f_color;
  99: f.diffuse = v2f_diffuse;
 100: f.light = v2f_light;
 101: 
 102: 
 103:     FLWMain(f);
 104: }

[13:33:09] [main/ERROR]: Shader compilation log for flywheel:oriented.vert: No errors.

[13:33:09] [main/ERROR]: Source for shader 'flywheel:oriented.vert':
   1: #version 110
   2: #define USE_FOG
   3: #define USE_FOG_LINEAR
   4: 
   5: #if defined(USE_FOG)
   6: varying float FragDistance;
   7: #endif
   8: 
   9: varying vec3 BoxCoord;
  10: 
  11: uniform vec3 uLightBoxSize;
  12: uniform vec3 uLightBoxMin;
  13: uniform mat4 uModel;
  14: 
  15: uniform float uTime;
  16: uniform mat4 uViewProjection;
  17: uniform vec3 uCameraPos;
  18: 
  19: void FLWFinalizeWorldPos(inout vec4 worldPos) {
  20:     worldPos = uModel * worldPos;
  21: 
  22:     BoxCoord = (worldPos.xyz - uLightBoxMin) / uLightBoxSize;
  23: 
  24:     #if defined(USE_FOG)
  25:     FragDistance = length(worldPos.xyz);
  26:     #endif
  27: 
  28:     gl_Position = uViewProjection * worldPos;
  29: }
  30: 
  31: void FLWFinalizeNormal(inout vec3 normal) {
  32:     mat3 m;
  33:     m[0] = uModel[0].xyz;
  34:     m[1] = uModel[1].xyz;
  35:     m[2] = uModel[2].xyz;
  36:     normal = m * normal;
  37: }
  38: 
  39: 
  40: 
  41: mat4 rotate(vec3 axis, float angle) {
  42:     float s = sin(angle);
  43:     float c = cos(angle);
  44:     float oc = 1. - c;
  45: 
  46:     vec3 sa = axis * s;
  47: 
  48:     mat4 mr = mat4(1.);
  49:     mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
  50:     mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
  51:     mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);
  52: 
  53:     return mr;
  54: }
  55: 
  56: mat4 rotation(vec3 rot) {
  57:     return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
  58: }
  59: 
  60: mat3 modelToNormal(mat4 mat) {
  61:     // Discard the edges. This won't be accurate for scaled or skewed matrices,
  62:     // but we don't have to work with those often.
  63:     mat3 m;
  64:     m[0] = mat[0].xyz;
  65:     m[1] = mat[1].xyz;
  66:     m[2] = mat[2].xyz;
  67:     return m;
  68: }
  69: 
  70: #define PIOVER2 1.5707963268
  71: 
  72: vec4 quat(vec3 axis, float angle) {
  73:     float halfAngle = angle * PIOVER2 / 180.0;
  74:     vec2 cs = sin(vec2(PIOVER2 - halfAngle, halfAngle)); // compute sin and cos in one instruction
  75:     return vec4(axis.xyz * cs.y,  cs.x);
  76: }
  77: 
  78: vec4 quatMult(vec4 q1, vec4 q2) {
  79:     // disgustingly vectorized quaternion multiplication
  80:     vec4 a = q1.w * q2.xyzw;
  81:     vec4 b = q1.x * q2.wzxy * vec4(1., -1., 1., -1.);
  82:     vec4 c = q1.y * q2.zwxy * vec4(1., 1., -1., -1.);
  83:     vec4 d = q1.z * q2.yxwz * vec4(-1., 1., 1., -1.);
  84: 
  85:     return a + b + c + d;
  86: }
  87: 
  88: vec3 rotateVertexByQuat(vec3 v, vec4 q) {
  89:     vec3 i = q.xyz;
  90:     return v + 2.0 * cross(i, cross(i, v) + q.w * v);
  91: }
  92: 
  93: vec3 rotateAbout(vec3 v, vec3 axis, float angle) {
  94:     return rotateVertexByQuat(v, quat(axis, angle));
  95: }
  96: 
  97: float diffuse(vec3 normal) {
  98:     vec3 n2 = normal * normal * vec3(.6, .25, .8);
  99:     return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
 100: }
 101: 
 102: 
 103: struct Oriented {
 104:     vec2 light;
 105:     vec4 color;
 106:     vec3 pos;
 107:     vec3 pivot;
 108:     vec4 rotation;
 109: };
 110: 
 111: 
 112: struct Vertex {
 113:     vec3 pos;
 114:     vec3 normal;
 115:     vec2 texCoords;
 116: };
 117: 
 118: struct BlockFrag {
 119:     vec2 texCoords;
 120:     vec4 color;
 121:     float diffuse;
 122:     vec2 light;
 123: };
 124: 
 125: BlockFrag FLWMain(Vertex v, Oriented o) {
 126:     vec4 worldPos = vec4(rotateVertexByQuat(v.pos - o.pivot, o.rotation) + o.pivot + o.pos, 1.);
 127: 
 128:     vec3 norm = rotateVertexByQuat(v.normal, o.rotation);
 129: 
 130:     FLWFinalizeWorldPos(worldPos);
 131:     FLWFinalizeNormal(norm);
 132: 
 133:     BlockFrag b;
 134:     b.diffuse = diffuse(norm);
 135:     b.texCoords = v.texCoords;
 136:     b.light = o.light;
 137:     #if defined(DEBUG_NORMAL)
 138:     b.color = vec4(norm, 1.);
 139:     #else
 140:     b.color = o.color;
 141:     #endif
 142:     return b;
 143: }
 144: attribute vec3 a_v_pos;
 145: attribute vec3 a_v_normal;
 146: attribute vec2 a_v_texCoords;
 147: 
 148: attribute vec2 a_i_light;
 149: attribute vec4 a_i_color;
 150: attribute vec3 a_i_pos;
 151: attribute vec3 a_i_pivot;
 152: attribute vec4 a_i_rotation;
 153: 
 154: 
 155: varying vec2 v2f_texCoords;
 156: varying vec4 v2f_color;
 157: varying float v2f_diffuse;
 158: varying vec2 v2f_light;
 159: 
 160: 
 161: void main() {
 162:     Vertex v;
 163:     v.pos = a_v_pos;
 164: v.normal = a_v_normal;
 165: v.texCoords = a_v_texCoords;
 166: 
 167: 
 168:     Oriented i;
 169:     i.light = a_i_light;
 170: i.color = a_i_color;
 171: i.pos = a_i_pos;
 172: i.pivot = a_i_pivot;
 173: i.rotation = a_i_rotation;
 174: 
 175: 
 176:     BlockFrag o = FLWMain(v, i);
 177: 
 178:     v2f_texCoords = o.texCoords;
 179: v2f_color = o.color;
 180: v2f_diffuse = o.diffuse;
 181: v2f_light = o.light;
 182: 
 183: }

[13:33:09] [main/ERROR]: Shader compilation log for flywheel:block.frag: No errors.

[13:33:09] [main/ERROR]: Source for shader 'flywheel:block.frag':
   1: #version 110
   2: #define USE_FOG
   3: #define USE_FOG_LINEAR
   4: 
   5: #if defined(USE_FOG)
   6: varying float FragDistance;
   7: uniform vec4 uFogColor;
   8: #endif
   9: 
  10: #if defined(USE_FOG_LINEAR)
  11: uniform vec2 uFogRange;
  12: 
  13: float FLWFogFactor() {
  14:     return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
  15: }
  16:     #endif
  17: 
  18:     #if defined(USE_FOG_EXP2)
  19: uniform float uFogDensity;
  20: 
  21: float FLWFogFactor() {
  22:     float dist = FragDistance * uFogDensity;
  23:     return 1. / exp2(dist * dist);
  24: }
  25:     #endif
  26: // Adjust the [0,1] normalized lightmap value based on the texture matrix from LightTexture#enableLightmap
  27: vec2 shiftLight(vec2 lm) {
  28:     return lm * 0.99609375 + 0.03125;// * 255/256 + 1/32
  29: }
  30: 
  31: varying vec3 BoxCoord;
  32: varying vec2 BoxLight;
  33: uniform sampler3D uLightVolume;
  34: 
  35: uniform sampler2D uBlockAtlas;
  36: uniform sampler2D uLightMap;
  37: 
  38: vec4 FLWBlockTexture(vec2 texCoords) {
  39:     return texture2D(uBlockAtlas, texCoords);
  40: }
  41: 
  42: void FLWFinalizeColor(vec4 color) {
  43:     #if defined(USE_FOG)
  44:     float a = color.a;
  45:     float fog = clamp(FLWFogFactor(), 0., 1.);
  46: 
  47:     color = mix(uFogColor, color, fog);
  48:     color.a = a;
  49:     #endif
  50: 
  51:     gl_FragColor = color;
  52: }
  53: 
  54: vec4 FLWLight(vec2 lightCoords) {
  55:     lightCoords = max(lightCoords, texture3D(uLightVolume, BoxCoord).rg);
  56: 
  57:     return texture2D(uLightMap, shiftLight(lightCoords));
  58: }
  59: 
  60: 
  61: 
  62: struct BlockFrag {
  63:     vec2 texCoords;
  64:     vec4 color;
  65:     float diffuse;
  66:     vec2 light;
  67: };
  68: 
  69: void FLWMain(BlockFrag r) {
  70:     vec4 tex = FLWBlockTexture(r.texCoords);
  71: 
  72:     vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;
  73: 
  74: //    flw_WorldPos = ;
  75: //    flw_Normal = ;
  76: //    flw_Albedo = tex.rgb;
  77: //    flw_Alpha = tex.a;
  78: //    flw_LightMap = r.light;
  79: //    flw_Tint = r.color;
  80:     FLWFinalizeColor(color);
  81: }
  82: 
  83: varying vec2 v2f_texCoords;
  84: varying vec4 v2f_color;
  85: varying float v2f_diffuse;
  86: varying vec2 v2f_light;
  87: 
  88: 
  89: //vec3 flw_WorldPos;
  90: //vec3 flw_Normal;
  91: //vec3 flw_Albedo;
  92: //float flw_Alpha;
  93: //vec2 flw_LightMap;
  94: //vec4 flw_Tint;
  95: 
  96: void main() {
  97:     BlockFrag f;
  98:     f.texCoords = v2f_texCoords;
  99: f.color = v2f_color;
 100: f.diffuse = v2f_diffuse;
 101: f.light = v2f_light;
 102: 
 103: 
 104:     FLWMain(f);
 105: }

[13:33:09] [main/ERROR]: Shader compilation log for flywheel:oriented.vert: No errors.

[13:33:09] [main/ERROR]: Source for shader 'flywheel:oriented.vert':
   1: #version 110
   2: #define USE_FOG
   3: #define USE_FOG_EXP2
   4: 
   5: #if defined(USE_FOG)
   6: varying float FragDistance;
   7: #endif
   8: 
   9: varying vec3 BoxCoord;
  10: 
  11: uniform vec3 uLightBoxSize;
  12: uniform vec3 uLightBoxMin;
  13: uniform mat4 uModel;
  14: 
  15: uniform float uTime;
  16: uniform mat4 uViewProjection;
  17: uniform vec3 uCameraPos;
  18: 
  19: void FLWFinalizeWorldPos(inout vec4 worldPos) {
  20:     worldPos = uModel * worldPos;
  21: 
  22:     BoxCoord = (worldPos.xyz - uLightBoxMin) / uLightBoxSize;
  23: 
  24:     #if defined(USE_FOG)
  25:     FragDistance = length(worldPos.xyz);
  26:     #endif
  27: 
  28:     gl_Position = uViewProjection * worldPos;
  29: }
  30: 
  31: void FLWFinalizeNormal(inout vec3 normal) {
  32:     mat3 m;
  33:     m[0] = uModel[0].xyz;
  34:     m[1] = uModel[1].xyz;
  35:     m[2] = uModel[2].xyz;
  36:     normal = m * normal;
  37: }
  38: 
  39: 
  40: 
  41: mat4 rotate(vec3 axis, float angle) {
  42:     float s = sin(angle);
  43:     float c = cos(angle);
  44:     float oc = 1. - c;
  45: 
  46:     vec3 sa = axis * s;
  47: 
  48:     mat4 mr = mat4(1.);
  49:     mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
  50:     mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
  51:     mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);
  52: 
  53:     return mr;
  54: }
  55: 
  56: mat4 rotation(vec3 rot) {
  57:     return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
  58: }
  59: 
  60: mat3 modelToNormal(mat4 mat) {
  61:     // Discard the edges. This won't be accurate for scaled or skewed matrices,
  62:     // but we don't have to work with those often.
  63:     mat3 m;
  64:     m[0] = mat[0].xyz;
  65:     m[1] = mat[1].xyz;
  66:     m[2] = mat[2].xyz;
  67:     return m;
  68: }
  69: 
  70: #define PIOVER2 1.5707963268
  71: 
  72: vec4 quat(vec3 axis, float angle) {
  73:     float halfAngle = angle * PIOVER2 / 180.0;
  74:     vec2 cs = sin(vec2(PIOVER2 - halfAngle, halfAngle)); // compute sin and cos in one instruction
  75:     return vec4(axis.xyz * cs.y,  cs.x);
  76: }
  77: 
  78: vec4 quatMult(vec4 q1, vec4 q2) {
  79:     // disgustingly vectorized quaternion multiplication
  80:     vec4 a = q1.w * q2.xyzw;
  81:     vec4 b = q1.x * q2.wzxy * vec4(1., -1., 1., -1.);
  82:     vec4 c = q1.y * q2.zwxy * vec4(1., 1., -1., -1.);
  83:     vec4 d = q1.z * q2.yxwz * vec4(-1., 1., 1., -1.);
  84: 
  85:     return a + b + c + d;
  86: }
  87: 
  88: vec3 rotateVertexByQuat(vec3 v, vec4 q) {
  89:     vec3 i = q.xyz;
  90:     return v + 2.0 * cross(i, cross(i, v) + q.w * v);
  91: }
  92: 
  93: vec3 rotateAbout(vec3 v, vec3 axis, float angle) {
  94:     return rotateVertexByQuat(v, quat(axis, angle));
  95: }
  96: 
  97: float diffuse(vec3 normal) {
  98:     vec3 n2 = normal * normal * vec3(.6, .25, .8);
  99:     return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
 100: }
 101: 
 102: 
 103: struct Oriented {
 104:     vec2 light;
 105:     vec4 color;
 106:     vec3 pos;
 107:     vec3 pivot;
 108:     vec4 rotation;
 109: };
 110: 
 111: 
 112: struct Vertex {
 113:     vec3 pos;
 114:     vec3 normal;
 115:     vec2 texCoords;
 116: };
 117: 
 118: struct BlockFrag {
 119:     vec2 texCoords;
 120:     vec4 color;
 121:     float diffuse;
 122:     vec2 light;
 123: };
 124: 
 125: BlockFrag FLWMain(Vertex v, Oriented o) {
 126:     vec4 worldPos = vec4(rotateVertexByQuat(v.pos - o.pivot, o.rotation) + o.pivot + o.pos, 1.);
 127: 
 128:     vec3 norm = rotateVertexByQuat(v.normal, o.rotation);
 129: 
 130:     FLWFinalizeWorldPos(worldPos);
 131:     FLWFinalizeNormal(norm);
 132: 
 133:     BlockFrag b;
 134:     b.diffuse = diffuse(norm);
 135:     b.texCoords = v.texCoords;
 136:     b.light = o.light;
 137:     #if defined(DEBUG_NORMAL)
 138:     b.color = vec4(norm, 1.);
 139:     #else
 140:     b.color = o.color;
 141:     #endif
 142:     return b;
 143: }
 144: attribute vec3 a_v_pos;
 145: attribute vec3 a_v_normal;
 146: attribute vec2 a_v_texCoords;
 147: 
 148: attribute vec2 a_i_light;
 149: attribute vec4 a_i_color;
 150: attribute vec3 a_i_pos;
 151: attribute vec3 a_i_pivot;
 152: attribute vec4 a_i_rotation;
 153: 
 154: 
 155: varying vec2 v2f_texCoords;
 156: varying vec4 v2f_color;
 157: varying float v2f_diffuse;
 158: varying vec2 v2f_light;
 159: 
 160: 
 161: void main() {
 162:     Vertex v;
 163:     v.pos = a_v_pos;
 164: v.normal = a_v_normal;
 165: v.texCoords = a_v_texCoords;
 166: 
 167: 
 168:     Oriented i;
 169:     i.light = a_i_light;
 170: i.color = a_i_color;
 171: i.pos = a_i_pos;
 172: i.pivot = a_i_pivot;
 173: i.rotation = a_i_rotation;
 174: 
 175: 
 176:     BlockFrag o = FLWMain(v, i);
 177: 
 178:     v2f_texCoords = o.texCoords;
 179: v2f_color = o.color;
 180: v2f_diffuse = o.diffuse;
 181: v2f_light = o.light;
 182: 
 183: }

[13:33:09] [main/ERROR]: Shader compilation log for flywheel:block.frag: No errors.

[13:33:09] [main/ERROR]: Source for shader 'flywheel:block.frag':
   1: #version 110
   2: #define USE_FOG
   3: #define USE_FOG_EXP2
   4: 
   5: #if defined(USE_FOG)
   6: varying float FragDistance;
   7: uniform vec4 uFogColor;
   8: #endif
   9: 
  10: #if defined(USE_FOG_LINEAR)
  11: uniform vec2 uFogRange;
  12: 
  13: float FLWFogFactor() {
  14:     return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
  15: }
  16:     #endif
  17: 
  18:     #if defined(USE_FOG_EXP2)
  19: uniform float uFogDensity;
  20: 
  21: float FLWFogFactor() {
  22:     float dist = FragDistance * uFogDensity;
  23:     return 1. / exp2(dist * dist);
  24: }
  25:     #endif
  26: // Adjust the [0,1] normalized lightmap value based on the texture matrix from LightTexture#enableLightmap
  27: vec2 shiftLight(vec2 lm) {
  28:     return lm * 0.99609375 + 0.03125;// * 255/256 + 1/32
  29: }
  30: 
  31: varying vec3 BoxCoord;
  32: varying vec2 BoxLight;
  33: uniform sampler3D uLightVolume;
  34: 
  35: uniform sampler2D uBlockAtlas;
  36: uniform sampler2D uLightMap;
  37: 
  38: vec4 FLWBlockTexture(vec2 texCoords) {
  39:     return texture2D(uBlockAtlas, texCoords);
  40: }
  41: 
  42: void FLWFinalizeColor(vec4 color) {
  43:     #if defined(USE_FOG)
  44:     float a = color.a;
  45:     float fog = clamp(FLWFogFactor(), 0., 1.);
  46: 
  47:     color = mix(uFogColor, color, fog);
  48:     color.a = a;
  49:     #endif
  50: 
  51:     gl_FragColor = color;
  52: }
  53: 
  54: vec4 FLWLight(vec2 lightCoords) {
  55:     lightCoords = max(lightCoords, texture3D(uLightVolume, BoxCoord).rg);
  56: 
  57:     return texture2D(uLightMap, shiftLight(lightCoords));
  58: }
  59: 
  60: 
  61: 
  62: struct BlockFrag {
  63:     vec2 texCoords;
  64:     vec4 color;
  65:     float diffuse;
  66:     vec2 light;
  67: };
  68: 
  69: void FLWMain(BlockFrag r) {
  70:     vec4 tex = FLWBlockTexture(r.texCoords);
  71: 
  72:     vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;
  73: 
  74: //    flw_WorldPos = ;
  75: //    flw_Normal = ;
  76: //    flw_Albedo = tex.rgb;
  77: //    flw_Alpha = tex.a;
  78: //    flw_LightMap = r.light;
  79: //    flw_Tint = r.color;
  80:     FLWFinalizeColor(color);
  81: }
  82: 
  83: varying vec2 v2f_texCoords;
  84: varying vec4 v2f_color;
  85: varying float v2f_diffuse;
  86: varying vec2 v2f_light;
  87: 
  88: 
  89: //vec3 flw_WorldPos;
  90: //vec3 flw_Normal;
  91: //vec3 flw_Albedo;
  92: //float flw_Alpha;
  93: //vec2 flw_LightMap;
  94: //vec4 flw_Tint;
  95: 
  96: void main() {
  97:     BlockFrag f;
  98:     f.texCoords = v2f_texCoords;
  99: f.color = v2f_color;
 100: f.diffuse = v2f_diffuse;
 101: f.light = v2f_light;
 102: 
 103: 
 104:     FLWMain(f);
 105: }

[13:33:09] [main/ERROR]: Shader compilation log for flywheel:oriented.vert: No errors.

[13:33:09] [main/ERROR]: Source for shader 'flywheel:oriented.vert':
   1: #version 110
   2: 
   3: #if defined(USE_FOG)
   4: varying float FragDistance;
   5: #endif
   6: 
   7: varying vec3 BoxCoord;
   8: 
   9: uniform vec3 uLightBoxSize;
  10: uniform vec3 uLightBoxMin;
  11: uniform mat4 uModel;
  12: 
  13: uniform float uTime;
  14: uniform mat4 uViewProjection;
  15: uniform vec3 uCameraPos;
  16: 
  17: void FLWFinalizeWorldPos(inout vec4 worldPos) {
  18:     worldPos = uModel * worldPos;
  19: 
  20:     BoxCoord = (worldPos.xyz - uLightBoxMin) / uLightBoxSize;
  21: 
  22:     #if defined(USE_FOG)
  23:     FragDistance = length(worldPos.xyz);
  24:     #endif
  25: 
  26:     gl_Position = uViewProjection * worldPos;
  27: }
  28: 
  29: void FLWFinalizeNormal(inout vec3 normal) {
  30:     mat3 m;
  31:     m[0] = uModel[0].xyz;
  32:     m[1] = uModel[1].xyz;
  33:     m[2] = uModel[2].xyz;
  34:     normal = m * normal;
  35: }
  36: 
  37: 
  38: 
  39: mat4 rotate(vec3 axis, float angle) {
  40:     float s = sin(angle);
  41:     float c = cos(angle);
  42:     float oc = 1. - c;
  43: 
  44:     vec3 sa = axis * s;
  45: 
  46:     mat4 mr = mat4(1.);
  47:     mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
  48:     mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
  49:     mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);
  50: 
  51:     return mr;
  52: }
  53: 
  54: mat4 rotation(vec3 rot) {
  55:     return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
  56: }
  57: 
  58: mat3 modelToNormal(mat4 mat) {
  59:     // Discard the edges. This won't be accurate for scaled or skewed matrices,
  60:     // but we don't have to work with those often.
  61:     mat3 m;
  62:     m[0] = mat[0].xyz;
  63:     m[1] = mat[1].xyz;
  64:     m[2] = mat[2].xyz;
  65:     return m;
  66: }
  67: 
  68: #define PIOVER2 1.5707963268
  69: 
  70: vec4 quat(vec3 axis, float angle) {
  71:     float halfAngle = angle * PIOVER2 / 180.0;
  72:     vec2 cs = sin(vec2(PIOVER2 - halfAngle, halfAngle)); // compute sin and cos in one instruction
  73:     return vec4(axis.xyz * cs.y,  cs.x);
  74: }
  75: 
  76: vec4 quatMult(vec4 q1, vec4 q2) {
  77:     // disgustingly vectorized quaternion multiplication
  78:     vec4 a = q1.w * q2.xyzw;
  79:     vec4 b = q1.x * q2.wzxy * vec4(1., -1., 1., -1.);
  80:     vec4 c = q1.y * q2.zwxy * vec4(1., 1., -1., -1.);
  81:     vec4 d = q1.z * q2.yxwz * vec4(-1., 1., 1., -1.);
  82: 
  83:     return a + b + c + d;
  84: }
  85: 
  86: vec3 rotateVertexByQuat(vec3 v, vec4 q) {
  87:     vec3 i = q.xyz;
  88:     return v + 2.0 * cross(i, cross(i, v) + q.w * v);
  89: }
  90: 
  91: vec3 rotateAbout(vec3 v, vec3 axis, float angle) {
  92:     return rotateVertexByQuat(v, quat(axis, angle));
  93: }
  94: 
  95: float diffuse(vec3 normal) {
  96:     vec3 n2 = normal * normal * vec3(.6, .25, .8);
  97:     return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
  98: }
  99: 
 100: 
 101: struct Oriented {
 102:     vec2 light;
 103:     vec4 color;
 104:     vec3 pos;
 105:     vec3 pivot;
 106:     vec4 rotation;
 107: };
 108: 
 109: 
 110: struct Vertex {
 111:     vec3 pos;
 112:     vec3 normal;
 113:     vec2 texCoords;
 114: };
 115: 
 116: struct BlockFrag {
 117:     vec2 texCoords;
 118:     vec4 color;
 119:     float diffuse;
 120:     vec2 light;
 121: };
 122: 
 123: BlockFrag FLWMain(Vertex v, Oriented o) {
 124:     vec4 worldPos = vec4(rotateVertexByQuat(v.pos - o.pivot, o.rotation) + o.pivot + o.pos, 1.);
 125: 
 126:     vec3 norm = rotateVertexByQuat(v.normal, o.rotation);
 127: 
 128:     FLWFinalizeWorldPos(worldPos);
 129:     FLWFinalizeNormal(norm);
 130: 
 131:     BlockFrag b;
 132:     b.diffuse = diffuse(norm);
 133:     b.texCoords = v.texCoords;
 134:     b.light = o.light;
 135:     #if defined(DEBUG_NORMAL)
 136:     b.color = vec4(norm, 1.);
 137:     #else
 138:     b.color = o.color;
 139:     #endif
 140:     return b;
 141: }
 142: attribute vec3 a_v_pos;
 143: attribute vec3 a_v_normal;
 144: attribute vec2 a_v_texCoords;
 145: 
 146: attribute vec2 a_i_light;
 147: attribute vec4 a_i_color;
 148: attribute vec3 a_i_pos;
 149: attribute vec3 a_i_pivot;
 150: attribute vec4 a_i_rotation;
 151: 
 152: 
 153: varying vec2 v2f_texCoords;
 154: varying vec4 v2f_color;
 155: varying float v2f_diffuse;
 156: varying vec2 v2f_light;
 157: 
 158: 
 159: void main() {
 160:     Vertex v;
 161:     v.pos = a_v_pos;
 162: v.normal = a_v_normal;
 163: v.texCoords = a_v_texCoords;
 164: 
 165: 
 166:     Oriented i;
 167:     i.light = a_i_light;
 168: i.color = a_i_color;
 169: i.pos = a_i_pos;
 170: i.pivot = a_i_pivot;
 171: i.rotation = a_i_rotation;
 172: 
 173: 
 174:     BlockFrag o = FLWMain(v, i);
 175: 
 176:     v2f_texCoords = o.texCoords;
 177: v2f_color = o.color;
 178: v2f_diffuse = o.diffuse;
 179: v2f_light = o.light;
 180: 
 181: }

[13:33:09] [main/ERROR]: Shader compilation log for flywheel:block.frag: No errors.

[13:33:09] [main/ERROR]: Source for shader 'flywheel:block.frag':
   1: #version 110
   2: 
   3: #if defined(USE_FOG)
   4: varying float FragDistance;
   5: uniform vec4 uFogColor;
   6: #endif
   7: 
   8: #if defined(USE_FOG_LINEAR)
   9: uniform vec2 uFogRange;
  10: 
  11: float FLWFogFactor() {
  12:     return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
  13: }
  14:     #endif
  15: 
  16:     #if defined(USE_FOG_EXP2)
  17: uniform float uFogDensity;
  18: 
  19: float FLWFogFactor() {
  20:     float dist = FragDistance * uFogDensity;
  21:     return 1. / exp2(dist * dist);
  22: }
  23:     #endif
  24: // Adjust the [0,1] normalized lightmap value based on the texture matrix from LightTexture#enableLightmap
  25: vec2 shiftLight(vec2 lm) {
  26:     return lm * 0.99609375 + 0.03125;// * 255/256 + 1/32
  27: }
  28: 
  29: varying vec3 BoxCoord;
  30: varying vec2 BoxLight;
  31: uniform sampler3D uLightVolume;
  32: 
  33: uniform sampler2D uBlockAtlas;
  34: uniform sampler2D uLightMap;
  35: 
  36: vec4 FLWBlockTexture(vec2 texCoords) {
  37:     return texture2D(uBlockAtlas, texCoords);
  38: }
  39: 
  40: void FLWFinalizeColor(vec4 color) {
  41:     #if defined(USE_FOG)
  42:     float a = color.a;
  43:     float fog = clamp(FLWFogFactor(), 0., 1.);
  44: 
  45:     color = mix(uFogColor, color, fog);
  46:     color.a = a;
  47:     #endif
  48: 
  49:     gl_FragColor = color;
  50: }
  51: 
  52: vec4 FLWLight(vec2 lightCoords) {
  53:     lightCoords = max(lightCoords, texture3D(uLightVolume, BoxCoord).rg);
  54: 
  55:     return texture2D(uLightMap, shiftLight(lightCoords));
  56: }
  57: 
  58: 
  59: 
  60: struct BlockFrag {
  61:     vec2 texCoords;
  62:     vec4 color;
  63:     float diffuse;
  64:     vec2 light;
  65: };
  66: 
  67: void FLWMain(BlockFrag r) {
  68:     vec4 tex = FLWBlockTexture(r.texCoords);
  69: 
  70:     vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;
  71: 
  72: //    flw_WorldPos = ;
  73: //    flw_Normal = ;
  74: //    flw_Albedo = tex.rgb;
  75: //    flw_Alpha = tex.a;
  76: //    flw_LightMap = r.light;
  77: //    flw_Tint = r.color;
  78:     FLWFinalizeColor(color);
  79: }
  80: 
  81: varying vec2 v2f_texCoords;
  82: varying vec4 v2f_color;
  83: varying float v2f_diffuse;
  84: varying vec2 v2f_light;
  85: 
  86: 
  87: //vec3 flw_WorldPos;
  88: //vec3 flw_Normal;
  89: //vec3 flw_Albedo;
  90: //float flw_Alpha;
  91: //vec2 flw_LightMap;
  92: //vec4 flw_Tint;
  93: 
  94: void main() {
  95:     BlockFrag f;
  96:     f.texCoords = v2f_texCoords;
  97: f.color = v2f_color;
  98: f.diffuse = v2f_diffuse;
  99: f.light = v2f_light;
 100: 
 101: 
 102:     FLWMain(f);
 103: }

[13:33:09] [main/ERROR]: Shader compilation log for flywheel:model.vert: No errors.

[13:33:09] [main/ERROR]: Source for shader 'flywheel:model.vert':
   1: #version 110
   2: #define DEBUG_NORMAL
   3: 
   4: #if defined(USE_FOG)
   5: varying float FragDistance;
   6: #endif
   7: 
   8: varying vec3 BoxCoord;
   9: 
  10: uniform vec3 uLightBoxSize;
  11: uniform vec3 uLightBoxMin;
  12: uniform mat4 uModel;
  13: 
  14: uniform float uTime;
  15: uniform mat4 uViewProjection;
  16: uniform vec3 uCameraPos;
  17: 
  18: void FLWFinalizeWorldPos(inout vec4 worldPos) {
  19:     worldPos = uModel * worldPos;
  20: 
  21:     BoxCoord = (worldPos.xyz - uLightBoxMin) / uLightBoxSize;
  22: 
  23:     #if defined(USE_FOG)
  24:     FragDistance = length(worldPos.xyz);
  25:     #endif
  26: 
  27:     gl_Position = uViewProjection * worldPos;
  28: }
  29: 
  30: void FLWFinalizeNormal(inout vec3 normal) {
  31:     mat3 m;
  32:     m[0] = uModel[0].xyz;
  33:     m[1] = uModel[1].xyz;
  34:     m[2] = uModel[2].xyz;
  35:     normal = m * normal;
  36: }
  37: 
  38: 
  39: 
  40: float diffuse(vec3 normal) {
  41:     vec3 n2 = normal * normal * vec3(.6, .25, .8);
  42:     return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
  43: }
  44: 
  45: 
  46: struct Vertex {
  47:     vec3 pos;
  48:     vec3 normal;
  49:     vec2 texCoords;
  50: };
  51: 
  52: struct BlockFrag {
  53:     vec2 texCoords;
  54:     vec4 color;
  55:     float diffuse;
  56:     vec2 light;
  57: };
  58: 
  59: 
  60: struct Instance {
  61:     vec2 light;
  62:     vec4 color;
  63:     mat4 transform;
  64:     mat3 normalMat;
  65: };
  66: 
  67: BlockFrag FLWMain(Vertex v, Instance i) {
  68:     vec4 worldPos = i.transform * vec4(v.pos, 1.);
  69: 
  70:     vec3 norm = i.normalMat * v.normal;
  71: 
  72:     FLWFinalizeWorldPos(worldPos);
  73:     FLWFinalizeNormal(norm);
  74: 
  75:     norm = normalize(norm);
  76: 
  77:     BlockFrag b;
  78:     b.diffuse = diffuse(norm);
  79:     b.texCoords = v.texCoords;
  80:     b.light = i.light;
  81:     #if defined(DEBUG_NORMAL)
  82:     b.color = vec4(norm, 1.);
  83:     #else
  84:     b.color = i.color;
  85:     #endif
  86:     return b;
  87: }
  88: attribute vec3 a_v_pos;
  89: attribute vec3 a_v_normal;
  90: attribute vec2 a_v_texCoords;
  91: 
  92: attribute vec2 a_i_light;
  93: attribute vec4 a_i_color;
  94: attribute mat4 a_i_transform;
  95: attribute mat3 a_i_normalMat;
  96: 
  97: 
  98: varying vec2 v2f_texCoords;
  99: varying vec4 v2f_color;
 100: varying float v2f_diffuse;
 101: varying vec2 v2f_light;
 102: 
 103: 
 104: void main() {
 105:     Vertex v;
 106:     v.pos = a_v_pos;
 107: v.normal = a_v_normal;
 108: v.texCoords = a_v_texCoords;
 109: 
 110: 
 111:     Instance i;
 112:     i.light = a_i_light;
 113: i.color = a_i_color;
 114: i.transform = a_i_transform;
 115: i.normalMat = a_i_normalMat;
 116: 
 117: 
 118:     BlockFrag o = FLWMain(v, i);
 119: 
 120:     v2f_texCoords = o.texCoords;
 121: v2f_color = o.color;
 122: v2f_diffuse = o.diffuse;
 123: v2f_light = o.light;
 124: 
 125: }

[13:33:09] [main/ERROR]: Shader compilation log for flywheel:block.frag: No errors.

[13:33:09] [main/ERROR]: Source for shader 'flywheel:block.frag':
   1: #version 110
   2: #define DEBUG_NORMAL
   3: 
   4: #if defined(USE_FOG)
   5: varying float FragDistance;
   6: uniform vec4 uFogColor;
   7: #endif
   8: 
   9: #if defined(USE_FOG_LINEAR)
  10: uniform vec2 uFogRange;
  11: 
  12: float FLWFogFactor() {
  13:     return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
  14: }
  15:     #endif
  16: 
  17:     #if defined(USE_FOG_EXP2)
  18: uniform float uFogDensity;
  19: 
  20: float FLWFogFactor() {
  21:     float dist = FragDistance * uFogDensity;
  22:     return 1. / exp2(dist * dist);
  23: }
  24:     #endif
  25: // Adjust the [0,1] normalized lightmap value based on the texture matrix from LightTexture#enableLightmap
  26: vec2 shiftLight(vec2 lm) {
  27:     return lm * 0.99609375 + 0.03125;// * 255/256 + 1/32
  28: }
  29: 
  30: varying vec3 BoxCoord;
  31: varying vec2 BoxLight;
  32: uniform sampler3D uLightVolume;
  33: 
  34: uniform sampler2D uBlockAtlas;
  35: uniform sampler2D uLightMap;
  36: 
  37: vec4 FLWBlockTexture(vec2 texCoords) {
  38:     return texture2D(uBlockAtlas, texCoords);
  39: }
  40: 
  41: void FLWFinalizeColor(vec4 color) {
  42:     #if defined(USE_FOG)
  43:     float a = color.a;
  44:     float fog = clamp(FLWFogFactor(), 0., 1.);
  45: 
  46:     color = mix(uFogColor, color, fog);
  47:     color.a = a;
  48:     #endif
  49: 
  50:     gl_FragColor = color;
  51: }
  52: 
  53: vec4 FLWLight(vec2 lightCoords) {
  54:     lightCoords = max(lightCoords, texture3D(uLightVolume, BoxCoord).rg);
  55: 
  56:     return texture2D(uLightMap, shiftLight(lightCoords));
  57: }
  58: 
  59: 
  60: 
  61: struct BlockFrag {
  62:     vec2 texCoords;
  63:     vec4 color;
  64:     float diffuse;
  65:     vec2 light;
  66: };
  67: 
  68: void FLWMain(BlockFrag r) {
  69:     vec4 tex = FLWBlockTexture(r.texCoords);
  70: 
  71:     vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;
  72: 
  73: //    flw_WorldPos = ;
  74: //    flw_Normal = ;
  75: //    flw_Albedo = tex.rgb;
  76: //    flw_Alpha = tex.a;
  77: //    flw_LightMap = r.light;
  78: //    flw_Tint = r.color;
  79:     FLWFinalizeColor(color);
  80: }
  81: 
  82: varying vec2 v2f_texCoords;
  83: varying vec4 v2f_color;
  84: varying float v2f_diffuse;
  85: varying vec2 v2f_light;
  86: 
  87: 
  88: //vec3 flw_WorldPos;
  89: //vec3 flw_Normal;
  90: //vec3 flw_Albedo;
  91: //float flw_Alpha;
  92: //vec2 flw_LightMap;
  93: //vec4 flw_Tint;
  94: 
  95: void main() {
  96:     BlockFrag f;
  97:     f.texCoords = v2f_texCoords;
  98: f.color = v2f_color;
  99: f.diffuse = v2f_diffuse;
 100: f.light = v2f_light;
 101: 
 102: 
 103:     FLWMain(f);
 104: }

[13:33:10] [main/ERROR]: Shader compilation log for flywheel:model.vert: No errors.

[13:33:10] [main/ERROR]: Source for shader 'flywheel:model.vert':
   1: #version 110
   2: #define USE_FOG
   3: #define USE_FOG_LINEAR
   4: 
   5: #if defined(USE_FOG)
   6: varying float FragDistance;
   7: #endif
   8: 
   9: varying vec3 BoxCoord;
  10: 
  11: uniform vec3 uLightBoxSize;
  12: uniform vec3 uLightBoxMin;
  13: uniform mat4 uModel;
  14: 
  15: uniform float uTime;
  16: uniform mat4 uViewProjection;
  17: uniform vec3 uCameraPos;
  18: 
  19: void FLWFinalizeWorldPos(inout vec4 worldPos) {
  20:     worldPos = uModel * worldPos;
  21: 
  22:     BoxCoord = (worldPos.xyz - uLightBoxMin) / uLightBoxSize;
  23: 
  24:     #if defined(USE_FOG)
  25:     FragDistance = length(worldPos.xyz);
  26:     #endif
  27: 
  28:     gl_Position = uViewProjection * worldPos;
  29: }
  30: 
  31: void FLWFinalizeNormal(inout vec3 normal) {
  32:     mat3 m;
  33:     m[0] = uModel[0].xyz;
  34:     m[1] = uModel[1].xyz;
  35:     m[2] = uModel[2].xyz;
  36:     normal = m * normal;
  37: }
  38: 
  39: 
  40: 
  41: float diffuse(vec3 normal) {
  42:     vec3 n2 = normal * normal * vec3(.6, .25, .8);
  43:     return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
  44: }
  45: 
  46: 
  47: struct Vertex {
  48:     vec3 pos;
  49:     vec3 normal;
  50:     vec2 texCoords;
  51: };
  52: 
  53: struct BlockFrag {
  54:     vec2 texCoords;
  55:     vec4 color;
  56:     float diffuse;
  57:     vec2 light;
  58: };
  59: 
  60: 
  61: struct Instance {
  62:     vec2 light;
  63:     vec4 color;
  64:     mat4 transform;
  65:     mat3 normalMat;
  66: };
  67: 
  68: BlockFrag FLWMain(Vertex v, Instance i) {
  69:     vec4 worldPos = i.transform * vec4(v.pos, 1.);
  70: 
  71:     vec3 norm = i.normalMat * v.normal;
  72: 
  73:     FLWFinalizeWorldPos(worldPos);
  74:     FLWFinalizeNormal(norm);
  75: 
  76:     norm = normalize(norm);
  77: 
  78:     BlockFrag b;
  79:     b.diffuse = diffuse(norm);
  80:     b.texCoords = v.texCoords;
  81:     b.light = i.light;
  82:     #if defined(DEBUG_NORMAL)
  83:     b.color = vec4(norm, 1.);
  84:     #else
  85:     b.color = i.color;
  86:     #endif
  87:     return b;
  88: }
  89: attribute vec3 a_v_pos;
  90: attribute vec3 a_v_normal;
  91: attribute vec2 a_v_texCoords;
  92: 
  93: attribute vec2 a_i_light;
  94: attribute vec4 a_i_color;
  95: attribute mat4 a_i_transform;
  96: attribute mat3 a_i_normalMat;
  97: 
  98: 
  99: varying vec2 v2f_texCoords;
 100: varying vec4 v2f_color;
 101: varying float v2f_diffuse;
 102: varying vec2 v2f_light;
 103: 
 104: 
 105: void main() {
 106:     Vertex v;
 107:     v.pos = a_v_pos;
 108: v.normal = a_v_normal;
 109: v.texCoords = a_v_texCoords;
 110: 
 111: 
 112:     Instance i;
 113:     i.light = a_i_light;
 114: i.color = a_i_color;
 115: i.transform = a_i_transform;
 116: i.normalMat = a_i_normalMat;
 117: 
 118: 
 119:     BlockFrag o = FLWMain(v, i);
 120: 
 121:     v2f_texCoords = o.texCoords;
 122: v2f_color = o.color;
 123: v2f_diffuse = o.diffuse;
 124: v2f_light = o.light;
 125: 
 126: }

[13:33:10] [main/ERROR]: Shader compilation log for flywheel:block.frag: No errors.

[13:33:10] [main/ERROR]: Source for shader 'flywheel:block.frag':
   1: #version 110
   2: #define USE_FOG
   3: #define USE_FOG_LINEAR
   4: 
   5: #if defined(USE_FOG)
   6: varying float FragDistance;
   7: uniform vec4 uFogColor;
   8: #endif
   9: 
  10: #if defined(USE_FOG_LINEAR)
  11: uniform vec2 uFogRange;
  12: 
  13: float FLWFogFactor() {
  14:     return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
  15: }
  16:     #endif
  17: 
  18:     #if defined(USE_FOG_EXP2)
  19: uniform float uFogDensity;
  20: 
  21: float FLWFogFactor() {
  22:     float dist = FragDistance * uFogDensity;
  23:     return 1. / exp2(dist * dist);
  24: }
  25:     #endif
  26: // Adjust the [0,1] normalized lightmap value based on the texture matrix from LightTexture#enableLightmap
  27: vec2 shiftLight(vec2 lm) {
  28:     return lm * 0.99609375 + 0.03125;// * 255/256 + 1/32
  29: }
  30: 
  31: varying vec3 BoxCoord;
  32: varying vec2 BoxLight;
  33: uniform sampler3D uLightVolume;
  34: 
  35: uniform sampler2D uBlockAtlas;
  36: uniform sampler2D uLightMap;
  37: 
  38: vec4 FLWBlockTexture(vec2 texCoords) {
  39:     return texture2D(uBlockAtlas, texCoords);
  40: }
  41: 
  42: void FLWFinalizeColor(vec4 color) {
  43:     #if defined(USE_FOG)
  44:     float a = color.a;
  45:     float fog = clamp(FLWFogFactor(), 0., 1.);
  46: 
  47:     color = mix(uFogColor, color, fog);
  48:     color.a = a;
  49:     #endif
  50: 
  51:     gl_FragColor = color;
  52: }
  53: 
  54: vec4 FLWLight(vec2 lightCoords) {
  55:     lightCoords = max(lightCoords, texture3D(uLightVolume, BoxCoord).rg);
  56: 
  57:     return texture2D(uLightMap, shiftLight(lightCoords));
  58: }
  59: 
  60: 
  61: 
  62: struct BlockFrag {
  63:     vec2 texCoords;
  64:     vec4 color;
  65:     float diffuse;
  66:     vec2 light;
  67: };
  68: 
  69: void FLWMain(BlockFrag r) {
  70:     vec4 tex = FLWBlockTexture(r.texCoords);
  71: 
  72:     vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;
  73: 
  74: //    flw_WorldPos = ;
  75: //    flw_Normal = ;
  76: //    flw_Albedo = tex.rgb;
  77: //    flw_Alpha = tex.a;
  78: //    flw_LightMap = r.light;
  79: //    flw_Tint = r.color;
  80:     FLWFinalizeColor(color);
  81: }
  82: 
  83: varying vec2 v2f_texCoords;
  84: varying vec4 v2f_color;
  85: varying float v2f_diffuse;
  86: varying vec2 v2f_light;
  87: 
  88: 
  89: //vec3 flw_WorldPos;
  90: //vec3 flw_Normal;
  91: //vec3 flw_Albedo;
  92: //float flw_Alpha;
  93: //vec2 flw_LightMap;
  94: //vec4 flw_Tint;
  95: 
  96: void main() {
  97:     BlockFrag f;
  98:     f.texCoords = v2f_texCoords;
  99: f.color = v2f_color;
 100: f.diffuse = v2f_diffuse;
 101: f.light = v2f_light;
 102: 
 103: 
 104:     FLWMain(f);
 105: }

[13:33:10] [main/ERROR]: Shader compilation log for flywheel:model.vert: No errors.

[13:33:10] [main/ERROR]: Source for shader 'flywheel:model.vert':
   1: #version 110
   2: #define USE_FOG
   3: #define USE_FOG_EXP2
   4: 
   5: #if defined(USE_FOG)
   6: varying float FragDistance;
   7: #endif
   8: 
   9: varying vec3 BoxCoord;
  10: 
  11: uniform vec3 uLightBoxSize;
  12: uniform vec3 uLightBoxMin;
  13: uniform mat4 uModel;
  14: 
  15: uniform float uTime;
  16: uniform mat4 uViewProjection;
  17: uniform vec3 uCameraPos;
  18: 
  19: void FLWFinalizeWorldPos(inout vec4 worldPos) {
  20:     worldPos = uModel * worldPos;
  21: 
  22:     BoxCoord = (worldPos.xyz - uLightBoxMin) / uLightBoxSize;
  23: 
  24:     #if defined(USE_FOG)
  25:     FragDistance = length(worldPos.xyz);
  26:     #endif
  27: 
  28:     gl_Position = uViewProjection * worldPos;
  29: }
  30: 
  31: void FLWFinalizeNormal(inout vec3 normal) {
  32:     mat3 m;
  33:     m[0] = uModel[0].xyz;
  34:     m[1] = uModel[1].xyz;
  35:     m[2] = uModel[2].xyz;
  36:     normal = m * normal;
  37: }
  38: 
  39: 
  40: 
  41: float diffuse(vec3 normal) {
  42:     vec3 n2 = normal * normal * vec3(.6, .25, .8);
  43:     return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
  44: }
  45: 
  46: 
  47: struct Vertex {
  48:     vec3 pos;
  49:     vec3 normal;
  50:     vec2 texCoords;
  51: };
  52: 
  53: struct BlockFrag {
  54:     vec2 texCoords;
  55:     vec4 color;
  56:     float diffuse;
  57:     vec2 light;
  58: };
  59: 
  60: 
  61: struct Instance {
  62:     vec2 light;
  63:     vec4 color;
  64:     mat4 transform;
  65:     mat3 normalMat;
  66: };
  67: 
  68: BlockFrag FLWMain(Vertex v, Instance i) {
  69:     vec4 worldPos = i.transform * vec4(v.pos, 1.);
  70: 
  71:     vec3 norm = i.normalMat * v.normal;
  72: 
  73:     FLWFinalizeWorldPos(worldPos);
  74:     FLWFinalizeNormal(norm);
  75: 
  76:     norm = normalize(norm);
  77: 
  78:     BlockFrag b;
  79:     b.diffuse = diffuse(norm);
  80:     b.texCoords = v.texCoords;
  81:     b.light = i.light;
  82:     #if defined(DEBUG_NORMAL)
  83:     b.color = vec4(norm, 1.);
  84:     #else
  85:     b.color = i.color;
  86:     #endif
  87:     return b;
  88: }
  89: attribute vec3 a_v_pos;
  90: attribute vec3 a_v_normal;
  91: attribute vec2 a_v_texCoords;
  92: 
  93: attribute vec2 a_i_light;
  94: attribute vec4 a_i_color;
  95: attribute mat4 a_i_transform;
  96: attribute mat3 a_i_normalMat;
  97: 
  98: 
  99: varying vec2 v2f_texCoords;
 100: varying vec4 v2f_color;
 101: varying float v2f_diffuse;
 102: varying vec2 v2f_light;
 103: 
 104: 
 105: void main() {
 106:     Vertex v;
 107:     v.pos = a_v_pos;
 108: v.normal = a_v_normal;
 109: v.texCoords = a_v_texCoords;
 110: 
 111: 
 112:     Instance i;
 113:     i.light = a_i_light;
 114: i.color = a_i_color;
 115: i.transform = a_i_transform;
 116: i.normalMat = a_i_normalMat;
 117: 
 118: 
 119:     BlockFrag o = FLWMain(v, i);
 120: 
 121:     v2f_texCoords = o.texCoords;
 122: v2f_color = o.color;
 123: v2f_diffuse = o.diffuse;
 124: v2f_light = o.light;
 125: 
 126: }

[13:33:10] [main/ERROR]: Shader compilation log for flywheel:block.frag: No errors.

[13:33:10] [main/ERROR]: Source for shader 'flywheel:block.frag':
   1: #version 110
   2: #define USE_FOG
   3: #define USE_FOG_EXP2
   4: 
   5: #if defined(USE_FOG)
   6: varying float FragDistance;
   7: uniform vec4 uFogColor;
   8: #endif
   9: 
  10: #if defined(USE_FOG_LINEAR)
  11: uniform vec2 uFogRange;
  12: 
  13: float FLWFogFactor() {
  14:     return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
  15: }
  16:     #endif
  17: 
  18:     #if defined(USE_FOG_EXP2)
  19: uniform float uFogDensity;
  20: 
  21: float FLWFogFactor() {
  22:     float dist = FragDistance * uFogDensity;
  23:     return 1. / exp2(dist * dist);
  24: }
  25:     #endif
  26: // Adjust the [0,1] normalized lightmap value based on the texture matrix from LightTexture#enableLightmap
  27: vec2 shiftLight(vec2 lm) {
  28:     return lm * 0.99609375 + 0.03125;// * 255/256 + 1/32
  29: }
  30: 
  31: varying vec3 BoxCoord;
  32: varying vec2 BoxLight;
  33: uniform sampler3D uLightVolume;
  34: 
  35: uniform sampler2D uBlockAtlas;
  36: uniform sampler2D uLightMap;
  37: 
  38: vec4 FLWBlockTexture(vec2 texCoords) {
  39:     return texture2D(uBlockAtlas, texCoords);
  40: }
  41: 
  42: void FLWFinalizeColor(vec4 color) {
  43:     #if defined(USE_FOG)
  44:     float a = color.a;
  45:     float fog = clamp(FLWFogFactor(), 0., 1.);
  46: 
  47:     color = mix(uFogColor, color, fog);
  48:     color.a = a;
  49:     #endif
  50: 
  51:     gl_FragColor = color;
  52: }
  53: 
  54: vec4 FLWLight(vec2 lightCoords) {
  55:     lightCoords = max(lightCoords, texture3D(uLightVolume, BoxCoord).rg);
  56: 
  57:     return texture2D(uLightMap, shiftLight(lightCoords));
  58: }
  59: 
  60: 
  61: 
  62: struct BlockFrag {
  63:     vec2 texCoords;
  64:     vec4 color;
  65:     float diffuse;
  66:     vec2 light;
  67: };
  68: 
  69: void FLWMain(BlockFrag r) {
  70:     vec4 tex = FLWBlockTexture(r.texCoords);
  71: 
  72:     vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;
  73: 
  74: //    flw_WorldPos = ;
  75: //    flw_Normal = ;
  76: //    flw_Albedo = tex.rgb;
  77: //    flw_Alpha = tex.a;
  78: //    flw_LightMap = r.light;
  79: //    flw_Tint = r.color;
  80:     FLWFinalizeColor(color);
  81: }
  82: 
  83: varying vec2 v2f_texCoords;
  84: varying vec4 v2f_color;
  85: varying float v2f_diffuse;
  86: varying vec2 v2f_light;
  87: 
  88: 
  89: //vec3 flw_WorldPos;
  90: //vec3 flw_Normal;
  91: //vec3 flw_Albedo;
  92: //float flw_Alpha;
  93: //vec2 flw_LightMap;
  94: //vec4 flw_Tint;
  95: 
  96: void main() {
  97:     BlockFrag f;
  98:     f.texCoords = v2f_texCoords;
  99: f.color = v2f_color;
 100: f.diffuse = v2f_diffuse;
 101: f.light = v2f_light;
 102: 
 103: 
 104:     FLWMain(f);
 105: }

[13:33:10] [main/ERROR]: Shader compilation log for flywheel:model.vert: No errors.

[13:33:10] [main/ERROR]: Source for shader 'flywheel:model.vert':
   1: #version 110
   2: 
   3: #if defined(USE_FOG)
   4: varying float FragDistance;
   5: #endif
   6: 
   7: varying vec3 BoxCoord;
   8: 
   9: uniform vec3 uLightBoxSize;
  10: uniform vec3 uLightBoxMin;
  11: uniform mat4 uModel;
  12: 
  13: uniform float uTime;
  14: uniform mat4 uViewProjection;
  15: uniform vec3 uCameraPos;
  16: 
  17: void FLWFinalizeWorldPos(inout vec4 worldPos) {
  18:     worldPos = uModel * worldPos;
  19: 
  20:     BoxCoord = (worldPos.xyz - uLightBoxMin) / uLightBoxSize;
  21: 
  22:     #if defined(USE_FOG)
  23:     FragDistance = length(worldPos.xyz);
  24:     #endif
  25: 
  26:     gl_Position = uViewProjection * worldPos;
  27: }
  28: 
  29: void FLWFinalizeNormal(inout vec3 normal) {
  30:     mat3 m;
  31:     m[0] = uModel[0].xyz;
  32:     m[1] = uModel[1].xyz;
  33:     m[2] = uModel[2].xyz;
  34:     normal = m * normal;
  35: }
  36: 
  37: 
  38: 
  39: float diffuse(vec3 normal) {
  40:     vec3 n2 = normal * normal * vec3(.6, .25, .8);
  41:     return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
  42: }
  43: 
  44: 
  45: struct Vertex {
  46:     vec3 pos;
  47:     vec3 normal;
  48:     vec2 texCoords;
  49: };
  50: 
  51: struct BlockFrag {
  52:     vec2 texCoords;
  53:     vec4 color;
  54:     float diffuse;
  55:     vec2 light;
  56: };
  57: 
  58: 
  59: struct Instance {
  60:     vec2 light;
  61:     vec4 color;
  62:     mat4 transform;
  63:     mat3 normalMat;
  64: };
  65: 
  66: BlockFrag FLWMain(Vertex v, Instance i) {
  67:     vec4 worldPos = i.transform * vec4(v.pos, 1.);
  68: 
  69:     vec3 norm = i.normalMat * v.normal;
  70: 
  71:     FLWFinalizeWorldPos(worldPos);
  72:     FLWFinalizeNormal(norm);
  73: 
  74:     norm = normalize(norm);
  75: 
  76:     BlockFrag b;
  77:     b.diffuse = diffuse(norm);
  78:     b.texCoords = v.texCoords;
  79:     b.light = i.light;
  80:     #if defined(DEBUG_NORMAL)
  81:     b.color = vec4(norm, 1.);
  82:     #else
  83:     b.color = i.color;
  84:     #endif
  85:     return b;
  86: }
  87: attribute vec3 a_v_pos;
  88: attribute vec3 a_v_normal;
  89: attribute vec2 a_v_texCoords;
  90: 
  91: attribute vec2 a_i_light;
  92: attribute vec4 a_i_color;
  93: attribute mat4 a_i_transform;
  94: attribute mat3 a_i_normalMat;
  95: 
  96: 
  97: varying vec2 v2f_texCoords;
  98: varying vec4 v2f_color;
  99: varying float v2f_diffuse;
 100: varying vec2 v2f_light;
 101: 
 102: 
 103: void main() {
 104:     Vertex v;
 105:     v.pos = a_v_pos;
 106: v.normal = a_v_normal;
 107: v.texCoords = a_v_texCoords;
 108: 
 109: 
 110:     Instance i;
 111:     i.light = a_i_light;
 112: i.color = a_i_color;
 113: i.transform = a_i_transform;
 114: i.normalMat = a_i_normalMat;
 115: 
 116: 
 117:     BlockFrag o = FLWMain(v, i);
 118: 
 119:     v2f_texCoords = o.texCoords;
 120: v2f_color = o.color;
 121: v2f_diffuse = o.diffuse;
 122: v2f_light = o.light;
 123: 
 124: }

[13:33:10] [main/ERROR]: Shader compilation log for flywheel:block.frag: No errors.

[13:33:10] [main/ERROR]: Source for shader 'flywheel:block.frag':
   1: #version 110
   2: 
   3: #if defined(USE_FOG)
   4: varying float FragDistance;
   5: uniform vec4 uFogColor;
   6: #endif
   7: 
   8: #if defined(USE_FOG_LINEAR)
   9: uniform vec2 uFogRange;
  10: 
  11: float FLWFogFactor() {
  12:     return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
  13: }
  14:     #endif
  15: 
  16:     #if defined(USE_FOG_EXP2)
  17: uniform float uFogDensity;
  18: 
  19: float FLWFogFactor() {
  20:     float dist = FragDistance * uFogDensity;
  21:     return 1. / exp2(dist * dist);
  22: }
  23:     #endif
  24: // Adjust the [0,1] normalized lightmap value based on the texture matrix from LightTexture#enableLightmap
  25: vec2 shiftLight(vec2 lm) {
  26:     return lm * 0.99609375 + 0.03125;// * 255/256 + 1/32
  27: }
  28: 
  29: varying vec3 BoxCoord;
  30: varying vec2 BoxLight;
  31: uniform sampler3D uLightVolume;
  32: 
  33: uniform sampler2D uBlockAtlas;
  34: uniform sampler2D uLightMap;
  35: 
  36: vec4 FLWBlockTexture(vec2 texCoords) {
  37:     return texture2D(uBlockAtlas, texCoords);
  38: }
  39: 
  40: void FLWFinalizeColor(vec4 color) {
  41:     #if defined(USE_FOG)
  42:     float a = color.a;
  43:     float fog = clamp(FLWFogFactor(), 0., 1.);
  44: 
  45:     color = mix(uFogColor, color, fog);
  46:     color.a = a;
  47:     #endif
  48: 
  49:     gl_FragColor = color;
  50: }
  51: 
  52: vec4 FLWLight(vec2 lightCoords) {
  53:     lightCoords = max(lightCoords, texture3D(uLightVolume, BoxCoord).rg);
  54: 
  55:     return texture2D(uLightMap, shiftLight(lightCoords));
  56: }
  57: 
  58: 
  59: 
  60: struct BlockFrag {
  61:     vec2 texCoords;
  62:     vec4 color;
  63:     float diffuse;
  64:     vec2 light;
  65: };
  66: 
  67: void FLWMain(BlockFrag r) {
  68:     vec4 tex = FLWBlockTexture(r.texCoords);
  69: 
  70:     vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;
  71: 
  72: //    flw_WorldPos = ;
  73: //    flw_Normal = ;
  74: //    flw_Albedo = tex.rgb;
  75: //    flw_Alpha = tex.a;
  76: //    flw_LightMap = r.light;
  77: //    flw_Tint = r.color;
  78:     FLWFinalizeColor(color);
  79: }
  80: 
  81: varying vec2 v2f_texCoords;
  82: varying vec4 v2f_color;
  83: varying float v2f_diffuse;
  84: varying vec2 v2f_light;
  85: 
  86: 
  87: //vec3 flw_WorldPos;
  88: //vec3 flw_Normal;
  89: //vec3 flw_Albedo;
  90: //float flw_Alpha;
  91: //vec2 flw_LightMap;
  92: //vec4 flw_Tint;
  93: 
  94: void main() {
  95:     BlockFrag f;
  96:     f.texCoords = v2f_texCoords;
  97: f.color = v2f_color;
  98: f.diffuse = v2f_diffuse;
  99: f.light = v2f_light;
 100: 
 101: 
 102:     FLWMain(f);
 103: }

[13:33:10] [main/INFO]: Loading context 'create:context/contraption'
[13:33:10] [main/ERROR]: Shader compilation log for create:contraption_structure.vert: No errors.

[13:33:10] [main/ERROR]: Source for shader 'create:contraption_structure.vert':
   1: #version 110
   2: #define DEBUG_NORMAL
   3: 
   4: #define PI 3.1415926538
   5: 
   6: #if defined(USE_FOG)
   7: varying float FragDistance;
   8: #endif
   9: 
  10: varying vec3 BoxCoord;
  11: 
  12: uniform vec3 uLightBoxSize;
  13: uniform vec3 uLightBoxMin;
  14: uniform mat4 uModel;
  15: 
  16: uniform float uTime;
  17: uniform mat4 uViewProjection;
  18: uniform vec3 uCameraPos;
  19: 
  20: void FLWFinalizeWorldPos(inout vec4 worldPos) {
  21:     worldPos = uModel * worldPos;
  22: 
  23:     BoxCoord = (worldPos.xyz - uLightBoxMin) / uLightBoxSize;
  24: 
  25:     #if defined(USE_FOG)
  26:     FragDistance = length(worldPos.xyz);
  27:     #endif
  28: 
  29:     gl_Position = uViewProjection * worldPos;
  30: }
  31: 
  32: void FLWFinalizeNormal(inout vec3 normal) {
  33:     mat3 m;
  34:     m[0] = uModel[0].xyz;
  35:     m[1] = uModel[1].xyz;
  36:     m[2] = uModel[2].xyz;
  37:     normal = m * normal;
  38: }
  39: 
  40: 
  41: 
  42: mat4 rotate(vec3 axis, float angle) {
  43:     float s = sin(angle);
  44:     float c = cos(angle);
  45:     float oc = 1. - c;
  46: 
  47:     vec3 sa = axis * s;
  48: 
  49:     mat4 mr = mat4(1.);
  50:     mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
  51:     mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
  52:     mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);
  53: 
  54:     return mr;
  55: }
  56: 
  57: mat4 rotation(vec3 rot) {
  58:     return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
  59: }
  60: 
  61: mat3 modelToNormal(mat4 mat) {
  62:     // Discard the edges. This won't be accurate for scaled or skewed matrices,
  63:     // but we don't have to work with those often.
  64:     mat3 m;
  65:     m[0] = mat[0].xyz;
  66:     m[1] = mat[1].xyz;
  67:     m[2] = mat[2].xyz;
  68:     return m;
  69: }
  70: 
  71: float diffuse(vec3 normal) {
  72:     vec3 n2 = normal * normal * vec3(.6, .25, .8);
  73:     return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
  74: }
  75: 
  76: 
  77: struct Vertex {
  78:     vec3 pos;
  79:     vec3 normal;
  80:     vec2 texCoords;
  81:     vec4 color;
  82:     vec2 modelLight;
  83: };
  84: 
  85: 
  86: struct BlockFrag {
  87:     vec2 texCoords;
  88:     vec4 color;
  89:     float diffuse;
  90:     vec2 light;
  91: };
  92: 
  93: BlockFrag FLWMain(Vertex v) {
  94:     vec4 worldPos = vec4(v.pos, 1.);
  95:     vec3 norm = v.normal;
  96: 
  97:     FLWFinalizeWorldPos(worldPos);
  98:     FLWFinalizeNormal(norm);
  99: 
 100:     BlockFrag b;
 101:     b.diffuse = diffuse(norm);
 102:     b.texCoords = v.texCoords;
 103:     b.light = v.modelLight;
 104: 
 105:     #if defined(DEBUG_NORMAL)
 106:     b.color = vec4(norm, 1.);
 107:     #else
 108:     b.color = vec4(v.color.rgb / diffuse(v.normal), v.color.a);
 109:     #endif
 110: 
 111:     return b;
 112: }
 113: attribute vec3 a_v_pos;
 114: attribute vec3 a_v_normal;
 115: attribute vec2 a_v_texCoords;
 116: attribute vec4 a_v_color;
 117: attribute vec2 a_v_modelLight;
 118: 
 119: 
 120: varying vec2 v2f_texCoords;
 121: varying vec4 v2f_color;
 122: varying float v2f_diffuse;
 123: varying vec2 v2f_light;
 124: 
 125: 
 126: void main() {
 127:     Vertex v;
 128:     v.pos = a_v_pos;
 129: v.normal = a_v_normal;
 130: v.texCoords = a_v_texCoords;
 131: v.color = a_v_color;
 132: v.modelLight = a_v_modelLight;
 133: 
 134: 
 135:     BlockFrag o = FLWMain(v);
 136: 
 137:     v2f_texCoords = o.texCoords;
 138: v2f_color = o.color;
 139: v2f_diffuse = o.diffuse;
 140: v2f_light = o.light;
 141: 
 142: }

[13:33:18] [main/ERROR]: Shader compilation log for flywheel:block.frag: No errors.

[13:33:18] [main/ERROR]: Source for shader 'flywheel:block.frag':
   1: #version 110
   2: #define DEBUG_NORMAL
   3: 
   4: #if defined(USE_FOG)
   5: varying float FragDistance;
   6: uniform vec4 uFogColor;
   7: #endif
   8: 
   9: #if defined(USE_FOG_LINEAR)
  10: uniform vec2 uFogRange;
  11: 
  12: float FLWFogFactor() {
  13:     return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
  14: }
  15:     #endif
  16: 
  17:     #if defined(USE_FOG_EXP2)
  18: uniform float uFogDensity;
  19: 
  20: float FLWFogFactor() {
  21:     float dist = FragDistance * uFogDensity;
  22:     return 1. / exp2(dist * dist);
  23: }
  24:     #endif
  25: // Adjust the [0,1] normalized lightmap value based on the texture matrix from LightTexture#enableLightmap
  26: vec2 shiftLight(vec2 lm) {
  27:     return lm * 0.99609375 + 0.03125;// * 255/256 + 1/32
  28: }
  29: 
  30: varying vec3 BoxCoord;
  31: varying vec2 BoxLight;
  32: uniform sampler3D uLightVolume;
  33: 
  34: uniform sampler2D uBlockAtlas;
  35: uniform sampler2D uLightMap;
  36: 
  37: vec4 FLWBlockTexture(vec2 texCoords) {
  38:     return texture2D(uBlockAtlas, texCoords);
  39: }
  40: 
  41: void FLWFinalizeColor(vec4 color) {
  42:     #if defined(USE_FOG)
  43:     float a = color.a;
  44:     float fog = clamp(FLWFogFactor(), 0., 1.);
  45: 
  46:     color = mix(uFogColor, color, fog);
  47:     color.a = a;
  48:     #endif
  49: 
  50:     gl_FragColor = color;
  51: }
  52: 
  53: vec4 FLWLight(vec2 lightCoords) {
  54:     lightCoords = max(lightCoords, texture3D(uLightVolume, BoxCoord).rg);
  55: 
  56:     return texture2D(uLightMap, shiftLight(lightCoords));
  57: }
  58: 
  59: 
  60: 
  61: struct BlockFrag {
  62:     vec2 texCoords;
  63:     vec4 color;
  64:     float diffuse;
  65:     vec2 light;
  66: };
  67: 
  68: void FLWMain(BlockFrag r) {
  69:     vec4 tex = FLWBlockTexture(r.texCoords);
  70: 
  71:     vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;
  72: 
  73: //    flw_WorldPos = ;
  74: //    flw_Normal = ;
  75: //    flw_Albedo = tex.rgb;
  76: //    flw_Alpha = tex.a;
  77: //    flw_LightMap = r.light;
  78: //    flw_Tint = r.color;
  79:     FLWFinalizeColor(color);
  80: }
  81: 
  82: varying vec2 v2f_texCoords;
  83: varying vec4 v2f_color;
  84: varying float v2f_diffuse;
  85: varying vec2 v2f_light;
  86: 
  87: 
  88: void main() {
  89:     BlockFrag f;
  90:     f.texCoords = v2f_texCoords;
  91: f.color = v2f_color;
  92: f.diffuse = v2f_diffuse;
  93: f.light = v2f_light;
  94: 
  95: 
  96:     FLWMain(f);
  97: }

[13:33:18] [main/ERROR]: Shader compilation log for create:contraption_structure.vert: No errors.

[13:33:18] [main/ERROR]: Source for shader 'create:contraption_structure.vert':
   1: #version 110
   2: #define USE_FOG
   3: #define USE_FOG_LINEAR
   4: 
   5: #define PI 3.1415926538
   6: 
   7: #if defined(USE_FOG)
   8: varying float FragDistance;
   9: #endif
  10: 
  11: varying vec3 BoxCoord;
  12: 
  13: uniform vec3 uLightBoxSize;
  14: uniform vec3 uLightBoxMin;
  15: uniform mat4 uModel;
  16: 
  17: uniform float uTime;
  18: uniform mat4 uViewProjection;
  19: uniform vec3 uCameraPos;
  20: 
  21: void FLWFinalizeWorldPos(inout vec4 worldPos) {
  22:     worldPos = uModel * worldPos;
  23: 
  24:     BoxCoord = (worldPos.xyz - uLightBoxMin) / uLightBoxSize;
  25: 
  26:     #if defined(USE_FOG)
  27:     FragDistance = length(worldPos.xyz);
  28:     #endif
  29: 
  30:     gl_Position = uViewProjection * worldPos;
  31: }
  32: 
  33: void FLWFinalizeNormal(inout vec3 normal) {
  34:     mat3 m;
  35:     m[0] = uModel[0].xyz;
  36:     m[1] = uModel[1].xyz;
  37:     m[2] = uModel[2].xyz;
  38:     normal = m * normal;
  39: }
  40: 
  41: 
  42: 
  43: mat4 rotate(vec3 axis, float angle) {
  44:     float s = sin(angle);
  45:     float c = cos(angle);
  46:     float oc = 1. - c;
  47: 
  48:     vec3 sa = axis * s;
  49: 
  50:     mat4 mr = mat4(1.);
  51:     mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
  52:     mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
  53:     mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);
  54: 
  55:     return mr;
  56: }
  57: 
  58: mat4 rotation(vec3 rot) {
  59:     return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
  60: }
  61: 
  62: mat3 modelToNormal(mat4 mat) {
  63:     // Discard the edges. This won't be accurate for scaled or skewed matrices,
  64:     // but we don't have to work with those often.
  65:     mat3 m;
  66:     m[0] = mat[0].xyz;
  67:     m[1] = mat[1].xyz;
  68:     m[2] = mat[2].xyz;
  69:     return m;
  70: }
  71: 
  72: float diffuse(vec3 normal) {
  73:     vec3 n2 = normal * normal * vec3(.6, .25, .8);
  74:     return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
  75: }
  76: 
  77: 
  78: struct Vertex {
  79:     vec3 pos;
  80:     vec3 normal;
  81:     vec2 texCoords;
  82:     vec4 color;
  83:     vec2 modelLight;
  84: };
  85: 
  86: 
  87: struct BlockFrag {
  88:     vec2 texCoords;
  89:     vec4 color;
  90:     float diffuse;
  91:     vec2 light;
  92: };
  93: 
  94: BlockFrag FLWMain(Vertex v) {
  95:     vec4 worldPos = vec4(v.pos, 1.);
  96:     vec3 norm = v.normal;
  97: 
  98:     FLWFinalizeWorldPos(worldPos);
  99:     FLWFinalizeNormal(norm);
 100: 
 101:     BlockFrag b;
 102:     b.diffuse = diffuse(norm);
 103:     b.texCoords = v.texCoords;
 104:     b.light = v.modelLight;
 105: 
 106:     #if defined(DEBUG_NORMAL)
 107:     b.color = vec4(norm, 1.);
 108:     #else
 109:     b.color = vec4(v.color.rgb / diffuse(v.normal), v.color.a);
 110:     #endif
 111: 
 112:     return b;
 113: }
 114: attribute vec3 a_v_pos;
 115: attribute vec3 a_v_normal;
 116: attribute vec2 a_v_texCoords;
 117: attribute vec4 a_v_color;
 118: attribute vec2 a_v_modelLight;
 119: 
 120: 
 121: varying vec2 v2f_texCoords;
 122: varying vec4 v2f_color;
 123: varying float v2f_diffuse;
 124: varying vec2 v2f_light;
 125: 
 126: 
 127: void main() {
 128:     Vertex v;
 129:     v.pos = a_v_pos;
 130: v.normal = a_v_normal;
 131: v.texCoords = a_v_texCoords;
 132: v.color = a_v_color;
 133: v.modelLight = a_v_modelLight;
 134: 
 135: 
 136:     BlockFrag o = FLWMain(v);
 137: 
 138:     v2f_texCoords = o.texCoords;
 139: v2f_color = o.color;
 140: v2f_diffuse = o.diffuse;
 141: v2f_light = o.light;
 142: 
 143: }

[13:33:18] [main/ERROR]: Shader compilation log for flywheel:block.frag: No errors.

[13:33:18] [main/ERROR]: Source for shader 'flywheel:block.frag':
   1: #version 110
   2: #define USE_FOG
   3: #define USE_FOG_LINEAR
   4: 
   5: #if defined(USE_FOG)
   6: varying float FragDistance;
   7: uniform vec4 uFogColor;
   8: #endif
   9: 
  10: #if defined(USE_FOG_LINEAR)
  11: uniform vec2 uFogRange;
  12: 
  13: float FLWFogFactor() {
  14:     return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
  15: }
  16:     #endif
  17: 
  18:     #if defined(USE_FOG_EXP2)
  19: uniform float uFogDensity;
  20: 
  21: float FLWFogFactor() {
  22:     float dist = FragDistance * uFogDensity;
  23:     return 1. / exp2(dist * dist);
  24: }
  25:     #endif
  26: // Adjust the [0,1] normalized lightmap value based on the texture matrix from LightTexture#enableLightmap
  27: vec2 shiftLight(vec2 lm) {
  28:     return lm * 0.99609375 + 0.03125;// * 255/256 + 1/32
  29: }
  30: 
  31: varying vec3 BoxCoord;
  32: varying vec2 BoxLight;
  33: uniform sampler3D uLightVolume;
  34: 
  35: uniform sampler2D uBlockAtlas;
  36: uniform sampler2D uLightMap;
  37: 
  38: vec4 FLWBlockTexture(vec2 texCoords) {
  39:     return texture2D(uBlockAtlas, texCoords);
  40: }
  41: 
  42: void FLWFinalizeColor(vec4 color) {
  43:     #if defined(USE_FOG)
  44:     float a = color.a;
  45:     float fog = clamp(FLWFogFactor(), 0., 1.);
  46: 
  47:     color = mix(uFogColor, color, fog);
  48:     color.a = a;
  49:     #endif
  50: 
  51:     gl_FragColor = color;
  52: }
  53: 
  54: vec4 FLWLight(vec2 lightCoords) {
  55:     lightCoords = max(lightCoords, texture3D(uLightVolume, BoxCoord).rg);
  56: 
  57:     return texture2D(uLightMap, shiftLight(lightCoords));
  58: }
  59: 
  60: 
  61: 
  62: struct BlockFrag {
  63:     vec2 texCoords;
  64:     vec4 color;
  65:     float diffuse;
  66:     vec2 light;
  67: };
  68: 
  69: void FLWMain(BlockFrag r) {
  70:     vec4 tex = FLWBlockTexture(r.texCoords);
  71: 
  72:     vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;
  73: 
  74: //    flw_WorldPos = ;
  75: //    flw_Normal = ;
  76: //    flw_Albedo = tex.rgb;
  77: //    flw_Alpha = tex.a;
  78: //    flw_LightMap = r.light;
  79: //    flw_Tint = r.color;
  80:     FLWFinalizeColor(color);
  81: }
  82: 
  83: varying vec2 v2f_texCoords;
  84: varying vec4 v2f_color;
  85: varying float v2f_diffuse;
  86: varying vec2 v2f_light;
  87: 
  88: 
  89: void main() {
  90:     BlockFrag f;
  91:     f.texCoords = v2f_texCoords;
  92: f.color = v2f_color;
  93: f.diffuse = v2f_diffuse;
  94: f.light = v2f_light;
  95: 
  96: 
  97:     FLWMain(f);
  98: }

[13:33:18] [main/ERROR]: Shader compilation log for create:contraption_structure.vert: No errors.

[13:33:18] [main/ERROR]: Source for shader 'create:contraption_structure.vert':
   1: #version 110
   2: #define USE_FOG
   3: #define USE_FOG_EXP2
   4: 
   5: #define PI 3.1415926538
   6: 
   7: #if defined(USE_FOG)
   8: varying float FragDistance;
   9: #endif
  10: 
  11: varying vec3 BoxCoord;
  12: 
  13: uniform vec3 uLightBoxSize;
  14: uniform vec3 uLightBoxMin;
  15: uniform mat4 uModel;
  16: 
  17: uniform float uTime;
  18: uniform mat4 uViewProjection;
  19: uniform vec3 uCameraPos;
  20: 
  21: void FLWFinalizeWorldPos(inout vec4 worldPos) {
  22:     worldPos = uModel * worldPos;
  23: 
  24:     BoxCoord = (worldPos.xyz - uLightBoxMin) / uLightBoxSize;
  25: 
  26:     #if defined(USE_FOG)
  27:     FragDistance = length(worldPos.xyz);
  28:     #endif
  29: 
  30:     gl_Position = uViewProjection * worldPos;
  31: }
  32: 
  33: void FLWFinalizeNormal(inout vec3 normal) {
  34:     mat3 m;
  35:     m[0] = uModel[0].xyz;
  36:     m[1] = uModel[1].xyz;
  37:     m[2] = uModel[2].xyz;
  38:     normal = m * normal;
  39: }
  40: 
  41: 
  42: 
  43: mat4 rotate(vec3 axis, float angle) {
  44:     float s = sin(angle);
  45:     float c = cos(angle);
  46:     float oc = 1. - c;
  47: 
  48:     vec3 sa = axis * s;
  49: 
  50:     mat4 mr = mat4(1.);
  51:     mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
  52:     mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
  53:     mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);
  54: 
  55:     return mr;
  56: }
  57: 
  58: mat4 rotation(vec3 rot) {
  59:     return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
  60: }
  61: 
  62: mat3 modelToNormal(mat4 mat) {
  63:     // Discard the edges. This won't be accurate for scaled or skewed matrices,
  64:     // but we don't have to work with those often.
  65:     mat3 m;
  66:     m[0] = mat[0].xyz;
  67:     m[1] = mat[1].xyz;
  68:     m[2] = mat[2].xyz;
  69:     return m;
  70: }
  71: 
  72: float diffuse(vec3 normal) {
  73:     vec3 n2 = normal * normal * vec3(.6, .25, .8);
  74:     return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
  75: }
  76: 
  77: 
  78: struct Vertex {
  79:     vec3 pos;
  80:     vec3 normal;
  81:     vec2 texCoords;
  82:     vec4 color;
  83:     vec2 modelLight;
  84: };
  85: 
  86: 
  87: struct BlockFrag {
  88:     vec2 texCoords;
  89:     vec4 color;
  90:     float diffuse;
  91:     vec2 light;
  92: };
  93: 
  94: BlockFrag FLWMain(Vertex v) {
  95:     vec4 worldPos = vec4(v.pos, 1.);
  96:     vec3 norm = v.normal;
  97: 
  98:     FLWFinalizeWorldPos(worldPos);
  99:     FLWFinalizeNormal(norm);
 100: 
 101:     BlockFrag b;
 102:     b.diffuse = diffuse(norm);
 103:     b.texCoords = v.texCoords;
 104:     b.light = v.modelLight;
 105: 
 106:     #if defined(DEBUG_NORMAL)
 107:     b.color = vec4(norm, 1.);
 108:     #else
 109:     b.color = vec4(v.color.rgb / diffuse(v.normal), v.color.a);
 110:     #endif
 111: 
 112:     return b;
 113: }
 114: attribute vec3 a_v_pos;
 115: attribute vec3 a_v_normal;
 116: attribute vec2 a_v_texCoords;
 117: attribute vec4 a_v_color;
 118: attribute vec2 a_v_modelLight;
 119: 
 120: 
 121: varying vec2 v2f_texCoords;
 122: varying vec4 v2f_color;
 123: varying float v2f_diffuse;
 124: varying vec2 v2f_light;
 125: 
 126: 
 127: void main() {
 128:     Vertex v;
 129:     v.pos = a_v_pos;
 130: v.normal = a_v_normal;
 131: v.texCoords = a_v_texCoords;
 132: v.color = a_v_color;
 133: v.modelLight = a_v_modelLight;
 134: 
 135: 
 136:     BlockFrag o = FLWMain(v);
 137: 
 138:     v2f_texCoords = o.texCoords;
 139: v2f_color = o.color;
 140: v2f_diffuse = o.diffuse;
 141: v2f_light = o.light;
 142: 
 143: }

[13:33:18] [main/ERROR]: Shader compilation log for flywheel:block.frag: No errors.

[13:33:18] [main/ERROR]: Source for shader 'flywheel:block.frag':
   1: #version 110
   2: #define USE_FOG
   3: #define USE_FOG_EXP2
   4: 
   5: #if defined(USE_FOG)
   6: varying float FragDistance;
   7: uniform vec4 uFogColor;
   8: #endif
   9: 
  10: #if defined(USE_FOG_LINEAR)
  11: uniform vec2 uFogRange;
  12: 
  13: float FLWFogFactor() {
  14:     return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
  15: }
  16:     #endif
  17: 
  18:     #if defined(USE_FOG_EXP2)
  19: uniform float uFogDensity;
  20: 
  21: float FLWFogFactor() {
  22:     float dist = FragDistance * uFogDensity;
  23:     return 1. / exp2(dist * dist);
  24: }
  25:     #endif
  26: // Adjust the [0,1] normalized lightmap value based on the texture matrix from LightTexture#enableLightmap
  27: vec2 shiftLight(vec2 lm) {
  28:     return lm * 0.99609375 + 0.03125;// * 255/256 + 1/32
  29: }
  30: 
  31: varying vec3 BoxCoord;
  32: varying vec2 BoxLight;
  33: uniform sampler3D uLightVolume;
  34: 
  35: uniform sampler2D uBlockAtlas;
  36: uniform sampler2D uLightMap;
  37: 
  38: vec4 FLWBlockTexture(vec2 texCoords) {
  39:     return texture2D(uBlockAtlas, texCoords);
  40: }
  41: 
  42: void FLWFinalizeColor(vec4 color) {
  43:     #if defined(USE_FOG)
  44:     float a = color.a;
  45:     float fog = clamp(FLWFogFactor(), 0., 1.);
  46: 
  47:     color = mix(uFogColor, color, fog);
  48:     color.a = a;
  49:     #endif
  50: 
  51:     gl_FragColor = color;
  52: }
  53: 
  54: vec4 FLWLight(vec2 lightCoords) {
  55:     lightCoords = max(lightCoords, texture3D(uLightVolume, BoxCoord).rg);
  56: 
  57:     return texture2D(uLightMap, shiftLight(lightCoords));
  58: }
  59: 
  60: 
  61: 
  62: struct BlockFrag {
  63:     vec2 texCoords;
  64:     vec4 color;
  65:     float diffuse;
  66:     vec2 light;
  67: };
  68: 
  69: void FLWMain(BlockFrag r) {
  70:     vec4 tex = FLWBlockTexture(r.texCoords);
  71: 
  72:     vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;
  73: 
  74: //    flw_WorldPos = ;
  75: //    flw_Normal = ;
  76: //    flw_Albedo = tex.rgb;
  77: //    flw_Alpha = tex.a;
  78: //    flw_LightMap = r.light;
  79: //    flw_Tint = r.color;
  80:     FLWFinalizeColor(color);
  81: }
  82: 
  83: varying vec2 v2f_texCoords;
  84: varying vec4 v2f_color;
  85: varying float v2f_diffuse;
  86: varying vec2 v2f_light;
  87: 
  88: 
  89: void main() {
  90:     BlockFrag f;
  91:     f.texCoords = v2f_texCoords;
  92: f.color = v2f_color;
  93: f.diffuse = v2f_diffuse;
  94: f.light = v2f_light;
  95: 
  96: 
  97:     FLWMain(f);
  98: }

[13:33:18] [main/ERROR]: Shader compilation log for create:contraption_structure.vert: No errors.

[13:33:18] [main/ERROR]: Source for shader 'create:contraption_structure.vert':
   1: #version 110
   2: 
   3: #define PI 3.1415926538
   4: 
   5: #if defined(USE_FOG)
   6: varying float FragDistance;
   7: #endif
   8: 
   9: varying vec3 BoxCoord;
  10: 
  11: uniform vec3 uLightBoxSize;
  12: uniform vec3 uLightBoxMin;
  13: uniform mat4 uModel;
  14: 
  15: uniform float uTime;
  16: uniform mat4 uViewProjection;
  17: uniform vec3 uCameraPos;
  18: 
  19: void FLWFinalizeWorldPos(inout vec4 worldPos) {
  20:     worldPos = uModel * worldPos;
  21: 
  22:     BoxCoord = (worldPos.xyz - uLightBoxMin) / uLightBoxSize;
  23: 
  24:     #if defined(USE_FOG)
  25:     FragDistance = length(worldPos.xyz);
  26:     #endif
  27: 
  28:     gl_Position = uViewProjection * worldPos;
  29: }
  30: 
  31: void FLWFinalizeNormal(inout vec3 normal) {
  32:     mat3 m;
  33:     m[0] = uModel[0].xyz;
  34:     m[1] = uModel[1].xyz;
  35:     m[2] = uModel[2].xyz;
  36:     normal = m * normal;
  37: }
  38: 
  39: 
  40: 
  41: mat4 rotate(vec3 axis, float angle) {
  42:     float s = sin(angle);
  43:     float c = cos(angle);
  44:     float oc = 1. - c;
  45: 
  46:     vec3 sa = axis * s;
  47: 
  48:     mat4 mr = mat4(1.);
  49:     mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
  50:     mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
  51:     mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);
  52: 
  53:     return mr;
  54: }
  55: 
  56: mat4 rotation(vec3 rot) {
  57:     return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
  58: }
  59: 
  60: mat3 modelToNormal(mat4 mat) {
  61:     // Discard the edges. This won't be accurate for scaled or skewed matrices,
  62:     // but we don't have to work with those often.
  63:     mat3 m;
  64:     m[0] = mat[0].xyz;
  65:     m[1] = mat[1].xyz;
  66:     m[2] = mat[2].xyz;
  67:     return m;
  68: }
  69: 
  70: float diffuse(vec3 normal) {
  71:     vec3 n2 = normal * normal * vec3(.6, .25, .8);
  72:     return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
  73: }
  74: 
  75: 
  76: struct Vertex {
  77:     vec3 pos;
  78:     vec3 normal;
  79:     vec2 texCoords;
  80:     vec4 color;
  81:     vec2 modelLight;
  82: };
  83: 
  84: 
  85: struct BlockFrag {
  86:     vec2 texCoords;
  87:     vec4 color;
  88:     float diffuse;
  89:     vec2 light;
  90: };
  91: 
  92: BlockFrag FLWMain(Vertex v) {
  93:     vec4 worldPos = vec4(v.pos, 1.);
  94:     vec3 norm = v.normal;
  95: 
  96:     FLWFinalizeWorldPos(worldPos);
  97:     FLWFinalizeNormal(norm);
  98: 
  99:     BlockFrag b;
 100:     b.diffuse = diffuse(norm);
 101:     b.texCoords = v.texCoords;
 102:     b.light = v.modelLight;
 103: 
 104:     #if defined(DEBUG_NORMAL)
 105:     b.color = vec4(norm, 1.);
 106:     #else
 107:     b.color = vec4(v.color.rgb / diffuse(v.normal), v.color.a);
 108:     #endif
 109: 
 110:     return b;
 111: }
 112: attribute vec3 a_v_pos;
 113: attribute vec3 a_v_normal;
 114: attribute vec2 a_v_texCoords;
 115: attribute vec4 a_v_color;
 116: attribute vec2 a_v_modelLight;
 117: 
 118: 
 119: varying vec2 v2f_texCoords;
 120: varying vec4 v2f_color;
 121: varying float v2f_diffuse;
 122: varying vec2 v2f_light;
 123: 
 124: 
 125: void main() {
 126:     Vertex v;
 127:     v.pos = a_v_pos;
 128: v.normal = a_v_normal;
 129: v.texCoords = a_v_texCoords;
 130: v.color = a_v_color;
 131: v.modelLight = a_v_modelLight;
 132: 
 133: 
 134:     BlockFrag o = FLWMain(v);
 135: 
 136:     v2f_texCoords = o.texCoords;
 137: v2f_color = o.color;
 138: v2f_diffuse = o.diffuse;
 139: v2f_light = o.light;
 140: 
 141: }

[13:33:18] [main/ERROR]: Shader compilation log for flywheel:block.frag: No errors.

[13:33:18] [main/ERROR]: Source for shader 'flywheel:block.frag':
   1: #version 110
   2: 
   3: #if defined(USE_FOG)
   4: varying float FragDistance;
   5: uniform vec4 uFogColor;
   6: #endif
   7: 
   8: #if defined(USE_FOG_LINEAR)
   9: uniform vec2 uFogRange;
  10: 
  11: float FLWFogFactor() {
  12:     return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
  13: }
  14:     #endif
  15: 
  16:     #if defined(USE_FOG_EXP2)
  17: uniform float uFogDensity;
  18: 
  19: float FLWFogFactor() {
  20:     float dist = FragDistance * uFogDensity;
  21:     return 1. / exp2(dist * dist);
  22: }
  23:     #endif
  24: // Adjust the [0,1] normalized lightmap value based on the texture matrix from LightTexture#enableLightmap
  25: vec2 shiftLight(vec2 lm) {
  26:     return lm * 0.99609375 + 0.03125;// * 255/256 + 1/32
  27: }
  28: 
  29: varying vec3 BoxCoord;
  30: varying vec2 BoxLight;
  31: uniform sampler3D uLightVolume;
  32: 
  33: uniform sampler2D uBlockAtlas;
  34: uniform sampler2D uLightMap;
  35: 
  36: vec4 FLWBlockTexture(vec2 texCoords) {
  37:     return texture2D(uBlockAtlas, texCoords);
  38: }
  39: 
  40: void FLWFinalizeColor(vec4 color) {
  41:     #if defined(USE_FOG)
  42:     float a = color.a;
  43:     float fog = clamp(FLWFogFactor(), 0., 1.);
  44: 
  45:     color = mix(uFogColor, color, fog);
  46:     color.a = a;
  47:     #endif
  48: 
  49:     gl_FragColor = color;
  50: }
  51: 
  52: vec4 FLWLight(vec2 lightCoords) {
  53:     lightCoords = max(lightCoords, texture3D(uLightVolume, BoxCoord).rg);
  54: 
  55:     return texture2D(uLightMap, shiftLight(lightCoords));
  56: }
  57: 
  58: 
  59: 
  60: struct BlockFrag {
  61:     vec2 texCoords;
  62:     vec4 color;
  63:     float diffuse;
  64:     vec2 light;
  65: };
  66: 
  67: void FLWMain(BlockFrag r) {
  68:     vec4 tex = FLWBlockTexture(r.texCoords);
  69: 
  70:     vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;
  71: 
  72: //    flw_WorldPos = ;
  73: //    flw_Normal = ;
  74: //    flw_Albedo = tex.rgb;
  75: //    flw_Alpha = tex.a;
  76: //    flw_LightMap = r.light;
  77: //    flw_Tint = r.color;
  78:     FLWFinalizeColor(color);
  79: }
  80: 
  81: varying vec2 v2f_texCoords;
  82: varying vec4 v2f_color;
  83: varying float v2f_diffuse;
  84: varying vec2 v2f_light;
  85: 
  86: 
  87: void main() {
  88:     BlockFrag f;
  89:     f.texCoords = v2f_texCoords;
  90: f.color = v2f_color;
  91: f.diffuse = v2f_diffuse;
  92: f.light = v2f_light;
  93: 
  94: 
  95:     FLWMain(f);
  96: }

[13:33:18] [main/INFO]: Loading context 'flywheel:context/crumbling'
[13:33:18] [main/ERROR]: Shader compilation log for create:rotating.vert: No errors.

[13:33:18] [main/ERROR]: Source for shader 'create:rotating.vert':
   1: #version 110
   2: #define DEBUG_RAINBOW
   3: 
   4: #define PI 3.1415926538
   5: 
   6: uniform float uTime;
   7: uniform mat4 uViewProjection;
   8: uniform vec3 uCameraPos;
   9: 
  10: #if defined(USE_FOG)
  11: varying float FragDistance;
  12: #endif
  13: 
  14: void FLWFinalizeWorldPos(inout vec4 worldPos) {
  15:     #if defined(USE_FOG)
  16:     FragDistance = length(worldPos.xyz - uCameraPos);
  17:     #endif
  18: 
  19:     gl_Position = uViewProjection * worldPos;
  20: }
  21: 
  22: void FLWFinalizeNormal(inout vec3 normal) {
  23:     // noop
  24: }
  25: 
  26: 
  27: mat4 rotate(vec3 axis, float angle) {
  28:     float s = sin(angle);
  29:     float c = cos(angle);
  30:     float oc = 1. - c;
  31: 
  32:     vec3 sa = axis * s;
  33: 
  34:     mat4 mr = mat4(1.);
  35:     mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
  36:     mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
  37:     mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);
  38: 
  39:     return mr;
  40: }
  41: 
  42: mat4 rotation(vec3 rot) {
  43:     return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
  44: }
  45: 
  46: mat3 modelToNormal(mat4 mat) {
  47:     // Discard the edges. This won't be accurate for scaled or skewed matrices,
  48:     // but we don't have to work with those often.
  49:     mat3 m;
  50:     m[0] = mat[0].xyz;
  51:     m[1] = mat[1].xyz;
  52:     m[2] = mat[2].xyz;
  53:     return m;
  54: }
  55: 
  56: float diffuse(vec3 normal) {
  57:     vec3 n2 = normal * normal * vec3(.6, .25, .8);
  58:     return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
  59: }
  60: 
  61: 
  62: struct Rotating {
  63:     vec2 light;
  64:     vec4 color;
  65:     vec3 pos;
  66:     float speed;
  67:     float offset;
  68:     vec3 axis;
  69: };
  70: 
  71: 
  72: struct Vertex {
  73:     vec3 pos;
  74:     vec3 normal;
  75:     vec2 texCoords;
  76: };
  77: 
  78: struct BlockFrag {
  79:     vec2 texCoords;
  80:     vec4 color;
  81:     float diffuse;
  82:     vec2 light;
  83: };
  84: 
  85: mat4 kineticRotation(float offset, float speed, vec3 axis) {
  86:     float degrees = offset + uTime * speed * 3./10.;
  87:     float angle = fract(degrees / 360.) * PI * 2.;
  88: 
  89:     return rotate(axis, angle);
  90: }
  91: 
  92: BlockFrag FLWMain(Vertex v, Rotating instance) {
  93:     mat4 spin = kineticRotation(instance.offset, instance.speed, instance.axis);
  94: 
  95:     vec4 worldPos = spin * vec4(v.pos - .5, 1.);
  96:     worldPos += vec4(instance.pos + .5, 0.);
  97: 
  98:     vec3 norm = modelToNormal(spin) * v.normal;
  99: 
 100:     FLWFinalizeWorldPos(worldPos);
 101:     FLWFinalizeNormal(norm);
 102: 
 103:     BlockFrag b;
 104:     b.diffuse = diffuse(norm);
 105:     b.texCoords = v.texCoords;
 106:     b.light = instance.light;
 107: 
 108:     #if defined(DEBUG_RAINBOW)
 109:     b.color = instance.color;
 110:     #elif defined(DEBUG_NORMAL)
 111:     b.color = vec4(norm, 1.);
 112:     #else
 113:     b.color = vec4(1.);
 114:     #endif
 115: 
 116:     return b;
 117: }
 118: attribute vec3 a_v_pos;
 119: attribute vec3 a_v_normal;
 120: attribute vec2 a_v_texCoords;
 121: 
 122: attribute vec2 a_i_light;
 123: attribute vec4 a_i_color;
 124: attribute vec3 a_i_pos;
 125: attribute float a_i_speed;
 126: attribute float a_i_offset;
 127: attribute vec3 a_i_axis;
 128: 
 129: 
 130: varying vec2 v2f_texCoords;
 131: varying vec4 v2f_color;
 132: varying float v2f_diffuse;
 133: varying vec2 v2f_light;
 134: 
 135: 
 136: void main() {
 137:     Vertex v;
 138:     v.pos = a_v_pos;
 139: v.normal = a_v_normal;
 140: v.texCoords = a_v_texCoords;
 141: 
 142: 
 143:     Rotating i;
 144:     i.light = a_i_light;
 145: i.color = a_i_color;
 146: i.pos = a_i_pos;
 147: i.speed = a_i_speed;
 148: i.offset = a_i_offset;
 149: i.axis = a_i_axis;
 150: 
 151: 
 152:     BlockFrag o = FLWMain(v, i);
 153: 
 154:     v2f_texCoords = o.texCoords;
 155: v2f_color = o.color;
 156: v2f_diffuse = o.diffuse;
 157: v2f_light = o.light;
 158: 
 159: }

[13:33:18] [main/ERROR]: Shader compilation log for flywheel:block.frag: No errors.

[13:33:18] [main/ERROR]: Source for shader 'flywheel:block.frag':
   1: #version 110
   2: #define DEBUG_RAINBOW
   3: 
   4: #if defined(USE_FOG)
   5: varying float FragDistance;
   6: uniform vec4 uFogColor;
   7: #endif
   8: 
   9: #if defined(USE_FOG_LINEAR)
  10: uniform vec2 uFogRange;
  11: 
  12: float FLWFogFactor() {
  13:     return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
  14: }
  15:     #endif
  16: 
  17:     #if defined(USE_FOG_EXP2)
  18: uniform float uFogDensity;
  19: 
  20: float FLWFogFactor() {
  21:     float dist = FragDistance * uFogDensity;
  22:     return 1. / exp2(dist * dist);
  23: }
  24:     #endif
  25: 
  26: uniform vec2 uTextureScale;
  27: uniform sampler2D uBlockAtlas;
  28: uniform sampler2D uLightMap;
  29: uniform sampler2D uCrumbling;
  30: 
  31: vec4 FLWBlockTexture(vec2 texCoords) {
  32:     vec4 cr = texture2D(uCrumbling, texCoords * uTextureScale);
  33:     float diffuseAlpha = texture2D(uBlockAtlas, texCoords).a;
  34:     cr.a = cr.a * diffuseAlpha;
  35:     return cr;
  36: }
  37: 
  38: void FLWFinalizeColor(vec4 color) {
  39:     #if defined(USE_FOG)
  40:     float a = color.a;
  41:     float fog = clamp(FLWFogFactor(), 0., 1.);
  42: 
  43:     color = mix(uFogColor, color, fog);
  44:     color.a = a;
  45:     #endif
  46: 
  47:     gl_FragColor = color;
  48: }
  49: 
  50: vec4 FLWLight(vec2 lightCoords) {
  51:     return vec4(1.);
  52: }
  53: 
  54: 
  55: 
  56: struct BlockFrag {
  57:     vec2 texCoords;
  58:     vec4 color;
  59:     float diffuse;
  60:     vec2 light;
  61: };
  62: 
  63: void FLWMain(BlockFrag r) {
  64:     vec4 tex = FLWBlockTexture(r.texCoords);
  65: 
  66:     vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;
  67: 
  68: //    flw_WorldPos = ;
  69: //    flw_Normal = ;
  70: //    flw_Albedo = tex.rgb;
  71: //    flw_Alpha = tex.a;
  72: //    flw_LightMap = r.light;
  73: //    flw_Tint = r.color;
  74:     FLWFinalizeColor(color);
  75: }
  76: 
  77: varying vec2 v2f_texCoords;
  78: varying vec4 v2f_color;
  79: varying float v2f_diffuse;
  80: varying vec2 v2f_light;
  81: 
  82: 
  83: //vec3 flw_WorldPos;
  84: //vec3 flw_Normal;
  85: //vec3 flw_Albedo;
  86: //float flw_Alpha;
  87: //vec2 flw_LightMap;
  88: //vec4 flw_Tint;
  89: 
  90: void main() {
  91:     BlockFrag f;
  92:     f.texCoords = v2f_texCoords;
  93: f.color = v2f_color;
  94: f.diffuse = v2f_diffuse;
  95: f.light = v2f_light;
  96: 
  97: 
  98:     FLWMain(f);
  99: }

[13:33:18] [main/ERROR]: Shader compilation log for create:rotating.vert: No errors.

[13:33:18] [main/ERROR]: Source for shader 'create:rotating.vert':
   1: #version 110
   2: #define DEBUG_NORMAL
   3: 
   4: #define PI 3.1415926538
   5: 
   6: uniform float uTime;
   7: uniform mat4 uViewProjection;
   8: uniform vec3 uCameraPos;
   9: 
  10: #if defined(USE_FOG)
  11: varying float FragDistance;
  12: #endif
  13: 
  14: void FLWFinalizeWorldPos(inout vec4 worldPos) {
  15:     #if defined(USE_FOG)
  16:     FragDistance = length(worldPos.xyz - uCameraPos);
  17:     #endif
  18: 
  19:     gl_Position = uViewProjection * worldPos;
  20: }
  21: 
  22: void FLWFinalizeNormal(inout vec3 normal) {
  23:     // noop
  24: }
  25: 
  26: 
  27: mat4 rotate(vec3 axis, float angle) {
  28:     float s = sin(angle);
  29:     float c = cos(angle);
  30:     float oc = 1. - c;
  31: 
  32:     vec3 sa = axis * s;
  33: 
  34:     mat4 mr = mat4(1.);
  35:     mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
  36:     mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
  37:     mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);
  38: 
  39:     return mr;
  40: }
  41: 
  42: mat4 rotation(vec3 rot) {
  43:     return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
  44: }
  45: 
  46: mat3 modelToNormal(mat4 mat) {
  47:     // Discard the edges. This won't be accurate for scaled or skewed matrices,
  48:     // but we don't have to work with those often.
  49:     mat3 m;
  50:     m[0] = mat[0].xyz;
  51:     m[1] = mat[1].xyz;
  52:     m[2] = mat[2].xyz;
  53:     return m;
  54: }
  55: 
  56: float diffuse(vec3 normal) {
  57:     vec3 n2 = normal * normal * vec3(.6, .25, .8);
  58:     return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
  59: }
  60: 
  61: 
  62: struct Rotating {
  63:     vec2 light;
  64:     vec4 color;
  65:     vec3 pos;
  66:     float speed;
  67:     float offset;
  68:     vec3 axis;
  69: };
  70: 
  71: 
  72: struct Vertex {
  73:     vec3 pos;
  74:     vec3 normal;
  75:     vec2 texCoords;
  76: };
  77: 
  78: struct BlockFrag {
  79:     vec2 texCoords;
  80:     vec4 color;
  81:     float diffuse;
  82:     vec2 light;
  83: };
  84: 
  85: mat4 kineticRotation(float offset, float speed, vec3 axis) {
  86:     float degrees = offset + uTime * speed * 3./10.;
  87:     float angle = fract(degrees / 360.) * PI * 2.;
  88: 
  89:     return rotate(axis, angle);
  90: }
  91: 
  92: BlockFrag FLWMain(Vertex v, Rotating instance) {
  93:     mat4 spin = kineticRotation(instance.offset, instance.speed, instance.axis);
  94: 
  95:     vec4 worldPos = spin * vec4(v.pos - .5, 1.);
  96:     worldPos += vec4(instance.pos + .5, 0.);
  97: 
  98:     vec3 norm = modelToNormal(spin) * v.normal;
  99: 
 100:     FLWFinalizeWorldPos(worldPos);
 101:     FLWFinalizeNormal(norm);
 102: 
 103:     BlockFrag b;
 104:     b.diffuse = diffuse(norm);
 105:     b.texCoords = v.texCoords;
 106:     b.light = instance.light;
 107: 
 108:     #if defined(DEBUG_RAINBOW)
 109:     b.color = instance.color;
 110:     #elif defined(DEBUG_NORMAL)
 111:     b.color = vec4(norm, 1.);
 112:     #else
 113:     b.color = vec4(1.);
 114:     #endif
 115: 
 116:     return b;
 117: }
 118: attribute vec3 a_v_pos;
 119: attribute vec3 a_v_normal;
 120: attribute vec2 a_v_texCoords;
 121: 
 122: attribute vec2 a_i_light;
 123: attribute vec4 a_i_color;
 124: attribute vec3 a_i_pos;
 125: attribute float a_i_speed;
 126: attribute float a_i_offset;
 127: attribute vec3 a_i_axis;
 128: 
 129: 
 130: varying vec2 v2f_texCoords;
 131: varying vec4 v2f_color;
 132: varying float v2f_diffuse;
 133: varying vec2 v2f_light;
 134: 
 135: 
 136: void main() {
 137:     Vertex v;
 138:     v.pos = a_v_pos;
 139: v.normal = a_v_normal;
 140: v.texCoords = a_v_texCoords;
 141: 
 142: 
 143:     Rotating i;
 144:     i.light = a_i_light;
 145: i.color = a_i_color;
 146: i.pos = a_i_pos;
 147: i.speed = a_i_speed;
 148: i.offset = a_i_offset;
 149: i.axis = a_i_axis;
 150: 
 151: 
 152:     BlockFrag o = FLWMain(v, i);
 153: 
 154:     v2f_texCoords = o.texCoords;
 155: v2f_color = o.color;
 156: v2f_diffuse = o.diffuse;
 157: v2f_light = o.light;
 158: 
 159: }

[13:33:18] [main/ERROR]: Shader compilation log for flywheel:block.frag: No errors.

[13:33:18] [main/ERROR]: Source for shader 'flywheel:block.frag':
   1: #version 110
   2: #define DEBUG_NORMAL
   3: 
   4: #if defined(USE_FOG)
   5: varying float FragDistance;
   6: uniform vec4 uFogColor;
   7: #endif
   8: 
   9: #if defined(USE_FOG_LINEAR)
  10: uniform vec2 uFogRange;
  11: 
  12: float FLWFogFactor() {
  13:     return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
  14: }
  15:     #endif
  16: 
  17:     #if defined(USE_FOG_EXP2)
  18: uniform float uFogDensity;
  19: 
  20: float FLWFogFactor() {
  21:     float dist = FragDistance * uFogDensity;
  22:     return 1. / exp2(dist * dist);
  23: }
  24:     #endif
  25: 
  26: uniform vec2 uTextureScale;
  27: uniform sampler2D uBlockAtlas;
  28: uniform sampler2D uLightMap;
  29: uniform sampler2D uCrumbling;
  30: 
  31: vec4 FLWBlockTexture(vec2 texCoords) {
  32:     vec4 cr = texture2D(uCrumbling, texCoords * uTextureScale);
  33:     float diffuseAlpha = texture2D(uBlockAtlas, texCoords).a;
  34:     cr.a = cr.a * diffuseAlpha;
  35:     return cr;
  36: }
  37: 
  38: void FLWFinalizeColor(vec4 color) {
  39:     #if defined(USE_FOG)
  40:     float a = color.a;
  41:     float fog = clamp(FLWFogFactor(), 0., 1.);
  42: 
  43:     color = mix(uFogColor, color, fog);
  44:     color.a = a;
  45:     #endif
  46: 
  47:     gl_FragColor = color;
  48: }
  49: 
  50: vec4 FLWLight(vec2 lightCoords) {
  51:     return vec4(1.);
  52: }
  53: 
  54: 
  55: 
  56: struct BlockFrag {
  57:     vec2 texCoords;
  58:     vec4 color;
  59:     float diffuse;
  60:     vec2 light;
  61: };
  62: 
  63: void FLWMain(BlockFrag r) {
  64:     vec4 tex = FLWBlockTexture(r.texCoords);
  65: 
  66:     vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;
  67: 
  68: //    flw_WorldPos = ;
  69: //    flw_Normal = ;
  70: //    flw_Albedo = tex.rgb;
  71: //    flw_Alpha = tex.a;
  72: //    flw_LightMap = r.light;
  73: //    flw_Tint = r.color;
  74:     FLWFinalizeColor(color);
  75: }
  76: 
  77: varying vec2 v2f_texCoords;
  78: varying vec4 v2f_color;
  79: varying float v2f_diffuse;
  80: varying vec2 v2f_light;
  81: 
  82: 
  83: //vec3 flw_WorldPos;
  84: //vec3 flw_Normal;
  85: //vec3 flw_Albedo;
  86: //float flw_Alpha;
  87: //vec2 flw_LightMap;
  88: //vec4 flw_Tint;
  89: 
  90: void main() {
  91:     BlockFrag f;
  92:     f.texCoords = v2f_texCoords;
  93: f.color = v2f_color;
  94: f.diffuse = v2f_diffuse;
  95: f.light = v2f_light;
  96: 
  97: 
  98:     FLWMain(f);
  99: }

[13:33:18] [main/ERROR]: Shader compilation log for create:rotating.vert: No errors.

[13:33:18] [main/ERROR]: Source for shader 'create:rotating.vert':
   1: #version 110
   2: #define USE_FOG
   3: #define USE_FOG_LINEAR
   4: 
   5: #define PI 3.1415926538
   6: 
   7: uniform float uTime;
   8: uniform mat4 uViewProjection;
   9: uniform vec3 uCameraPos;
  10: 
  11: #if defined(USE_FOG)
  12: varying float FragDistance;
  13: #endif
  14: 
  15: void FLWFinalizeWorldPos(inout vec4 worldPos) {
  16:     #if defined(USE_FOG)
  17:     FragDistance = length(worldPos.xyz - uCameraPos);
  18:     #endif
  19: 
  20:     gl_Position = uViewProjection * worldPos;
  21: }
  22: 
  23: void FLWFinalizeNormal(inout vec3 normal) {
  24:     // noop
  25: }
  26: 
  27: 
  28: mat4 rotate(vec3 axis, float angle) {
  29:     float s = sin(angle);
  30:     float c = cos(angle);
  31:     float oc = 1. - c;
  32: 
  33:     vec3 sa = axis * s;
  34: 
  35:     mat4 mr = mat4(1.);
  36:     mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
  37:     mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
  38:     mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);
  39: 
  40:     return mr;
  41: }
  42: 
  43: mat4 rotation(vec3 rot) {
  44:     return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
  45: }
  46: 
  47: mat3 modelToNormal(mat4 mat) {
  48:     // Discard the edges. This won't be accurate for scaled or skewed matrices,
  49:     // but we don't have to work with those often.
  50:     mat3 m;
  51:     m[0] = mat[0].xyz;
  52:     m[1] = mat[1].xyz;
  53:     m[2] = mat[2].xyz;
  54:     return m;
  55: }
  56: 
  57: float diffuse(vec3 normal) {
  58:     vec3 n2 = normal * normal * vec3(.6, .25, .8);
  59:     return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
  60: }
  61: 
  62: 
  63: struct Rotating {
  64:     vec2 light;
  65:     vec4 color;
  66:     vec3 pos;
  67:     float speed;
  68:     float offset;
  69:     vec3 axis;
  70: };
  71: 
  72: 
  73: struct Vertex {
  74:     vec3 pos;
  75:     vec3 normal;
  76:     vec2 texCoords;
  77: };
  78: 
  79: struct BlockFrag {
  80:     vec2 texCoords;
  81:     vec4 color;
  82:     float diffuse;
  83:     vec2 light;
  84: };
  85: 
  86: mat4 kineticRotation(float offset, float speed, vec3 axis) {
  87:     float degrees = offset + uTime * speed * 3./10.;
  88:     float angle = fract(degrees / 360.) * PI * 2.;
  89: 
  90:     return rotate(axis, angle);
  91: }
  92: 
  93: BlockFrag FLWMain(Vertex v, Rotating instance) {
  94:     mat4 spin = kineticRotation(instance.offset, instance.speed, instance.axis);
  95: 
  96:     vec4 worldPos = spin * vec4(v.pos - .5, 1.);
  97:     worldPos += vec4(instance.pos + .5, 0.);
  98: 
  99:     vec3 norm = modelToNormal(spin) * v.normal;
 100: 
 101:     FLWFinalizeWorldPos(worldPos);
 102:     FLWFinalizeNormal(norm);
 103: 
 104:     BlockFrag b;
 105:     b.diffuse = diffuse(norm);
 106:     b.texCoords = v.texCoords;
 107:     b.light = instance.light;
 108: 
 109:     #if defined(DEBUG_RAINBOW)
 110:     b.color = instance.color;
 111:     #elif defined(DEBUG_NORMAL)
 112:     b.color = vec4(norm, 1.);
 113:     #else
 114:     b.color = vec4(1.);
 115:     #endif
 116: 
 117:     return b;
 118: }
 119: attribute vec3 a_v_pos;
 120: attribute vec3 a_v_normal;
 121: attribute vec2 a_v_texCoords;
 122: 
 123: attribute vec2 a_i_light;
 124: attribute vec4 a_i_color;
 125: attribute vec3 a_i_pos;
 126: attribute float a_i_speed;
 127: attribute float a_i_offset;
 128: attribute vec3 a_i_axis;
 129: 
 130: 
 131: varying vec2 v2f_texCoords;
 132: varying vec4 v2f_color;
 133: varying float v2f_diffuse;
 134: varying vec2 v2f_light;
 135: 
 136: 
 137: void main() {
 138:     Vertex v;
 139:     v.pos = a_v_pos;
 140: v.normal = a_v_normal;
 141: v.texCoords = a_v_texCoords;
 142: 
 143: 
 144:     Rotating i;
 145:     i.light = a_i_light;
 146: i.color = a_i_color;
 147: i.pos = a_i_pos;
 148: i.speed = a_i_speed;
 149: i.offset = a_i_offset;
 150: i.axis = a_i_axis;
 151: 
 152: 
 153:     BlockFrag o = FLWMain(v, i);
 154: 
 155:     v2f_texCoords = o.texCoords;
 156: v2f_color = o.color;
 157: v2f_diffuse = o.diffuse;
 158: v2f_light = o.light;
 159: 
 160: }

[13:33:18] [main/ERROR]: Shader compilation log for flywheel:block.frag: No errors.

[13:33:18] [main/ERROR]: Source for shader 'flywheel:block.frag':
   1: #version 110
   2: #define USE_FOG
   3: #define USE_FOG_LINEAR
   4: 
   5: #if defined(USE_FOG)
   6: varying float FragDistance;
   7: uniform vec4 uFogColor;
   8: #endif
   9: 
  10: #if defined(USE_FOG_LINEAR)
  11: uniform vec2 uFogRange;
  12: 
  13: float FLWFogFactor() {
  14:     return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
  15: }
  16:     #endif
  17: 
  18:     #if defined(USE_FOG_EXP2)
  19: uniform float uFogDensity;
  20: 
  21: float FLWFogFactor() {
  22:     float dist = FragDistance * uFogDensity;
  23:     return 1. / exp2(dist * dist);
  24: }
  25:     #endif
  26: 
  27: uniform vec2 uTextureScale;
  28: uniform sampler2D uBlockAtlas;
  29: uniform sampler2D uLightMap;
  30: uniform sampler2D uCrumbling;
  31: 
  32: vec4 FLWBlockTexture(vec2 texCoords) {
  33:     vec4 cr = texture2D(uCrumbling, texCoords * uTextureScale);
  34:     float diffuseAlpha = texture2D(uBlockAtlas, texCoords).a;
  35:     cr.a = cr.a * diffuseAlpha;
  36:     return cr;
  37: }
  38: 
  39: void FLWFinalizeColor(vec4 color) {
  40:     #if defined(USE_FOG)
  41:     float a = color.a;
  42:     float fog = clamp(FLWFogFactor(), 0., 1.);
  43: 
  44:     color = mix(uFogColor, color, fog);
  45:     color.a = a;
  46:     #endif
  47: 
  48:     gl_FragColor = color;
  49: }
  50: 
  51: vec4 FLWLight(vec2 lightCoords) {
  52:     return vec4(1.);
  53: }
  54: 
  55: 
  56: 
  57: struct BlockFrag {
  58:     vec2 texCoords;
  59:     vec4 color;
  60:     float diffuse;
  61:     vec2 light;
  62: };
  63: 
  64: void FLWMain(BlockFrag r) {
  65:     vec4 tex = FLWBlockTexture(r.texCoords);
  66: 
  67:     vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;
  68: 
  69: //    flw_WorldPos = ;
  70: //    flw_Normal = ;
  71: //    flw_Albedo = tex.rgb;
  72: //    flw_Alpha = tex.a;
  73: //    flw_LightMap = r.light;
  74: //    flw_Tint = r.color;
  75:     FLWFinalizeColor(color);
  76: }
  77: 
  78: varying vec2 v2f_texCoords;
  79: varying vec4 v2f_color;
  80: varying float v2f_diffuse;
  81: varying vec2 v2f_light;
  82: 
  83: 
  84: //vec3 flw_WorldPos;
  85: //vec3 flw_Normal;
  86: //vec3 flw_Albedo;
  87: //float flw_Alpha;
  88: //vec2 flw_LightMap;
  89: //vec4 flw_Tint;
  90: 
  91: void main() {
  92:     BlockFrag f;
  93:     f.texCoords = v2f_texCoords;
  94: f.color = v2f_color;
  95: f.diffuse = v2f_diffuse;
  96: f.light = v2f_light;
  97: 
  98: 
  99:     FLWMain(f);
 100: }

[13:33:18] [main/ERROR]: Shader compilation log for create:rotating.vert: No errors.

[13:33:18] [main/ERROR]: Source for shader 'create:rotating.vert':
   1: #version 110
   2: #define USE_FOG
   3: #define USE_FOG_EXP2
   4: 
   5: #define PI 3.1415926538
   6: 
   7: uniform float uTime;
   8: uniform mat4 uViewProjection;
   9: uniform vec3 uCameraPos;
  10: 
  11: #if defined(USE_FOG)
  12: varying float FragDistance;
  13: #endif
  14: 
  15: void FLWFinalizeWorldPos(inout vec4 worldPos) {
  16:     #if defined(USE_FOG)
  17:     FragDistance = length(worldPos.xyz - uCameraPos);
  18:     #endif
  19: 
  20:     gl_Position = uViewProjection * worldPos;
  21: }
  22: 
  23: void FLWFinalizeNormal(inout vec3 normal) {
  24:     // noop
  25: }
  26: 
  27: 
  28: mat4 rotate(vec3 axis, float angle) {
  29:     float s = sin(angle);
  30:     float c = cos(angle);
  31:     float oc = 1. - c;
  32: 
  33:     vec3 sa = axis * s;
  34: 
  35:     mat4 mr = mat4(1.);
  36:     mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
  37:     mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
  38:     mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);
  39: 
  40:     return mr;
  41: }
  42: 
  43: mat4 rotation(vec3 rot) {
  44:     return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
  45: }
  46: 
  47: mat3 modelToNormal(mat4 mat) {
  48:     // Discard the edges. This won't be accurate for scaled or skewed matrices,
  49:     // but we don't have to work with those often.
  50:     mat3 m;
  51:     m[0] = mat[0].xyz;
  52:     m[1] = mat[1].xyz;
  53:     m[2] = mat[2].xyz;
  54:     return m;
  55: }
  56: 
  57: float diffuse(vec3 normal) {
  58:     vec3 n2 = normal * normal * vec3(.6, .25, .8);
  59:     return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
  60: }
  61: 
  62: 
  63: struct Rotating {
  64:     vec2 light;
  65:     vec4 color;
  66:     vec3 pos;
  67:     float speed;
  68:     float offset;
  69:     vec3 axis;
  70: };
  71: 
  72: 
  73: struct Vertex {
  74:     vec3 pos;
  75:     vec3 normal;
  76:     vec2 texCoords;
  77: };
  78: 
  79: struct BlockFrag {
  80:     vec2 texCoords;
  81:     vec4 color;
  82:     float diffuse;
  83:     vec2 light;
  84: };
  85: 
  86: mat4 kineticRotation(float offset, float speed, vec3 axis) {
  87:     float degrees = offset + uTime * speed * 3./10.;
  88:     float angle = fract(degrees / 360.) * PI * 2.;
  89: 
  90:     return rotate(axis, angle);
  91: }
  92: 
  93: BlockFrag FLWMain(Vertex v, Rotating instance) {
  94:     mat4 spin = kineticRotation(instance.offset, instance.speed, instance.axis);
  95: 
  96:     vec4 worldPos = spin * vec4(v.pos - .5, 1.);
  97:     worldPos += vec4(instance.pos + .5, 0.);
  98: 
  99:     vec3 norm = modelToNormal(spin) * v.normal;
 100: 
 101:     FLWFinalizeWorldPos(worldPos);
 102:     FLWFinalizeNormal(norm);
 103: 
 104:     BlockFrag b;
 105:     b.diffuse = diffuse(norm);
 106:     b.texCoords = v.texCoords;
 107:     b.light = instance.light;
 108: 
 109:     #if defined(DEBUG_RAINBOW)
 110:     b.color = instance.color;
 111:     #elif defined(DEBUG_NORMAL)
 112:     b.color = vec4(norm, 1.);
 113:     #else
 114:     b.color = vec4(1.);
 115:     #endif
 116: 
 117:     return b;
 118: }
 119: attribute vec3 a_v_pos;
 120: attribute vec3 a_v_normal;
 121: attribute vec2 a_v_texCoords;
 122: 
 123: attribute vec2 a_i_light;
 124: attribute vec4 a_i_color;
 125: attribute vec3 a_i_pos;
 126: attribute float a_i_speed;
 127: attribute float a_i_offset;
 128: attribute vec3 a_i_axis;
 129: 
 130: 
 131: varying vec2 v2f_texCoords;
 132: varying vec4 v2f_color;
 133: varying float v2f_diffuse;
 134: varying vec2 v2f_light;
 135: 
 136: 
 137: void main() {
 138:     Vertex v;
 139:     v.pos = a_v_pos;
 140: v.normal = a_v_normal;
 141: v.texCoords = a_v_texCoords;
 142: 
 143: 
 144:     Rotating i;
 145:     i.light = a_i_light;
 146: i.color = a_i_color;
 147: i.pos = a_i_pos;
 148: i.speed = a_i_speed;
 149: i.offset = a_i_offset;
 150: i.axis = a_i_axis;
 151: 
 152: 
 153:     BlockFrag o = FLWMain(v, i);
 154: 
 155:     v2f_texCoords = o.texCoords;
 156: v2f_color = o.color;
 157: v2f_diffuse = o.diffuse;
 158: v2f_light = o.light;
 159: 
 160: }

[13:33:18] [main/ERROR]: Shader compilation log for flywheel:block.frag: No errors.

[13:33:18] [main/ERROR]: Source for shader 'flywheel:block.frag':
   1: #version 110
   2: #define USE_FOG
   3: #define USE_FOG_EXP2
   4: 
   5: #if defined(USE_FOG)
   6: varying float FragDistance;
   7: uniform vec4 uFogColor;
   8: #endif
   9: 
  10: #if defined(USE_FOG_LINEAR)
  11: uniform vec2 uFogRange;
  12: 
  13: float FLWFogFactor() {
  14:     return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
  15: }
  16:     #endif
  17: 
  18:     #if defined(USE_FOG_EXP2)
  19: uniform float uFogDensity;
  20: 
  21: float FLWFogFactor() {
  22:     float dist = FragDistance * uFogDensity;
  23:     return 1. / exp2(dist * dist);
  24: }
  25:     #endif
  26: 
  27: uniform vec2 uTextureScale;
  28: uniform sampler2D uBlockAtlas;
  29: uniform sampler2D uLightMap;
  30: uniform sampler2D uCrumbling;
  31: 
  32: vec4 FLWBlockTexture(vec2 texCoords) {
  33:     vec4 cr = texture2D(uCrumbling, texCoords * uTextureScale);
  34:     float diffuseAlpha = texture2D(uBlockAtlas, texCoords).a;
  35:     cr.a = cr.a * diffuseAlpha;
  36:     return cr;
  37: }
  38: 
  39: void FLWFinalizeColor(vec4 color) {
  40:     #if defined(USE_FOG)
  41:     float a = color.a;
  42:     float fog = clamp(FLWFogFactor(), 0., 1.);
  43: 
  44:     color = mix(uFogColor, color, fog);
  45:     color.a = a;
  46:     #endif
  47: 
  48:     gl_FragColor = color;
  49: }
  50: 
  51: vec4 FLWLight(vec2 lightCoords) {
  52:     return vec4(1.);
  53: }
  54: 
  55: 
  56: 
  57: struct BlockFrag {
  58:     vec2 texCoords;
  59:     vec4 color;
  60:     float diffuse;
  61:     vec2 light;
  62: };
  63: 
  64: void FLWMain(BlockFrag r) {
  65:     vec4 tex = FLWBlockTexture(r.texCoords);
  66: 
  67:     vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;
  68: 
  69: //    flw_WorldPos = ;
  70: //    flw_Normal = ;
  71: //    flw_Albedo = tex.rgb;
  72: //    flw_Alpha = tex.a;
  73: //    flw_LightMap = r.light;
  74: //    flw_Tint = r.color;
  75:     FLWFinalizeColor(color);
  76: }
  77: 
  78: varying vec2 v2f_texCoords;
  79: varying vec4 v2f_color;
  80: varying float v2f_diffuse;
  81: varying vec2 v2f_light;
  82: 
  83: 
  84: //vec3 flw_WorldPos;
  85: //vec3 flw_Normal;
  86: //vec3 flw_Albedo;
  87: //float flw_Alpha;
  88: //vec2 flw_LightMap;
  89: //vec4 flw_Tint;
  90: 
  91: void main() {
  92:     BlockFrag f;
  93:     f.texCoords = v2f_texCoords;
  94: f.color = v2f_color;
  95: f.diffuse = v2f_diffuse;
  96: f.light = v2f_light;
  97: 
  98: 
  99:     FLWMain(f);
 100: }

[13:33:18] [main/ERROR]: Shader compilation log for create:rotating.vert: No errors.

[13:33:18] [main/ERROR]: Source for shader 'create:rotating.vert':
   1: #version 110
   2: 
   3: #define PI 3.1415926538
   4: 
   5: uniform float uTime;
   6: uniform mat4 uViewProjection;
   7: uniform vec3 uCameraPos;
   8: 
   9: #if defined(USE_FOG)
  10: varying float FragDistance;
  11: #endif
  12: 
  13: void FLWFinalizeWorldPos(inout vec4 worldPos) {
  14:     #if defined(USE_FOG)
  15:     FragDistance = length(worldPos.xyz - uCameraPos);
  16:     #endif
  17: 
  18:     gl_Position = uViewProjection * worldPos;
  19: }
  20: 
  21: void FLWFinalizeNormal(inout vec3 normal) {
  22:     // noop
  23: }
  24: 
  25: 
  26: mat4 rotate(vec3 axis, float angle) {
  27:     float s = sin(angle);
  28:     float c = cos(angle);
  29:     float oc = 1. - c;
  30: 
  31:     vec3 sa = axis * s;
  32: 
  33:     mat4 mr = mat4(1.);
  34:     mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
  35:     mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
  36:     mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);
  37: 
  38:     return mr;
  39: }
  40: 
  41: mat4 rotation(vec3 rot) {
  42:     return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
  43: }
  44: 
  45: mat3 modelToNormal(mat4 mat) {
  46:     // Discard the edges. This won't be accurate for scaled or skewed matrices,
  47:     // but we don't have to work with those often.
  48:     mat3 m;
  49:     m[0] = mat[0].xyz;
  50:     m[1] = mat[1].xyz;
  51:     m[2] = mat[2].xyz;
  52:     return m;
  53: }
  54: 
  55: float diffuse(vec3 normal) {
  56:     vec3 n2 = normal * normal * vec3(.6, .25, .8);
  57:     return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
  58: }
  59: 
  60: 
  61: struct Rotating {
  62:     vec2 light;
  63:     vec4 color;
  64:     vec3 pos;
  65:     float speed;
  66:     float offset;
  67:     vec3 axis;
  68: };
  69: 
  70: 
  71: struct Vertex {
  72:     vec3 pos;
  73:     vec3 normal;
  74:     vec2 texCoords;
  75: };
  76: 
  77: struct BlockFrag {
  78:     vec2 texCoords;
  79:     vec4 color;
  80:     float diffuse;
  81:     vec2 light;
  82: };
  83: 
  84: mat4 kineticRotation(float offset, float speed, vec3 axis) {
  85:     float degrees = offset + uTime * speed * 3./10.;
  86:     float angle = fract(degrees / 360.) * PI * 2.;
  87: 
  88:     return rotate(axis, angle);
  89: }
  90: 
  91: BlockFrag FLWMain(Vertex v, Rotating instance) {
  92:     mat4 spin = kineticRotation(instance.offset, instance.speed, instance.axis);
  93: 
  94:     vec4 worldPos = spin * vec4(v.pos - .5, 1.);
  95:     worldPos += vec4(instance.pos + .5, 0.);
  96: 
  97:     vec3 norm = modelToNormal(spin) * v.normal;
  98: 
  99:     FLWFinalizeWorldPos(worldPos);
 100:     FLWFinalizeNormal(norm);
 101: 
 102:     BlockFrag b;
 103:     b.diffuse = diffuse(norm);
 104:     b.texCoords = v.texCoords;
 105:     b.light = instance.light;
 106: 
 107:     #if defined(DEBUG_RAINBOW)
 108:     b.color = instance.color;
 109:     #elif defined(DEBUG_NORMAL)
 110:     b.color = vec4(norm, 1.);
 111:     #else
 112:     b.color = vec4(1.);
 113:     #endif
 114: 
 115:     return b;
 116: }
 117: attribute vec3 a_v_pos;
 118: attribute vec3 a_v_normal;
 119: attribute vec2 a_v_texCoords;
 120: 
 121: attribute vec2 a_i_light;
 122: attribute vec4 a_i_color;
 123: attribute vec3 a_i_pos;
 124: attribute float a_i_speed;
 125: attribute float a_i_offset;
 126: attribute vec3 a_i_axis;
 127: 
 128: 
 129: varying vec2 v2f_texCoords;
 130: varying vec4 v2f_color;
 131: varying float v2f_diffuse;
 132: varying vec2 v2f_light;
 133: 
 134: 
 135: void main() {
 136:     Vertex v;
 137:     v.pos = a_v_pos;
 138: v.normal = a_v_normal;
 139: v.texCoords = a_v_texCoords;
 140: 
 141: 
 142:     Rotating i;
 143:     i.light = a_i_light;
 144: i.color = a_i_color;
 145: i.pos = a_i_pos;
 146: i.speed = a_i_speed;
 147: i.offset = a_i_offset;
 148: i.axis = a_i_axis;
 149: 
 150: 
 151:     BlockFrag o = FLWMain(v, i);
 152: 
 153:     v2f_texCoords = o.texCoords;
 154: v2f_color = o.color;
 155: v2f_diffuse = o.diffuse;
 156: v2f_light = o.light;
 157: 
 158: }

[13:33:18] [main/ERROR]: Shader compilation log for flywheel:block.frag: No errors.

[13:33:18] [main/ERROR]: Source for shader 'flywheel:block.frag':
   1: #version 110
   2: 
   3: #if defined(USE_FOG)
   4: varying float FragDistance;
   5: uniform vec4 uFogColor;
   6: #endif
   7: 
   8: #if defined(USE_FOG_LINEAR)
   9: uniform vec2 uFogRange;
  10: 
  11: float FLWFogFactor() {
  12:     return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
  13: }
  14:     #endif
  15: 
  16:     #if defined(USE_FOG_EXP2)
  17: uniform float uFogDensity;
  18: 
  19: float FLWFogFactor() {
  20:     float dist = FragDistance * uFogDensity;
  21:     return 1. / exp2(dist * dist);
  22: }
  23:     #endif
  24: 
  25: uniform vec2 uTextureScale;
  26: uniform sampler2D uBlockAtlas;
  27: uniform sampler2D uLightMap;
  28: uniform sampler2D uCrumbling;
  29: 
  30: vec4 FLWBlockTexture(vec2 texCoords) {
  31:     vec4 cr = texture2D(uCrumbling, texCoords * uTextureScale);
  32:     float diffuseAlpha = texture2D(uBlockAtlas, texCoords).a;
  33:     cr.a = cr.a * diffuseAlpha;
  34:     return cr;
  35: }
  36: 
  37: void FLWFinalizeColor(vec4 color) {
  38:     #if defined(USE_FOG)
  39:     float a = color.a;
  40:     float fog = clamp(FLWFogFactor(), 0., 1.);
  41: 
  42:     color = mix(uFogColor, color, fog);
  43:     color.a = a;
  44:     #endif
  45: 
  46:     gl_FragColor = color;
  47: }
  48: 
  49: vec4 FLWLight(vec2 lightCoords) {
  50:     return vec4(1.);
  51: }
  52: 
  53: 
  54: 
  55: struct BlockFrag {
  56:     vec2 texCoords;
  57:     vec4 color;
  58:     float diffuse;
  59:     vec2 light;
  60: };
  61: 
  62: void FLWMain(BlockFrag r) {
  63:     vec4 tex = FLWBlockTexture(r.texCoords);
  64: 
  65:     vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;
  66: 
  67: //    flw_WorldPos = ;
  68: //    flw_Normal = ;
  69: //    flw_Albedo = tex.rgb;
  70: //    flw_Alpha = tex.a;
  71: //    flw_LightMap = r.light;
  72: //    flw_Tint = r.color;
  73:     FLWFinalizeColor(color);
  74: }
  75: 
  76: varying vec2 v2f_texCoords;
  77: varying vec4 v2f_color;
  78: varying float v2f_diffuse;
  79: varying vec2 v2f_light;
  80: 
  81: 
  82: //vec3 flw_WorldPos;
  83: //vec3 flw_Normal;
  84: //vec3 flw_Albedo;
  85: //float flw_Alpha;
  86: //vec2 flw_LightMap;
  87: //vec4 flw_Tint;
  88: 
  89: void main() {
  90:     BlockFrag f;
  91:     f.texCoords = v2f_texCoords;
  92: f.color = v2f_color;
  93: f.diffuse = v2f_diffuse;
  94: f.light = v2f_light;
  95: 
  96: 
  97:     FLWMain(f);
  98: }

[13:33:18] [main/ERROR]: Shader compilation log for create:contraption_actor.vert: No errors.

[13:33:18] [main/ERROR]: Source for shader 'create:contraption_actor.vert':
   1: #version 110
   2: #define DEBUG_NORMAL
   3: 
   4: #define PI 3.1415926538
   5: 
   6: uniform float uTime;
   7: uniform mat4 uViewProjection;
   8: uniform vec3 uCameraPos;
   9: 
  10: #if defined(USE_FOG)
  11: varying float FragDistance;
  12: #endif
  13: 
  14: void FLWFinalizeWorldPos(inout vec4 worldPos) {
  15:     #if defined(USE_FOG)
  16:     FragDistance = length(worldPos.xyz - uCameraPos);
  17:     #endif
  18: 
  19:     gl_Position = uViewProjection * worldPos;
  20: }
  21: 
  22: void FLWFinalizeNormal(inout vec3 normal) {
  23:     // noop
  24: }
  25: 
  26: 
  27: mat4 rotate(vec3 axis, float angle) {
  28:     float s = sin(angle);
  29:     float c = cos(angle);
  30:     float oc = 1. - c;
  31: 
  32:     vec3 sa = axis * s;
  33: 
  34:     mat4 mr = mat4(1.);
  35:     mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
  36:     mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
  37:     mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);
  38: 
  39:     return mr;
  40: }
  41: 
  42: mat4 rotation(vec3 rot) {
  43:     return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
  44: }
  45: 
  46: mat3 modelToNormal(mat4 mat) {
  47:     // Discard the edges. This won't be accurate for scaled or skewed matrices,
  48:     // but we don't have to work with those often.
  49:     mat3 m;
  50:     m[0] = mat[0].xyz;
  51:     m[1] = mat[1].xyz;
  52:     m[2] = mat[2].xyz;
  53:     return m;
  54: }
  55: 
  56: #define PIOVER2 1.5707963268
  57: 
  58: vec4 quat(vec3 axis, float angle) {
  59:     float halfAngle = angle * PIOVER2 / 180.0;
  60:     vec2 cs = sin(vec2(PIOVER2 - halfAngle, halfAngle)); // compute sin and cos in one instruction
  61:     return vec4(axis.xyz * cs.y,  cs.x);
  62: }
  63: 
  64: vec4 quatMult(vec4 q1, vec4 q2) {
  65:     // disgustingly vectorized quaternion multiplication
  66:     vec4 a = q1.w * q2.xyzw;
  67:     vec4 b = q1.x * q2.wzxy * vec4(1., -1., 1., -1.);
  68:     vec4 c = q1.y * q2.zwxy * vec4(1., 1., -1., -1.);
  69:     vec4 d = q1.z * q2.yxwz * vec4(-1., 1., 1., -1.);
  70: 
  71:     return a + b + c + d;
  72: }
  73: 
  74: vec3 rotateVertexByQuat(vec3 v, vec4 q) {
  75:     vec3 i = q.xyz;
  76:     return v + 2.0 * cross(i, cross(i, v) + q.w * v);
  77: }
  78: 
  79: vec3 rotateAbout(vec3 v, vec3 axis, float angle) {
  80:     return rotateVertexByQuat(v, quat(axis, angle));
  81: }
  82: 
  83: float diffuse(vec3 normal) {
  84:     vec3 n2 = normal * normal * vec3(.6, .25, .8);
  85:     return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
  86: }
  87: 
  88: 
  89: struct Actor {
  90:     vec3 pos;
  91:     vec2 light;
  92:     float offset;
  93:     vec3 axis;
  94:     vec4 rotation;
  95:     vec3 rotationCenter;
  96:     float speed;
  97: };
  98: 
  99: 
 100: struct Vertex {
 101:     vec3 pos;
 102:     vec3 normal;
 103:     vec2 texCoords;
 104: };
 105: 
 106: struct BlockFrag {
 107:     vec2 texCoords;
 108:     vec4 color;
 109:     float diffuse;
 110:     vec2 light;
 111: };
 112: 
 113: BlockFrag FLWMain(Vertex v, Actor instance) {
 114:     float degrees = instance.offset + uTime * instance.speed / 20.;
 115:     //float angle = fract(degrees / 360.) * PI * 2.;
 116: 
 117:     vec4 kineticRot = quat(instance.axis, degrees);
 118:     vec3 rotated = rotateVertexByQuat(v.pos - instance.rotationCenter, kineticRot) + instance.rotationCenter;
 119: 
 120:     vec4 worldPos = vec4(rotateVertexByQuat(rotated - .5, instance.rotation) + instance.pos + .5, 1.);
 121:     vec3 norm = rotateVertexByQuat(rotateVertexByQuat(v.normal, kineticRot), instance.rotation);
 122: 
 123:     FLWFinalizeWorldPos(worldPos);
 124:     FLWFinalizeNormal(norm);
 125: 
 126:     BlockFrag b;
 127:     b.diffuse = diffuse(norm);
 128:     b.texCoords = v.texCoords;
 129:     b.light = instance.light;
 130: 
 131:     #if defined(DEBUG_NORMAL)
 132:     b.color = vec4(norm, 1.);
 133:     #else
 134:     b.color = vec4(1.);
 135:     #endif
 136: 
 137:     return b;
 138: }
 139: attribute vec3 a_v_pos;
 140: attribute vec3 a_v_normal;
 141: attribute vec2 a_v_texCoords;
 142: 
 143: attribute vec3 a_i_pos;
 144: attribute vec2 a_i_light;
 145: attribute float a_i_offset;
 146: attribute vec3 a_i_axis;
 147: attribute vec4 a_i_rotation;
 148: attribute vec3 a_i_rotationCenter;
 149: attribute float a_i_speed;
 150: 
 151: 
 152: varying vec2 v2f_texCoords;
 153: varying vec4 v2f_color;
 154: varying float v2f_diffuse;
 155: varying vec2 v2f_light;
 156: 
 157: 
 158: void main() {
 159:     Vertex v;
 160:     v.pos = a_v_pos;
 161: v.normal = a_v_normal;
 162: v.texCoords = a_v_texCoords;
 163: 
 164: 
 165:     Actor i;
 166:     i.pos = a_i_pos;
 167: i.light = a_i_light;
 168: i.offset = a_i_offset;
 169: i.axis = a_i_axis;
 170: i.rotation = a_i_rotation;
 171: i.rotationCenter = a_i_rotationCenter;
 172: i.speed = a_i_speed;
 173: 
 174: 
 175:     BlockFrag o = FLWMain(v, i);
 176: 
 177:     v2f_texCoords = o.texCoords;
 178: v2f_color = o.color;
 179: v2f_diffuse = o.diffuse;
 180: v2f_light = o.light;
 181: 
 182: }

[13:33:18] [main/ERROR]: Shader compilation log for flywheel:block.frag: No errors.

[13:33:18] [main/ERROR]: Source for shader 'flywheel:block.frag':
   1: #version 110
   2: #define DEBUG_NORMAL
   3: 
   4: #if defined(USE_FOG)
   5: varying float FragDistance;
   6: uniform vec4 uFogColor;
   7: #endif
   8: 
   9: #if defined(USE_FOG_LINEAR)
  10: uniform vec2 uFogRange;
  11: 
  12: float FLWFogFactor() {
  13:     return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
  14: }
  15:     #endif
  16: 
  17:     #if defined(USE_FOG_EXP2)
  18: uniform float uFogDensity;
  19: 
  20: float FLWFogFactor() {
  21:     float dist = FragDistance * uFogDensity;
  22:     return 1. / exp2(dist * dist);
  23: }
  24:     #endif
  25: 
  26: uniform vec2 uTextureScale;
  27: uniform sampler2D uBlockAtlas;
  28: uniform sampler2D uLightMap;
  29: uniform sampler2D uCrumbling;
  30: 
  31: vec4 FLWBlockTexture(vec2 texCoords) {
  32:     vec4 cr = texture2D(uCrumbling, texCoords * uTextureScale);
  33:     float diffuseAlpha = texture2D(uBlockAtlas, texCoords).a;
  34:     cr.a = cr.a * diffuseAlpha;
  35:     return cr;
  36: }
  37: 
  38: void FLWFinalizeColor(vec4 color) {
  39:     #if defined(USE_FOG)
  40:     float a = color.a;
  41:     float fog = clamp(FLWFogFactor(), 0., 1.);
  42: 
  43:     color = mix(uFogColor, color, fog);
  44:     color.a = a;
  45:     #endif
  46: 
  47:     gl_FragColor = color;
  48: }
  49: 
  50: vec4 FLWLight(vec2 lightCoords) {
  51:     return vec4(1.);
  52: }
  53: 
  54: 
  55: 
  56: struct BlockFrag {
  57:     vec2 texCoords;
  58:     vec4 color;
  59:     float diffuse;
  60:     vec2 light;
  61: };
  62: 
  63: void FLWMain(BlockFrag r) {
  64:     vec4 tex = FLWBlockTexture(r.texCoords);
  65: 
  66:     vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;
  67: 
  68: //    flw_WorldPos = ;
  69: //    flw_Normal = ;
  70: //    flw_Albedo = tex.rgb;
  71: //    flw_Alpha = tex.a;
  72: //    flw_LightMap = r.light;
  73: //    flw_Tint = r.color;
  74:     FLWFinalizeColor(color);
  75: }
  76: 
  77: varying vec2 v2f_texCoords;
  78: varying vec4 v2f_color;
  79: varying float v2f_diffuse;
  80: varying vec2 v2f_light;
  81: 
  82: 
  83: //vec3 flw_WorldPos;
  84: //vec3 flw_Normal;
  85: //vec3 flw_Albedo;
  86: //float flw_Alpha;
  87: //vec2 flw_LightMap;
  88: //vec4 flw_Tint;
  89: 
  90: void main() {
  91:     BlockFrag f;
  92:     f.texCoords = v2f_texCoords;
  93: f.color = v2f_color;
  94: f.diffuse = v2f_diffuse;
  95: f.light = v2f_light;
  96: 
  97: 
  98:     FLWMain(f);
  99: }

[13:33:18] [main/ERROR]: Shader compilation log for create:contraption_actor.vert: No errors.

[13:33:18] [main/ERROR]: Source for shader 'create:contraption_actor.vert':
   1: #version 110
   2: #define USE_FOG
   3: #define USE_FOG_LINEAR
   4: 
   5: #define PI 3.1415926538
   6: 
   7: uniform float uTime;
   8: uniform mat4 uViewProjection;
   9: uniform vec3 uCameraPos;
  10: 
  11: #if defined(USE_FOG)
  12: varying float FragDistance;
  13: #endif
  14: 
  15: void FLWFinalizeWorldPos(inout vec4 worldPos) {
  16:     #if defined(USE_FOG)
  17:     FragDistance = length(worldPos.xyz - uCameraPos);
  18:     #endif
  19: 
  20:     gl_Position = uViewProjection * worldPos;
  21: }
  22: 
  23: void FLWFinalizeNormal(inout vec3 normal) {
  24:     // noop
  25: }
  26: 
  27: 
  28: mat4 rotate(vec3 axis, float angle) {
  29:     float s = sin(angle);
  30:     float c = cos(angle);
  31:     float oc = 1. - c;
  32: 
  33:     vec3 sa = axis * s;
  34: 
  35:     mat4 mr = mat4(1.);
  36:     mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
  37:     mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
  38:     mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);
  39: 
  40:     return mr;
  41: }
  42: 
  43: mat4 rotation(vec3 rot) {
  44:     return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
  45: }
  46: 
  47: mat3 modelToNormal(mat4 mat) {
  48:     // Discard the edges. This won't be accurate for scaled or skewed matrices,
  49:     // but we don't have to work with those often.
  50:     mat3 m;
  51:     m[0] = mat[0].xyz;
  52:     m[1] = mat[1].xyz;
  53:     m[2] = mat[2].xyz;
  54:     return m;
  55: }
  56: 
  57: #define PIOVER2 1.5707963268
  58: 
  59: vec4 quat(vec3 axis, float angle) {
  60:     float halfAngle = angle * PIOVER2 / 180.0;
  61:     vec2 cs = sin(vec2(PIOVER2 - halfAngle, halfAngle)); // compute sin and cos in one instruction
  62:     return vec4(axis.xyz * cs.y,  cs.x);
  63: }
  64: 
  65: vec4 quatMult(vec4 q1, vec4 q2) {
  66:     // disgustingly vectorized quaternion multiplication
  67:     vec4 a = q1.w * q2.xyzw;
  68:     vec4 b = q1.x * q2.wzxy * vec4(1., -1., 1., -1.);
  69:     vec4 c = q1.y * q2.zwxy * vec4(1., 1., -1., -1.);
  70:     vec4 d = q1.z * q2.yxwz * vec4(-1., 1., 1., -1.);
  71: 
  72:     return a + b + c + d;
  73: }
  74: 
  75: vec3 rotateVertexByQuat(vec3 v, vec4 q) {
  76:     vec3 i = q.xyz;
  77:     return v + 2.0 * cross(i, cross(i, v) + q.w * v);
  78: }
  79: 
  80: vec3 rotateAbout(vec3 v, vec3 axis, float angle) {
  81:     return rotateVertexByQuat(v, quat(axis, angle));
  82: }
  83: 
  84: float diffuse(vec3 normal) {
  85:     vec3 n2 = normal * normal * vec3(.6, .25, .8);
  86:     return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
  87: }
  88: 
  89: 
  90: struct Actor {
  91:     vec3 pos;
  92:     vec2 light;
  93:     float offset;
  94:     vec3 axis;
  95:     vec4 rotation;
  96:     vec3 rotationCenter;
  97:     float speed;
  98: };
  99: 
 100: 
 101: struct Vertex {
 102:     vec3 pos;
 103:     vec3 normal;
 104:     vec2 texCoords;
 105: };
 106: 
 107: struct BlockFrag {
 108:     vec2 texCoords;
 109:     vec4 color;
 110:     float diffuse;
 111:     vec2 light;
 112: };
 113: 
 114: BlockFrag FLWMain(Vertex v, Actor instance) {
 115:     float degrees = instance.offset + uTime * instance.speed / 20.;
 116:     //float angle = fract(degrees / 360.) * PI * 2.;
 117: 
 118:     vec4 kineticRot = quat(instance.axis, degrees);
 119:     vec3 rotated = rotateVertexByQuat(v.pos - instance.rotationCenter, kineticRot) + instance.rotationCenter;
 120: 
 121:     vec4 worldPos = vec4(rotateVertexByQuat(rotated - .5, instance.rotation) + instance.pos + .5, 1.);
 122:     vec3 norm = rotateVertexByQuat(rotateVertexByQuat(v.normal, kineticRot), instance.rotation);
 123: 
 124:     FLWFinalizeWorldPos(worldPos);
 125:     FLWFinalizeNormal(norm);
 126: 
 127:     BlockFrag b;
 128:     b.diffuse = diffuse(norm);
 129:     b.texCoords = v.texCoords;
 130:     b.light = instance.light;
 131: 
 132:     #if defined(DEBUG_NORMAL)
 133:     b.color = vec4(norm, 1.);
 134:     #else
 135:     b.color = vec4(1.);
 136:     #endif
 137: 
 138:     return b;
 139: }
 140: attribute vec3 a_v_pos;
 141: attribute vec3 a_v_normal;
 142: attribute vec2 a_v_texCoords;
 143: 
 144: attribute vec3 a_i_pos;
 145: attribute vec2 a_i_light;
 146: attribute float a_i_offset;
 147: attribute vec3 a_i_axis;
 148: attribute vec4 a_i_rotation;
 149: attribute vec3 a_i_rotationCenter;
 150: attribute float a_i_speed;
 151: 
 152: 
 153: varying vec2 v2f_texCoords;
 154: varying vec4 v2f_color;
 155: varying float v2f_diffuse;
 156: varying vec2 v2f_light;
 157: 
 158: 
 159: void main() {
 160:     Vertex v;
 161:     v.pos = a_v_pos;
 162: v.normal = a_v_normal;
 163: v.texCoords = a_v_texCoords;
 164: 
 165: 
 166:     Actor i;
 167:     i.pos = a_i_pos;
 168: i.light = a_i_light;
 169: i.offset = a_i_offset;
 170: i.axis = a_i_axis;
 171: i.rotation = a_i_rotation;
 172: i.rotationCenter = a_i_rotationCenter;
 173: i.speed = a_i_speed;
 174: 
 175: 
 176:     BlockFrag o = FLWMain(v, i);
 177: 
 178:     v2f_texCoords = o.texCoords;
 179: v2f_color = o.color;
 180: v2f_diffuse = o.diffuse;
 181: v2f_light = o.light;
 182: 
 183: }

[13:33:18] [main/ERROR]: Shader compilation log for flywheel:block.frag: No errors.

[13:33:18] [main/ERROR]: Source for shader 'flywheel:block.frag':
   1: #version 110
   2: #define USE_FOG
   3: #define USE_FOG_LINEAR
   4: 
   5: #if defined(USE_FOG)
   6: varying float FragDistance;
   7: uniform vec4 uFogColor;
   8: #endif
   9: 
  10: #if defined(USE_FOG_LINEAR)
  11: uniform vec2 uFogRange;
  12: 
  13: float FLWFogFactor() {
  14:     return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
  15: }
  16:     #endif
  17: 
  18:     #if defined(USE_FOG_EXP2)
  19: uniform float uFogDensity;
  20: 
  21: float FLWFogFactor() {
  22:     float dist = FragDistance * uFogDensity;
  23:     return 1. / exp2(dist * dist);
  24: }
  25:     #endif
  26: 
  27: uniform vec2 uTextureScale;
  28: uniform sampler2D uBlockAtlas;
  29: uniform sampler2D uLightMap;
  30: uniform sampler2D uCrumbling;
  31: 
  32: vec4 FLWBlockTexture(vec2 texCoords) {
  33:     vec4 cr = texture2D(uCrumbling, texCoords * uTextureScale);
  34:     float diffuseAlpha = texture2D(uBlockAtlas, texCoords).a;
  35:     cr.a = cr.a * diffuseAlpha;
  36:     return cr;
  37: }
  38: 
  39: void FLWFinalizeColor(vec4 color) {
  40:     #if defined(USE_FOG)
  41:     float a = color.a;
  42:     float fog = clamp(FLWFogFactor(), 0., 1.);
  43: 
  44:     color = mix(uFogColor, color, fog);
  45:     color.a = a;
  46:     #endif
  47: 
  48:     gl_FragColor = color;
  49: }
  50: 
  51: vec4 FLWLight(vec2 lightCoords) {
  52:     return vec4(1.);
  53: }
  54: 
  55: 
  56: 
  57: struct BlockFrag {
  58:     vec2 texCoords;
  59:     vec4 color;
  60:     float diffuse;
  61:     vec2 light;
  62: };
  63: 
  64: void FLWMain(BlockFrag r) {
  65:     vec4 tex = FLWBlockTexture(r.texCoords);
  66: 
  67:     vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;
  68: 
  69: //    flw_WorldPos = ;
  70: //    flw_Normal = ;
  71: //    flw_Albedo = tex.rgb;
  72: //    flw_Alpha = tex.a;
  73: //    flw_LightMap = r.light;
  74: //    flw_Tint = r.color;
  75:     FLWFinalizeColor(color);
  76: }
  77: 
  78: varying vec2 v2f_texCoords;
  79: varying vec4 v2f_color;
  80: varying float v2f_diffuse;
  81: varying vec2 v2f_light;
  82: 
  83: 
  84: //vec3 flw_WorldPos;
  85: //vec3 flw_Normal;
  86: //vec3 flw_Albedo;
  87: //float flw_Alpha;
  88: //vec2 flw_LightMap;
  89: //vec4 flw_Tint;
  90: 
  91: void main() {
  92:     BlockFrag f;
  93:     f.texCoords = v2f_texCoords;
  94: f.color = v2f_color;
  95: f.diffuse = v2f_diffuse;
  96: f.light = v2f_light;
  97: 
  98: 
  99:     FLWMain(f);
 100: }

[13:33:18] [main/ERROR]: Shader compilation log for create:contraption_actor.vert: No errors.

[13:33:18] [main/ERROR]: Source for shader 'create:contraption_actor.vert':
   1: #version 110
   2: #define USE_FOG
   3: #define USE_FOG_EXP2
   4: 
   5: #define PI 3.1415926538
   6: 
   7: uniform float uTime;
   8: uniform mat4 uViewProjection;
   9: uniform vec3 uCameraPos;
  10: 
  11: #if defined(USE_FOG)
  12: varying float FragDistance;
  13: #endif
  14: 
  15: void FLWFinalizeWorldPos(inout vec4 worldPos) {
  16:     #if defined(USE_FOG)
  17:     FragDistance = length(worldPos.xyz - uCameraPos);
  18:     #endif
  19: 
  20:     gl_Position = uViewProjection * worldPos;
  21: }
  22: 
  23: void FLWFinalizeNormal(inout vec3 normal) {
  24:     // noop
  25: }
  26: 
  27: 
  28: mat4 rotate(vec3 axis, float angle) {
  29:     float s = sin(angle);
  30:     float c = cos(angle);
  31:     float oc = 1. - c;
  32: 
  33:     vec3 sa = axis * s;
  34: 
  35:     mat4 mr = mat4(1.);
  36:     mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
  37:     mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
  38:     mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);
  39: 
  40:     return mr;
  41: }
  42: 
  43: mat4 rotation(vec3 rot) {
  44:     return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
  45: }
  46: 
  47: mat3 modelToNormal(mat4 mat) {
  48:     // Discard the edges. This won't be accurate for scaled or skewed matrices,
  49:     // but we don't have to work with those often.
  50:     mat3 m;
  51:     m[0] = mat[0].xyz;
  52:     m[1] = mat[1].xyz;
  53:     m[2] = mat[2].xyz;
  54:     return m;
  55: }
  56: 
  57: #define PIOVER2 1.5707963268
  58: 
  59: vec4 quat(vec3 axis, float angle) {
  60:     float halfAngle = angle * PIOVER2 / 180.0;
  61:     vec2 cs = sin(vec2(PIOVER2 - halfAngle, halfAngle)); // compute sin and cos in one instruction
  62:     return vec4(axis.xyz * cs.y,  cs.x);
  63: }
  64: 
  65: vec4 quatMult(vec4 q1, vec4 q2) {
  66:     // disgustingly vectorized quaternion multiplication
  67:     vec4 a = q1.w * q2.xyzw;
  68:     vec4 b = q1.x * q2.wzxy * vec4(1., -1., 1., -1.);
  69:     vec4 c = q1.y * q2.zwxy * vec4(1., 1., -1., -1.);
  70:     vec4 d = q1.z * q2.yxwz * vec4(-1., 1., 1., -1.);
  71: 
  72:     return a + b + c + d;
  73: }
  74: 
  75: vec3 rotateVertexByQuat(vec3 v, vec4 q) {
  76:     vec3 i = q.xyz;
  77:     return v + 2.0 * cross(i, cross(i, v) + q.w * v);
  78: }
  79: 
  80: vec3 rotateAbout(vec3 v, vec3 axis, float angle) {
  81:     return rotateVertexByQuat(v, quat(axis, angle));
  82: }
  83: 
  84: float diffuse(vec3 normal) {
  85:     vec3 n2 = normal * normal * vec3(.6, .25, .8);
  86:     return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
  87: }
  88: 
  89: 
  90: struct Actor {
  91:     vec3 pos;
  92:     vec2 light;
  93:     float offset;
  94:     vec3 axis;
  95:     vec4 rotation;
  96:     vec3 rotationCenter;
  97:     float speed;
  98: };
  99: 
 100: 
 101: struct Vertex {
 102:     vec3 pos;
 103:     vec3 normal;
 104:     vec2 texCoords;
 105: };
 106: 
 107: struct BlockFrag {
 108:     vec2 texCoords;
 109:     vec4 color;
 110:     float diffuse;
 111:     vec2 light;
 112: };
 113: 
 114: BlockFrag FLWMain(Vertex v, Actor instance) {
 115:     float degrees = instance.offset + uTime * instance.speed / 20.;
 116:     //float angle = fract(degrees / 360.) * PI * 2.;
 117: 
 118:     vec4 kineticRot = quat(instance.axis, degrees);
 119:     vec3 rotated = rotateVertexByQuat(v.pos - instance.rotationCenter, kineticRot) + instance.rotationCenter;
 120: 
 121:     vec4 worldPos = vec4(rotateVertexByQuat(rotated - .5, instance.rotation) + instance.pos + .5, 1.);
 122:     vec3 norm = rotateVertexByQuat(rotateVertexByQuat(v.normal, kineticRot), instance.rotation);
 123: 
 124:     FLWFinalizeWorldPos(worldPos);
 125:     FLWFinalizeNormal(norm);
 126: 
 127:     BlockFrag b;
 128:     b.diffuse = diffuse(norm);
 129:     b.texCoords = v.texCoords;
 130:     b.light = instance.light;
 131: 
 132:     #if defined(DEBUG_NORMAL)
 133:     b.color = vec4(norm, 1.);
 134:     #else
 135:     b.color = vec4(1.);
 136:     #endif
 137: 
 138:     return b;
 139: }
 140: attribute vec3 a_v_pos;
 141: attribute vec3 a_v_normal;
 142: attribute vec2 a_v_texCoords;
 143: 
 144: attribute vec3 a_i_pos;
 145: attribute vec2 a_i_light;
 146: attribute float a_i_offset;
 147: attribute vec3 a_i_axis;
 148: attribute vec4 a_i_rotation;
 149: attribute vec3 a_i_rotationCenter;
 150: attribute float a_i_speed;
 151: 
 152: 
 153: varying vec2 v2f_texCoords;
 154: varying vec4 v2f_color;
 155: varying float v2f_diffuse;
 156: varying vec2 v2f_light;
 157: 
 158: 
 159: void main() {
 160:     Vertex v;
 161:     v.pos = a_v_pos;
 162: v.normal = a_v_normal;
 163: v.texCoords = a_v_texCoords;
 164: 
 165: 
 166:     Actor i;
 167:     i.pos = a_i_pos;
 168: i.light = a_i_light;
 169: i.offset = a_i_offset;
 170: i.axis = a_i_axis;
 171: i.rotation = a_i_rotation;
 172: i.rotationCenter = a_i_rotationCenter;
 173: i.speed = a_i_speed;
 174: 
 175: 
 176:     BlockFrag o = FLWMain(v, i);
 177: 
 178:     v2f_texCoords = o.texCoords;
 179: v2f_color = o.color;
 180: v2f_diffuse = o.diffuse;
 181: v2f_light = o.light;
 182: 
 183: }

[13:33:18] [main/ERROR]: Shader compilation log for flywheel:block.frag: No errors.

[13:33:18] [main/ERROR]: Source for shader 'flywheel:block.frag':
   1: #version 110
   2: #define USE_FOG
   3: #define USE_FOG_EXP2
   4: 
   5: #if defined(USE_FOG)
   6: varying float FragDistance;
   7: uniform vec4 uFogColor;
   8: #endif
   9: 
  10: #if defined(USE_FOG_LINEAR)
  11: uniform vec2 uFogRange;
  12: 
  13: float FLWFogFactor() {
  14:     return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
  15: }
  16:     #endif
  17: 
  18:     #if defined(USE_FOG_EXP2)
  19: uniform float uFogDensity;
  20: 
  21: float FLWFogFactor() {
  22:     float dist = FragDistance * uFogDensity;
  23:     return 1. / exp2(dist * dist);
  24: }
  25:     #endif
  26: 
  27: uniform vec2 uTextureScale;
  28: uniform sampler2D uBlockAtlas;
  29: uniform sampler2D uLightMap;
  30: uniform sampler2D uCrumbling;
  31: 
  32: vec4 FLWBlockTexture(vec2 texCoords) {
  33:     vec4 cr = texture2D(uCrumbling, texCoords * uTextureScale);
  34:     float diffuseAlpha = texture2D(uBlockAtlas, texCoords).a;
  35:     cr.a = cr.a * diffuseAlpha;
  36:     return cr;
  37: }
  38: 
  39: void FLWFinalizeColor(vec4 color) {
  40:     #if defined(USE_FOG)
  41:     float a = color.a;
  42:     float fog = clamp(FLWFogFactor(), 0., 1.);
  43: 
  44:     color = mix(uFogColor, color, fog);
  45:     color.a = a;
  46:     #endif
  47: 
  48:     gl_FragColor = color;
  49: }
  50: 
  51: vec4 FLWLight(vec2 lightCoords) {
  52:     return vec4(1.);
  53: }
  54: 
  55: 
  56: 
  57: struct BlockFrag {
  58:     vec2 texCoords;
  59:     vec4 color;
  60:     float diffuse;
  61:     vec2 light;
  62: };
  63: 
  64: void FLWMain(BlockFrag r) {
  65:     vec4 tex = FLWBlockTexture(r.texCoords);
  66: 
  67:     vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;
  68: 
  69: //    flw_WorldPos = ;
  70: //    flw_Normal = ;
  71: //    flw_Albedo = tex.rgb;
  72: //    flw_Alpha = tex.a;
  73: //    flw_LightMap = r.light;
  74: //    flw_Tint = r.color;
  75:     FLWFinalizeColor(color);
  76: }
  77: 
  78: varying vec2 v2f_texCoords;
  79: varying vec4 v2f_color;
  80: varying float v2f_diffuse;
  81: varying vec2 v2f_light;
  82: 
  83: 
  84: //vec3 flw_WorldPos;
  85: //vec3 flw_Normal;
  86: //vec3 flw_Albedo;
  87: //float flw_Alpha;
  88: //vec2 flw_LightMap;
  89: //vec4 flw_Tint;
  90: 
  91: void main() {
  92:     BlockFrag f;
  93:     f.texCoords = v2f_texCoords;
  94: f.color = v2f_color;
  95: f.diffuse = v2f_diffuse;
  96: f.light = v2f_light;
  97: 
  98: 
  99:     FLWMain(f);
 100: }

[13:33:18] [main/ERROR]: Shader compilation log for create:contraption_actor.vert: No errors.

[13:33:18] [main/ERROR]: Source for shader 'create:contraption_actor.vert':
   1: #version 110
   2: 
   3: #define PI 3.1415926538
   4: 
   5: uniform float uTime;
   6: uniform mat4 uViewProjection;
   7: uniform vec3 uCameraPos;
   8: 
   9: #if defined(USE_FOG)
  10: varying float FragDistance;
  11: #endif
  12: 
  13: void FLWFinalizeWorldPos(inout vec4 worldPos) {
  14:     #if defined(USE_FOG)
  15:     FragDistance = length(worldPos.xyz - uCameraPos);
  16:     #endif
  17: 
  18:     gl_Position = uViewProjection * worldPos;
  19: }
  20: 
  21: void FLWFinalizeNormal(inout vec3 normal) {
  22:     // noop
  23: }
  24: 
  25: 
  26: mat4 rotate(vec3 axis, float angle) {
  27:     float s = sin(angle);
  28:     float c = cos(angle);
  29:     float oc = 1. - c;
  30: 
  31:     vec3 sa = axis * s;
  32: 
  33:     mat4 mr = mat4(1.);
  34:     mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
  35:     mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
  36:     mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);
  37: 
  38:     return mr;
  39: }
  40: 
  41: mat4 rotation(vec3 rot) {
  42:     return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
  43: }
  44: 
  45: mat3 modelToNormal(mat4 mat) {
  46:     // Discard the edges. This won't be accurate for scaled or skewed matrices,
  47:     // but we don't have to work with those often.
  48:     mat3 m;
  49:     m[0] = mat[0].xyz;
  50:     m[1] = mat[1].xyz;
  51:     m[2] = mat[2].xyz;
  52:     return m;
  53: }
  54: 
  55: #define PIOVER2 1.5707963268
  56: 
  57: vec4 quat(vec3 axis, float angle) {
  58:     float halfAngle = angle * PIOVER2 / 180.0;
  59:     vec2 cs = sin(vec2(PIOVER2 - halfAngle, halfAngle)); // compute sin and cos in one instruction
  60:     return vec4(axis.xyz * cs.y,  cs.x);
  61: }
  62: 
  63: vec4 quatMult(vec4 q1, vec4 q2) {
  64:     // disgustingly vectorized quaternion multiplication
  65:     vec4 a = q1.w * q2.xyzw;
  66:     vec4 b = q1.x * q2.wzxy * vec4(1., -1., 1., -1.);
  67:     vec4 c = q1.y * q2.zwxy * vec4(1., 1., -1., -1.);
  68:     vec4 d = q1.z * q2.yxwz * vec4(-1., 1., 1., -1.);
  69: 
  70:     return a + b + c + d;
  71: }
  72: 
  73: vec3 rotateVertexByQuat(vec3 v, vec4 q) {
  74:     vec3 i = q.xyz;
  75:     return v + 2.0 * cross(i, cross(i, v) + q.w * v);
  76: }
  77: 
  78: vec3 rotateAbout(vec3 v, vec3 axis, float angle) {
  79:     return rotateVertexByQuat(v, quat(axis, angle));
  80: }
  81: 
  82: float diffuse(vec3 normal) {
  83:     vec3 n2 = normal * normal * vec3(.6, .25, .8);
  84:     return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
  85: }
  86: 
  87: 
  88: struct Actor {
  89:     vec3 pos;
  90:     vec2 light;
  91:     float offset;
  92:     vec3 axis;
  93:     vec4 rotation;
  94:     vec3 rotationCenter;
  95:     float speed;
  96: };
  97: 
  98: 
  99: struct Vertex {
 100:     vec3 pos;
 101:     vec3 normal;
 102:     vec2 texCoords;
 103: };
 104: 
 105: struct BlockFrag {
 106:     vec2 texCoords;
 107:     vec4 color;
 108:     float diffuse;
 109:     vec2 light;
 110: };
 111: 
 112: BlockFrag FLWMain(Vertex v, Actor instance) {
 113:     float degrees = instance.offset + uTime * instance.speed / 20.;
 114:     //float angle = fract(degrees / 360.) * PI * 2.;
 115: 
 116:     vec4 kineticRot = quat(instance.axis, degrees);
 117:     vec3 rotated = rotateVertexByQuat(v.pos - instance.rotationCenter, kineticRot) + instance.rotationCenter;
 118: 
 119:     vec4 worldPos = vec4(rotateVertexByQuat(rotated - .5, instance.rotation) + instance.pos + .5, 1.);
 120:     vec3 norm = rotateVertexByQuat(rotateVertexByQuat(v.normal, kineticRot), instance.rotation);
 121: 
 122:     FLWFinalizeWorldPos(worldPos);
 123:     FLWFinalizeNormal(norm);
 124: 
 125:     BlockFrag b;
 126:     b.diffuse = diffuse(norm);
 127:     b.texCoords = v.texCoords;
 128:     b.light = instance.light;
 129: 
 130:     #if defined(DEBUG_NORMAL)
 131:     b.color = vec4(norm, 1.);
 132:     #else
 133:     b.color = vec4(1.);
 134:     #endif
 135: 
 136:     return b;
 137: }
 138: attribute vec3 a_v_pos;
 139: attribute vec3 a_v_normal;
 140: attribute vec2 a_v_texCoords;
 141: 
 142: attribute vec3 a_i_pos;
 143: attribute vec2 a_i_light;
 144: attribute float a_i_offset;
 145: attribute vec3 a_i_axis;
 146: attribute vec4 a_i_rotation;
 147: attribute vec3 a_i_rotationCenter;
 148: attribute float a_i_speed;
 149: 
 150: 
 151: varying vec2 v2f_texCoords;
 152: varying vec4 v2f_color;
 153: varying float v2f_diffuse;
 154: varying vec2 v2f_light;
 155: 
 156: 
 157: void main() {
 158:     Vertex v;
 159:     v.pos = a_v_pos;
 160: v.normal = a_v_normal;
 161: v.texCoords = a_v_texCoords;
 162: 
 163: 
 164:     Actor i;
 165:     i.pos = a_i_pos;
 166: i.light = a_i_light;
 167: i.offset = a_i_offset;
 168: i.axis = a_i_axis;
 169: i.rotation = a_i_rotation;
 170: i.rotationCenter = a_i_rotationCenter;
 171: i.speed = a_i_speed;
 172: 
 173: 
 174:     BlockFrag o = FLWMain(v, i);
 175: 
 176:     v2f_texCoords = o.texCoords;
 177: v2f_color = o.color;
 178: v2f_diffuse = o.diffuse;
 179: v2f_light = o.light;
 180: 
 181: }

[13:33:18] [main/ERROR]: Shader compilation log for flywheel:block.frag: No errors.

[13:33:18] [main/ERROR]: Source for shader 'flywheel:block.frag':
   1: #version 110
   2: 
   3: #if defined(USE_FOG)
   4: varying float FragDistance;
   5: uniform vec4 uFogColor;
   6: #endif
   7: 
   8: #if defined(USE_FOG_LINEAR)
   9: uniform vec2 uFogRange;
  10: 
  11: float FLWFogFactor() {
  12:     return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
  13: }
  14:     #endif
  15: 
  16:     #if defined(USE_FOG_EXP2)
  17: uniform float uFogDensity;
  18: 
  19: float FLWFogFactor() {
  20:     float dist = FragDistance * uFogDensity;
  21:     return 1. / exp2(dist * dist);
  22: }
  23:     #endif
  24: 
  25: uniform vec2 uTextureScale;
  26: uniform sampler2D uBlockAtlas;
  27: uniform sampler2D uLightMap;
  28: uniform sampler2D uCrumbling;
  29: 
  30: vec4 FLWBlockTexture(vec2 texCoords) {
  31:     vec4 cr = texture2D(uCrumbling, texCoords * uTextureScale);
  32:     float diffuseAlpha = texture2D(uBlockAtlas, texCoords).a;
  33:     cr.a = cr.a * diffuseAlpha;
  34:     return cr;
  35: }
  36: 
  37: void FLWFinalizeColor(vec4 color) {
  38:     #if defined(USE_FOG)
  39:     float a = color.a;
  40:     float fog = clamp(FLWFogFactor(), 0., 1.);
  41: 
  42:     color = mix(uFogColor, color, fog);
  43:     color.a = a;
  44:     #endif
  45: 
  46:     gl_FragColor = color;
  47: }
  48: 
  49: vec4 FLWLight(vec2 lightCoords) {
  50:     return vec4(1.);
  51: }
  52: 
  53: 
  54: 
  55: struct BlockFrag {
  56:     vec2 texCoords;
  57:     vec4 color;
  58:     float diffuse;
  59:     vec2 light;
  60: };
  61: 
  62: void FLWMain(BlockFrag r) {
  63:     vec4 tex = FLWBlockTexture(r.texCoords);
  64: 
  65:     vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;
  66: 
  67: //    flw_WorldPos = ;
  68: //    flw_Normal = ;
  69: //    flw_Albedo = tex.rgb;
  70: //    flw_Alpha = tex.a;
  71: //    flw_LightMap = r.light;
  72: //    flw_Tint = r.color;
  73:     FLWFinalizeColor(color);
  74: }
  75: 
  76: varying vec2 v2f_texCoords;
  77: varying vec4 v2f_color;
  78: varying float v2f_diffuse;
  79: varying vec2 v2f_light;
  80: 
  81: 
  82: //vec3 flw_WorldPos;
  83: //vec3 flw_Normal;
  84: //vec3 flw_Albedo;
  85: //float flw_Alpha;
  86: //vec2 flw_LightMap;
  87: //vec4 flw_Tint;
  88: 
  89: void main() {
  90:     BlockFrag f;
  91:     f.texCoords = v2f_texCoords;
  92: f.color = v2f_color;
  93: f.diffuse = v2f_diffuse;
  94: f.light = v2f_light;
  95: 
  96: 
  97:     FLWMain(f);
  98: }

[13:33:18] [main/ERROR]: Shader compilation log for create:flap.vert: No errors.

[13:33:18] [main/ERROR]: Source for shader 'create:flap.vert':
   1: #version 110
   2: #define DEBUG_NORMAL
   3: 
   4: #define PI 3.1415926538
   5: 
   6: uniform float uTime;
   7: uniform mat4 uViewProjection;
   8: uniform vec3 uCameraPos;
   9: 
  10: #if defined(USE_FOG)
  11: varying float FragDistance;
  12: #endif
  13: 
  14: void FLWFinalizeWorldPos(inout vec4 worldPos) {
  15:     #if defined(USE_FOG)
  16:     FragDistance = length(worldPos.xyz - uCameraPos);
  17:     #endif
  18: 
  19:     gl_Position = uViewProjection * worldPos;
  20: }
  21: 
  22: void FLWFinalizeNormal(inout vec3 normal) {
  23:     // noop
  24: }
  25: 
  26: 
  27: mat4 rotate(vec3 axis, float angle) {
  28:     float s = sin(angle);
  29:     float c = cos(angle);
  30:     float oc = 1. - c;
  31: 
  32:     vec3 sa = axis * s;
  33: 
  34:     mat4 mr = mat4(1.);
  35:     mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
  36:     mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
  37:     mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);
  38: 
  39:     return mr;
  40: }
  41: 
  42: mat4 rotation(vec3 rot) {
  43:     return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
  44: }
  45: 
  46: mat3 modelToNormal(mat4 mat) {
  47:     // Discard the edges. This won't be accurate for scaled or skewed matrices,
  48:     // but we don't have to work with those often.
  49:     mat3 m;
  50:     m[0] = mat[0].xyz;
  51:     m[1] = mat[1].xyz;
  52:     m[2] = mat[2].xyz;
  53:     return m;
  54: }
  55: 
  56: #define PIOVER2 1.5707963268
  57: 
  58: vec4 quat(vec3 axis, float angle) {
  59:     float halfAngle = angle * PIOVER2 / 180.0;
  60:     vec2 cs = sin(vec2(PIOVER2 - halfAngle, halfAngle)); // compute sin and cos in one instruction
  61:     return vec4(axis.xyz * cs.y,  cs.x);
  62: }
  63: 
  64: vec4 quatMult(vec4 q1, vec4 q2) {
  65:     // disgustingly vectorized quaternion multiplication
  66:     vec4 a = q1.w * q2.xyzw;
  67:     vec4 b = q1.x * q2.wzxy * vec4(1., -1., 1., -1.);
  68:     vec4 c = q1.y * q2.zwxy * vec4(1., 1., -1., -1.);
  69:     vec4 d = q1.z * q2.yxwz * vec4(-1., 1., 1., -1.);
  70: 
  71:     return a + b + c + d;
  72: }
  73: 
  74: vec3 rotateVertexByQuat(vec3 v, vec4 q) {
  75:     vec3 i = q.xyz;
  76:     return v + 2.0 * cross(i, cross(i, v) + q.w * v);
  77: }
  78: 
  79: vec3 rotateAbout(vec3 v, vec3 axis, float angle) {
  80:     return rotateVertexByQuat(v, quat(axis, angle));
  81: }
  82: 
  83: float diffuse(vec3 normal) {
  84:     vec3 n2 = normal * normal * vec3(.6, .25, .8);
  85:     return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
  86: }
  87: 
  88: 
  89: struct Flap {
  90:     vec3 instancePos;
  91:     vec2 light;
  92:     vec3 segmentOffset;
  93:     vec3 pivot;
  94:     float horizontalAngle;
  95:     float intensity;
  96:     float flapScale;
  97:     float flapness;
  98: };
  99: 
 100: 
 101: struct Vertex {
 102:     vec3 pos;
 103:     vec3 normal;
 104:     vec2 texCoords;
 105: };
 106: 
 107: struct BlockFrag {
 108:     vec2 texCoords;
 109:     vec4 color;
 110:     float diffuse;
 111:     vec2 light;
 112: };
 113: 
 114: 
 115: float toRad(float degrees) {
 116:     return fract(degrees / 360.) * PI * 2.;
 117: }
 118: 
 119: float getFlapAngle(float flapness, float intensity, float scale) {
 120:     float absFlap = abs(flapness);
 121: 
 122:     float angle = sin((1. - absFlap) * PI * intensity) * 30. * flapness * scale;
 123: 
 124:     float halfAngle = angle * 0.5;
 125: 
 126:     float which = step(0., flapness);// 0 if negative, 1 if positive
 127:     float degrees = which * halfAngle + (1. - which) * angle;// branchless conditional multiply
 128: 
 129:     return degrees;
 130: }
 131: 
 132: BlockFrag FLWMain(Vertex v, Flap flap) {
 133:     float flapAngle = getFlapAngle(flap.flapness, flap.intensity, flap.flapScale);
 134: 
 135:     vec4 orientation = quat(vec3(0., 1., 0.), -flap.horizontalAngle);
 136:     vec4 flapRotation = quat(vec3(1., 0., 0.), flapAngle);
 137: 
 138:     vec3 rotated = rotateVertexByQuat(v.pos - flap.pivot, flapRotation) + flap.pivot + flap.segmentOffset;
 139:     rotated = rotateVertexByQuat(rotated - .5, orientation) + flap.instancePos + .5;
 140: 
 141:     vec4 worldPos = vec4(rotated, 1.);
 142:     vec3 norm = rotateVertexByQuat(rotateVertexByQuat(v.normal, flapRotation), orientation);
 143: 
 144:     FLWFinalizeWorldPos(worldPos);
 145:     FLWFinalizeNormal(norm);
 146: 
 147:     BlockFrag b;
 148:     b.diffuse = diffuse(norm);
 149:     b.texCoords = v.texCoords;
 150:     b.light = flap.light;
 151:     #if defined(DEBUG_NORMAL)
 152:     b.color = vec4(norm, 1.);
 153:     #else
 154:     b.color = vec4(1.);
 155:     #endif
 156:     return b;
 157: }
 158: attribute vec3 a_v_pos;
 159: attribute vec3 a_v_normal;
 160: attribute vec2 a_v_texCoords;
 161: 
 162: attribute vec3 a_i_instancePos;
 163: attribute vec2 a_i_light;
 164: attribute vec3 a_i_segmentOffset;
 165: attribute vec3 a_i_pivot;
 166: attribute float a_i_horizontalAngle;
 167: attribute float a_i_intensity;
 168: attribute float a_i_flapScale;
 169: attribute float a_i_flapness;
 170: 
 171: 
 172: varying vec2 v2f_texCoords;
 173: varying vec4 v2f_color;
 174: varying float v2f_diffuse;
 175: varying vec2 v2f_light;
 176: 
 177: 
 178: void main() {
 179:     Vertex v;
 180:     v.pos = a_v_pos;
 181: v.normal = a_v_normal;
 182: v.texCoords = a_v_texCoords;
 183: 
 184: 
 185:     Flap i;
 186:     i.instancePos = a_i_instancePos;
 187: i.light = a_i_light;
 188: i.segmentOffset = a_i_segmentOffset;
 189: i.pivot = a_i_pivot;
 190: i.horizontalAngle = a_i_horizontalAngle;
 191: i.intensity = a_i_intensity;
 192: i.flapScale = a_i_flapScale;
 193: i.flapness = a_i_flapness;
 194: 
 195: 
 196:     BlockFrag o = FLWMain(v, i);
 197: 
 198:     v2f_texCoords = o.texCoords;
 199: v2f_color = o.color;
 200: v2f_diffuse = o.diffuse;
 201: v2f_light = o.light;
 202: 
 203: }

[13:33:18] [main/ERROR]: Shader compilation log for flywheel:block.frag: No errors.

[13:33:18] [main/ERROR]: Source for shader 'flywheel:block.frag':
   1: #version 110
   2: #define DEBUG_NORMAL
   3: 
   4: #if defined(USE_FOG)
   5: varying float FragDistance;
   6: uniform vec4 uFogColor;
   7: #endif
   8: 
   9: #if defined(USE_FOG_LINEAR)
  10: uniform vec2 uFogRange;
  11: 
  12: float FLWFogFactor() {
  13:     return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
  14: }
  15:     #endif
  16: 
  17:     #if defined(USE_FOG_EXP2)
  18: uniform float uFogDensity;
  19: 
  20: float FLWFogFactor() {
  21:     float dist = FragDistance * uFogDensity;
  22:     return 1. / exp2(dist * dist);
  23: }
  24:     #endif
  25: 
  26: uniform vec2 uTextureScale;
  27: uniform sampler2D uBlockAtlas;
  28: uniform sampler2D uLightMap;
  29: uniform sampler2D uCrumbling;
  30: 
  31: vec4 FLWBlockTexture(vec2 texCoords) {
  32:     vec4 cr = texture2D(uCrumbling, texCoords * uTextureScale);
  33:     float diffuseAlpha = texture2D(uBlockAtlas, texCoords).a;
  34:     cr.a = cr.a * diffuseAlpha;
  35:     return cr;
  36: }
  37: 
  38: void FLWFinalizeColor(vec4 color) {
  39:     #if defined(USE_FOG)
  40:     float a = color.a;
  41:     float fog = clamp(FLWFogFactor(), 0., 1.);
  42: 
  43:     color = mix(uFogColor, color, fog);
  44:     color.a = a;
  45:     #endif
  46: 
  47:     gl_FragColor = color;
  48: }
  49: 
  50: vec4 FLWLight(vec2 lightCoords) {
  51:     return vec4(1.);
  52: }
  53: 
  54: 
  55: 
  56: struct BlockFrag {
  57:     vec2 texCoords;
  58:     vec4 color;
  59:     float diffuse;
  60:     vec2 light;
  61: };
  62: 
  63: void FLWMain(BlockFrag r) {
  64:     vec4 tex = FLWBlockTexture(r.texCoords);
  65: 
  66:     vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;
  67: 
  68: //    flw_WorldPos = ;
  69: //    flw_Normal = ;
  70: //    flw_Albedo = tex.rgb;
  71: //    flw_Alpha = tex.a;
  72: //    flw_LightMap = r.light;
  73: //    flw_Tint = r.color;
  74:     FLWFinalizeColor(color);
  75: }
  76: 
  77: varying vec2 v2f_texCoords;
  78: varying vec4 v2f_color;
  79: varying float v2f_diffuse;
  80: varying vec2 v2f_light;
  81: 
  82: 
  83: //vec3 flw_WorldPos;
  84: //vec3 flw_Normal;
  85: //vec3 flw_Albedo;
  86: //float flw_Alpha;
  87: //vec2 flw_LightMap;
  88: //vec4 flw_Tint;
  89: 
  90: void main() {
  91:     BlockFrag f;
  92:     f.texCoords = v2f_texCoords;
  93: f.color = v2f_color;
  94: f.diffuse = v2f_diffuse;
  95: f.light = v2f_light;
  96: 
  97: 
  98:     FLWMain(f);
  99: }

[13:33:19] [main/ERROR]: Shader compilation log for create:flap.vert: No errors.

[13:33:19] [main/ERROR]: Source for shader 'create:flap.vert':
   1: #version 110
   2: #define USE_FOG
   3: #define USE_FOG_LINEAR
   4: 
   5: #define PI 3.1415926538
   6: 
   7: uniform float uTime;
   8: uniform mat4 uViewProjection;
   9: uniform vec3 uCameraPos;
  10: 
  11: #if defined(USE_FOG)
  12: varying float FragDistance;
  13: #endif
  14: 
  15: void FLWFinalizeWorldPos(inout vec4 worldPos) {
  16:     #if defined(USE_FOG)
  17:     FragDistance = length(worldPos.xyz - uCameraPos);
  18:     #endif
  19: 
  20:     gl_Position = uViewProjection * worldPos;
  21: }
  22: 
  23: void FLWFinalizeNormal(inout vec3 normal) {
  24:     // noop
  25: }
  26: 
  27: 
  28: mat4 rotate(vec3 axis, float angle) {
  29:     float s = sin(angle);
  30:     float c = cos(angle);
  31:     float oc = 1. - c;
  32: 
  33:     vec3 sa = axis * s;
  34: 
  35:     mat4 mr = mat4(1.);
  36:     mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
  37:     mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
  38:     mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);
  39: 
  40:     return mr;
  41: }
  42: 
  43: mat4 rotation(vec3 rot) {
  44:     return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
  45: }
  46: 
  47: mat3 modelToNormal(mat4 mat) {
  48:     // Discard the edges. This won't be accurate for scaled or skewed matrices,
  49:     // but we don't have to work with those often.
  50:     mat3 m;
  51:     m[0] = mat[0].xyz;
  52:     m[1] = mat[1].xyz;
  53:     m[2] = mat[2].xyz;
  54:     return m;
  55: }
  56: 
  57: #define PIOVER2 1.5707963268
  58: 
  59: vec4 quat(vec3 axis, float angle) {
  60:     float halfAngle = angle * PIOVER2 / 180.0;
  61:     vec2 cs = sin(vec2(PIOVER2 - halfAngle, halfAngle)); // compute sin and cos in one instruction
  62:     return vec4(axis.xyz * cs.y,  cs.x);
  63: }
  64: 
  65: vec4 quatMult(vec4 q1, vec4 q2) {
  66:     // disgustingly vectorized quaternion multiplication
  67:     vec4 a = q1.w * q2.xyzw;
  68:     vec4 b = q1.x * q2.wzxy * vec4(1., -1., 1., -1.);
  69:     vec4 c = q1.y * q2.zwxy * vec4(1., 1., -1., -1.);
  70:     vec4 d = q1.z * q2.yxwz * vec4(-1., 1., 1., -1.);
  71: 
  72:     return a + b + c + d;
  73: }
  74: 
  75: vec3 rotateVertexByQuat(vec3 v, vec4 q) {
  76:     vec3 i = q.xyz;
  77:     return v + 2.0 * cross(i, cross(i, v) + q.w * v);
  78: }
  79: 
  80: vec3 rotateAbout(vec3 v, vec3 axis, float angle) {
  81:     return rotateVertexByQuat(v, quat(axis, angle));
  82: }
  83: 
  84: float diffuse(vec3 normal) {
  85:     vec3 n2 = normal * normal * vec3(.6, .25, .8);
  86:     return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
  87: }
  88: 
  89: 
  90: struct Flap {
  91:     vec3 instancePos;
  92:     vec2 light;
  93:     vec3 segmentOffset;
  94:     vec3 pivot;
  95:     float horizontalAngle;
  96:     float intensity;
  97:     float flapScale;
  98:     float flapness;
  99: };
 100: 
 101: 
 102: struct Vertex {
 103:     vec3 pos;
 104:     vec3 normal;
 105:     vec2 texCoords;
 106: };
 107: 
 108: struct BlockFrag {
 109:     vec2 texCoords;
 110:     vec4 color;
 111:     float diffuse;
 112:     vec2 light;
 113: };
 114: 
 115: 
 116: float toRad(float degrees) {
 117:     return fract(degrees / 360.) * PI * 2.;
 118: }
 119: 
 120: float getFlapAngle(float flapness, float intensity, float scale) {
 121:     float absFlap = abs(flapness);
 122: 
 123:     float angle = sin((1. - absFlap) * PI * intensity) * 30. * flapness * scale;
 124: 
 125:     float halfAngle = angle * 0.5;
 126: 
 127:     float which = step(0., flapness);// 0 if negative, 1 if positive
 128:     float degrees = which * halfAngle + (1. - which) * angle;// branchless conditional multiply
 129: 
 130:     return degrees;
 131: }
 132: 
 133: BlockFrag FLWMain(Vertex v, Flap flap) {
 134:     float flapAngle = getFlapAngle(flap.flapness, flap.intensity, flap.flapScale);
 135: 
 136:     vec4 orientation = quat(vec3(0., 1., 0.), -flap.horizontalAngle);
 137:     vec4 flapRotation = quat(vec3(1., 0., 0.), flapAngle);
 138: 
 139:     vec3 rotated = rotateVertexByQuat(v.pos - flap.pivot, flapRotation) + flap.pivot + flap.segmentOffset;
 140:     rotated = rotateVertexByQuat(rotated - .5, orientation) + flap.instancePos + .5;
 141: 
 142:     vec4 worldPos = vec4(rotated, 1.);
 143:     vec3 norm = rotateVertexByQuat(rotateVertexByQuat(v.normal, flapRotation), orientation);
 144: 
 145:     FLWFinalizeWorldPos(worldPos);
 146:     FLWFinalizeNormal(norm);
 147: 
 148:     BlockFrag b;
 149:     b.diffuse = diffuse(norm);
 150:     b.texCoords = v.texCoords;
 151:     b.light = flap.light;
 152:     #if defined(DEBUG_NORMAL)
 153:     b.color = vec4(norm, 1.);
 154:     #else
 155:     b.color = vec4(1.);
 156:     #endif
 157:     return b;
 158: }
 159: attribute vec3 a_v_pos;
 160: attribute vec3 a_v_normal;
 161: attribute vec2 a_v_texCoords;
 162: 
 163: attribute vec3 a_i_instancePos;
 164: attribute vec2 a_i_light;
 165: attribute vec3 a_i_segmentOffset;
 166: attribute vec3 a_i_pivot;
 167: attribute float a_i_horizontalAngle;
 168: attribute float a_i_intensity;
 169: attribute float a_i_flapScale;
 170: attribute float a_i_flapness;
 171: 
 172: 
 173: varying vec2 v2f_texCoords;
 174: varying vec4 v2f_color;
 175: varying float v2f_diffuse;
 176: varying vec2 v2f_light;
 177: 
 178: 
 179: void main() {
 180:     Vertex v;
 181:     v.pos = a_v_pos;
 182: v.normal = a_v_normal;
 183: v.texCoords = a_v_texCoords;
 184: 
 185: 
 186:     Flap i;
 187:     i.instancePos = a_i_instancePos;
 188: i.light = a_i_light;
 189: i.segmentOffset = a_i_segmentOffset;
 190: i.pivot = a_i_pivot;
 191: i.horizontalAngle = a_i_horizontalAngle;
 192: i.intensity = a_i_intensity;
 193: i.flapScale = a_i_flapScale;
 194: i.flapness = a_i_flapness;
 195: 
 196: 
 197:     BlockFrag o = FLWMain(v, i);
 198: 
 199:     v2f_texCoords = o.texCoords;
 200: v2f_color = o.color;
 201: v2f_diffuse = o.diffuse;
 202: v2f_light = o.light;
 203: 
 204: }

[13:33:19] [main/ERROR]: Shader compilation log for flywheel:block.frag: No errors.

[13:33:19] [main/ERROR]: Source for shader 'flywheel:block.frag':
   1: #version 110
   2: #define USE_FOG
   3: #define USE_FOG_LINEAR
   4: 
   5: #if defined(USE_FOG)
   6: varying float FragDistance;
   7: uniform vec4 uFogColor;
   8: #endif
   9: 
  10: #if defined(USE_FOG_LINEAR)
  11: uniform vec2 uFogRange;
  12: 
  13: float FLWFogFactor() {
  14:     return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
  15: }
  16:     #endif
  17: 
  18:     #if defined(USE_FOG_EXP2)
  19: uniform float uFogDensity;
  20: 
  21: float FLWFogFactor() {
  22:     float dist = FragDistance * uFogDensity;
  23:     return 1. / exp2(dist * dist);
  24: }
  25:     #endif
  26: 
  27: uniform vec2 uTextureScale;
  28: uniform sampler2D uBlockAtlas;
  29: uniform sampler2D uLightMap;
  30: uniform sampler2D uCrumbling;
  31: 
  32: vec4 FLWBlockTexture(vec2 texCoords) {
  33:     vec4 cr = texture2D(uCrumbling, texCoords * uTextureScale);
  34:     float diffuseAlpha = texture2D(uBlockAtlas, texCoords).a;
  35:     cr.a = cr.a * diffuseAlpha;
  36:     return cr;
  37: }
  38: 
  39: void FLWFinalizeColor(vec4 color) {
  40:     #if defined(USE_FOG)
  41:     float a = color.a;
  42:     float fog = clamp(FLWFogFactor(), 0., 1.);
  43: 
  44:     color = mix(uFogColor, color, fog);
  45:     color.a = a;
  46:     #endif
  47: 
  48:     gl_FragColor = color;
  49: }
  50: 
  51: vec4 FLWLight(vec2 lightCoords) {
  52:     return vec4(1.);
  53: }
  54: 
  55: 
  56: 
  57: struct BlockFrag {
  58:     vec2 texCoords;
  59:     vec4 color;
  60:     float diffuse;
  61:     vec2 light;
  62: };
  63: 
  64: void FLWMain(BlockFrag r) {
  65:     vec4 tex = FLWBlockTexture(r.texCoords);
  66: 
  67:     vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;
  68: 
  69: //    flw_WorldPos = ;
  70: //    flw_Normal = ;
  71: //    flw_Albedo = tex.rgb;
  72: //    flw_Alpha = tex.a;
  73: //    flw_LightMap = r.light;
  74: //    flw_Tint = r.color;
  75:     FLWFinalizeColor(color);
  76: }
  77: 
  78: varying vec2 v2f_texCoords;
  79: varying vec4 v2f_color;
  80: varying float v2f_diffuse;
  81: varying vec2 v2f_light;
  82: 
  83: 
  84: //vec3 flw_WorldPos;
  85: //vec3 flw_Normal;
  86: //vec3 flw_Albedo;
  87: //float flw_Alpha;
  88: //vec2 flw_LightMap;
  89: //vec4 flw_Tint;
  90: 
  91: void main() {
  92:     BlockFrag f;
  93:     f.texCoords = v2f_texCoords;
  94: f.color = v2f_color;
  95: f.diffuse = v2f_diffuse;
  96: f.light = v2f_light;
  97: 
  98: 
  99:     FLWMain(f);
 100: }

[13:33:19] [main/ERROR]: Shader compilation log for create:flap.vert: No errors.

[13:33:19] [main/ERROR]: Source for shader 'create:flap.vert':
   1: #version 110
   2: #define USE_FOG
   3: #define USE_FOG_EXP2
   4: 
   5: #define PI 3.1415926538
   6: 
   7: uniform float uTime;
   8: uniform mat4 uViewProjection;
   9: uniform vec3 uCameraPos;
  10: 
  11: #if defined(USE_FOG)
  12: varying float FragDistance;
  13: #endif
  14: 
  15: void FLWFinalizeWorldPos(inout vec4 worldPos) {
  16:     #if defined(USE_FOG)
  17:     FragDistance = length(worldPos.xyz - uCameraPos);
  18:     #endif
  19: 
  20:     gl_Position = uViewProjection * worldPos;
  21: }
  22: 
  23: void FLWFinalizeNormal(inout vec3 normal) {
  24:     // noop
  25: }
  26: 
  27: 
  28: mat4 rotate(vec3 axis, float angle) {
  29:     float s = sin(angle);
  30:     float c = cos(angle);
  31:     float oc = 1. - c;
  32: 
  33:     vec3 sa = axis * s;
  34: 
  35:     mat4 mr = mat4(1.);
  36:     mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
  37:     mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
  38:     mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);
  39: 
  40:     return mr;
  41: }
  42: 
  43: mat4 rotation(vec3 rot) {
  44:     return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
  45: }
  46: 
  47: mat3 modelToNormal(mat4 mat) {
  48:     // Discard the edges. This won't be accurate for scaled or skewed matrices,
  49:     // but we don't have to work with those often.
  50:     mat3 m;
  51:     m[0] = mat[0].xyz;
  52:     m[1] = mat[1].xyz;
  53:     m[2] = mat[2].xyz;
  54:     return m;
  55: }
  56: 
  57: #define PIOVER2 1.5707963268
  58: 
  59: vec4 quat(vec3 axis, float angle) {
  60:     float halfAngle = angle * PIOVER2 / 180.0;
  61:     vec2 cs = sin(vec2(PIOVER2 - halfAngle, halfAngle)); // compute sin and cos in one instruction
  62:     return vec4(axis.xyz * cs.y,  cs.x);
  63: }
  64: 
  65: vec4 quatMult(vec4 q1, vec4 q2) {
  66:     // disgustingly vectorized quaternion multiplication
  67:     vec4 a = q1.w * q2.xyzw;
  68:     vec4 b = q1.x * q2.wzxy * vec4(1., -1., 1., -1.);
  69:     vec4 c = q1.y * q2.zwxy * vec4(1., 1., -1., -1.);
  70:     vec4 d = q1.z * q2.yxwz * vec4(-1., 1., 1., -1.);
  71: 
  72:     return a + b + c + d;
  73: }
  74: 
  75: vec3 rotateVertexByQuat(vec3 v, vec4 q) {
  76:     vec3 i = q.xyz;
  77:     return v + 2.0 * cross(i, cross(i, v) + q.w * v);
  78: }
  79: 
  80: vec3 rotateAbout(vec3 v, vec3 axis, float angle) {
  81:     return rotateVertexByQuat(v, quat(axis, angle));
  82: }
  83: 
  84: float diffuse(vec3 normal) {
  85:     vec3 n2 = normal * normal * vec3(.6, .25, .8);
  86:     return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
  87: }
  88: 
  89: 
  90: struct Flap {
  91:     vec3 instancePos;
  92:     vec2 light;
  93:     vec3 segmentOffset;
  94:     vec3 pivot;
  95:     float horizontalAngle;
  96:     float intensity;
  97:     float flapScale;
  98:     float flapness;
  99: };
 100: 
 101: 
 102: struct Vertex {
 103:     vec3 pos;
 104:     vec3 normal;
 105:     vec2 texCoords;
 106: };
 107: 
 108: struct BlockFrag {
 109:     vec2 texCoords;
 110:     vec4 color;
 111:     float diffuse;
 112:     vec2 light;
 113: };
 114: 
 115: 
 116: float toRad(float degrees) {
 117:     return fract(degrees / 360.) * PI * 2.;
 118: }
 119: 
 120: float getFlapAngle(float flapness, float intensity, float scale) {
 121:     float absFlap = abs(flapness);
 122: 
 123:     float angle = sin((1. - absFlap) * PI * intensity) * 30. * flapness * scale;
 124: 
 125:     float halfAngle = angle * 0.5;
 126: 
 127:     float which = step(0., flapness);// 0 if negative, 1 if positive
 128:     float degrees = which * halfAngle + (1. - which) * angle;// branchless conditional multiply
 129: 
 130:     return degrees;
 131: }
 132: 
 133: BlockFrag FLWMain(Vertex v, Flap flap) {
 134:     float flapAngle = getFlapAngle(flap.flapness, flap.intensity, flap.flapScale);
 135: 
 136:     vec4 orientation = quat(vec3(0., 1., 0.), -flap.horizontalAngle);
 137:     vec4 flapRotation = quat(vec3(1., 0., 0.), flapAngle);
 138: 
 139:     vec3 rotated = rotateVertexByQuat(v.pos - flap.pivot, flapRotation) + flap.pivot + flap.segmentOffset;
 140:     rotated = rotateVertexByQuat(rotated - .5, orientation) + flap.instancePos + .5;
 141: 
 142:     vec4 worldPos = vec4(rotated, 1.);
 143:     vec3 norm = rotateVertexByQuat(rotateVertexByQuat(v.normal, flapRotation), orientation);
 144: 
 145:     FLWFinalizeWorldPos(worldPos);
 146:     FLWFinalizeNormal(norm);
 147: 
 148:     BlockFrag b;
 149:     b.diffuse = diffuse(norm);
 150:     b.texCoords = v.texCoords;
 151:     b.light = flap.light;
 152:     #if defined(DEBUG_NORMAL)
 153:     b.color = vec4(norm, 1.);
 154:     #else
 155:     b.color = vec4(1.);
 156:     #endif
 157:     return b;
 158: }
 159: attribute vec3 a_v_pos;
 160: attribute vec3 a_v_normal;
 161: attribute vec2 a_v_texCoords;
 162: 
 163: attribute vec3 a_i_instancePos;
 164: attribute vec2 a_i_light;
 165: attribute vec3 a_i_segmentOffset;
 166: attribute vec3 a_i_pivot;
 167: attribute float a_i_horizontalAngle;
 168: attribute float a_i_intensity;
 169: attribute float a_i_flapScale;
 170: attribute float a_i_flapness;
 171: 
 172: 
 173: varying vec2 v2f_texCoords;
 174: varying vec4 v2f_color;
 175: varying float v2f_diffuse;
 176: varying vec2 v2f_light;
 177: 
 178: 
 179: void main() {
 180:     Vertex v;
 181:     v.pos = a_v_pos;
 182: v.normal = a_v_normal;
 183: v.texCoords = a_v_texCoords;
 184: 
 185: 
 186:     Flap i;
 187:     i.instancePos = a_i_instancePos;
 188: i.light = a_i_light;
 189: i.segmentOffset = a_i_segmentOffset;
 190: i.pivot = a_i_pivot;
 191: i.horizontalAngle = a_i_horizontalAngle;
 192: i.intensity = a_i_intensity;
 193: i.flapScale = a_i_flapScale;
 194: i.flapness = a_i_flapness;
 195: 
 196: 
 197:     BlockFrag o = FLWMain(v, i);
 198: 
 199:     v2f_texCoords = o.texCoords;
 200: v2f_color = o.color;
 201: v2f_diffuse = o.diffuse;
 202: v2f_light = o.light;
 203: 
 204: }

[13:33:19] [main/ERROR]: Shader compilation log for flywheel:block.frag: No errors.

[13:33:19] [main/ERROR]: Source for shader 'flywheel:block.frag':
   1: #version 110
   2: #define USE_FOG
   3: #define USE_FOG_EXP2
   4: 
   5: #if defined(USE_FOG)
   6: varying float FragDistance;
   7: uniform vec4 uFogColor;
   8: #endif
   9: 
  10: #if defined(USE_FOG_LINEAR)
  11: uniform vec2 uFogRange;
  12: 
  13: float FLWFogFactor() {
  14:     return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
  15: }
  16:     #endif
  17: 
  18:     #if defined(USE_FOG_EXP2)
  19: uniform float uFogDensity;
  20: 
  21: float FLWFogFactor() {
  22:     float dist = FragDistance * uFogDensity;
  23:     return 1. / exp2(dist * dist);
  24: }
  25:     #endif
  26: 
  27: uniform vec2 uTextureScale;
  28: uniform sampler2D uBlockAtlas;
  29: uniform sampler2D uLightMap;
  30: uniform sampler2D uCrumbling;
  31: 
  32: vec4 FLWBlockTexture(vec2 texCoords) {
  33:     vec4 cr = texture2D(uCrumbling, texCoords * uTextureScale);
  34:     float diffuseAlpha = texture2D(uBlockAtlas, texCoords).a;
  35:     cr.a = cr.a * diffuseAlpha;
  36:     return cr;
  37: }
  38: 
  39: void FLWFinalizeColor(vec4 color) {
  40:     #if defined(USE_FOG)
  41:     float a = color.a;
  42:     float fog = clamp(FLWFogFactor(), 0., 1.);
  43: 
  44:     color = mix(uFogColor, color, fog);
  45:     color.a = a;
  46:     #endif
  47: 
  48:     gl_FragColor = color;
  49: }
  50: 
  51: vec4 FLWLight(vec2 lightCoords) {
  52:     return vec4(1.);
  53: }
  54: 
  55: 
  56: 
  57: struct BlockFrag {
  58:     vec2 texCoords;
  59:     vec4 color;
  60:     float diffuse;
  61:     vec2 light;
  62: };
  63: 
  64: void FLWMain(BlockFrag r) {
  65:     vec4 tex = FLWBlockTexture(r.texCoords);
  66: 
  67:     vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;
  68: 
  69: //    flw_WorldPos = ;
  70: //    flw_Normal = ;
  71: //    flw_Albedo = tex.rgb;
  72: //    flw_Alpha = tex.a;
  73: //    flw_LightMap = r.light;
  74: //    flw_Tint = r.color;
  75:     FLWFinalizeColor(color);
  76: }
  77: 
  78: varying vec2 v2f_texCoords;
  79: varying vec4 v2f_color;
  80: varying float v2f_diffuse;
  81: varying vec2 v2f_light;
  82: 
  83: 
  84: //vec3 flw_WorldPos;
  85: //vec3 flw_Normal;
  86: //vec3 flw_Albedo;
  87: //float flw_Alpha;
  88: //vec2 flw_LightMap;
  89: //vec4 flw_Tint;
  90: 
  91: void main() {
  92:     BlockFrag f;
  93:     f.texCoords = v2f_texCoords;
  94: f.color = v2f_color;
  95: f.diffuse = v2f_diffuse;
  96: f.light = v2f_light;
  97: 
  98: 
  99:     FLWMain(f);
 100: }

[13:33:19] [main/ERROR]: Shader compilation log for create:flap.vert: No errors.

[13:33:19] [main/ERROR]: Source for shader 'create:flap.vert':
   1: #version 110
   2: 
   3: #define PI 3.1415926538
   4: 
   5: uniform float uTime;
   6: uniform mat4 uViewProjection;
   7: uniform vec3 uCameraPos;
   8: 
   9: #if defined(USE_FOG)
  10: varying float FragDistance;
  11: #endif
  12: 
  13: void FLWFinalizeWorldPos(inout vec4 worldPos) {
  14:     #if defined(USE_FOG)
  15:     FragDistance = length(worldPos.xyz - uCameraPos);
  16:     #endif
  17: 
  18:     gl_Position = uViewProjection * worldPos;
  19: }
  20: 
  21: void FLWFinalizeNormal(inout vec3 normal) {
  22:     // noop
  23: }
  24: 
  25: 
  26: mat4 rotate(vec3 axis, float angle) {
  27:     float s = sin(angle);
  28:     float c = cos(angle);
  29:     float oc = 1. - c;
  30: 
  31:     vec3 sa = axis * s;
  32: 
  33:     mat4 mr = mat4(1.);
  34:     mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
  35:     mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
  36:     mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);
  37: 
  38:     return mr;
  39: }
  40: 
  41: mat4 rotation(vec3 rot) {
  42:     return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
  43: }
  44: 
  45: mat3 modelToNormal(mat4 mat) {
  46:     // Discard the edges. This won't be accurate for scaled or skewed matrices,
  47:     // but we don't have to work with those often.
  48:     mat3 m;
  49:     m[0] = mat[0].xyz;
  50:     m[1] = mat[1].xyz;
  51:     m[2] = mat[2].xyz;
  52:     return m;
  53: }
  54: 
  55: #define PIOVER2 1.5707963268
  56: 
  57: vec4 quat(vec3 axis, float angle) {
  58:     float halfAngle = angle * PIOVER2 / 180.0;
  59:     vec2 cs = sin(vec2(PIOVER2 - halfAngle, halfAngle)); // compute sin and cos in one instruction
  60:     return vec4(axis.xyz * cs.y,  cs.x);
  61: }
  62: 
  63: vec4 quatMult(vec4 q1, vec4 q2) {
  64:     // disgustingly vectorized quaternion multiplication
  65:     vec4 a = q1.w * q2.xyzw;
  66:     vec4 b = q1.x * q2.wzxy * vec4(1., -1., 1., -1.);
  67:     vec4 c = q1.y * q2.zwxy * vec4(1., 1., -1., -1.);
  68:     vec4 d = q1.z * q2.yxwz * vec4(-1., 1., 1., -1.);
  69: 
  70:     return a + b + c + d;
  71: }
  72: 
  73: vec3 rotateVertexByQuat(vec3 v, vec4 q) {
  74:     vec3 i = q.xyz;
  75:     return v + 2.0 * cross(i, cross(i, v) + q.w * v);
  76: }
  77: 
  78: vec3 rotateAbout(vec3 v, vec3 axis, float angle) {
  79:     return rotateVertexByQuat(v, quat(axis, angle));
  80: }
  81: 
  82: float diffuse(vec3 normal) {
  83:     vec3 n2 = normal * normal * vec3(.6, .25, .8);
  84:     return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
  85: }
  86: 
  87: 
  88: struct Flap {
  89:     vec3 instancePos;
  90:     vec2 light;
  91:     vec3 segmentOffset;
  92:     vec3 pivot;
  93:     float horizontalAngle;
  94:     float intensity;
  95:     float flapScale;
  96:     float flapness;
  97: };
  98: 
  99: 
 100: struct Vertex {
 101:     vec3 pos;
 102:     vec3 normal;
 103:     vec2 texCoords;
 104: };
 105: 
 106: struct BlockFrag {
 107:     vec2 texCoords;
 108:     vec4 color;
 109:     float diffuse;
 110:     vec2 light;
 111: };
 112: 
 113: 
 114: float toRad(float degrees) {
 115:     return fract(degrees / 360.) * PI * 2.;
 116: }
 117: 
 118: float getFlapAngle(float flapness, float intensity, float scale) {
 119:     float absFlap = abs(flapness);
 120: 
 121:     float angle = sin((1. - absFlap) * PI * intensity) * 30. * flapness * scale;
 122: 
 123:     float halfAngle = angle * 0.5;
 124: 
 125:     float which = step(0., flapness);// 0 if negative, 1 if positive
 126:     float degrees = which * halfAngle + (1. - which) * angle;// branchless conditional multiply
 127: 
 128:     return degrees;
 129: }
 130: 
 131: BlockFrag FLWMain(Vertex v, Flap flap) {
 132:     float flapAngle = getFlapAngle(flap.flapness, flap.intensity, flap.flapScale);
 133: 
 134:     vec4 orientation = quat(vec3(0., 1., 0.), -flap.horizontalAngle);
 135:     vec4 flapRotation = quat(vec3(1., 0., 0.), flapAngle);
 136: 
 137:     vec3 rotated = rotateVertexByQuat(v.pos - flap.pivot, flapRotation) + flap.pivot + flap.segmentOffset;
 138:     rotated = rotateVertexByQuat(rotated - .5, orientation) + flap.instancePos + .5;
 139: 
 140:     vec4 worldPos = vec4(rotated, 1.);
 141:     vec3 norm = rotateVertexByQuat(rotateVertexByQuat(v.normal, flapRotation), orientation);
 142: 
 143:     FLWFinalizeWorldPos(worldPos);
 144:     FLWFinalizeNormal(norm);
 145: 
 146:     BlockFrag b;
 147:     b.diffuse = diffuse(norm);
 148:     b.texCoords = v.texCoords;
 149:     b.light = flap.light;
 150:     #if defined(DEBUG_NORMAL)
 151:     b.color = vec4(norm, 1.);
 152:     #else
 153:     b.color = vec4(1.);
 154:     #endif
 155:     return b;
 156: }
 157: attribute vec3 a_v_pos;
 158: attribute vec3 a_v_normal;
 159: attribute vec2 a_v_texCoords;
 160: 
 161: attribute vec3 a_i_instancePos;
 162: attribute vec2 a_i_light;
 163: attribute vec3 a_i_segmentOffset;
 164: attribute vec3 a_i_pivot;
 165: attribute float a_i_horizontalAngle;
 166: attribute float a_i_intensity;
 167: attribute float a_i_flapScale;
 168: attribute float a_i_flapness;
 169: 
 170: 
 171: varying vec2 v2f_texCoords;
 172: varying vec4 v2f_color;
 173: varying float v2f_diffuse;
 174: varying vec2 v2f_light;
 175: 
 176: 
 177: void main() {
 178:     Vertex v;
 179:     v.pos = a_v_pos;
 180: v.normal = a_v_normal;
 181: v.texCoords = a_v_texCoords;
 182: 
 183: 
 184:     Flap i;
 185:     i.instancePos = a_i_instancePos;
 186: i.light = a_i_light;
 187: i.segmentOffset = a_i_segmentOffset;
 188: i.pivot = a_i_pivot;
 189: i.horizontalAngle = a_i_horizontalAngle;
 190: i.intensity = a_i_intensity;
 191: i.flapScale = a_i_flapScale;
 192: i.flapness = a_i_flapness;
 193: 
 194: 
 195:     BlockFrag o = FLWMain(v, i);
 196: 
 197:     v2f_texCoords = o.texCoords;
 198: v2f_color = o.color;
 199: v2f_diffuse = o.diffuse;
 200: v2f_light = o.light;
 201: 
 202: }

[13:33:19] [main/ERROR]: Shader compilation log for flywheel:block.frag: No errors.

[13:33:19] [main/ERROR]: Source for shader 'flywheel:block.frag':
   1: #version 110
   2: 
   3: #if defined(USE_FOG)
   4: varying float FragDistance;
   5: uniform vec4 uFogColor;
   6: #endif
   7: 
   8: #if defined(USE_FOG_LINEAR)
   9: uniform vec2 uFogRange;
  10: 
  11: float FLWFogFactor() {
  12:     return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
  13: }
  14:     #endif
  15: 
  16:     #if defined(USE_FOG_EXP2)
  17: uniform float uFogDensity;
  18: 
  19: float FLWFogFactor() {
  20:     float dist = FragDistance * uFogDensity;
  21:     return 1. / exp2(dist * dist);
  22: }
  23:     #endif
  24: 
  25: uniform vec2 uTextureScale;
  26: uniform sampler2D uBlockAtlas;
  27: uniform sampler2D uLightMap;
  28: uniform sampler2D uCrumbling;
  29: 
  30: vec4 FLWBlockTexture(vec2 texCoords) {
  31:     vec4 cr = texture2D(uCrumbling, texCoords * uTextureScale);
  32:     float diffuseAlpha = texture2D(uBlockAtlas, texCoords).a;
  33:     cr.a = cr.a * diffuseAlpha;
  34:     return cr;
  35: }
  36: 
  37: void FLWFinalizeColor(vec4 color) {
  38:     #if defined(USE_FOG)
  39:     float a = color.a;
  40:     float fog = clamp(FLWFogFactor(), 0., 1.);
  41: 
  42:     color = mix(uFogColor, color, fog);
  43:     color.a = a;
  44:     #endif
  45: 
  46:     gl_FragColor = color;
  47: }
  48: 
  49: vec4 FLWLight(vec2 lightCoords) {
  50:     return vec4(1.);
  51: }
  52: 
  53: 
  54: 
  55: struct BlockFrag {
  56:     vec2 texCoords;
  57:     vec4 color;
  58:     float diffuse;
  59:     vec2 light;
  60: };
  61: 
  62: void FLWMain(BlockFrag r) {
  63:     vec4 tex = FLWBlockTexture(r.texCoords);
  64: 
  65:     vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;
  66: 
  67: //    flw_WorldPos = ;
  68: //    flw_Normal = ;
  69: //    flw_Albedo = tex.rgb;
  70: //    flw_Alpha = tex.a;
  71: //    flw_LightMap = r.light;
  72: //    flw_Tint = r.color;
  73:     FLWFinalizeColor(color);
  74: }
  75: 
  76: varying vec2 v2f_texCoords;
  77: varying vec4 v2f_color;
  78: varying float v2f_diffuse;
  79: varying vec2 v2f_light;
  80: 
  81: 
  82: //vec3 flw_WorldPos;
  83: //vec3 flw_Normal;
  84: //vec3 flw_Albedo;
  85: //float flw_Alpha;
  86: //vec2 flw_LightMap;
  87: //vec4 flw_Tint;
  88: 
  89: void main() {
  90:     BlockFrag f;
  91:     f.texCoords = v2f_texCoords;
  92: f.color = v2f_color;
  93: f.diffuse = v2f_diffuse;
  94: f.light = v2f_light;
  95: 
  96: 
  97:     FLWMain(f);
  98: }

[13:33:19] [main/ERROR]: Shader compilation log for create:belt.vert: No errors.

[13:33:19] [main/ERROR]: Source for shader 'create:belt.vert':
   1: #version 110
   2: #define DEBUG_RAINBOW
   3: 
   4: #define PI 3.1415926538
   5: 
   6: uniform float uTime;
   7: uniform mat4 uViewProjection;
   8: uniform vec3 uCameraPos;
   9: 
  10: #if defined(USE_FOG)
  11: varying float FragDistance;
  12: #endif
  13: 
  14: void FLWFinalizeWorldPos(inout vec4 worldPos) {
  15:     #if defined(USE_FOG)
  16:     FragDistance = length(worldPos.xyz - uCameraPos);
  17:     #endif
  18: 
  19:     gl_Position = uViewProjection * worldPos;
  20: }
  21: 
  22: void FLWFinalizeNormal(inout vec3 normal) {
  23:     // noop
  24: }
  25: 
  26: 
  27: #define PIOVER2 1.5707963268
  28: 
  29: vec4 quat(vec3 axis, float angle) {
  30:     float halfAngle = angle * PIOVER2 / 180.0;
  31:     vec2 cs = sin(vec2(PIOVER2 - halfAngle, halfAngle)); // compute sin and cos in one instruction
  32:     return vec4(axis.xyz * cs.y,  cs.x);
  33: }
  34: 
  35: vec4 quatMult(vec4 q1, vec4 q2) {
  36:     // disgustingly vectorized quaternion multiplication
  37:     vec4 a = q1.w * q2.xyzw;
  38:     vec4 b = q1.x * q2.wzxy * vec4(1., -1., 1., -1.);
  39:     vec4 c = q1.y * q2.zwxy * vec4(1., 1., -1., -1.);
  40:     vec4 d = q1.z * q2.yxwz * vec4(-1., 1., 1., -1.);
  41: 
  42:     return a + b + c + d;
  43: }
  44: 
  45: vec3 rotateVertexByQuat(vec3 v, vec4 q) {
  46:     vec3 i = q.xyz;
  47:     return v + 2.0 * cross(i, cross(i, v) + q.w * v);
  48: }
  49: 
  50: vec3 rotateAbout(vec3 v, vec3 axis, float angle) {
  51:     return rotateVertexByQuat(v, quat(axis, angle));
  52: }
  53: 
  54: mat4 rotate(vec3 axis, float angle) {
  55:     float s = sin(angle);
  56:     float c = cos(angle);
  57:     float oc = 1. - c;
  58: 
  59:     vec3 sa = axis * s;
  60: 
  61:     mat4 mr = mat4(1.);
  62:     mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
  63:     mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
  64:     mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);
  65: 
  66:     return mr;
  67: }
  68: 
  69: mat4 rotation(vec3 rot) {
  70:     return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
  71: }
  72: 
  73: mat3 modelToNormal(mat4 mat) {
  74:     // Discard the edges. This won't be accurate for scaled or skewed matrices,
  75:     // but we don't have to work with those often.
  76:     mat3 m;
  77:     m[0] = mat[0].xyz;
  78:     m[1] = mat[1].xyz;
  79:     m[2] = mat[2].xyz;
  80:     return m;
  81: }
  82: 
  83: float diffuse(vec3 normal) {
  84:     vec3 n2 = normal * normal * vec3(.6, .25, .8);
  85:     return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
  86: }
  87: 
  88: 
  89: struct Belt {
  90:     vec2 light;
  91:     vec4 color;
  92:     vec3 pos;
  93:     float speed;
  94:     float offset;
  95:     vec4 rotation;
  96:     vec2 sourceTexture;
  97:     vec4 scrollTexture;
  98:     float scrollMult;
  99: };
 100: 
 101: 
 102: struct Vertex {
 103:     vec3 pos;
 104:     vec3 normal;
 105:     vec2 texCoords;
 106: };
 107: 
 108: struct BlockFrag {
 109:     vec2 texCoords;
 110:     vec4 color;
 111:     float diffuse;
 112:     vec2 light;
 113: };
 114: 
 115: BlockFrag FLWMain(Vertex v, Belt instance) {
 116:     vec3 rotated = rotateVertexByQuat(v.pos - .5, instance.rotation) + instance.pos + .5;
 117: 
 118:     vec4 worldPos = vec4(rotated, 1.);
 119: 
 120:     vec3 norm = rotateVertexByQuat(v.normal, instance.rotation);
 121: 
 122:     FLWFinalizeWorldPos(worldPos);
 123:     FLWFinalizeNormal(norm);
 124: 
 125:     float scrollSize = instance.scrollTexture.w - instance.scrollTexture.y;
 126:     float scroll = fract(instance.speed * uTime / (31.5 * 16.) + instance.offset) * scrollSize * instance.scrollMult;
 127: 
 128:     BlockFrag b;
 129:     b.diffuse = diffuse(norm);
 130:     b.texCoords = v.texCoords - instance.sourceTexture + instance.scrollTexture.xy + vec2(0, scroll);
 131:     b.light = instance.light;
 132: 
 133:     #if defined(DEBUG_RAINBOW)
 134:     b.color = instance.color;
 135:     #elif defined(DEBUG_NORMAL)
 136:     b.color = vec4(norm, 1.);
 137:     #else
 138:     b.color = vec4(1.);
 139:     #endif
 140: 
 141:     return b;
 142: }
 143: attribute vec3 a_v_pos;
 144: attribute vec3 a_v_normal;
 145: attribute vec2 a_v_texCoords;
 146: 
 147: attribute vec2 a_i_light;
 148: attribute vec4 a_i_color;
 149: attribute vec3 a_i_pos;
 150: attribute float a_i_speed;
 151: attribute float a_i_offset;
 152: attribute vec4 a_i_rotation;
 153: attribute vec2 a_i_sourceTexture;
 154: attribute vec4 a_i_scrollTexture;
 155: attribute float a_i_scrollMult;
 156: 
 157: 
 158: varying vec2 v2f_texCoords;
 159: varying vec4 v2f_color;
 160: varying float v2f_diffuse;
 161: varying vec2 v2f_light;
 162: 
 163: 
 164: void main() {
 165:     Vertex v;
 166:     v.pos = a_v_pos;
 167: v.normal = a_v_normal;
 168: v.texCoords = a_v_texCoords;
 169: 
 170: 
 171:     Belt i;
 172:     i.light = a_i_light;
 173: i.color = a_i_color;
 174: i.pos = a_i_pos;
 175: i.speed = a_i_speed;
 176: i.offset = a_i_offset;
 177: i.rotation = a_i_rotation;
 178: i.sourceTexture = a_i_sourceTexture;
 179: i.scrollTexture = a_i_scrollTexture;
 180: i.scrollMult = a_i_scrollMult;
 181: 
 182: 
 183:     BlockFrag o = FLWMain(v, i);
 184: 
 185:     v2f_texCoords = o.texCoords;
 186: v2f_color = o.color;
 187: v2f_diffuse = o.diffuse;
 188: v2f_light = o.light;
 189: 
 190: }

[13:33:19] [main/ERROR]: Shader compilation log for flywheel:block.frag: No errors.

[13:33:19] [main/ERROR]: Source for shader 'flywheel:block.frag':
   1: #version 110
   2: #define DEBUG_RAINBOW
   3: 
   4: #if defined(USE_FOG)
   5: varying float FragDistance;
   6: uniform vec4 uFogColor;
   7: #endif
   8: 
   9: #if defined(USE_FOG_LINEAR)
  10: uniform vec2 uFogRange;
  11: 
  12: float FLWFogFactor() {
  13:     return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
  14: }
  15:     #endif
  16: 
  17:     #if defined(USE_FOG_EXP2)
  18: uniform float uFogDensity;
  19: 
  20: float FLWFogFactor() {
  21:     float dist = FragDistance * uFogDensity;
  22:     return 1. / exp2(dist * dist);
  23: }
  24:     #endif
  25: 
  26: uniform vec2 uTextureScale;
  27: uniform sampler2D uBlockAtlas;
  28: uniform sampler2D uLightMap;
  29: uniform sampler2D uCrumbling;
  30: 
  31: vec4 FLWBlockTexture(vec2 texCoords) {
  32:     vec4 cr = texture2D(uCrumbling, texCoords * uTextureScale);
  33:     float diffuseAlpha = texture2D(uBlockAtlas, texCoords).a;
  34:     cr.a = cr.a * diffuseAlpha;
  35:     return cr;
  36: }
  37: 
  38: void FLWFinalizeColor(vec4 color) {
  39:     #if defined(USE_FOG)
  40:     float a = color.a;
  41:     float fog = clamp(FLWFogFactor(), 0., 1.);
  42: 
  43:     color = mix(uFogColor, color, fog);
  44:     color.a = a;
  45:     #endif
  46: 
  47:     gl_FragColor = color;
  48: }
  49: 
  50: vec4 FLWLight(vec2 lightCoords) {
  51:     return vec4(1.);
  52: }
  53: 
  54: 
  55: 
  56: struct BlockFrag {
  57:     vec2 texCoords;
  58:     vec4 color;
  59:     float diffuse;
  60:     vec2 light;
  61: };
  62: 
  63: void FLWMain(BlockFrag r) {
  64:     vec4 tex = FLWBlockTexture(r.texCoords);
  65: 
  66:     vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;
  67: 
  68: //    flw_WorldPos = ;
  69: //    flw_Normal = ;
  70: //    flw_Albedo = tex.rgb;
  71: //    flw_Alpha = tex.a;
  72: //    flw_LightMap = r.light;
  73: //    flw_Tint = r.color;
  74:     FLWFinalizeColor(color);
  75: }
  76: 
  77: varying vec2 v2f_texCoords;
  78: varying vec4 v2f_color;
  79: varying float v2f_diffuse;
  80: varying vec2 v2f_light;
  81: 
  82: 
  83: //vec3 flw_WorldPos;
  84: //vec3 flw_Normal;
  85: //vec3 flw_Albedo;
  86: //float flw_Alpha;
  87: //vec2 flw_LightMap;
  88: //vec4 flw_Tint;
  89: 
  90: void main() {
  91:     BlockFrag f;
  92:     f.texCoords = v2f_texCoords;
  93: f.color = v2f_color;
  94: f.diffuse = v2f_diffuse;
  95: f.light = v2f_light;
  96: 
  97: 
  98:     FLWMain(f);
  99: }

[13:33:19] [main/ERROR]: Shader compilation log for create:belt.vert: No errors.

[13:33:19] [main/ERROR]: Source for shader 'create:belt.vert':
   1: #version 110
   2: #define DEBUG_NORMAL
   3: 
   4: #define PI 3.1415926538
   5: 
   6: uniform float uTime;
   7: uniform mat4 uViewProjection;
   8: uniform vec3 uCameraPos;
   9: 
  10: #if defined(USE_FOG)
  11: varying float FragDistance;
  12: #endif
  13: 
  14: void FLWFinalizeWorldPos(inout vec4 worldPos) {
  15:     #if defined(USE_FOG)
  16:     FragDistance = length(worldPos.xyz - uCameraPos);
  17:     #endif
  18: 
  19:     gl_Position = uViewProjection * worldPos;
  20: }
  21: 
  22: void FLWFinalizeNormal(inout vec3 normal) {
  23:     // noop
  24: }
  25: 
  26: 
  27: #define PIOVER2 1.5707963268
  28: 
  29: vec4 quat(vec3 axis, float angle) {
  30:     float halfAngle = angle * PIOVER2 / 180.0;
  31:     vec2 cs = sin(vec2(PIOVER2 - halfAngle, halfAngle)); // compute sin and cos in one instruction
  32:     return vec4(axis.xyz * cs.y,  cs.x);
  33: }
  34: 
  35: vec4 quatMult(vec4 q1, vec4 q2) {
  36:     // disgustingly vectorized quaternion multiplication
  37:     vec4 a = q1.w * q2.xyzw;
  38:     vec4 b = q1.x * q2.wzxy * vec4(1., -1., 1., -1.);
  39:     vec4 c = q1.y * q2.zwxy * vec4(1., 1., -1., -1.);
  40:     vec4 d = q1.z * q2.yxwz * vec4(-1., 1., 1., -1.);
  41: 
  42:     return a + b + c + d;
  43: }
  44: 
  45: vec3 rotateVertexByQuat(vec3 v, vec4 q) {
  46:     vec3 i = q.xyz;
  47:     return v + 2.0 * cross(i, cross(i, v) + q.w * v);
  48: }
  49: 
  50: vec3 rotateAbout(vec3 v, vec3 axis, float angle) {
  51:     return rotateVertexByQuat(v, quat(axis, angle));
  52: }
  53: 
  54: mat4 rotate(vec3 axis, float angle) {
  55:     float s = sin(angle);
  56:     float c = cos(angle);
  57:     float oc = 1. - c;
  58: 
  59:     vec3 sa = axis * s;
  60: 
  61:     mat4 mr = mat4(1.);
  62:     mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
  63:     mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
  64:     mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);
  65: 
  66:     return mr;
  67: }
  68: 
  69: mat4 rotation(vec3 rot) {
  70:     return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
  71: }
  72: 
  73: mat3 modelToNormal(mat4 mat) {
  74:     // Discard the edges. This won't be accurate for scaled or skewed matrices,
  75:     // but we don't have to work with those often.
  76:     mat3 m;
  77:     m[0] = mat[0].xyz;
  78:     m[1] = mat[1].xyz;
  79:     m[2] = mat[2].xyz;
  80:     return m;
  81: }
  82: 
  83: float diffuse(vec3 normal) {
  84:     vec3 n2 = normal * normal * vec3(.6, .25, .8);
  85:     return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
  86: }
  87: 
  88: 
  89: struct Belt {
  90:     vec2 light;
  91:     vec4 color;
  92:     vec3 pos;
  93:     float speed;
  94:     float offset;
  95:     vec4 rotation;
  96:     vec2 sourceTexture;
  97:     vec4 scrollTexture;
  98:     float scrollMult;
  99: };
 100: 
 101: 
 102: struct Vertex {
 103:     vec3 pos;
 104:     vec3 normal;
 105:     vec2 texCoords;
 106: };
 107: 
 108: struct BlockFrag {
 109:     vec2 texCoords;
 110:     vec4 color;
 111:     float diffuse;
 112:     vec2 light;
 113: };
 114: 
 115: BlockFrag FLWMain(Vertex v, Belt instance) {
 116:     vec3 rotated = rotateVertexByQuat(v.pos - .5, instance.rotation) + instance.pos + .5;
 117: 
 118:     vec4 worldPos = vec4(rotated, 1.);
 119: 
 120:     vec3 norm = rotateVertexByQuat(v.normal, instance.rotation);
 121: 
 122:     FLWFinalizeWorldPos(worldPos);
 123:     FLWFinalizeNormal(norm);
 124: 
 125:     float scrollSize = instance.scrollTexture.w - instance.scrollTexture.y;
 126:     float scroll = fract(instance.speed * uTime / (31.5 * 16.) + instance.offset) * scrollSize * instance.scrollMult;
 127: 
 128:     BlockFrag b;
 129:     b.diffuse = diffuse(norm);
 130:     b.texCoords = v.texCoords - instance.sourceTexture + instance.scrollTexture.xy + vec2(0, scroll);
 131:     b.light = instance.light;
 132: 
 133:     #if defined(DEBUG_RAINBOW)
 134:     b.color = instance.color;
 135:     #elif defined(DEBUG_NORMAL)
 136:     b.color = vec4(norm, 1.);
 137:     #else
 138:     b.color = vec4(1.);
 139:     #endif
 140: 
 141:     return b;
 142: }
 143: attribute vec3 a_v_pos;
 144: attribute vec3 a_v_normal;
 145: attribute vec2 a_v_texCoords;
 146: 
 147: attribute vec2 a_i_light;
 148: attribute vec4 a_i_color;
 149: attribute vec3 a_i_pos;
 150: attribute float a_i_speed;
 151: attribute float a_i_offset;
 152: attribute vec4 a_i_rotation;
 153: attribute vec2 a_i_sourceTexture;
 154: attribute vec4 a_i_scrollTexture;
 155: attribute float a_i_scrollMult;
 156: 
 157: 
 158: varying vec2 v2f_texCoords;
 159: varying vec4 v2f_color;
 160: varying float v2f_diffuse;
 161: varying vec2 v2f_light;
 162: 
 163: 
 164: void main() {
 165:     Vertex v;
 166:     v.pos = a_v_pos;
 167: v.normal = a_v_normal;
 168: v.texCoords = a_v_texCoords;
 169: 
 170: 
 171:     Belt i;
 172:     i.light = a_i_light;
 173: i.color = a_i_color;
 174: i.pos = a_i_pos;
 175: i.speed = a_i_speed;
 176: i.offset = a_i_offset;
 177: i.rotation = a_i_rotation;
 178: i.sourceTexture = a_i_sourceTexture;
 179: i.scrollTexture = a_i_scrollTexture;
 180: i.scrollMult = a_i_scrollMult;
 181: 
 182: 
 183:     BlockFrag o = FLWMain(v, i);
 184: 
 185:     v2f_texCoords = o.texCoords;
 186: v2f_color = o.color;
 187: v2f_diffuse = o.diffuse;
 188: v2f_light = o.light;
 189: 
 190: }

[13:33:19] [main/ERROR]: Shader compilation log for flywheel:block.frag: No errors.

[13:33:19] [main/ERROR]: Source for shader 'flywheel:block.frag':
   1: #version 110
   2: #define DEBUG_NORMAL
   3: 
   4: #if defined(USE_FOG)
   5: varying float FragDistance;
   6: uniform vec4 uFogColor;
   7: #endif
   8: 
   9: #if defined(USE_FOG_LINEAR)
  10: uniform vec2 uFogRange;
  11: 
  12: float FLWFogFactor() {
  13:     return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
  14: }
  15:     #endif
  16: 
  17:     #if defined(USE_FOG_EXP2)
  18: uniform float uFogDensity;
  19: 
  20: float FLWFogFactor() {
  21:     float dist = FragDistance * uFogDensity;
  22:     return 1. / exp2(dist * dist);
  23: }
  24:     #endif
  25: 
  26: uniform vec2 uTextureScale;
  27: uniform sampler2D uBlockAtlas;
  28: uniform sampler2D uLightMap;
  29: uniform sampler2D uCrumbling;
  30: 
  31: vec4 FLWBlockTexture(vec2 texCoords) {
  32:     vec4 cr = texture2D(uCrumbling, texCoords * uTextureScale);
  33:     float diffuseAlpha = texture2D(uBlockAtlas, texCoords).a;
  34:     cr.a = cr.a * diffuseAlpha;
  35:     return cr;
  36: }
  37: 
  38: void FLWFinalizeColor(vec4 color) {
  39:     #if defined(USE_FOG)
  40:     float a = color.a;
  41:     float fog = clamp(FLWFogFactor(), 0., 1.);
  42: 
  43:     color = mix(uFogColor, color, fog);
  44:     color.a = a;
  45:     #endif
  46: 
  47:     gl_FragColor = color;
  48: }
  49: 
  50: vec4 FLWLight(vec2 lightCoords) {
  51:     return vec4(1.);
  52: }
  53: 
  54: 
  55: 
  56: struct BlockFrag {
  57:     vec2 texCoords;
  58:     vec4 color;
  59:     float diffuse;
  60:     vec2 light;
  61: };
  62: 
  63: void FLWMain(BlockFrag r) {
  64:     vec4 tex = FLWBlockTexture(r.texCoords);
  65: 
  66:     vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;
  67: 
  68: //    flw_WorldPos = ;
  69: //    flw_Normal = ;
  70: //    flw_Albedo = tex.rgb;
  71: //    flw_Alpha = tex.a;
  72: //    flw_LightMap = r.light;
  73: //    flw_Tint = r.color;
  74:     FLWFinalizeColor(color);
  75: }
  76: 
  77: varying vec2 v2f_texCoords;
  78: varying vec4 v2f_color;
  79: varying float v2f_diffuse;
  80: varying vec2 v2f_light;
  81: 
  82: 
  83: //vec3 flw_WorldPos;
  84: //vec3 flw_Normal;
  85: //vec3 flw_Albedo;
  86: //float flw_Alpha;
  87: //vec2 flw_LightMap;
  88: //vec4 flw_Tint;
  89: 
  90: void main() {
  91:     BlockFrag f;
  92:     f.texCoords = v2f_texCoords;
  93: f.color = v2f_color;
  94: f.diffuse = v2f_diffuse;
  95: f.light = v2f_light;
  96: 
  97: 
  98:     FLWMain(f);
  99: }

[13:33:19] [main/ERROR]: Shader compilation log for create:belt.vert: No errors.

[13:33:19] [main/ERROR]: Source for shader 'create:belt.vert':
   1: #version 110
   2: #define USE_FOG
   3: #define USE_FOG_LINEAR
   4: 
   5: #define PI 3.1415926538
   6: 
   7: uniform float uTime;
   8: uniform mat4 uViewProjection;
   9: uniform vec3 uCameraPos;
  10: 
  11: #if defined(USE_FOG)
  12: varying float FragDistance;
  13: #endif
  14: 
  15: void FLWFinalizeWorldPos(inout vec4 worldPos) {
  16:     #if defined(USE_FOG)
  17:     FragDistance = length(worldPos.xyz - uCameraPos);
  18:     #endif
  19: 
  20:     gl_Position = uViewProjection * worldPos;
  21: }
  22: 
  23: void FLWFinalizeNormal(inout vec3 normal) {
  24:     // noop
  25: }
  26: 
  27: 
  28: #define PIOVER2 1.5707963268
  29: 
  30: vec4 quat(vec3 axis, float angle) {
  31:     float halfAngle = angle * PIOVER2 / 180.0;
  32:     vec2 cs = sin(vec2(PIOVER2 - halfAngle, halfAngle)); // compute sin and cos in one instruction
  33:     return vec4(axis.xyz * cs.y,  cs.x);
  34: }
  35: 
  36: vec4 quatMult(vec4 q1, vec4 q2) {
  37:     // disgustingly vectorized quaternion multiplication
  38:     vec4 a = q1.w * q2.xyzw;
  39:     vec4 b = q1.x * q2.wzxy * vec4(1., -1., 1., -1.);
  40:     vec4 c = q1.y * q2.zwxy * vec4(1., 1., -1., -1.);
  41:     vec4 d = q1.z * q2.yxwz * vec4(-1., 1., 1., -1.);
  42: 
  43:     return a + b + c + d;
  44: }
  45: 
  46: vec3 rotateVertexByQuat(vec3 v, vec4 q) {
  47:     vec3 i = q.xyz;
  48:     return v + 2.0 * cross(i, cross(i, v) + q.w * v);
  49: }
  50: 
  51: vec3 rotateAbout(vec3 v, vec3 axis, float angle) {
  52:     return rotateVertexByQuat(v, quat(axis, angle));
  53: }
  54: 
  55: mat4 rotate(vec3 axis, float angle) {
  56:     float s = sin(angle);
  57:     float c = cos(angle);
  58:     float oc = 1. - c;
  59: 
  60:     vec3 sa = axis * s;
  61: 
  62:     mat4 mr = mat4(1.);
  63:     mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
  64:     mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
  65:     mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);
  66: 
  67:     return mr;
  68: }
  69: 
  70: mat4 rotation(vec3 rot) {
  71:     return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
  72: }
  73: 
  74: mat3 modelToNormal(mat4 mat) {
  75:     // Discard the edges. This won't be accurate for scaled or skewed matrices,
  76:     // but we don't have to work with those often.
  77:     mat3 m;
  78:     m[0] = mat[0].xyz;
  79:     m[1] = mat[1].xyz;
  80:     m[2] = mat[2].xyz;
  81:     return m;
  82: }
  83: 
  84: float diffuse(vec3 normal) {
  85:     vec3 n2 = normal * normal * vec3(.6, .25, .8);
  86:     return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
  87: }
  88: 
  89: 
  90: struct Belt {
  91:     vec2 light;
  92:     vec4 color;
  93:     vec3 pos;
  94:     float speed;
  95:     float offset;
  96:     vec4 rotation;
  97:     vec2 sourceTexture;
  98:     vec4 scrollTexture;
  99:     float scrollMult;
 100: };
 101: 
 102: 
 103: struct Vertex {
 104:     vec3 pos;
 105:     vec3 normal;
 106:     vec2 texCoords;
 107: };
 108: 
 109: struct BlockFrag {
 110:     vec2 texCoords;
 111:     vec4 color;
 112:     float diffuse;
 113:     vec2 light;
 114: };
 115: 
 116: BlockFrag FLWMain(Vertex v, Belt instance) {
 117:     vec3 rotated = rotateVertexByQuat(v.pos - .5, instance.rotation) + instance.pos + .5;
 118: 
 119:     vec4 worldPos = vec4(rotated, 1.);
 120: 
 121:     vec3 norm = rotateVertexByQuat(v.normal, instance.rotation);
 122: 
 123:     FLWFinalizeWorldPos(worldPos);
 124:     FLWFinalizeNormal(norm);
 125: 
 126:     float scrollSize = instance.scrollTexture.w - instance.scrollTexture.y;
 127:     float scroll = fract(instance.speed * uTime / (31.5 * 16.) + instance.offset) * scrollSize * instance.scrollMult;
 128: 
 129:     BlockFrag b;
 130:     b.diffuse = diffuse(norm);
 131:     b.texCoords = v.texCoords - instance.sourceTexture + instance.scrollTexture.xy + vec2(0, scroll);
 132:     b.light = instance.light;
 133: 
 134:     #if defined(DEBUG_RAINBOW)
 135:     b.color = instance.color;
 136:     #elif defined(DEBUG_NORMAL)
 137:     b.color = vec4(norm, 1.);
 138:     #else
 139:     b.color = vec4(1.);
 140:     #endif
 141: 
 142:     return b;
 143: }
 144: attribute vec3 a_v_pos;
 145: attribute vec3 a_v_normal;
 146: attribute vec2 a_v_texCoords;
 147: 
 148: attribute vec2 a_i_light;
 149: attribute vec4 a_i_color;
 150: attribute vec3 a_i_pos;
 151: attribute float a_i_speed;
 152: attribute float a_i_offset;
 153: attribute vec4 a_i_rotation;
 154: attribute vec2 a_i_sourceTexture;
 155: attribute vec4 a_i_scrollTexture;
 156: attribute float a_i_scrollMult;
 157: 
 158: 
 159: varying vec2 v2f_texCoords;
 160: varying vec4 v2f_color;
 161: varying float v2f_diffuse;
 162: varying vec2 v2f_light;
 163: 
 164: 
 165: void main() {
 166:     Vertex v;
 167:     v.pos = a_v_pos;
 168: v.normal = a_v_normal;
 169: v.texCoords = a_v_texCoords;
 170: 
 171: 
 172:     Belt i;
 173:     i.light = a_i_light;
 174: i.color = a_i_color;
 175: i.pos = a_i_pos;
 176: i.speed = a_i_speed;
 177: i.offset = a_i_offset;
 178: i.rotation = a_i_rotation;
 179: i.sourceTexture = a_i_sourceTexture;
 180: i.scrollTexture = a_i_scrollTexture;
 181: i.scrollMult = a_i_scrollMult;
 182: 
 183: 
 184:     BlockFrag o = FLWMain(v, i);
 185: 
 186:     v2f_texCoords = o.texCoords;
 187: v2f_color = o.color;
 188: v2f_diffuse = o.diffuse;
 189: v2f_light = o.light;
 190: 
 191: }

[13:33:19] [main/ERROR]: Shader compilation log for flywheel:block.frag: No errors.

[13:33:19] [main/ERROR]: Source for shader 'flywheel:block.frag':
   1: #version 110
   2: #define USE_FOG
   3: #define USE_FOG_LINEAR
   4: 
   5: #if defined(USE_FOG)
   6: varying float FragDistance;
   7: uniform vec4 uFogColor;
   8: #endif
   9: 
  10: #if defined(USE_FOG_LINEAR)
  11: uniform vec2 uFogRange;
  12: 
  13: float FLWFogFactor() {
  14:     return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
  15: }
  16:     #endif
  17: 
  18:     #if defined(USE_FOG_EXP2)
  19: uniform float uFogDensity;
  20: 
  21: float FLWFogFactor() {
  22:     float dist = FragDistance * uFogDensity;
  23:     return 1. / exp2(dist * dist);
  24: }
  25:     #endif
  26: 
  27: uniform vec2 uTextureScale;
  28: uniform sampler2D uBlockAtlas;
  29: uniform sampler2D uLightMap;
  30: uniform sampler2D uCrumbling;
  31: 
  32: vec4 FLWBlockTexture(vec2 texCoords) {
  33:     vec4 cr = texture2D(uCrumbling, texCoords * uTextureScale);
  34:     float diffuseAlpha = texture2D(uBlockAtlas, texCoords).a;
  35:     cr.a = cr.a * diffuseAlpha;
  36:     return cr;
  37: }
  38: 
  39: void FLWFinalizeColor(vec4 color) {
  40:     #if defined(USE_FOG)
  41:     float a = color.a;
  42:     float fog = clamp(FLWFogFactor(), 0., 1.);
  43: 
  44:     color = mix(uFogColor, color, fog);
  45:     color.a = a;
  46:     #endif
  47: 
  48:     gl_FragColor = color;
  49: }
  50: 
  51: vec4 FLWLight(vec2 lightCoords) {
  52:     return vec4(1.);
  53: }
  54: 
  55: 
  56: 
  57: struct BlockFrag {
  58:     vec2 texCoords;
  59:     vec4 color;
  60:     float diffuse;
  61:     vec2 light;
  62: };
  63: 
  64: void FLWMain(BlockFrag r) {
  65:     vec4 tex = FLWBlockTexture(r.texCoords);
  66: 
  67:     vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;
  68: 
  69: //    flw_WorldPos = ;
  70: //    flw_Normal = ;
  71: //    flw_Albedo = tex.rgb;
  72: //    flw_Alpha = tex.a;
  73: //    flw_LightMap = r.light;
  74: //    flw_Tint = r.color;
  75:     FLWFinalizeColor(color);
  76: }
  77: 
  78: varying vec2 v2f_texCoords;
  79: varying vec4 v2f_color;
  80: varying float v2f_diffuse;
  81: varying vec2 v2f_light;
  82: 
  83: 
  84: //vec3 flw_WorldPos;
  85: //vec3 flw_Normal;
  86: //vec3 flw_Albedo;
  87: //float flw_Alpha;
  88: //vec2 flw_LightMap;
  89: //vec4 flw_Tint;
  90: 
  91: void main() {
  92:     BlockFrag f;
  93:     f.texCoords = v2f_texCoords;
  94: f.color = v2f_color;
  95: f.diffuse = v2f_diffuse;
  96: f.light = v2f_light;
  97: 
  98: 
  99:     FLWMain(f);
 100: }

[13:33:19] [main/ERROR]: Shader compilation log for create:belt.vert: No errors.

[13:33:19] [main/ERROR]: Source for shader 'create:belt.vert':
   1: #version 110
   2: #define USE_FOG
   3: #define USE_FOG_EXP2
   4: 
   5: #define PI 3.1415926538
   6: 
   7: uniform float uTime;
   8: uniform mat4 uViewProjection;
   9: uniform vec3 uCameraPos;
  10: 
  11: #if defined(USE_FOG)
  12: varying float FragDistance;
  13: #endif
  14: 
  15: void FLWFinalizeWorldPos(inout vec4 worldPos) {
  16:     #if defined(USE_FOG)
  17:     FragDistance = length(worldPos.xyz - uCameraPos);
  18:     #endif
  19: 
  20:     gl_Position = uViewProjection * worldPos;
  21: }
  22: 
  23: void FLWFinalizeNormal(inout vec3 normal) {
  24:     // noop
  25: }
  26: 
  27: 
  28: #define PIOVER2 1.5707963268
  29: 
  30: vec4 quat(vec3 axis, float angle) {
  31:     float halfAngle = angle * PIOVER2 / 180.0;
  32:     vec2 cs = sin(vec2(PIOVER2 - halfAngle, halfAngle)); // compute sin and cos in one instruction
  33:     return vec4(axis.xyz * cs.y,  cs.x);
  34: }
  35: 
  36: vec4 quatMult(vec4 q1, vec4 q2) {
  37:     // disgustingly vectorized quaternion multiplication
  38:     vec4 a = q1.w * q2.xyzw;
  39:     vec4 b = q1.x * q2.wzxy * vec4(1., -1., 1., -1.);
  40:     vec4 c = q1.y * q2.zwxy * vec4(1., 1., -1., -1.);
  41:     vec4 d = q1.z * q2.yxwz * vec4(-1., 1., 1., -1.);
  42: 
  43:     return a + b + c + d;
  44: }
  45: 
  46: vec3 rotateVertexByQuat(vec3 v, vec4 q) {
  47:     vec3 i = q.xyz;
  48:     return v + 2.0 * cross(i, cross(i, v) + q.w * v);
  49: }
  50: 
  51: vec3 rotateAbout(vec3 v, vec3 axis, float angle) {
  52:     return rotateVertexByQuat(v, quat(axis, angle));
  53: }
  54: 
  55: mat4 rotate(vec3 axis, float angle) {
  56:     float s = sin(angle);
  57:     float c = cos(angle);
  58:     float oc = 1. - c;
  59: 
  60:     vec3 sa = axis * s;
  61: 
  62:     mat4 mr = mat4(1.);
  63:     mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
  64:     mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
  65:     mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);
  66: 
  67:     return mr;
  68: }
  69: 
  70: mat4 rotation(vec3 rot) {
  71:     return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
  72: }
  73: 
  74: mat3 modelToNormal(mat4 mat) {
  75:     // Discard the edges. This won't be accurate for scaled or skewed matrices,
  76:     // but we don't have to work with those often.
  77:     mat3 m;
  78:     m[0] = mat[0].xyz;
  79:     m[1] = mat[1].xyz;
  80:     m[2] = mat[2].xyz;
  81:     return m;
  82: }
  83: 
  84: float diffuse(vec3 normal) {
  85:     vec3 n2 = normal * normal * vec3(.6, .25, .8);
  86:     return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
  87: }
  88: 
  89: 
  90: struct Belt {
  91:     vec2 light;
  92:     vec4 color;
  93:     vec3 pos;
  94:     float speed;
  95:     float offset;
  96:     vec4 rotation;
  97:     vec2 sourceTexture;
  98:     vec4 scrollTexture;
  99:     float scrollMult;
 100: };
 101: 
 102: 
 103: struct Vertex {
 104:     vec3 pos;
 105:     vec3 normal;
 106:     vec2 texCoords;
 107: };
 108: 
 109: struct BlockFrag {
 110:     vec2 texCoords;
 111:     vec4 color;
 112:     float diffuse;
 113:     vec2 light;
 114: };
 115: 
 116: BlockFrag FLWMain(Vertex v, Belt instance) {
 117:     vec3 rotated = rotateVertexByQuat(v.pos - .5, instance.rotation) + instance.pos + .5;
 118: 
 119:     vec4 worldPos = vec4(rotated, 1.);
 120: 
 121:     vec3 norm = rotateVertexByQuat(v.normal, instance.rotation);
 122: 
 123:     FLWFinalizeWorldPos(worldPos);
 124:     FLWFinalizeNormal(norm);
 125: 
 126:     float scrollSize = instance.scrollTexture.w - instance.scrollTexture.y;
 127:     float scroll = fract(instance.speed * uTime / (31.5 * 16.) + instance.offset) * scrollSize * instance.scrollMult;
 128: 
 129:     BlockFrag b;
 130:     b.diffuse = diffuse(norm);
 131:     b.texCoords = v.texCoords - instance.sourceTexture + instance.scrollTexture.xy + vec2(0, scroll);
 132:     b.light = instance.light;
 133: 
 134:     #if defined(DEBUG_RAINBOW)
 135:     b.color = instance.color;
 136:     #elif defined(DEBUG_NORMAL)
 137:     b.color = vec4(norm, 1.);
 138:     #else
 139:     b.color = vec4(1.);
 140:     #endif
 141: 
 142:     return b;
 143: }
 144: attribute vec3 a_v_pos;
 145: attribute vec3 a_v_normal;
 146: attribute vec2 a_v_texCoords;
 147: 
 148: attribute vec2 a_i_light;
 149: attribute vec4 a_i_color;
 150: attribute vec3 a_i_pos;
 151: attribute float a_i_speed;
 152: attribute float a_i_offset;
 153: attribute vec4 a_i_rotation;
 154: attribute vec2 a_i_sourceTexture;
 155: attribute vec4 a_i_scrollTexture;
 156: attribute float a_i_scrollMult;
 157: 
 158: 
 159: varying vec2 v2f_texCoords;
 160: varying vec4 v2f_color;
 161: varying float v2f_diffuse;
 162: varying vec2 v2f_light;
 163: 
 164: 
 165: void main() {
 166:     Vertex v;
 167:     v.pos = a_v_pos;
 168: v.normal = a_v_normal;
 169: v.texCoords = a_v_texCoords;
 170: 
 171: 
 172:     Belt i;
 173:     i.light = a_i_light;
 174: i.color = a_i_color;
 175: i.pos = a_i_pos;
 176: i.speed = a_i_speed;
 177: i.offset = a_i_offset;
 178: i.rotation = a_i_rotation;
 179: i.sourceTexture = a_i_sourceTexture;
 180: i.scrollTexture = a_i_scrollTexture;
 181: i.scrollMult = a_i_scrollMult;
 182: 
 183: 
 184:     BlockFrag o = FLWMain(v, i);
 185: 
 186:     v2f_texCoords = o.texCoords;
 187: v2f_color = o.color;
 188: v2f_diffuse = o.diffuse;
 189: v2f_light = o.light;
 190: 
 191: }

[13:33:19] [main/ERROR]: Shader compilation log for flywheel:block.frag: No errors.

[13:33:19] [main/ERROR]: Source for shader 'flywheel:block.frag':
   1: #version 110
   2: #define USE_FOG
   3: #define USE_FOG_EXP2
   4: 
   5: #if defined(USE_FOG)
   6: varying float FragDistance;
   7: uniform vec4 uFogColor;
   8: #endif
   9: 
  10: #if defined(USE_FOG_LINEAR)
  11: uniform vec2 uFogRange;
  12: 
  13: float FLWFogFactor() {
  14:     return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
  15: }
  16:     #endif
  17: 
  18:     #if defined(USE_FOG_EXP2)
  19: uniform float uFogDensity;
  20: 
  21: float FLWFogFactor() {
  22:     float dist = FragDistance * uFogDensity;
  23:     return 1. / exp2(dist * dist);
  24: }
  25:     #endif
  26: 
  27: uniform vec2 uTextureScale;
  28: uniform sampler2D uBlockAtlas;
  29: uniform sampler2D uLightMap;
  30: uniform sampler2D uCrumbling;
  31: 
  32: vec4 FLWBlockTexture(vec2 texCoords) {
  33:     vec4 cr = texture2D(uCrumbling, texCoords * uTextureScale);
  34:     float diffuseAlpha = texture2D(uBlockAtlas, texCoords).a;
  35:     cr.a = cr.a * diffuseAlpha;
  36:     return cr;
  37: }
  38: 
  39: void FLWFinalizeColor(vec4 color) {
  40:     #if defined(USE_FOG)
  41:     float a = color.a;
  42:     float fog = clamp(FLWFogFactor(), 0., 1.);
  43: 
  44:     color = mix(uFogColor, color, fog);
  45:     color.a = a;
  46:     #endif
  47: 
  48:     gl_FragColor = color;
  49: }
  50: 
  51: vec4 FLWLight(vec2 lightCoords) {
  52:     return vec4(1.);
  53: }
  54: 
  55: 
  56: 
  57: struct BlockFrag {
  58:     vec2 texCoords;
  59:     vec4 color;
  60:     float diffuse;
  61:     vec2 light;
  62: };
  63: 
  64: void FLWMain(BlockFrag r) {
  65:     vec4 tex = FLWBlockTexture(r.texCoords);
  66: 
  67:     vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;
  68: 
  69: //    flw_WorldPos = ;
  70: //    flw_Normal = ;
  71: //    flw_Albedo = tex.rgb;
  72: //    flw_Alpha = tex.a;
  73: //    flw_LightMap = r.light;
  74: //    flw_Tint = r.color;
  75:     FLWFinalizeColor(color);
  76: }
  77: 
  78: varying vec2 v2f_texCoords;
  79: varying vec4 v2f_color;
  80: varying float v2f_diffuse;
  81: varying vec2 v2f_light;
  82: 
  83: 
  84: //vec3 flw_WorldPos;
  85: //vec3 flw_Normal;
  86: //vec3 flw_Albedo;
  87: //float flw_Alpha;
  88: //vec2 flw_LightMap;
  89: //vec4 flw_Tint;
  90: 
  91: void main() {
  92:     BlockFrag f;
  93:     f.texCoords = v2f_texCoords;
  94: f.color = v2f_color;
  95: f.diffuse = v2f_diffuse;
  96: f.light = v2f_light;
  97: 
  98: 
  99:     FLWMain(f);
 100: }

[13:33:19] [main/ERROR]: Shader compilation log for create:belt.vert: No errors.

[13:33:19] [main/ERROR]: Source for shader 'create:belt.vert':
   1: #version 110
   2: 
   3: #define PI 3.1415926538
   4: 
   5: uniform float uTime;
   6: uniform mat4 uViewProjection;
   7: uniform vec3 uCameraPos;
   8: 
   9: #if defined(USE_FOG)
  10: varying float FragDistance;
  11: #endif
  12: 
  13: void FLWFinalizeWorldPos(inout vec4 worldPos) {
  14:     #if defined(USE_FOG)
  15:     FragDistance = length(worldPos.xyz - uCameraPos);
  16:     #endif
  17: 
  18:     gl_Position = uViewProjection * worldPos;
  19: }
  20: 
  21: void FLWFinalizeNormal(inout vec3 normal) {
  22:     // noop
  23: }
  24: 
  25: 
  26: #define PIOVER2 1.5707963268
  27: 
  28: vec4 quat(vec3 axis, float angle) {
  29:     float halfAngle = angle * PIOVER2 / 180.0;
  30:     vec2 cs = sin(vec2(PIOVER2 - halfAngle, halfAngle)); // compute sin and cos in one instruction
  31:     return vec4(axis.xyz * cs.y,  cs.x);
  32: }
  33: 
  34: vec4 quatMult(vec4 q1, vec4 q2) {
  35:     // disgustingly vectorized quaternion multiplication
  36:     vec4 a = q1.w * q2.xyzw;
  37:     vec4 b = q1.x * q2.wzxy * vec4(1., -1., 1., -1.);
  38:     vec4 c = q1.y * q2.zwxy * vec4(1., 1., -1., -1.);
  39:     vec4 d = q1.z * q2.yxwz * vec4(-1., 1., 1., -1.);
  40: 
  41:     return a + b + c + d;
  42: }
  43: 
  44: vec3 rotateVertexByQuat(vec3 v, vec4 q) {
  45:     vec3 i = q.xyz;
  46:     return v + 2.0 * cross(i, cross(i, v) + q.w * v);
  47: }
  48: 
  49: vec3 rotateAbout(vec3 v, vec3 axis, float angle) {
  50:     return rotateVertexByQuat(v, quat(axis, angle));
  51: }
  52: 
  53: mat4 rotate(vec3 axis, float angle) {
  54:     float s = sin(angle);
  55:     float c = cos(angle);
  56:     float oc = 1. - c;
  57: 
  58:     vec3 sa = axis * s;
  59: 
  60:     mat4 mr = mat4(1.);
  61:     mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
  62:     mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
  63:     mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);
  64: 
  65:     return mr;
  66: }
  67: 
  68: mat4 rotation(vec3 rot) {
  69:     return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
  70: }
  71: 
  72: mat3 modelToNormal(mat4 mat) {
  73:     // Discard the edges. This won't be accurate for scaled or skewed matrices,
  74:     // but we don't have to work with those often.
  75:     mat3 m;
  76:     m[0] = mat[0].xyz;
  77:     m[1] = mat[1].xyz;
  78:     m[2] = mat[2].xyz;
  79:     return m;
  80: }
  81: 
  82: float diffuse(vec3 normal) {
  83:     vec3 n2 = normal * normal * vec3(.6, .25, .8);
  84:     return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
  85: }
  86: 
  87: 
  88: struct Belt {
  89:     vec2 light;
  90:     vec4 color;
  91:     vec3 pos;
  92:     float speed;
  93:     float offset;
  94:     vec4 rotation;
  95:     vec2 sourceTexture;
  96:     vec4 scrollTexture;
  97:     float scrollMult;
  98: };
  99: 
 100: 
 101: struct Vertex {
 102:     vec3 pos;
 103:     vec3 normal;
 104:     vec2 texCoords;
 105: };
 106: 
 107: struct BlockFrag {
 108:     vec2 texCoords;
 109:     vec4 color;
 110:     float diffuse;
 111:     vec2 light;
 112: };
 113: 
 114: BlockFrag FLWMain(Vertex v, Belt instance) {
 115:     vec3 rotated = rotateVertexByQuat(v.pos - .5, instance.rotation) + instance.pos + .5;
 116: 
 117:     vec4 worldPos = vec4(rotated, 1.);
 118: 
 119:     vec3 norm = rotateVertexByQuat(v.normal, instance.rotation);
 120: 
 121:     FLWFinalizeWorldPos(worldPos);
 122:     FLWFinalizeNormal(norm);
 123: 
 124:     float scrollSize = instance.scrollTexture.w - instance.scrollTexture.y;
 125:     float scroll = fract(instance.speed * uTime / (31.5 * 16.) + instance.offset) * scrollSize * instance.scrollMult;
 126: 
 127:     BlockFrag b;
 128:     b.diffuse = diffuse(norm);
 129:     b.texCoords = v.texCoords - instance.sourceTexture + instance.scrollTexture.xy + vec2(0, scroll);
 130:     b.light = instance.light;
 131: 
 132:     #if defined(DEBUG_RAINBOW)
 133:     b.color = instance.color;
 134:     #elif defined(DEBUG_NORMAL)
 135:     b.color = vec4(norm, 1.);
 136:     #else
 137:     b.color = vec4(1.);
 138:     #endif
 139: 
 140:     return b;
 141: }
 142: attribute vec3 a_v_pos;
 143: attribute vec3 a_v_normal;
 144: attribute vec2 a_v_texCoords;
 145: 
 146: attribute vec2 a_i_light;
 147: attribute vec4 a_i_color;
 148: attribute vec3 a_i_pos;
 149: attribute float a_i_speed;
 150: attribute float a_i_offset;
 151: attribute vec4 a_i_rotation;
 152: attribute vec2 a_i_sourceTexture;
 153: attribute vec4 a_i_scrollTexture;
 154: attribute float a_i_scrollMult;
 155: 
 156: 
 157: varying vec2 v2f_texCoords;
 158: varying vec4 v2f_color;
 159: varying float v2f_diffuse;
 160: varying vec2 v2f_light;
 161: 
 162: 
 163: void main() {
 164:     Vertex v;
 165:     v.pos = a_v_pos;
 166: v.normal = a_v_normal;
 167: v.texCoords = a_v_texCoords;
 168: 
 169: 
 170:     Belt i;
 171:     i.light = a_i_light;
 172: i.color = a_i_color;
 173: i.pos = a_i_pos;
 174: i.speed = a_i_speed;
 175: i.offset = a_i_offset;
 176: i.rotation = a_i_rotation;
 177: i.sourceTexture = a_i_sourceTexture;
 178: i.scrollTexture = a_i_scrollTexture;
 179: i.scrollMult = a_i_scrollMult;
 180: 
 181: 
 182:     BlockFrag o = FLWMain(v, i);
 183: 
 184:     v2f_texCoords = o.texCoords;
 185: v2f_color = o.color;
 186: v2f_diffuse = o.diffuse;
 187: v2f_light = o.light;
 188: 
 189: }

[13:33:19] [main/ERROR]: Shader compilation log for flywheel:block.frag: No errors.

[13:33:19] [main/ERROR]: Source for shader 'flywheel:block.frag':
   1: #version 110
   2: 
   3: #if defined(USE_FOG)
   4: varying float FragDistance;
   5: uniform vec4 uFogColor;
   6: #endif
   7: 
   8: #if defined(USE_FOG_LINEAR)
   9: uniform vec2 uFogRange;
  10: 
  11: float FLWFogFactor() {
  12:     return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
  13: }
  14:     #endif
  15: 
  16:     #if defined(USE_FOG_EXP2)
  17: uniform float uFogDensity;
  18: 
  19: float FLWFogFactor() {
  20:     float dist = FragDistance * uFogDensity;
  21:     return 1. / exp2(dist * dist);
  22: }
  23:     #endif
  24: 
  25: uniform vec2 uTextureScale;
  26: uniform sampler2D uBlockAtlas;
  27: uniform sampler2D uLightMap;
  28: uniform sampler2D uCrumbling;
  29: 
  30: vec4 FLWBlockTexture(vec2 texCoords) {
  31:     vec4 cr = texture2D(uCrumbling, texCoords * uTextureScale);
  32:     float diffuseAlpha = texture2D(uBlockAtlas, texCoords).a;
  33:     cr.a = cr.a * diffuseAlpha;
  34:     return cr;
  35: }
  36: 
  37: void FLWFinalizeColor(vec4 color) {
  38:     #if defined(USE_FOG)
  39:     float a = color.a;
  40:     float fog = clamp(FLWFogFactor(), 0., 1.);
  41: 
  42:     color = mix(uFogColor, color, fog);
  43:     color.a = a;
  44:     #endif
  45: 
  46:     gl_FragColor = color;
  47: }
  48: 
  49: vec4 FLWLight(vec2 lightCoords) {
  50:     return vec4(1.);
  51: }
  52: 
  53: 
  54: 
  55: struct BlockFrag {
  56:     vec2 texCoords;
  57:     vec4 color;
  58:     float diffuse;
  59:     vec2 light;
  60: };
  61: 
  62: void FLWMain(BlockFrag r) {
  63:     vec4 tex = FLWBlockTexture(r.texCoords);
  64: 
  65:     vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;
  66: 
  67: //    flw_WorldPos = ;
  68: //    flw_Normal = ;
  69: //    flw_Albedo = tex.rgb;
  70: //    flw_Alpha = tex.a;
  71: //    flw_LightMap = r.light;
  72: //    flw_Tint = r.color;
  73:     FLWFinalizeColor(color);
  74: }
  75: 
  76: varying vec2 v2f_texCoords;
  77: varying vec4 v2f_color;
  78: varying float v2f_diffuse;
  79: varying vec2 v2f_light;
  80: 
  81: 
  82: //vec3 flw_WorldPos;
  83: //vec3 flw_Normal;
  84: //vec3 flw_Albedo;
  85: //float flw_Alpha;
  86: //vec2 flw_LightMap;
  87: //vec4 flw_Tint;
  88: 
  89: void main() {
  90:     BlockFrag f;
  91:     f.texCoords = v2f_texCoords;
  92: f.color = v2f_color;
  93: f.diffuse = v2f_diffuse;
  94: f.light = v2f_light;
  95: 
  96: 
  97:     FLWMain(f);
  98: }

[13:33:19] [main/ERROR]: Shader compilation log for flywheel:oriented.vert: No errors.

[13:33:19] [main/ERROR]: Source for shader 'flywheel:oriented.vert':
   1: #version 110
   2: #define DEBUG_NORMAL
   3: 
   4: uniform float uTime;
   5: uniform mat4 uViewProjection;
   6: uniform vec3 uCameraPos;
   7: 
   8: #if defined(USE_FOG)
   9: varying float FragDistance;
  10: #endif
  11: 
  12: void FLWFinalizeWorldPos(inout vec4 worldPos) {
  13:     #if defined(USE_FOG)
  14:     FragDistance = length(worldPos.xyz - uCameraPos);
  15:     #endif
  16: 
  17:     gl_Position = uViewProjection * worldPos;
  18: }
  19: 
  20: void FLWFinalizeNormal(inout vec3 normal) {
  21:     // noop
  22: }
  23: 
  24: 
  25: mat4 rotate(vec3 axis, float angle) {
  26:     float s = sin(angle);
  27:     float c = cos(angle);
  28:     float oc = 1. - c;
  29: 
  30:     vec3 sa = axis * s;
  31: 
  32:     mat4 mr = mat4(1.);
  33:     mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
  34:     mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
  35:     mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);
  36: 
  37:     return mr;
  38: }
  39: 
  40: mat4 rotation(vec3 rot) {
  41:     return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
  42: }
  43: 
  44: mat3 modelToNormal(mat4 mat) {
  45:     // Discard the edges. This won't be accurate for scaled or skewed matrices,
  46:     // but we don't have to work with those often.
  47:     mat3 m;
  48:     m[0] = mat[0].xyz;
  49:     m[1] = mat[1].xyz;
  50:     m[2] = mat[2].xyz;
  51:     return m;
  52: }
  53: 
  54: #define PIOVER2 1.5707963268
  55: 
  56: vec4 quat(vec3 axis, float angle) {
  57:     float halfAngle = angle * PIOVER2 / 180.0;
  58:     vec2 cs = sin(vec2(PIOVER2 - halfAngle, halfAngle)); // compute sin and cos in one instruction
  59:     return vec4(axis.xyz * cs.y,  cs.x);
  60: }
  61: 
  62: vec4 quatMult(vec4 q1, vec4 q2) {
  63:     // disgustingly vectorized quaternion multiplication
  64:     vec4 a = q1.w * q2.xyzw;
  65:     vec4 b = q1.x * q2.wzxy * vec4(1., -1., 1., -1.);
  66:     vec4 c = q1.y * q2.zwxy * vec4(1., 1., -1., -1.);
  67:     vec4 d = q1.z * q2.yxwz * vec4(-1., 1., 1., -1.);
  68: 
  69:     return a + b + c + d;
  70: }
  71: 
  72: vec3 rotateVertexByQuat(vec3 v, vec4 q) {
  73:     vec3 i = q.xyz;
  74:     return v + 2.0 * cross(i, cross(i, v) + q.w * v);
  75: }
  76: 
  77: vec3 rotateAbout(vec3 v, vec3 axis, float angle) {
  78:     return rotateVertexByQuat(v, quat(axis, angle));
  79: }
  80: 
  81: float diffuse(vec3 normal) {
  82:     vec3 n2 = normal * normal * vec3(.6, .25, .8);
  83:     return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
  84: }
  85: 
  86: 
  87: struct Oriented {
  88:     vec2 light;
  89:     vec4 color;
  90:     vec3 pos;
  91:     vec3 pivot;
  92:     vec4 rotation;
  93: };
  94: 
  95: 
  96: struct Vertex {
  97:     vec3 pos;
  98:     vec3 normal;
  99:     vec2 texCoords;
 100: };
 101: 
 102: struct BlockFrag {
 103:     vec2 texCoords;
 104:     vec4 color;
 105:     float diffuse;
 106:     vec2 light;
 107: };
 108: 
 109: BlockFrag FLWMain(Vertex v, Oriented o) {
 110:     vec4 worldPos = vec4(rotateVertexByQuat(v.pos - o.pivot, o.rotation) + o.pivot + o.pos, 1.);
 111: 
 112:     vec3 norm = rotateVertexByQuat(v.normal, o.rotation);
 113: 
 114:     FLWFinalizeWorldPos(worldPos);
 115:     FLWFinalizeNormal(norm);
 116: 
 117:     BlockFrag b;
 118:     b.diffuse = diffuse(norm);
 119:     b.texCoords = v.texCoords;
 120:     b.light = o.light;
 121:     #if defined(DEBUG_NORMAL)
 122:     b.color = vec4(norm, 1.);
 123:     #else
 124:     b.color = o.color;
 125:     #endif
 126:     return b;
 127: }
 128: attribute vec3 a_v_pos;
 129: attribute vec3 a_v_normal;
 130: attribute vec2 a_v_texCoords;
 131: 
 132: attribute vec2 a_i_light;
 133: attribute vec4 a_i_color;
 134: attribute vec3 a_i_pos;
 135: attribute vec3 a_i_pivot;
 136: attribute vec4 a_i_rotation;
 137: 
 138: 
 139: varying vec2 v2f_texCoords;
 140: varying vec4 v2f_color;
 141: varying float v2f_diffuse;
 142: varying vec2 v2f_light;
 143: 
 144: 
 145: void main() {
 146:     Vertex v;
 147:     v.pos = a_v_pos;
 148: v.normal = a_v_normal;
 149: v.texCoords = a_v_texCoords;
 150: 
 151: 
 152:     Oriented i;
 153:     i.light = a_i_light;
 154: i.color = a_i_color;
 155: i.pos = a_i_pos;
 156: i.pivot = a_i_pivot;
 157: i.rotation = a_i_rotation;
 158: 
 159: 
 160:     BlockFrag o = FLWMain(v, i);
 161: 
 162:     v2f_texCoords = o.texCoords;
 163: v2f_color = o.color;
 164: v2f_diffuse = o.diffuse;
 165: v2f_light = o.light;
 166: 
 167: }

[13:33:19] [main/ERROR]: Shader compilation log for flywheel:block.frag: No errors.

[13:33:19] [main/ERROR]: Source for shader 'flywheel:block.frag':
   1: #version 110
   2: #define DEBUG_NORMAL
   3: 
   4: #if defined(USE_FOG)
   5: varying float FragDistance;
   6: uniform vec4 uFogColor;
   7: #endif
   8: 
   9: #if defined(USE_FOG_LINEAR)
  10: uniform vec2 uFogRange;
  11: 
  12: float FLWFogFactor() {
  13:     return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
  14: }
  15:     #endif
  16: 
  17:     #if defined(USE_FOG_EXP2)
  18: uniform float uFogDensity;
  19: 
  20: float FLWFogFactor() {
  21:     float dist = FragDistance * uFogDensity;
  22:     return 1. / exp2(dist * dist);
  23: }
  24:     #endif
  25: 
  26: uniform vec2 uTextureScale;
  27: uniform sampler2D uBlockAtlas;
  28: uniform sampler2D uLightMap;
  29: uniform sampler2D uCrumbling;
  30: 
  31: vec4 FLWBlockTexture(vec2 texCoords) {
  32:     vec4 cr = texture2D(uCrumbling, texCoords * uTextureScale);
  33:     float diffuseAlpha = texture2D(uBlockAtlas, texCoords).a;
  34:     cr.a = cr.a * diffuseAlpha;
  35:     return cr;
  36: }
  37: 
  38: void FLWFinalizeColor(vec4 color) {
  39:     #if defined(USE_FOG)
  40:     float a = color.a;
  41:     float fog = clamp(FLWFogFactor(), 0., 1.);
  42: 
  43:     color = mix(uFogColor, color, fog);
  44:     color.a = a;
  45:     #endif
  46: 
  47:     gl_FragColor = color;
  48: }
  49: 
  50: vec4 FLWLight(vec2 lightCoords) {
  51:     return vec4(1.);
  52: }
  53: 
  54: 
  55: 
  56: struct BlockFrag {
  57:     vec2 texCoords;
  58:     vec4 color;
  59:     float diffuse;
  60:     vec2 light;
  61: };
  62: 
  63: void FLWMain(BlockFrag r) {
  64:     vec4 tex = FLWBlockTexture(r.texCoords);
  65: 
  66:     vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;
  67: 
  68: //    flw_WorldPos = ;
  69: //    flw_Normal = ;
  70: //    flw_Albedo = tex.rgb;
  71: //    flw_Alpha = tex.a;
  72: //    flw_LightMap = r.light;
  73: //    flw_Tint = r.color;
  74:     FLWFinalizeColor(color);
  75: }
  76: 
  77: varying vec2 v2f_texCoords;
  78: varying vec4 v2f_color;
  79: varying float v2f_diffuse;
  80: varying vec2 v2f_light;
  81: 
  82: 
  83: //vec3 flw_WorldPos;
  84: //vec3 flw_Normal;
  85: //vec3 flw_Albedo;
  86: //float flw_Alpha;
  87: //vec2 flw_LightMap;
  88: //vec4 flw_Tint;
  89: 
  90: void main() {
  91:     BlockFrag f;
  92:     f.texCoords = v2f_texCoords;
  93: f.color = v2f_color;
  94: f.diffuse = v2f_diffuse;
  95: f.light = v2f_light;
  96: 
  97: 
  98:     FLWMain(f);
  99: }

[13:33:19] [main/ERROR]: Shader compilation log for flywheel:oriented.vert: No errors.

[13:33:19] [main/ERROR]: Source for shader 'flywheel:oriented.vert':
   1: #version 110
   2: #define USE_FOG
   3: #define USE_FOG_LINEAR
   4: 
   5: uniform float uTime;
   6: uniform mat4 uViewProjection;
   7: uniform vec3 uCameraPos;
   8: 
   9: #if defined(USE_FOG)
  10: varying float FragDistance;
  11: #endif
  12: 
  13: void FLWFinalizeWorldPos(inout vec4 worldPos) {
  14:     #if defined(USE_FOG)
  15:     FragDistance = length(worldPos.xyz - uCameraPos);
  16:     #endif
  17: 
  18:     gl_Position = uViewProjection * worldPos;
  19: }
  20: 
  21: void FLWFinalizeNormal(inout vec3 normal) {
  22:     // noop
  23: }
  24: 
  25: 
  26: mat4 rotate(vec3 axis, float angle) {
  27:     float s = sin(angle);
  28:     float c = cos(angle);
  29:     float oc = 1. - c;
  30: 
  31:     vec3 sa = axis * s;
  32: 
  33:     mat4 mr = mat4(1.);
  34:     mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
  35:     mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
  36:     mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);
  37: 
  38:     return mr;
  39: }
  40: 
  41: mat4 rotation(vec3 rot) {
  42:     return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
  43: }
  44: 
  45: mat3 modelToNormal(mat4 mat) {
  46:     // Discard the edges. This won't be accurate for scaled or skewed matrices,
  47:     // but we don't have to work with those often.
  48:     mat3 m;
  49:     m[0] = mat[0].xyz;
  50:     m[1] = mat[1].xyz;
  51:     m[2] = mat[2].xyz;
  52:     return m;
  53: }
  54: 
  55: #define PIOVER2 1.5707963268
  56: 
  57: vec4 quat(vec3 axis, float angle) {
  58:     float halfAngle = angle * PIOVER2 / 180.0;
  59:     vec2 cs = sin(vec2(PIOVER2 - halfAngle, halfAngle)); // compute sin and cos in one instruction
  60:     return vec4(axis.xyz * cs.y,  cs.x);
  61: }
  62: 
  63: vec4 quatMult(vec4 q1, vec4 q2) {
  64:     // disgustingly vectorized quaternion multiplication
  65:     vec4 a = q1.w * q2.xyzw;
  66:     vec4 b = q1.x * q2.wzxy * vec4(1., -1., 1., -1.);
  67:     vec4 c = q1.y * q2.zwxy * vec4(1., 1., -1., -1.);
  68:     vec4 d = q1.z * q2.yxwz * vec4(-1., 1., 1., -1.);
  69: 
  70:     return a + b + c + d;
  71: }
  72: 
  73: vec3 rotateVertexByQuat(vec3 v, vec4 q) {
  74:     vec3 i = q.xyz;
  75:     return v + 2.0 * cross(i, cross(i, v) + q.w * v);
  76: }
  77: 
  78: vec3 rotateAbout(vec3 v, vec3 axis, float angle) {
  79:     return rotateVertexByQuat(v, quat(axis, angle));
  80: }
  81: 
  82: float diffuse(vec3 normal) {
  83:     vec3 n2 = normal * normal * vec3(.6, .25, .8);
  84:     return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
  85: }
  86: 
  87: 
  88: struct Oriented {
  89:     vec2 light;
  90:     vec4 color;
  91:     vec3 pos;
  92:     vec3 pivot;
  93:     vec4 rotation;
  94: };
  95: 
  96: 
  97: struct Vertex {
  98:     vec3 pos;
  99:     vec3 normal;
 100:     vec2 texCoords;
 101: };
 102: 
 103: struct BlockFrag {
 104:     vec2 texCoords;
 105:     vec4 color;
 106:     float diffuse;
 107:     vec2 light;
 108: };
 109: 
 110: BlockFrag FLWMain(Vertex v, Oriented o) {
 111:     vec4 worldPos = vec4(rotateVertexByQuat(v.pos - o.pivot, o.rotation) + o.pivot + o.pos, 1.);
 112: 
 113:     vec3 norm = rotateVertexByQuat(v.normal, o.rotation);
 114: 
 115:     FLWFinalizeWorldPos(worldPos);
 116:     FLWFinalizeNormal(norm);
 117: 
 118:     BlockFrag b;
 119:     b.diffuse = diffuse(norm);
 120:     b.texCoords = v.texCoords;
 121:     b.light = o.light;
 122:     #if defined(DEBUG_NORMAL)
 123:     b.color = vec4(norm, 1.);
 124:     #else
 125:     b.color = o.color;
 126:     #endif
 127:     return b;
 128: }
 129: attribute vec3 a_v_pos;
 130: attribute vec3 a_v_normal;
 131: attribute vec2 a_v_texCoords;
 132: 
 133: attribute vec2 a_i_light;
 134: attribute vec4 a_i_color;
 135: attribute vec3 a_i_pos;
 136: attribute vec3 a_i_pivot;
 137: attribute vec4 a_i_rotation;
 138: 
 139: 
 140: varying vec2 v2f_texCoords;
 141: varying vec4 v2f_color;
 142: varying float v2f_diffuse;
 143: varying vec2 v2f_light;
 144: 
 145: 
 146: void main() {
 147:     Vertex v;
 148:     v.pos = a_v_pos;
 149: v.normal = a_v_normal;
 150: v.texCoords = a_v_texCoords;
 151: 
 152: 
 153:     Oriented i;
 154:     i.light = a_i_light;
 155: i.color = a_i_color;
 156: i.pos = a_i_pos;
 157: i.pivot = a_i_pivot;
 158: i.rotation = a_i_rotation;
 159: 
 160: 
 161:     BlockFrag o = FLWMain(v, i);
 162: 
 163:     v2f_texCoords = o.texCoords;
 164: v2f_color = o.color;
 165: v2f_diffuse = o.diffuse;
 166: v2f_light = o.light;
 167: 
 168: }

[13:33:19] [main/ERROR]: Shader compilation log for flywheel:block.frag: No errors.

[13:33:19] [main/ERROR]: Source for shader 'flywheel:block.frag':
   1: #version 110
   2: #define USE_FOG
   3: #define USE_FOG_LINEAR
   4: 
   5: #if defined(USE_FOG)
   6: varying float FragDistance;
   7: uniform vec4 uFogColor;
   8: #endif
   9: 
  10: #if defined(USE_FOG_LINEAR)
  11: uniform vec2 uFogRange;
  12: 
  13: float FLWFogFactor() {
  14:     return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
  15: }
  16:     #endif
  17: 
  18:     #if defined(USE_FOG_EXP2)
  19: uniform float uFogDensity;
  20: 
  21: float FLWFogFactor() {
  22:     float dist = FragDistance * uFogDensity;
  23:     return 1. / exp2(dist * dist);
  24: }
  25:     #endif
  26: 
  27: uniform vec2 uTextureScale;
  28: uniform sampler2D uBlockAtlas;
  29: uniform sampler2D uLightMap;
  30: uniform sampler2D uCrumbling;
  31: 
  32: vec4 FLWBlockTexture(vec2 texCoords) {
  33:     vec4 cr = texture2D(uCrumbling, texCoords * uTextureScale);
  34:     float diffuseAlpha = texture2D(uBlockAtlas, texCoords).a;
  35:     cr.a = cr.a * diffuseAlpha;
  36:     return cr;
  37: }
  38: 
  39: void FLWFinalizeColor(vec4 color) {
  40:     #if defined(USE_FOG)
  41:     float a = color.a;
  42:     float fog = clamp(FLWFogFactor(), 0., 1.);
  43: 
  44:     color = mix(uFogColor, color, fog);
  45:     color.a = a;
  46:     #endif
  47: 
  48:     gl_FragColor = color;
  49: }
  50: 
  51: vec4 FLWLight(vec2 lightCoords) {
  52:     return vec4(1.);
  53: }
  54: 
  55: 
  56: 
  57: struct BlockFrag {
  58:     vec2 texCoords;
  59:     vec4 color;
  60:     float diffuse;
  61:     vec2 light;
  62: };
  63: 
  64: void FLWMain(BlockFrag r) {
  65:     vec4 tex = FLWBlockTexture(r.texCoords);
  66: 
  67:     vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;
  68: 
  69: //    flw_WorldPos = ;
  70: //    flw_Normal = ;
  71: //    flw_Albedo = tex.rgb;
  72: //    flw_Alpha = tex.a;
  73: //    flw_LightMap = r.light;
  74: //    flw_Tint = r.color;
  75:     FLWFinalizeColor(color);
  76: }
  77: 
  78: varying vec2 v2f_texCoords;
  79: varying vec4 v2f_color;
  80: varying float v2f_diffuse;
  81: varying vec2 v2f_light;
  82: 
  83: 
  84: //vec3 flw_WorldPos;
  85: //vec3 flw_Normal;
  86: //vec3 flw_Albedo;
  87: //float flw_Alpha;
  88: //vec2 flw_LightMap;
  89: //vec4 flw_Tint;
  90: 
  91: void main() {
  92:     BlockFrag f;
  93:     f.texCoords = v2f_texCoords;
  94: f.color = v2f_color;
  95: f.diffuse = v2f_diffuse;
  96: f.light = v2f_light;
  97: 
  98: 
  99:     FLWMain(f);
 100: }

[13:33:19] [main/ERROR]: Shader compilation log for flywheel:oriented.vert: No errors.

[13:33:19] [main/ERROR]: Source for shader 'flywheel:oriented.vert':
   1: #version 110
   2: #define USE_FOG
   3: #define USE_FOG_EXP2
   4: 
   5: uniform float uTime;
   6: uniform mat4 uViewProjection;
   7: uniform vec3 uCameraPos;
   8: 
   9: #if defined(USE_FOG)
  10: varying float FragDistance;
  11: #endif
  12: 
  13: void FLWFinalizeWorldPos(inout vec4 worldPos) {
  14:     #if defined(USE_FOG)
  15:     FragDistance = length(worldPos.xyz - uCameraPos);
  16:     #endif
  17: 
  18:     gl_Position = uViewProjection * worldPos;
  19: }
  20: 
  21: void FLWFinalizeNormal(inout vec3 normal) {
  22:     // noop
  23: }
  24: 
  25: 
  26: mat4 rotate(vec3 axis, float angle) {
  27:     float s = sin(angle);
  28:     float c = cos(angle);
  29:     float oc = 1. - c;
  30: 
  31:     vec3 sa = axis * s;
  32: 
  33:     mat4 mr = mat4(1.);
  34:     mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
  35:     mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
  36:     mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);
  37: 
  38:     return mr;
  39: }
  40: 
  41: mat4 rotation(vec3 rot) {
  42:     return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
  43: }
  44: 
  45: mat3 modelToNormal(mat4 mat) {
  46:     // Discard the edges. This won't be accurate for scaled or skewed matrices,
  47:     // but we don't have to work with those often.
  48:     mat3 m;
  49:     m[0] = mat[0].xyz;
  50:     m[1] = mat[1].xyz;
  51:     m[2] = mat[2].xyz;
  52:     return m;
  53: }
  54: 
  55: #define PIOVER2 1.5707963268
  56: 
  57: vec4 quat(vec3 axis, float angle) {
  58:     float halfAngle = angle * PIOVER2 / 180.0;
  59:     vec2 cs = sin(vec2(PIOVER2 - halfAngle, halfAngle)); // compute sin and cos in one instruction
  60:     return vec4(axis.xyz * cs.y,  cs.x);
  61: }
  62: 
  63: vec4 quatMult(vec4 q1, vec4 q2) {
  64:     // disgustingly vectorized quaternion multiplication
  65:     vec4 a = q1.w * q2.xyzw;
  66:     vec4 b = q1.x * q2.wzxy * vec4(1., -1., 1., -1.);
  67:     vec4 c = q1.y * q2.zwxy * vec4(1., 1., -1., -1.);
  68:     vec4 d = q1.z * q2.yxwz * vec4(-1., 1., 1., -1.);
  69: 
  70:     return a + b + c + d;
  71: }
  72: 
  73: vec3 rotateVertexByQuat(vec3 v, vec4 q) {
  74:     vec3 i = q.xyz;
  75:     return v + 2.0 * cross(i, cross(i, v) + q.w * v);
  76: }
  77: 
  78: vec3 rotateAbout(vec3 v, vec3 axis, float angle) {
  79:     return rotateVertexByQuat(v, quat(axis, angle));
  80: }
  81: 
  82: float diffuse(vec3 normal) {
  83:     vec3 n2 = normal * normal * vec3(.6, .25, .8);
  84:     return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
  85: }
  86: 
  87: 
  88: struct Oriented {
  89:     vec2 light;
  90:     vec4 color;
  91:     vec3 pos;
  92:     vec3 pivot;
  93:     vec4 rotation;
  94: };
  95: 
  96: 
  97: struct Vertex {
  98:     vec3 pos;
  99:     vec3 normal;
 100:     vec2 texCoords;
 101: };
 102: 
 103: struct BlockFrag {
 104:     vec2 texCoords;
 105:     vec4 color;
 106:     float diffuse;
 107:     vec2 light;
 108: };
 109: 
 110: BlockFrag FLWMain(Vertex v, Oriented o) {
 111:     vec4 worldPos = vec4(rotateVertexByQuat(v.pos - o.pivot, o.rotation) + o.pivot + o.pos, 1.);
 112: 
 113:     vec3 norm = rotateVertexByQuat(v.normal, o.rotation);
 114: 
 115:     FLWFinalizeWorldPos(worldPos);
 116:     FLWFinalizeNormal(norm);
 117: 
 118:     BlockFrag b;
 119:     b.diffuse = diffuse(norm);
 120:     b.texCoords = v.texCoords;
 121:     b.light = o.light;
 122:     #if defined(DEBUG_NORMAL)
 123:     b.color = vec4(norm, 1.);
 124:     #else
 125:     b.color = o.color;
 126:     #endif
 127:     return b;
 128: }
 129: attribute vec3 a_v_pos;
 130: attribute vec3 a_v_normal;
 131: attribute vec2 a_v_texCoords;
 132: 
 133: attribute vec2 a_i_light;
 134: attribute vec4 a_i_color;
 135: attribute vec3 a_i_pos;
 136: attribute vec3 a_i_pivot;
 137: attribute vec4 a_i_rotation;
 138: 
 139: 
 140: varying vec2 v2f_texCoords;
 141: varying vec4 v2f_color;
 142: varying float v2f_diffuse;
 143: varying vec2 v2f_light;
 144: 
 145: 
 146: void main() {
 147:     Vertex v;
 148:     v.pos = a_v_pos;
 149: v.normal = a_v_normal;
 150: v.texCoords = a_v_texCoords;
 151: 
 152: 
 153:     Oriented i;
 154:     i.light = a_i_light;
 155: i.color = a_i_color;
 156: i.pos = a_i_pos;
 157: i.pivot = a_i_pivot;
 158: i.rotation = a_i_rotation;
 159: 
 160: 
 161:     BlockFrag o = FLWMain(v, i);
 162: 
 163:     v2f_texCoords = o.texCoords;
 164: v2f_color = o.color;
 165: v2f_diffuse = o.diffuse;
 166: v2f_light = o.light;
 167: 
 168: }

[13:33:19] [main/ERROR]: Shader compilation log for flywheel:block.frag: No errors.

[13:33:19] [main/ERROR]: Source for shader 'flywheel:block.frag':
   1: #version 110
   2: #define USE_FOG
   3: #define USE_FOG_EXP2
   4: 
   5: #if defined(USE_FOG)
   6: varying float FragDistance;
   7: uniform vec4 uFogColor;
   8: #endif
   9: 
  10: #if defined(USE_FOG_LINEAR)
  11: uniform vec2 uFogRange;
  12: 
  13: float FLWFogFactor() {
  14:     return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
  15: }
  16:     #endif
  17: 
  18:     #if defined(USE_FOG_EXP2)
  19: uniform float uFogDensity;
  20: 
  21: float FLWFogFactor() {
  22:     float dist = FragDistance * uFogDensity;
  23:     return 1. / exp2(dist * dist);
  24: }
  25:     #endif
  26: 
  27: uniform vec2 uTextureScale;
  28: uniform sampler2D uBlockAtlas;
  29: uniform sampler2D uLightMap;
  30: uniform sampler2D uCrumbling;
  31: 
  32: vec4 FLWBlockTexture(vec2 texCoords) {
  33:     vec4 cr = texture2D(uCrumbling, texCoords * uTextureScale);
  34:     float diffuseAlpha = texture2D(uBlockAtlas, texCoords).a;
  35:     cr.a = cr.a * diffuseAlpha;
  36:     return cr;
  37: }
  38: 
  39: void FLWFinalizeColor(vec4 color) {
  40:     #if defined(USE_FOG)
  41:     float a = color.a;
  42:     float fog = clamp(FLWFogFactor(), 0., 1.);
  43: 
  44:     color = mix(uFogColor, color, fog);
  45:     color.a = a;
  46:     #endif
  47: 
  48:     gl_FragColor = color;
  49: }
  50: 
  51: vec4 FLWLight(vec2 lightCoords) {
  52:     return vec4(1.);
  53: }
  54: 
  55: 
  56: 
  57: struct BlockFrag {
  58:     vec2 texCoords;
  59:     vec4 color;
  60:     float diffuse;
  61:     vec2 light;
  62: };
  63: 
  64: void FLWMain(BlockFrag r) {
  65:     vec4 tex = FLWBlockTexture(r.texCoords);
  66: 
  67:     vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;
  68: 
  69: //    flw_WorldPos = ;
  70: //    flw_Normal = ;
  71: //    flw_Albedo = tex.rgb;
  72: //    flw_Alpha = tex.a;
  73: //    flw_LightMap = r.light;
  74: //    flw_Tint = r.color;
  75:     FLWFinalizeColor(color);
  76: }
  77: 
  78: varying vec2 v2f_texCoords;
  79: varying vec4 v2f_color;
  80: varying float v2f_diffuse;
  81: varying vec2 v2f_light;
  82: 
  83: 
  84: //vec3 flw_WorldPos;
  85: //vec3 flw_Normal;
  86: //vec3 flw_Albedo;
  87: //float flw_Alpha;
  88: //vec2 flw_LightMap;
  89: //vec4 flw_Tint;
  90: 
  91: void main() {
  92:     BlockFrag f;
  93:     f.texCoords = v2f_texCoords;
  94: f.color = v2f_color;
  95: f.diffuse = v2f_diffuse;
  96: f.light = v2f_light;
  97: 
  98: 
  99:     FLWMain(f);
 100: }

[13:33:19] [main/ERROR]: Shader compilation log for flywheel:oriented.vert: No errors.

[13:33:19] [main/ERROR]: Source for shader 'flywheel:oriented.vert':
   1: #version 110
   2: 
   3: uniform float uTime;
   4: uniform mat4 uViewProjection;
   5: uniform vec3 uCameraPos;
   6: 
   7: #if defined(USE_FOG)
   8: varying float FragDistance;
   9: #endif
  10: 
  11: void FLWFinalizeWorldPos(inout vec4 worldPos) {
  12:     #if defined(USE_FOG)
  13:     FragDistance = length(worldPos.xyz - uCameraPos);
  14:     #endif
  15: 
  16:     gl_Position = uViewProjection * worldPos;
  17: }
  18: 
  19: void FLWFinalizeNormal(inout vec3 normal) {
  20:     // noop
  21: }
  22: 
  23: 
  24: mat4 rotate(vec3 axis, float angle) {
  25:     float s = sin(angle);
  26:     float c = cos(angle);
  27:     float oc = 1. - c;
  28: 
  29:     vec3 sa = axis * s;
  30: 
  31:     mat4 mr = mat4(1.);
  32:     mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
  33:     mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
  34:     mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);
  35: 
  36:     return mr;
  37: }
  38: 
  39: mat4 rotation(vec3 rot) {
  40:     return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
  41: }
  42: 
  43: mat3 modelToNormal(mat4 mat) {
  44:     // Discard the edges. This won't be accurate for scaled or skewed matrices,
  45:     // but we don't have to work with those often.
  46:     mat3 m;
  47:     m[0] = mat[0].xyz;
  48:     m[1] = mat[1].xyz;
  49:     m[2] = mat[2].xyz;
  50:     return m;
  51: }
  52: 
  53: #define PIOVER2 1.5707963268
  54: 
  55: vec4 quat(vec3 axis, float angle) {
  56:     float halfAngle = angle * PIOVER2 / 180.0;
  57:     vec2 cs = sin(vec2(PIOVER2 - halfAngle, halfAngle)); // compute sin and cos in one instruction
  58:     return vec4(axis.xyz * cs.y,  cs.x);
  59: }
  60: 
  61: vec4 quatMult(vec4 q1, vec4 q2) {
  62:     // disgustingly vectorized quaternion multiplication
  63:     vec4 a = q1.w * q2.xyzw;
  64:     vec4 b = q1.x * q2.wzxy * vec4(1., -1., 1., -1.);
  65:     vec4 c = q1.y * q2.zwxy * vec4(1., 1., -1., -1.);
  66:     vec4 d = q1.z * q2.yxwz * vec4(-1., 1., 1., -1.);
  67: 
  68:     return a + b + c + d;
  69: }
  70: 
  71: vec3 rotateVertexByQuat(vec3 v, vec4 q) {
  72:     vec3 i = q.xyz;
  73:     return v + 2.0 * cross(i, cross(i, v) + q.w * v);
  74: }
  75: 
  76: vec3 rotateAbout(vec3 v, vec3 axis, float angle) {
  77:     return rotateVertexByQuat(v, quat(axis, angle));
  78: }
  79: 
  80: float diffuse(vec3 normal) {
  81:     vec3 n2 = normal * normal * vec3(.6, .25, .8);
  82:     return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
  83: }
  84: 
  85: 
  86: struct Oriented {
  87:     vec2 light;
  88:     vec4 color;
  89:     vec3 pos;
  90:     vec3 pivot;
  91:     vec4 rotation;
  92: };
  93: 
  94: 
  95: struct Vertex {
  96:     vec3 pos;
  97:     vec3 normal;
  98:     vec2 texCoords;
  99: };
 100: 
 101: struct BlockFrag {
 102:     vec2 texCoords;
 103:     vec4 color;
 104:     float diffuse;
 105:     vec2 light;
 106: };
 107: 
 108: BlockFrag FLWMain(Vertex v, Oriented o) {
 109:     vec4 worldPos = vec4(rotateVertexByQuat(v.pos - o.pivot, o.rotation) + o.pivot + o.pos, 1.);
 110: 
 111:     vec3 norm = rotateVertexByQuat(v.normal, o.rotation);
 112: 
 113:     FLWFinalizeWorldPos(worldPos);
 114:     FLWFinalizeNormal(norm);
 115: 
 116:     BlockFrag b;
 117:     b.diffuse = diffuse(norm);
 118:     b.texCoords = v.texCoords;
 119:     b.light = o.light;
 120:     #if defined(DEBUG_NORMAL)
 121:     b.color = vec4(norm, 1.);
 122:     #else
 123:     b.color = o.color;
 124:     #endif
 125:     return b;
 126: }
 127: attribute vec3 a_v_pos;
 128: attribute vec3 a_v_normal;
 129: attribute vec2 a_v_texCoords;
 130: 
 131: attribute vec2 a_i_light;
 132: attribute vec4 a_i_color;
 133: attribute vec3 a_i_pos;
 134: attribute vec3 a_i_pivot;
 135: attribute vec4 a_i_rotation;
 136: 
 137: 
 138: varying vec2 v2f_texCoords;
 139: varying vec4 v2f_color;
 140: varying float v2f_diffuse;
 141: varying vec2 v2f_light;
 142: 
 143: 
 144: void main() {
 145:     Vertex v;
 146:     v.pos = a_v_pos;
 147: v.normal = a_v_normal;
 148: v.texCoords = a_v_texCoords;
 149: 
 150: 
 151:     Oriented i;
 152:     i.light = a_i_light;
 153: i.color = a_i_color;
 154: i.pos = a_i_pos;
 155: i.pivot = a_i_pivot;
 156: i.rotation = a_i_rotation;
 157: 
 158: 
 159:     BlockFrag o = FLWMain(v, i);
 160: 
 161:     v2f_texCoords = o.texCoords;
 162: v2f_color = o.color;
 163: v2f_diffuse = o.diffuse;
 164: v2f_light = o.light;
 165: 
 166: }

[13:33:19] [main/ERROR]: Shader compilation log for flywheel:block.frag: No errors.

[13:33:19] [main/ERROR]: Source for shader 'flywheel:block.frag':
   1: #version 110
   2: 
   3: #if defined(USE_FOG)
   4: varying float FragDistance;
   5: uniform vec4 uFogColor;
   6: #endif
   7: 
   8: #if defined(USE_FOG_LINEAR)
   9: uniform vec2 uFogRange;
  10: 
  11: float FLWFogFactor() {
  12:     return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
  13: }
  14:     #endif
  15: 
  16:     #if defined(USE_FOG_EXP2)
  17: uniform float uFogDensity;
  18: 
  19: float FLWFogFactor() {
  20:     float dist = FragDistance * uFogDensity;
  21:     return 1. / exp2(dist * dist);
  22: }
  23:     #endif
  24: 
  25: uniform vec2 uTextureScale;
  26: uniform sampler2D uBlockAtlas;
  27: uniform sampler2D uLightMap;
  28: uniform sampler2D uCrumbling;
  29: 
  30: vec4 FLWBlockTexture(vec2 texCoords) {
  31:     vec4 cr = texture2D(uCrumbling, texCoords * uTextureScale);
  32:     float diffuseAlpha = texture2D(uBlockAtlas, texCoords).a;
  33:     cr.a = cr.a * diffuseAlpha;
  34:     return cr;
  35: }
  36: 
  37: void FLWFinalizeColor(vec4 color) {
  38:     #if defined(USE_FOG)
  39:     float a = color.a;
  40:     float fog = clamp(FLWFogFactor(), 0., 1.);
  41: 
  42:     color = mix(uFogColor, color, fog);
  43:     color.a = a;
  44:     #endif
  45: 
  46:     gl_FragColor = color;
  47: }
  48: 
  49: vec4 FLWLight(vec2 lightCoords) {
  50:     return vec4(1.);
  51: }
  52: 
  53: 
  54: 
  55: struct BlockFrag {
  56:     vec2 texCoords;
  57:     vec4 color;
  58:     float diffuse;
  59:     vec2 light;
  60: };
  61: 
  62: void FLWMain(BlockFrag r) {
  63:     vec4 tex = FLWBlockTexture(r.texCoords);
  64: 
  65:     vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;
  66: 
  67: //    flw_WorldPos = ;
  68: //    flw_Normal = ;
  69: //    flw_Albedo = tex.rgb;
  70: //    flw_Alpha = tex.a;
  71: //    flw_LightMap = r.light;
  72: //    flw_Tint = r.color;
  73:     FLWFinalizeColor(color);
  74: }
  75: 
  76: varying vec2 v2f_texCoords;
  77: varying vec4 v2f_color;
  78: varying float v2f_diffuse;
  79: varying vec2 v2f_light;
  80: 
  81: 
  82: //vec3 flw_WorldPos;
  83: //vec3 flw_Normal;
  84: //vec3 flw_Albedo;
  85: //float flw_Alpha;
  86: //vec2 flw_LightMap;
  87: //vec4 flw_Tint;
  88: 
  89: void main() {
  90:     BlockFrag f;
  91:     f.texCoords = v2f_texCoords;
  92: f.color = v2f_color;
  93: f.diffuse = v2f_diffuse;
  94: f.light = v2f_light;
  95: 
  96: 
  97:     FLWMain(f);
  98: }

[13:33:19] [main/ERROR]: Shader compilation log for flywheel:model.vert: No errors.

[13:33:19] [main/ERROR]: Source for shader 'flywheel:model.vert':
   1: #version 110
   2: #define DEBUG_NORMAL
   3: 
   4: uniform float uTime;
   5: uniform mat4 uViewProjection;
   6: uniform vec3 uCameraPos;
   7: 
   8: #if defined(USE_FOG)
   9: varying float FragDistance;
  10: #endif
  11: 
  12: void FLWFinalizeWorldPos(inout vec4 worldPos) {
  13:     #if defined(USE_FOG)
  14:     FragDistance = length(worldPos.xyz - uCameraPos);
  15:     #endif
  16: 
  17:     gl_Position = uViewProjection * worldPos;
  18: }
  19: 
  20: void FLWFinalizeNormal(inout vec3 normal) {
  21:     // noop
  22: }
  23: 
  24: 
  25: float diffuse(vec3 normal) {
  26:     vec3 n2 = normal * normal * vec3(.6, .25, .8);
  27:     return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
  28: }
  29: 
  30: 
  31: struct Vertex {
  32:     vec3 pos;
  33:     vec3 normal;
  34:     vec2 texCoords;
  35: };
  36: 
  37: struct BlockFrag {
  38:     vec2 texCoords;
  39:     vec4 color;
  40:     float diffuse;
  41:     vec2 light;
  42: };
  43: 
  44: 
  45: struct Instance {
  46:     vec2 light;
  47:     vec4 color;
  48:     mat4 transform;
  49:     mat3 normalMat;
  50: };
  51: 
  52: BlockFrag FLWMain(Vertex v, Instance i) {
  53:     vec4 worldPos = i.transform * vec4(v.pos, 1.);
  54: 
  55:     vec3 norm = i.normalMat * v.normal;
  56: 
  57:     FLWFinalizeWorldPos(worldPos);
  58:     FLWFinalizeNormal(norm);
  59: 
  60:     norm = normalize(norm);
  61: 
  62:     BlockFrag b;
  63:     b.diffuse = diffuse(norm);
  64:     b.texCoords = v.texCoords;
  65:     b.light = i.light;
  66:     #if defined(DEBUG_NORMAL)
  67:     b.color = vec4(norm, 1.);
  68:     #else
  69:     b.color = i.color;
  70:     #endif
  71:     return b;
  72: }
  73: attribute vec3 a_v_pos;
  74: attribute vec3 a_v_normal;
  75: attribute vec2 a_v_texCoords;
  76: 
  77: attribute vec2 a_i_light;
  78: attribute vec4 a_i_color;
  79: attribute mat4 a_i_transform;
  80: attribute mat3 a_i_normalMat;
  81: 
  82: 
  83: varying vec2 v2f_texCoords;
  84: varying vec4 v2f_color;
  85: varying float v2f_diffuse;
  86: varying vec2 v2f_light;
  87: 
  88: 
  89: void main() {
  90:     Vertex v;
  91:     v.pos = a_v_pos;
  92: v.normal = a_v_normal;
  93: v.texCoords = a_v_texCoords;
  94: 
  95: 
  96:     Instance i;
  97:     i.light = a_i_light;
  98: i.color = a_i_color;
  99: i.transform = a_i_transform;
 100: i.normalMat = a_i_normalMat;
 101: 
 102: 
 103:     BlockFrag o = FLWMain(v, i);
 104: 
 105:     v2f_texCoords = o.texCoords;
 106: v2f_color = o.color;
 107: v2f_diffuse = o.diffuse;
 108: v2f_light = o.light;
 109: 
 110: }

[13:33:19] [main/ERROR]: Shader compilation log for flywheel:block.frag: No errors.

[13:33:19] [main/ERROR]: Source for shader 'flywheel:block.frag':
   1: #version 110
   2: #define DEBUG_NORMAL
   3: 
   4: #if defined(USE_FOG)
   5: varying float FragDistance;
   6: uniform vec4 uFogColor;
   7: #endif
   8: 
   9: #if defined(USE_FOG_LINEAR)
  10: uniform vec2 uFogRange;
  11: 
  12: float FLWFogFactor() {
  13:     return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
  14: }
  15:     #endif
  16: 
  17:     #if defined(USE_FOG_EXP2)
  18: uniform float uFogDensity;
  19: 
  20: float FLWFogFactor() {
  21:     float dist = FragDistance * uFogDensity;
  22:     return 1. / exp2(dist * dist);
  23: }
  24:     #endif
  25: 
  26: uniform vec2 uTextureScale;
  27: uniform sampler2D uBlockAtlas;
  28: uniform sampler2D uLightMap;
  29: uniform sampler2D uCrumbling;
  30: 
  31: vec4 FLWBlockTexture(vec2 texCoords) {
  32:     vec4 cr = texture2D(uCrumbling, texCoords * uTextureScale);
  33:     float diffuseAlpha = texture2D(uBlockAtlas, texCoords).a;
  34:     cr.a = cr.a * diffuseAlpha;
  35:     return cr;
  36: }
  37: 
  38: void FLWFinalizeColor(vec4 color) {
  39:     #if defined(USE_FOG)
  40:     float a = color.a;
  41:     float fog = clamp(FLWFogFactor(), 0., 1.);
  42: 
  43:     color = mix(uFogColor, color, fog);
  44:     color.a = a;
  45:     #endif
  46: 
  47:     gl_FragColor = color;
  48: }
  49: 
  50: vec4 FLWLight(vec2 lightCoords) {
  51:     return vec4(1.);
  52: }
  53: 
  54: 
  55: 
  56: struct BlockFrag {
  57:     vec2 texCoords;
  58:     vec4 color;
  59:     float diffuse;
  60:     vec2 light;
  61: };
  62: 
  63: void FLWMain(BlockFrag r) {
  64:     vec4 tex = FLWBlockTexture(r.texCoords);
  65: 
  66:     vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;
  67: 
  68: //    flw_WorldPos = ;
  69: //    flw_Normal = ;
  70: //    flw_Albedo = tex.rgb;
  71: //    flw_Alpha = tex.a;
  72: //    flw_LightMap = r.light;
  73: //    flw_Tint = r.color;
  74:     FLWFinalizeColor(color);
  75: }
  76: 
  77: varying vec2 v2f_texCoords;
  78: varying vec4 v2f_color;
  79: varying float v2f_diffuse;
  80: varying vec2 v2f_light;
  81: 
  82: 
  83: //vec3 flw_WorldPos;
  84: //vec3 flw_Normal;
  85: //vec3 flw_Albedo;
  86: //float flw_Alpha;
  87: //vec2 flw_LightMap;
  88: //vec4 flw_Tint;
  89: 
  90: void main() {
  91:     BlockFrag f;
  92:     f.texCoords = v2f_texCoords;
  93: f.color = v2f_color;
  94: f.diffuse = v2f_diffuse;
  95: f.light = v2f_light;
  96: 
  97: 
  98:     FLWMain(f);
  99: }

[13:33:19] [main/ERROR]: Shader compilation log for flywheel:model.vert: No errors.

[13:33:19] [main/ERROR]: Source for shader 'flywheel:model.vert':
   1: #version 110
   2: #define USE_FOG
   3: #define USE_FOG_LINEAR
   4: 
   5: uniform float uTime;
   6: uniform mat4 uViewProjection;
   7: uniform vec3 uCameraPos;
   8: 
   9: #if defined(USE_FOG)
  10: varying float FragDistance;
  11: #endif
  12: 
  13: void FLWFinalizeWorldPos(inout vec4 worldPos) {
  14:     #if defined(USE_FOG)
  15:     FragDistance = length(worldPos.xyz - uCameraPos);
  16:     #endif
  17: 
  18:     gl_Position = uViewProjection * worldPos;
  19: }
  20: 
  21: void FLWFinalizeNormal(inout vec3 normal) {
  22:     // noop
  23: }
  24: 
  25: 
  26: float diffuse(vec3 normal) {
  27:     vec3 n2 = normal * normal * vec3(.6, .25, .8);
  28:     return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
  29: }
  30: 
  31: 
  32: struct Vertex {
  33:     vec3 pos;
  34:     vec3 normal;
  35:     vec2 texCoords;
  36: };
  37: 
  38: struct BlockFrag {
  39:     vec2 texCoords;
  40:     vec4 color;
  41:     float diffuse;
  42:     vec2 light;
  43: };
  44: 
  45: 
  46: struct Instance {
  47:     vec2 light;
  48:     vec4 color;
  49:     mat4 transform;
  50:     mat3 normalMat;
  51: };
  52: 
  53: BlockFrag FLWMain(Vertex v, Instance i) {
  54:     vec4 worldPos = i.transform * vec4(v.pos, 1.);
  55: 
  56:     vec3 norm = i.normalMat * v.normal;
  57: 
  58:     FLWFinalizeWorldPos(worldPos);
  59:     FLWFinalizeNormal(norm);
  60: 
  61:     norm = normalize(norm);
  62: 
  63:     BlockFrag b;
  64:     b.diffuse = diffuse(norm);
  65:     b.texCoords = v.texCoords;
  66:     b.light = i.light;
  67:     #if defined(DEBUG_NORMAL)
  68:     b.color = vec4(norm, 1.);
  69:     #else
  70:     b.color = i.color;
  71:     #endif
  72:     return b;
  73: }
  74: attribute vec3 a_v_pos;
  75: attribute vec3 a_v_normal;
  76: attribute vec2 a_v_texCoords;
  77: 
  78: attribute vec2 a_i_light;
  79: attribute vec4 a_i_color;
  80: attribute mat4 a_i_transform;
  81: attribute mat3 a_i_normalMat;
  82: 
  83: 
  84: varying vec2 v2f_texCoords;
  85: varying vec4 v2f_color;
  86: varying float v2f_diffuse;
  87: varying vec2 v2f_light;
  88: 
  89: 
  90: void main() {
  91:     Vertex v;
  92:     v.pos = a_v_pos;
  93: v.normal = a_v_normal;
  94: v.texCoords = a_v_texCoords;
  95: 
  96: 
  97:     Instance i;
  98:     i.light = a_i_light;
  99: i.color = a_i_color;
 100: i.transform = a_i_transform;
 101: i.normalMat = a_i_normalMat;
 102: 
 103: 
 104:     BlockFrag o = FLWMain(v, i);
 105: 
 106:     v2f_texCoords = o.texCoords;
 107: v2f_color = o.color;
 108: v2f_diffuse = o.diffuse;
 109: v2f_light = o.light;
 110: 
 111: }

[13:33:19] [main/ERROR]: Shader compilation log for flywheel:block.frag: No errors.

[13:33:19] [main/ERROR]: Source for shader 'flywheel:block.frag':
   1: #version 110
   2: #define USE_FOG
   3: #define USE_FOG_LINEAR
   4: 
   5: #if defined(USE_FOG)
   6: varying float FragDistance;
   7: uniform vec4 uFogColor;
   8: #endif
   9: 
  10: #if defined(USE_FOG_LINEAR)
  11: uniform vec2 uFogRange;
  12: 
  13: float FLWFogFactor() {
  14:     return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
  15: }
  16:     #endif
  17: 
  18:     #if defined(USE_FOG_EXP2)
  19: uniform float uFogDensity;
  20: 
  21: float FLWFogFactor() {
  22:     float dist = FragDistance * uFogDensity;
  23:     return 1. / exp2(dist * dist);
  24: }
  25:     #endif
  26: 
  27: uniform vec2 uTextureScale;
  28: uniform sampler2D uBlockAtlas;
  29: uniform sampler2D uLightMap;
  30: uniform sampler2D uCrumbling;
  31: 
  32: vec4 FLWBlockTexture(vec2 texCoords) {
  33:     vec4 cr = texture2D(uCrumbling, texCoords * uTextureScale);
  34:     float diffuseAlpha = texture2D(uBlockAtlas, texCoords).a;
  35:     cr.a = cr.a * diffuseAlpha;
  36:     return cr;
  37: }
  38: 
  39: void FLWFinalizeColor(vec4 color) {
  40:     #if defined(USE_FOG)
  41:     float a = color.a;
  42:     float fog = clamp(FLWFogFactor(), 0., 1.);
  43: 
  44:     color = mix(uFogColor, color, fog);
  45:     color.a = a;
  46:     #endif
  47: 
  48:     gl_FragColor = color;
  49: }
  50: 
  51: vec4 FLWLight(vec2 lightCoords) {
  52:     return vec4(1.);
  53: }
  54: 
  55: 
  56: 
  57: struct BlockFrag {
  58:     vec2 texCoords;
  59:     vec4 color;
  60:     float diffuse;
  61:     vec2 light;
  62: };
  63: 
  64: void FLWMain(BlockFrag r) {
  65:     vec4 tex = FLWBlockTexture(r.texCoords);
  66: 
  67:     vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;
  68: 
  69: //    flw_WorldPos = ;
  70: //    flw_Normal = ;
  71: //    flw_Albedo = tex.rgb;
  72: //    flw_Alpha = tex.a;
  73: //    flw_LightMap = r.light;
  74: //    flw_Tint = r.color;
  75:     FLWFinalizeColor(color);
  76: }
  77: 
  78: varying vec2 v2f_texCoords;
  79: varying vec4 v2f_color;
  80: varying float v2f_diffuse;
  81: varying vec2 v2f_light;
  82: 
  83: 
  84: //vec3 flw_WorldPos;
  85: //vec3 flw_Normal;
  86: //vec3 flw_Albedo;
  87: //float flw_Alpha;
  88: //vec2 flw_LightMap;
  89: //vec4 flw_Tint;
  90: 
  91: void main() {
  92:     BlockFrag f;
  93:     f.texCoords = v2f_texCoords;
  94: f.color = v2f_color;
  95: f.diffuse = v2f_diffuse;
  96: f.light = v2f_light;
  97: 
  98: 
  99:     FLWMain(f);
 100: }

[13:33:19] [main/ERROR]: Shader compilation log for flywheel:model.vert: No errors.

[13:33:19] [main/ERROR]: Source for shader 'flywheel:model.vert':
   1: #version 110
   2: #define USE_FOG
   3: #define USE_FOG_EXP2
   4: 
   5: uniform float uTime;
   6: uniform mat4 uViewProjection;
   7: uniform vec3 uCameraPos;
   8: 
   9: #if defined(USE_FOG)
  10: varying float FragDistance;
  11: #endif
  12: 
  13: void FLWFinalizeWorldPos(inout vec4 worldPos) {
  14:     #if defined(USE_FOG)
  15:     FragDistance = length(worldPos.xyz - uCameraPos);
  16:     #endif
  17: 
  18:     gl_Position = uViewProjection * worldPos;
  19: }
  20: 
  21: void FLWFinalizeNormal(inout vec3 normal) {
  22:     // noop
  23: }
  24: 
  25: 
  26: float diffuse(vec3 normal) {
  27:     vec3 n2 = normal * normal * vec3(.6, .25, .8);
  28:     return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
  29: }
  30: 
  31: 
  32: struct Vertex {
  33:     vec3 pos;
  34:     vec3 normal;
  35:     vec2 texCoords;
  36: };
  37: 
  38: struct BlockFrag {
  39:     vec2 texCoords;
  40:     vec4 color;
  41:     float diffuse;
  42:     vec2 light;
  43: };
  44: 
  45: 
  46: struct Instance {
  47:     vec2 light;
  48:     vec4 color;
  49:     mat4 transform;
  50:     mat3 normalMat;
  51: };
  52: 
  53: BlockFrag FLWMain(Vertex v, Instance i) {
  54:     vec4 worldPos = i.transform * vec4(v.pos, 1.);
  55: 
  56:     vec3 norm = i.normalMat * v.normal;
  57: 
  58:     FLWFinalizeWorldPos(worldPos);
  59:     FLWFinalizeNormal(norm);
  60: 
  61:     norm = normalize(norm);
  62: 
  63:     BlockFrag b;
  64:     b.diffuse = diffuse(norm);
  65:     b.texCoords = v.texCoords;
  66:     b.light = i.light;
  67:     #if defined(DEBUG_NORMAL)
  68:     b.color = vec4(norm, 1.);
  69:     #else
  70:     b.color = i.color;
  71:     #endif
  72:     return b;
  73: }
  74: attribute vec3 a_v_pos;
  75: attribute vec3 a_v_normal;
  76: attribute vec2 a_v_texCoords;
  77: 
  78: attribute vec2 a_i_light;
  79: attribute vec4 a_i_color;
  80: attribute mat4 a_i_transform;
  81: attribute mat3 a_i_normalMat;
  82: 
  83: 
  84: varying vec2 v2f_texCoords;
  85: varying vec4 v2f_color;
  86: varying float v2f_diffuse;
  87: varying vec2 v2f_light;
  88: 
  89: 
  90: void main() {
  91:     Vertex v;
  92:     v.pos = a_v_pos;
  93: v.normal = a_v_normal;
  94: v.texCoords = a_v_texCoords;
  95: 
  96: 
  97:     Instance i;
  98:     i.light = a_i_light;
  99: i.color = a_i_color;
 100: i.transform = a_i_transform;
 101: i.normalMat = a_i_normalMat;
 102: 
 103: 
 104:     BlockFrag o = FLWMain(v, i);
 105: 
 106:     v2f_texCoords = o.texCoords;
 107: v2f_color = o.color;
 108: v2f_diffuse = o.diffuse;
 109: v2f_light = o.light;
 110: 
 111: }

[13:33:19] [main/ERROR]: Shader compilation log for flywheel:block.frag: No errors.

[13:33:19] [main/ERROR]: Source for shader 'flywheel:block.frag':
   1: #version 110
   2: #define USE_FOG
   3: #define USE_FOG_EXP2
   4: 
   5: #if defined(USE_FOG)
   6: varying float FragDistance;
   7: uniform vec4 uFogColor;
   8: #endif
   9: 
  10: #if defined(USE_FOG_LINEAR)
  11: uniform vec2 uFogRange;
  12: 
  13: float FLWFogFactor() {
  14:     return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
  15: }
  16:     #endif
  17: 
  18:     #if defined(USE_FOG_EXP2)
  19: uniform float uFogDensity;
  20: 
  21: float FLWFogFactor() {
  22:     float dist = FragDistance * uFogDensity;
  23:     return 1. / exp2(dist * dist);
  24: }
  25:     #endif
  26: 
  27: uniform vec2 uTextureScale;
  28: uniform sampler2D uBlockAtlas;
  29: uniform sampler2D uLightMap;
  30: uniform sampler2D uCrumbling;
  31: 
  32: vec4 FLWBlockTexture(vec2 texCoords) {
  33:     vec4 cr = texture2D(uCrumbling, texCoords * uTextureScale);
  34:     float diffuseAlpha = texture2D(uBlockAtlas, texCoords).a;
  35:     cr.a = cr.a * diffuseAlpha;
  36:     return cr;
  37: }
  38: 
  39: void FLWFinalizeColor(vec4 color) {
  40:     #if defined(USE_FOG)
  41:     float a = color.a;
  42:     float fog = clamp(FLWFogFactor(), 0., 1.);
  43: 
  44:     color = mix(uFogColor, color, fog);
  45:     color.a = a;
  46:     #endif
  47: 
  48:     gl_FragColor = color;
  49: }
  50: 
  51: vec4 FLWLight(vec2 lightCoords) {
  52:     return vec4(1.);
  53: }
  54: 
  55: 
  56: 
  57: struct BlockFrag {
  58:     vec2 texCoords;
  59:     vec4 color;
  60:     float diffuse;
  61:     vec2 light;
  62: };
  63: 
  64: void FLWMain(BlockFrag r) {
  65:     vec4 tex = FLWBlockTexture(r.texCoords);
  66: 
  67:     vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;
  68: 
  69: //    flw_WorldPos = ;
  70: //    flw_Normal = ;
  71: //    flw_Albedo = tex.rgb;
  72: //    flw_Alpha = tex.a;
  73: //    flw_LightMap = r.light;
  74: //    flw_Tint = r.color;
  75:     FLWFinalizeColor(color);
  76: }
  77: 
  78: varying vec2 v2f_texCoords;
  79: varying vec4 v2f_color;
  80: varying float v2f_diffuse;
  81: varying vec2 v2f_light;
  82: 
  83: 
  84: //vec3 flw_WorldPos;
  85: //vec3 flw_Normal;
  86: //vec3 flw_Albedo;
  87: //float flw_Alpha;
  88: //vec2 flw_LightMap;
  89: //vec4 flw_Tint;
  90: 
  91: void main() {
  92:     BlockFrag f;
  93:     f.texCoords = v2f_texCoords;
  94: f.color = v2f_color;
  95: f.diffuse = v2f_diffuse;
  96: f.light = v2f_light;
  97: 
  98: 
  99:     FLWMain(f);
 100: }

[13:33:19] [main/ERROR]: Shader compilation log for flywheel:model.vert: No errors.

[13:33:19] [main/ERROR]: Source for shader 'flywheel:model.vert':
   1: #version 110
   2: 
   3: uniform float uTime;
   4: uniform mat4 uViewProjection;
   5: uniform vec3 uCameraPos;
   6: 
   7: #if defined(USE_FOG)
   8: varying float FragDistance;
   9: #endif
  10: 
  11: void FLWFinalizeWorldPos(inout vec4 worldPos) {
  12:     #if defined(USE_FOG)
  13:     FragDistance = length(worldPos.xyz - uCameraPos);
  14:     #endif
  15: 
  16:     gl_Position = uViewProjection * worldPos;
  17: }
  18: 
  19: void FLWFinalizeNormal(inout vec3 normal) {
  20:     // noop
  21: }
  22: 
  23: 
  24: float diffuse(vec3 normal) {
  25:     vec3 n2 = normal * normal * vec3(.6, .25, .8);
  26:     return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
  27: }
  28: 
  29: 
  30: struct Vertex {
  31:     vec3 pos;
  32:     vec3 normal;
  33:     vec2 texCoords;
  34: };
  35: 
  36: struct BlockFrag {
  37:     vec2 texCoords;
  38:     vec4 color;
  39:     float diffuse;
  40:     vec2 light;
  41: };
  42: 
  43: 
  44: struct Instance {
  45:     vec2 light;
  46:     vec4 color;
  47:     mat4 transform;
  48:     mat3 normalMat;
  49: };
  50: 
  51: BlockFrag FLWMain(Vertex v, Instance i) {
  52:     vec4 worldPos = i.transform * vec4(v.pos, 1.);
  53: 
  54:     vec3 norm = i.normalMat * v.normal;
  55: 
  56:     FLWFinalizeWorldPos(worldPos);
  57:     FLWFinalizeNormal(norm);
  58: 
  59:     norm = normalize(norm);
  60: 
  61:     BlockFrag b;
  62:     b.diffuse = diffuse(norm);
  63:     b.texCoords = v.texCoords;
  64:     b.light = i.light;
  65:     #if defined(DEBUG_NORMAL)
  66:     b.color = vec4(norm, 1.);
  67:     #else
  68:     b.color = i.color;
  69:     #endif
  70:     return b;
  71: }
  72: attribute vec3 a_v_pos;
  73: attribute vec3 a_v_normal;
  74: attribute vec2 a_v_texCoords;
  75: 
  76: attribute vec2 a_i_light;
  77: attribute vec4 a_i_color;
  78: attribute mat4 a_i_transform;
  79: attribute mat3 a_i_normalMat;
  80: 
  81: 
  82: varying vec2 v2f_texCoords;
  83: varying vec4 v2f_color;
  84: varying float v2f_diffuse;
  85: varying vec2 v2f_light;
  86: 
  87: 
  88: void main() {
  89:     Vertex v;
  90:     v.pos = a_v_pos;
  91: v.normal = a_v_normal;
  92: v.texCoords = a_v_texCoords;
  93: 
  94: 
  95:     Instance i;
  96:     i.light = a_i_light;
  97: i.color = a_i_color;
  98: i.transform = a_i_transform;
  99: i.normalMat = a_i_normalMat;
 100: 
 101: 
 102:     BlockFrag o = FLWMain(v, i);
 103: 
 104:     v2f_texCoords = o.texCoords;
 105: v2f_color = o.color;
 106: v2f_diffuse = o.diffuse;
 107: v2f_light = o.light;
 108: 
 109: }

[13:33:19] [main/ERROR]: Shader compilation log for flywheel:block.frag: No errors.

[13:33:19] [main/ERROR]: Source for shader 'flywheel:block.frag':
   1: #version 110
   2: 
   3: #if defined(USE_FOG)
   4: varying float FragDistance;
   5: uniform vec4 uFogColor;
   6: #endif
   7: 
   8: #if defined(USE_FOG_LINEAR)
   9: uniform vec2 uFogRange;
  10: 
  11: float FLWFogFactor() {
  12:     return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
  13: }
  14:     #endif
  15: 
  16:     #if defined(USE_FOG_EXP2)
  17: uniform float uFogDensity;
  18: 
  19: float FLWFogFactor() {
  20:     float dist = FragDistance * uFogDensity;
  21:     return 1. / exp2(dist * dist);
  22: }
  23:     #endif
  24: 
  25: uniform vec2 uTextureScale;
  26: uniform sampler2D uBlockAtlas;
  27: uniform sampler2D uLightMap;
  28: uniform sampler2D uCrumbling;
  29: 
  30: vec4 FLWBlockTexture(vec2 texCoords) {
  31:     vec4 cr = texture2D(uCrumbling, texCoords * uTextureScale);
  32:     float diffuseAlpha = texture2D(uBlockAtlas, texCoords).a;
  33:     cr.a = cr.a * diffuseAlpha;
  34:     return cr;
  35: }
  36: 
  37: void FLWFinalizeColor(vec4 color) {
  38:     #if defined(USE_FOG)
  39:     float a = color.a;
  40:     float fog = clamp(FLWFogFactor(), 0., 1.);
  41: 
  42:     color = mix(uFogColor, color, fog);
  43:     color.a = a;
  44:     #endif
  45: 
  46:     gl_FragColor = color;
  47: }
  48: 
  49: vec4 FLWLight(vec2 lightCoords) {
  50:     return vec4(1.);
  51: }
  52: 
  53: 
  54: 
  55: struct BlockFrag {
  56:     vec2 texCoords;
  57:     vec4 color;
  58:     float diffuse;
  59:     vec2 light;
  60: };
  61: 
  62: void FLWMain(BlockFrag r) {
  63:     vec4 tex = FLWBlockTexture(r.texCoords);
  64: 
  65:     vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;
  66: 
  67: //    flw_WorldPos = ;
  68: //    flw_Normal = ;
  69: //    flw_Albedo = tex.rgb;
  70: //    flw_Alpha = tex.a;
  71: //    flw_LightMap = r.light;
  72: //    flw_Tint = r.color;
  73:     FLWFinalizeColor(color);
  74: }
  75: 
  76: varying vec2 v2f_texCoords;
  77: varying vec4 v2f_color;
  78: varying float v2f_diffuse;
  79: varying vec2 v2f_light;
  80: 
  81: 
  82: //vec3 flw_WorldPos;
  83: //vec3 flw_Normal;
  84: //vec3 flw_Albedo;
  85: //float flw_Alpha;
  86: //vec2 flw_LightMap;
  87: //vec4 flw_Tint;
  88: 
  89: void main() {
  90:     BlockFrag f;
  91:     f.texCoords = v2f_texCoords;
  92: f.color = v2f_color;
  93: f.diffuse = v2f_diffuse;
  94: f.light = v2f_light;
  95: 
  96: 
  97:     FLWMain(f);
  98: }

[13:33:20] [main/INFO]: Loading context 'flywheel:context/world'
[13:33:20] [main/ERROR]: Shader compilation log for create:rotating.vert: No errors.

[13:33:20] [main/ERROR]: Source for shader 'create:rotating.vert':
   1: #version 110
   2: #define DEBUG_RAINBOW
   3: 
   4: #define PI 3.1415926538
   5: 
   6: uniform float uTime;
   7: uniform mat4 uViewProjection;
   8: uniform vec3 uCameraPos;
   9: 
  10: #if defined(USE_FOG)
  11: varying float FragDistance;
  12: #endif
  13: 
  14: void FLWFinalizeWorldPos(inout vec4 worldPos) {
  15:     #if defined(USE_FOG)
  16:     FragDistance = length(worldPos.xyz - uCameraPos);
  17:     #endif
  18: 
  19:     gl_Position = uViewProjection * worldPos;
  20: }
  21: 
  22: void FLWFinalizeNormal(inout vec3 normal) {
  23:     // noop
  24: }
  25: 
  26: 
  27: mat4 rotate(vec3 axis, float angle) {
  28:     float s = sin(angle);
  29:     float c = cos(angle);
  30:     float oc = 1. - c;
  31: 
  32:     vec3 sa = axis * s;
  33: 
  34:     mat4 mr = mat4(1.);
  35:     mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
  36:     mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
  37:     mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);
  38: 
  39:     return mr;
  40: }
  41: 
  42: mat4 rotation(vec3 rot) {
  43:     return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
  44: }
  45: 
  46: mat3 modelToNormal(mat4 mat) {
  47:     // Discard the edges. This won't be accurate for scaled or skewed matrices,
  48:     // but we don't have to work with those often.
  49:     mat3 m;
  50:     m[0] = mat[0].xyz;
  51:     m[1] = mat[1].xyz;
  52:     m[2] = mat[2].xyz;
  53:     return m;
  54: }
  55: 
  56: float diffuse(vec3 normal) {
  57:     vec3 n2 = normal * normal * vec3(.6, .25, .8);
  58:     return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
  59: }
  60: 
  61: 
  62: struct Rotating {
  63:     vec2 light;
  64:     vec4 color;
  65:     vec3 pos;
  66:     float speed;
  67:     float offset;
  68:     vec3 axis;
  69: };
  70: 
  71: 
  72: struct Vertex {
  73:     vec3 pos;
  74:     vec3 normal;
  75:     vec2 texCoords;
  76: };
  77: 
  78: struct BlockFrag {
  79:     vec2 texCoords;
  80:     vec4 color;
  81:     float diffuse;
  82:     vec2 light;
  83: };
  84: 
  85: mat4 kineticRotation(float offset, float speed, vec3 axis) {
  86:     float degrees = offset + uTime * speed * 3./10.;
  87:     float angle = fract(degrees / 360.) * PI * 2.;
  88: 
  89:     return rotate(axis, angle);
  90: }
  91: 
  92: BlockFrag FLWMain(Vertex v, Rotating instance) {
  93:     mat4 spin = kineticRotation(instance.offset, instance.speed, instance.axis);
  94: 
  95:     vec4 worldPos = spin * vec4(v.pos - .5, 1.);
  96:     worldPos += vec4(instance.pos + .5, 0.);
  97: 
  98:     vec3 norm = modelToNormal(spin) * v.normal;
  99: 
 100:     FLWFinalizeWorldPos(worldPos);
 101:     FLWFinalizeNormal(norm);
 102: 
 103:     BlockFrag b;
 104:     b.diffuse = diffuse(norm);
 105:     b.texCoords = v.texCoords;
 106:     b.light = instance.light;
 107: 
 108:     #if defined(DEBUG_RAINBOW)
 109:     b.color = instance.color;
 110:     #elif defined(DEBUG_NORMAL)
 111:     b.color = vec4(norm, 1.);
 112:     #else
 113:     b.color = vec4(1.);
 114:     #endif
 115: 
 116:     return b;
 117: }
 118: attribute vec3 a_v_pos;
 119: attribute vec3 a_v_normal;
 120: attribute vec2 a_v_texCoords;
 121: 
 122: attribute vec2 a_i_light;
 123: attribute vec4 a_i_color;
 124: attribute vec3 a_i_pos;
 125: attribute float a_i_speed;
 126: attribute float a_i_offset;
 127: attribute vec3 a_i_axis;
 128: 
 129: 
 130: varying vec2 v2f_texCoords;
 131: varying vec4 v2f_color;
 132: varying float v2f_diffuse;
 133: varying vec2 v2f_light;
 134: 
 135: 
 136: void main() {
 137:     Vertex v;
 138:     v.pos = a_v_pos;
 139: v.normal = a_v_normal;
 140: v.texCoords = a_v_texCoords;
 141: 
 142: 
 143:     Rotating i;
 144:     i.light = a_i_light;
 145: i.color = a_i_color;
 146: i.pos = a_i_pos;
 147: i.speed = a_i_speed;
 148: i.offset = a_i_offset;
 149: i.axis = a_i_axis;
 150: 
 151: 
 152:     BlockFrag o = FLWMain(v, i);
 153: 
 154:     v2f_texCoords = o.texCoords;
 155: v2f_color = o.color;
 156: v2f_diffuse = o.diffuse;
 157: v2f_light = o.light;
 158: 
 159: }

[13:33:20] [main/ERROR]: Shader compilation log for flywheel:block.frag: No errors.

[13:33:20] [main/ERROR]: Source for shader 'flywheel:block.frag':
   1: #version 110
   2: #define DEBUG_RAINBOW
   3: 
   4: #if defined(USE_FOG)
   5: varying float FragDistance;
   6: uniform vec4 uFogColor;
   7: #endif
   8: 
   9: #if defined(USE_FOG_LINEAR)
  10: uniform vec2 uFogRange;
  11: 
  12: float FLWFogFactor() {
  13:     return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
  14: }
  15:     #endif
  16: 
  17:     #if defined(USE_FOG_EXP2)
  18: uniform float uFogDensity;
  19: 
  20: float FLWFogFactor() {
  21:     float dist = FragDistance * uFogDensity;
  22:     return 1. / exp2(dist * dist);
  23: }
  24:     #endif
  25: // Adjust the [0,1] normalized lightmap value based on the texture matrix from LightTexture#enableLightmap
  26: vec2 shiftLight(vec2 lm) {
  27:     return lm * 0.99609375 + 0.03125;// * 255/256 + 1/32
  28: }
  29: 
  30: uniform sampler2D uBlockAtlas;
  31: uniform sampler2D uLightMap;
  32: 
  33: vec4 FLWBlockTexture(vec2 texCoords) {
  34:     return texture2D(uBlockAtlas, texCoords);
  35: }
  36: 
  37: void FLWFinalizeColor(vec4 color) {
  38:     #if defined(USE_FOG)
  39:     float a = color.a;
  40:     float fog = clamp(FLWFogFactor(), 0., 1.);
  41: 
  42:     color = mix(uFogColor, color, fog);
  43:     color.a = a;
  44:     #endif
  45: 
  46:     gl_FragColor = color;
  47: }
  48: 
  49: vec4 FLWLight(vec2 lightCoords) {
  50:     return texture2D(uLightMap, shiftLight(lightCoords));
  51: }
  52: 
  53: 
  54: 
  55: struct BlockFrag {
  56:     vec2 texCoords;
  57:     vec4 color;
  58:     float diffuse;
  59:     vec2 light;
  60: };
  61: 
  62: void FLWMain(BlockFrag r) {
  63:     vec4 tex = FLWBlockTexture(r.texCoords);
  64: 
  65:     vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;
  66: 
  67: //    flw_WorldPos = ;
  68: //    flw_Normal = ;
  69: //    flw_Albedo = tex.rgb;
  70: //    flw_Alpha = tex.a;
  71: //    flw_LightMap = r.light;
  72: //    flw_Tint = r.color;
  73:     FLWFinalizeColor(color);
  74: }
  75: 
  76: varying vec2 v2f_texCoords;
  77: varying vec4 v2f_color;
  78: varying float v2f_diffuse;
  79: varying vec2 v2f_light;
  80: 
  81: 
  82: //vec3 flw_WorldPos;
  83: //vec3 flw_Normal;
  84: //vec3 flw_Albedo;
  85: //float flw_Alpha;
  86: //vec2 flw_LightMap;
  87: //vec4 flw_Tint;
  88: 
  89: void main() {
  90:     BlockFrag f;
  91:     f.texCoords = v2f_texCoords;
  92: f.color = v2f_color;
  93: f.diffuse = v2f_diffuse;
  94: f.light = v2f_light;
  95: 
  96: 
  97:     FLWMain(f);
  98: }

[13:33:20] [main/ERROR]: Shader compilation log for create:rotating.vert: No errors.

[13:33:20] [main/ERROR]: Source for shader 'create:rotating.vert':
   1: #version 110
   2: #define DEBUG_NORMAL
   3: 
   4: #define PI 3.1415926538
   5: 
   6: uniform float uTime;
   7: uniform mat4 uViewProjection;
   8: uniform vec3 uCameraPos;
   9: 
  10: #if defined(USE_FOG)
  11: varying float FragDistance;
  12: #endif
  13: 
  14: void FLWFinalizeWorldPos(inout vec4 worldPos) {
  15:     #if defined(USE_FOG)
  16:     FragDistance = length(worldPos.xyz - uCameraPos);
  17:     #endif
  18: 
  19:     gl_Position = uViewProjection * worldPos;
  20: }
  21: 
  22: void FLWFinalizeNormal(inout vec3 normal) {
  23:     // noop
  24: }
  25: 
  26: 
  27: mat4 rotate(vec3 axis, float angle) {
  28:     float s = sin(angle);
  29:     float c = cos(angle);
  30:     float oc = 1. - c;
  31: 
  32:     vec3 sa = axis * s;
  33: 
  34:     mat4 mr = mat4(1.);
  35:     mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
  36:     mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
  37:     mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);
  38: 
  39:     return mr;
  40: }
  41: 
  42: mat4 rotation(vec3 rot) {
  43:     return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
  44: }
  45: 
  46: mat3 modelToNormal(mat4 mat) {
  47:     // Discard the edges. This won't be accurate for scaled or skewed matrices,
  48:     // but we don't have to work with those often.
  49:     mat3 m;
  50:     m[0] = mat[0].xyz;
  51:     m[1] = mat[1].xyz;
  52:     m[2] = mat[2].xyz;
  53:     return m;
  54: }
  55: 
  56: float diffuse(vec3 normal) {
  57:     vec3 n2 = normal * normal * vec3(.6, .25, .8);
  58:     return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
  59: }
  60: 
  61: 
  62: struct Rotating {
  63:     vec2 light;
  64:     vec4 color;
  65:     vec3 pos;
  66:     float speed;
  67:     float offset;
  68:     vec3 axis;
  69: };
  70: 
  71: 
  72: struct Vertex {
  73:     vec3 pos;
  74:     vec3 normal;
  75:     vec2 texCoords;
  76: };
  77: 
  78: struct BlockFrag {
  79:     vec2 texCoords;
  80:     vec4 color;
  81:     float diffuse;
  82:     vec2 light;
  83: };
  84: 
  85: mat4 kineticRotation(float offset, float speed, vec3 axis) {
  86:     float degrees = offset + uTime * speed * 3./10.;
  87:     float angle = fract(degrees / 360.) * PI * 2.;
  88: 
  89:     return rotate(axis, angle);
  90: }
  91: 
  92: BlockFrag FLWMain(Vertex v, Rotating instance) {
  93:     mat4 spin = kineticRotation(instance.offset, instance.speed, instance.axis);
  94: 
  95:     vec4 worldPos = spin * vec4(v.pos - .5, 1.);
  96:     worldPos += vec4(instance.pos + .5, 0.);
  97: 
  98:     vec3 norm = modelToNormal(spin) * v.normal;
  99: 
 100:     FLWFinalizeWorldPos(worldPos);
 101:     FLWFinalizeNormal(norm);
 102: 
 103:     BlockFrag b;
 104:     b.diffuse = diffuse(norm);
 105:     b.texCoords = v.texCoords;
 106:     b.light = instance.light;
 107: 
 108:     #if defined(DEBUG_RAINBOW)
 109:     b.color = instance.color;
 110:     #elif defined(DEBUG_NORMAL)
 111:     b.color = vec4(norm, 1.);
 112:     #else
 113:     b.color = vec4(1.);
 114:     #endif
 115: 
 116:     return b;
 117: }
 118: attribute vec3 a_v_pos;
 119: attribute vec3 a_v_normal;
 120: attribute vec2 a_v_texCoords;
 121: 
 122: attribute vec2 a_i_light;
 123: attribute vec4 a_i_color;
 124: attribute vec3 a_i_pos;
 125: attribute float a_i_speed;
 126: attribute float a_i_offset;
 127: attribute vec3 a_i_axis;
 128: 
 129: 
 130: varying vec2 v2f_texCoords;
 131: varying vec4 v2f_color;
 132: varying float v2f_diffuse;
 133: varying vec2 v2f_light;
 134: 
 135: 
 136: void main() {
 137:     Vertex v;
 138:     v.pos = a_v_pos;
 139: v.normal = a_v_normal;
 140: v.texCoords = a_v_texCoords;
 141: 
 142: 
 143:     Rotating i;
 144:     i.light = a_i_light;
 145: i.color = a_i_color;
 146: i.pos = a_i_pos;
 147: i.speed = a_i_speed;
 148: i.offset = a_i_offset;
 149: i.axis = a_i_axis;
 150: 
 151: 
 152:     BlockFrag o = FLWMain(v, i);
 153: 
 154:     v2f_texCoords = o.texCoords;
 155: v2f_color = o.color;
 156: v2f_diffuse = o.diffuse;
 157: v2f_light = o.light;
 158: 
 159: }

[13:33:20] [main/ERROR]: Shader compilation log for flywheel:block.frag: No errors.

[13:33:20] [main/ERROR]: Source for shader 'flywheel:block.frag':
   1: #version 110
   2: #define DEBUG_NORMAL
   3: 
   4: #if defined(USE_FOG)
   5: varying float FragDistance;
   6: uniform vec4 uFogColor;
   7: #endif
   8: 
   9: #if defined(USE_FOG_LINEAR)
  10: uniform vec2 uFogRange;
  11: 
  12: float FLWFogFactor() {
  13:     return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
  14: }
  15:     #endif
  16: 
  17:     #if defined(USE_FOG_EXP2)
  18: uniform float uFogDensity;
  19: 
  20: float FLWFogFactor() {
  21:     float dist = FragDistance * uFogDensity;
  22:     return 1. / exp2(dist * dist);
  23: }
  24:     #endif
  25: // Adjust the [0,1] normalized lightmap value based on the texture matrix from LightTexture#enableLightmap
  26: vec2 shiftLight(vec2 lm) {
  27:     return lm * 0.99609375 + 0.03125;// * 255/256 + 1/32
  28: }
  29: 
  30: uniform sampler2D uBlockAtlas;
  31: uniform sampler2D uLightMap;
  32: 
  33: vec4 FLWBlockTexture(vec2 texCoords) {
  34:     return texture2D(uBlockAtlas, texCoords);
  35: }
  36: 
  37: void FLWFinalizeColor(vec4 color) {
  38:     #if defined(USE_FOG)
  39:     float a = color.a;
  40:     float fog = clamp(FLWFogFactor(), 0., 1.);
  41: 
  42:     color = mix(uFogColor, color, fog);
  43:     color.a = a;
  44:     #endif
  45: 
  46:     gl_FragColor = color;
  47: }
  48: 
  49: vec4 FLWLight(vec2 lightCoords) {
  50:     return texture2D(uLightMap, shiftLight(lightCoords));
  51: }
  52: 
  53: 
  54: 
  55: struct BlockFrag {
  56:     vec2 texCoords;
  57:     vec4 color;
  58:     float diffuse;
  59:     vec2 light;
  60: };
  61: 
  62: void FLWMain(BlockFrag r) {
  63:     vec4 tex = FLWBlockTexture(r.texCoords);
  64: 
  65:     vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;
  66: 
  67: //    flw_WorldPos = ;
  68: //    flw_Normal = ;
  69: //    flw_Albedo = tex.rgb;
  70: //    flw_Alpha = tex.a;
  71: //    flw_LightMap = r.light;
  72: //    flw_Tint = r.color;
  73:     FLWFinalizeColor(color);
  74: }
  75: 
  76: varying vec2 v2f_texCoords;
  77: varying vec4 v2f_color;
  78: varying float v2f_diffuse;
  79: varying vec2 v2f_light;
  80: 
  81: 
  82: //vec3 flw_WorldPos;
  83: //vec3 flw_Normal;
  84: //vec3 flw_Albedo;
  85: //float flw_Alpha;
  86: //vec2 flw_LightMap;
  87: //vec4 flw_Tint;
  88: 
  89: void main() {
  90:     BlockFrag f;
  91:     f.texCoords = v2f_texCoords;
  92: f.color = v2f_color;
  93: f.diffuse = v2f_diffuse;
  94: f.light = v2f_light;
  95: 
  96: 
  97:     FLWMain(f);
  98: }

[13:33:20] [main/ERROR]: Shader compilation log for create:rotating.vert: No errors.

[13:33:20] [main/ERROR]: Source for shader 'create:rotating.vert':
   1: #version 110
   2: #define USE_FOG
   3: #define USE_FOG_LINEAR
   4: 
   5: #define PI 3.1415926538
   6: 
   7: uniform float uTime;
   8: uniform mat4 uViewProjection;
   9: uniform vec3 uCameraPos;
  10: 
  11: #if defined(USE_FOG)
  12: varying float FragDistance;
  13: #endif
  14: 
  15: void FLWFinalizeWorldPos(inout vec4 worldPos) {
  16:     #if defined(USE_FOG)
  17:     FragDistance = length(worldPos.xyz - uCameraPos);
  18:     #endif
  19: 
  20:     gl_Position = uViewProjection * worldPos;
  21: }
  22: 
  23: void FLWFinalizeNormal(inout vec3 normal) {
  24:     // noop
  25: }
  26: 
  27: 
  28: mat4 rotate(vec3 axis, float angle) {
  29:     float s = sin(angle);
  30:     float c = cos(angle);
  31:     float oc = 1. - c;
  32: 
  33:     vec3 sa = axis * s;
  34: 
  35:     mat4 mr = mat4(1.);
  36:     mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
  37:     mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
  38:     mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);
  39: 
  40:     return mr;
  41: }
  42: 
  43: mat4 rotation(vec3 rot) {
  44:     return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
  45: }
  46: 
  47: mat3 modelToNormal(mat4 mat) {
  48:     // Discard the edges. This won't be accurate for scaled or skewed matrices,
  49:     // but we don't have to work with those often.
  50:     mat3 m;
  51:     m[0] = mat[0].xyz;
  52:     m[1] = mat[1].xyz;
  53:     m[2] = mat[2].xyz;
  54:     return m;
  55: }
  56: 
  57: float diffuse(vec3 normal) {
  58:     vec3 n2 = normal * normal * vec3(.6, .25, .8);
  59:     return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
  60: }
  61: 
  62: 
  63: struct Rotating {
  64:     vec2 light;
  65:     vec4 color;
  66:     vec3 pos;
  67:     float speed;
  68:     float offset;
  69:     vec3 axis;
  70: };
  71: 
  72: 
  73: struct Vertex {
  74:     vec3 pos;
  75:     vec3 normal;
  76:     vec2 texCoords;
  77: };
  78: 
  79: struct BlockFrag {
  80:     vec2 texCoords;
  81:     vec4 color;
  82:     float diffuse;
  83:     vec2 light;
  84: };
  85: 
  86: mat4 kineticRotation(float offset, float speed, vec3 axis) {
  87:     float degrees = offset + uTime * speed * 3./10.;
  88:     float angle = fract(degrees / 360.) * PI * 2.;
  89: 
  90:     return rotate(axis, angle);
  91: }
  92: 
  93: BlockFrag FLWMain(Vertex v, Rotating instance) {
  94:     mat4 spin = kineticRotation(instance.offset, instance.speed, instance.axis);
  95: 
  96:     vec4 worldPos = spin * vec4(v.pos - .5, 1.);
  97:     worldPos += vec4(instance.pos + .5, 0.);
  98: 
  99:     vec3 norm = modelToNormal(spin) * v.normal;
 100: 
 101:     FLWFinalizeWorldPos(worldPos);
 102:     FLWFinalizeNormal(norm);
 103: 
 104:     BlockFrag b;
 105:     b.diffuse = diffuse(norm);
 106:     b.texCoords = v.texCoords;
 107:     b.light = instance.light;
 108: 
 109:     #if defined(DEBUG_RAINBOW)
 110:     b.color = instance.color;
 111:     #elif defined(DEBUG_NORMAL)
 112:     b.color = vec4(norm, 1.);
 113:     #else
 114:     b.color = vec4(1.);
 115:     #endif
 116: 
 117:     return b;
 118: }
 119: attribute vec3 a_v_pos;
 120: attribute vec3 a_v_normal;
 121: attribute vec2 a_v_texCoords;
 122: 
 123: attribute vec2 a_i_light;
 124: attribute vec4 a_i_color;
 125: attribute vec3 a_i_pos;
 126: attribute float a_i_speed;
 127: attribute float a_i_offset;
 128: attribute vec3 a_i_axis;
 129: 
 130: 
 131: varying vec2 v2f_texCoords;
 132: varying vec4 v2f_color;
 133: varying float v2f_diffuse;
 134: varying vec2 v2f_light;
 135: 
 136: 
 137: void main() {
 138:     Vertex v;
 139:     v.pos = a_v_pos;
 140: v.normal = a_v_normal;
 141: v.texCoords = a_v_texCoords;
 142: 
 143: 
 144:     Rotating i;
 145:     i.light = a_i_light;
 146: i.color = a_i_color;
 147: i.pos = a_i_pos;
 148: i.speed = a_i_speed;
 149: i.offset = a_i_offset;
 150: i.axis = a_i_axis;
 151: 
 152: 
 153:     BlockFrag o = FLWMain(v, i);
 154: 
 155:     v2f_texCoords = o.texCoords;
 156: v2f_color = o.color;
 157: v2f_diffuse = o.diffuse;
 158: v2f_light = o.light;
 159: 
 160: }

[13:33:20] [main/ERROR]: Shader compilation log for flywheel:block.frag: No errors.

[13:33:20] [main/ERROR]: Source for shader 'flywheel:block.frag':
   1: #version 110
   2: #define USE_FOG
   3: #define USE_FOG_LINEAR
   4: 
   5: #if defined(USE_FOG)
   6: varying float FragDistance;
   7: uniform vec4 uFogColor;
   8: #endif
   9: 
  10: #if defined(USE_FOG_LINEAR)
  11: uniform vec2 uFogRange;
  12: 
  13: float FLWFogFactor() {
  14:     return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
  15: }
  16:     #endif
  17: 
  18:     #if defined(USE_FOG_EXP2)
  19: uniform float uFogDensity;
  20: 
  21: float FLWFogFactor() {
  22:     float dist = FragDistance * uFogDensity;
  23:     return 1. / exp2(dist * dist);
  24: }
  25:     #endif
  26: // Adjust the [0,1] normalized lightmap value based on the texture matrix from LightTexture#enableLightmap
  27: vec2 shiftLight(vec2 lm) {
  28:     return lm * 0.99609375 + 0.03125;// * 255/256 + 1/32
  29: }
  30: 
  31: uniform sampler2D uBlockAtlas;
  32: uniform sampler2D uLightMap;
  33: 
  34: vec4 FLWBlockTexture(vec2 texCoords) {
  35:     return texture2D(uBlockAtlas, texCoords);
  36: }
  37: 
  38: void FLWFinalizeColor(vec4 color) {
  39:     #if defined(USE_FOG)
  40:     float a = color.a;
  41:     float fog = clamp(FLWFogFactor(), 0., 1.);
  42: 
  43:     color = mix(uFogColor, color, fog);
  44:     color.a = a;
  45:     #endif
  46: 
  47:     gl_FragColor = color;
  48: }
  49: 
  50: vec4 FLWLight(vec2 lightCoords) {
  51:     return texture2D(uLightMap, shiftLight(lightCoords));
  52: }
  53: 
  54: 
  55: 
  56: struct BlockFrag {
  57:     vec2 texCoords;
  58:     vec4 color;
  59:     float diffuse;
  60:     vec2 light;
  61: };
  62: 
  63: void FLWMain(BlockFrag r) {
  64:     vec4 tex = FLWBlockTexture(r.texCoords);
  65: 
  66:     vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;
  67: 
  68: //    flw_WorldPos = ;
  69: //    flw_Normal = ;
  70: //    flw_Albedo = tex.rgb;
  71: //    flw_Alpha = tex.a;
  72: //    flw_LightMap = r.light;
  73: //    flw_Tint = r.color;
  74:     FLWFinalizeColor(color);
  75: }
  76: 
  77: varying vec2 v2f_texCoords;
  78: varying vec4 v2f_color;
  79: varying float v2f_diffuse;
  80: varying vec2 v2f_light;
  81: 
  82: 
  83: //vec3 flw_WorldPos;
  84: //vec3 flw_Normal;
  85: //vec3 flw_Albedo;
  86: //float flw_Alpha;
  87: //vec2 flw_LightMap;
  88: //vec4 flw_Tint;
  89: 
  90: void main() {
  91:     BlockFrag f;
  92:     f.texCoords = v2f_texCoords;
  93: f.color = v2f_color;
  94: f.diffuse = v2f_diffuse;
  95: f.light = v2f_light;
  96: 
  97: 
  98:     FLWMain(f);
  99: }

[13:33:20] [main/ERROR]: Shader compilation log for create:rotating.vert: No errors.

[13:33:20] [main/ERROR]: Source for shader 'create:rotating.vert':
   1: #version 110
   2: #define USE_FOG
   3: #define USE_FOG_EXP2
   4: 
   5: #define PI 3.1415926538
   6: 
   7: uniform float uTime;
   8: uniform mat4 uViewProjection;
   9: uniform vec3 uCameraPos;
  10: 
  11: #if defined(USE_FOG)
  12: varying float FragDistance;
  13: #endif
  14: 
  15: void FLWFinalizeWorldPos(inout vec4 worldPos) {
  16:     #if defined(USE_FOG)
  17:     FragDistance = length(worldPos.xyz - uCameraPos);
  18:     #endif
  19: 
  20:     gl_Position = uViewProjection * worldPos;
  21: }
  22: 
  23: void FLWFinalizeNormal(inout vec3 normal) {
  24:     // noop
  25: }
  26: 
  27: 
  28: mat4 rotate(vec3 axis, float angle) {
  29:     float s = sin(angle);
  30:     float c = cos(angle);
  31:     float oc = 1. - c;
  32: 
  33:     vec3 sa = axis * s;
  34: 
  35:     mat4 mr = mat4(1.);
  36:     mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
  37:     mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
  38:     mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);
  39: 
  40:     return mr;
  41: }
  42: 
  43: mat4 rotation(vec3 rot) {
  44:     return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
  45: }
  46: 
  47: mat3 modelToNormal(mat4 mat) {
  48:     // Discard the edges. This won't be accurate for scaled or skewed matrices,
  49:     // but we don't have to work with those often.
  50:     mat3 m;
  51:     m[0] = mat[0].xyz;
  52:     m[1] = mat[1].xyz;
  53:     m[2] = mat[2].xyz;
  54:     return m;
  55: }
  56: 
  57: float diffuse(vec3 normal) {
  58:     vec3 n2 = normal * normal * vec3(.6, .25, .8);
  59:     return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
  60: }
  61: 
  62: 
  63: struct Rotating {
  64:     vec2 light;
  65:     vec4 color;
  66:     vec3 pos;
  67:     float speed;
  68:     float offset;
  69:     vec3 axis;
  70: };
  71: 
  72: 
  73: struct Vertex {
  74:     vec3 pos;
  75:     vec3 normal;
  76:     vec2 texCoords;
  77: };
  78: 
  79: struct BlockFrag {
  80:     vec2 texCoords;
  81:     vec4 color;
  82:     float diffuse;
  83:     vec2 light;
  84: };
  85: 
  86: mat4 kineticRotation(float offset, float speed, vec3 axis) {
  87:     float degrees = offset + uTime * speed * 3./10.;
  88:     float angle = fract(degrees / 360.) * PI * 2.;
  89: 
  90:     return rotate(axis, angle);
  91: }
  92: 
  93: BlockFrag FLWMain(Vertex v, Rotating instance) {
  94:     mat4 spin = kineticRotation(instance.offset, instance.speed, instance.axis);
  95: 
  96:     vec4 worldPos = spin * vec4(v.pos - .5, 1.);
  97:     worldPos += vec4(instance.pos + .5, 0.);
  98: 
  99:     vec3 norm = modelToNormal(spin) * v.normal;
 100: 
 101:     FLWFinalizeWorldPos(worldPos);
 102:     FLWFinalizeNormal(norm);
 103: 
 104:     BlockFrag b;
 105:     b.diffuse = diffuse(norm);
 106:     b.texCoords = v.texCoords;
 107:     b.light = instance.light;
 108: 
 109:     #if defined(DEBUG_RAINBOW)
 110:     b.color = instance.color;
 111:     #elif defined(DEBUG_NORMAL)
 112:     b.color = vec4(norm, 1.);
 113:     #else
 114:     b.color = vec4(1.);
 115:     #endif
 116: 
 117:     return b;
 118: }
 119: attribute vec3 a_v_pos;
 120: attribute vec3 a_v_normal;
 121: attribute vec2 a_v_texCoords;
 122: 
 123: attribute vec2 a_i_light;
 124: attribute vec4 a_i_color;
 125: attribute vec3 a_i_pos;
 126: attribute float a_i_speed;
 127: attribute float a_i_offset;
 128: attribute vec3 a_i_axis;
 129: 
 130: 
 131: varying vec2 v2f_texCoords;
 132: varying vec4 v2f_color;
 133: varying float v2f_diffuse;
 134: varying vec2 v2f_light;
 135: 
 136: 
 137: void main() {
 138:     Vertex v;
 139:     v.pos = a_v_pos;
 140: v.normal = a_v_normal;
 141: v.texCoords = a_v_texCoords;
 142: 
 143: 
 144:     Rotating i;
 145:     i.light = a_i_light;
 146: i.color = a_i_color;
 147: i.pos = a_i_pos;
 148: i.speed = a_i_speed;
 149: i.offset = a_i_offset;
 150: i.axis = a_i_axis;
 151: 
 152: 
 153:     BlockFrag o = FLWMain(v, i);
 154: 
 155:     v2f_texCoords = o.texCoords;
 156: v2f_color = o.color;
 157: v2f_diffuse = o.diffuse;
 158: v2f_light = o.light;
 159: 
 160: }

[13:33:20] [main/ERROR]: Shader compilation log for flywheel:block.frag: No errors.

[13:33:20] [main/ERROR]: Source for shader 'flywheel:block.frag':
   1: #version 110
   2: #define USE_FOG
   3: #define USE_FOG_EXP2
   4: 
   5: #if defined(USE_FOG)
   6: varying float FragDistance;
   7: uniform vec4 uFogColor;
   8: #endif
   9: 
  10: #if defined(USE_FOG_LINEAR)
  11: uniform vec2 uFogRange;
  12: 
  13: float FLWFogFactor() {
  14:     return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
  15: }
  16:     #endif
  17: 
  18:     #if defined(USE_FOG_EXP2)
  19: uniform float uFogDensity;
  20: 
  21: float FLWFogFactor() {
  22:     float dist = FragDistance * uFogDensity;
  23:     return 1. / exp2(dist * dist);
  24: }
  25:     #endif
  26: // Adjust the [0,1] normalized lightmap value based on the texture matrix from LightTexture#enableLightmap
  27: vec2 shiftLight(vec2 lm) {
  28:     return lm * 0.99609375 + 0.03125;// * 255/256 + 1/32
  29: }
  30: 
  31: uniform sampler2D uBlockAtlas;
  32: uniform sampler2D uLightMap;
  33: 
  34: vec4 FLWBlockTexture(vec2 texCoords) {
  35:     return texture2D(uBlockAtlas, texCoords);
  36: }
  37: 
  38: void FLWFinalizeColor(vec4 color) {
  39:     #if defined(USE_FOG)
  40:     float a = color.a;
  41:     float fog = clamp(FLWFogFactor(), 0., 1.);
  42: 
  43:     color = mix(uFogColor, color, fog);
  44:     color.a = a;
  45:     #endif
  46: 
  47:     gl_FragColor = color;
  48: }
  49: 
  50: vec4 FLWLight(vec2 lightCoords) {
  51:     return texture2D(uLightMap, shiftLight(lightCoords));
  52: }
  53: 
  54: 
  55: 
  56: struct BlockFrag {
  57:     vec2 texCoords;
  58:     vec4 color;
  59:     float diffuse;
  60:     vec2 light;
  61: };
  62: 
  63: void FLWMain(BlockFrag r) {
  64:     vec4 tex = FLWBlockTexture(r.texCoords);
  65: 
  66:     vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;
  67: 
  68: //    flw_WorldPos = ;
  69: //    flw_Normal = ;
  70: //    flw_Albedo = tex.rgb;
  71: //    flw_Alpha = tex.a;
  72: //    flw_LightMap = r.light;
  73: //    flw_Tint = r.color;
  74:     FLWFinalizeColor(color);
  75: }
  76: 
  77: varying vec2 v2f_texCoords;
  78: varying vec4 v2f_color;
  79: varying float v2f_diffuse;
  80: varying vec2 v2f_light;
  81: 
  82: 
  83: //vec3 flw_WorldPos;
  84: //vec3 flw_Normal;
  85: //vec3 flw_Albedo;
  86: //float flw_Alpha;
  87: //vec2 flw_LightMap;
  88: //vec4 flw_Tint;
  89: 
  90: void main() {
  91:     BlockFrag f;
  92:     f.texCoords = v2f_texCoords;
  93: f.color = v2f_color;
  94: f.diffuse = v2f_diffuse;
  95: f.light = v2f_light;
  96: 
  97: 
  98:     FLWMain(f);
  99: }

[13:33:20] [main/ERROR]: Shader compilation log for create:rotating.vert: No errors.

[13:33:20] [main/ERROR]: Source for shader 'create:rotating.vert':
   1: #version 110
   2: 
   3: #define PI 3.1415926538
   4: 
   5: uniform float uTime;
   6: uniform mat4 uViewProjection;
   7: uniform vec3 uCameraPos;
   8: 
   9: #if defined(USE_FOG)
  10: varying float FragDistance;
  11: #endif
  12: 
  13: void FLWFinalizeWorldPos(inout vec4 worldPos) {
  14:     #if defined(USE_FOG)
  15:     FragDistance = length(worldPos.xyz - uCameraPos);
  16:     #endif
  17: 
  18:     gl_Position = uViewProjection * worldPos;
  19: }
  20: 
  21: void FLWFinalizeNormal(inout vec3 normal) {
  22:     // noop
  23: }
  24: 
  25: 
  26: mat4 rotate(vec3 axis, float angle) {
  27:     float s = sin(angle);
  28:     float c = cos(angle);
  29:     float oc = 1. - c;
  30: 
  31:     vec3 sa = axis * s;
  32: 
  33:     mat4 mr = mat4(1.);
  34:     mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
  35:     mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
  36:     mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);
  37: 
  38:     return mr;
  39: }
  40: 
  41: mat4 rotation(vec3 rot) {
  42:     return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
  43: }
  44: 
  45: mat3 modelToNormal(mat4 mat) {
  46:     // Discard the edges. This won't be accurate for scaled or skewed matrices,
  47:     // but we don't have to work with those often.
  48:     mat3 m;
  49:     m[0] = mat[0].xyz;
  50:     m[1] = mat[1].xyz;
  51:     m[2] = mat[2].xyz;
  52:     return m;
  53: }
  54: 
  55: float diffuse(vec3 normal) {
  56:     vec3 n2 = normal * normal * vec3(.6, .25, .8);
  57:     return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
  58: }
  59: 
  60: 
  61: struct Rotating {
  62:     vec2 light;
  63:     vec4 color;
  64:     vec3 pos;
  65:     float speed;
  66:     float offset;
  67:     vec3 axis;
  68: };
  69: 
  70: 
  71: struct Vertex {
  72:     vec3 pos;
  73:     vec3 normal;
  74:     vec2 texCoords;
  75: };
  76: 
  77: struct BlockFrag {
  78:     vec2 texCoords;
  79:     vec4 color;
  80:     float diffuse;
  81:     vec2 light;
  82: };
  83: 
  84: mat4 kineticRotation(float offset, float speed, vec3 axis) {
  85:     float degrees = offset + uTime * speed * 3./10.;
  86:     float angle = fract(degrees / 360.) * PI * 2.;
  87: 
  88:     return rotate(axis, angle);
  89: }
  90: 
  91: BlockFrag FLWMain(Vertex v, Rotating instance) {
  92:     mat4 spin = kineticRotation(instance.offset, instance.speed, instance.axis);
  93: 
  94:     vec4 worldPos = spin * vec4(v.pos - .5, 1.);
  95:     worldPos += vec4(instance.pos + .5, 0.);
  96: 
  97:     vec3 norm = modelToNormal(spin) * v.normal;
  98: 
  99:     FLWFinalizeWorldPos(worldPos);
 100:     FLWFinalizeNormal(norm);
 101: 
 102:     BlockFrag b;
 103:     b.diffuse = diffuse(norm);
 104:     b.texCoords = v.texCoords;
 105:     b.light = instance.light;
 106: 
 107:     #if defined(DEBUG_RAINBOW)
 108:     b.color = instance.color;
 109:     #elif defined(DEBUG_NORMAL)
 110:     b.color = vec4(norm, 1.);
 111:     #else
 112:     b.color = vec4(1.);
 113:     #endif
 114: 
 115:     return b;
 116: }
 117: attribute vec3 a_v_pos;
 118: attribute vec3 a_v_normal;
 119: attribute vec2 a_v_texCoords;
 120: 
 121: attribute vec2 a_i_light;
 122: attribute vec4 a_i_color;
 123: attribute vec3 a_i_pos;
 124: attribute float a_i_speed;
 125: attribute float a_i_offset;
 126: attribute vec3 a_i_axis;
 127: 
 128: 
 129: varying vec2 v2f_texCoords;
 130: varying vec4 v2f_color;
 131: varying float v2f_diffuse;
 132: varying vec2 v2f_light;
 133: 
 134: 
 135: void main() {
 136:     Vertex v;
 137:     v.pos = a_v_pos;
 138: v.normal = a_v_normal;
 139: v.texCoords = a_v_texCoords;
 140: 
 141: 
 142:     Rotating i;
 143:     i.light = a_i_light;
 144: i.color = a_i_color;
 145: i.pos = a_i_pos;
 146: i.speed = a_i_speed;
 147: i.offset = a_i_offset;
 148: i.axis = a_i_axis;
 149: 
 150: 
 151:     BlockFrag o = FLWMain(v, i);
 152: 
 153:     v2f_texCoords = o.texCoords;
 154: v2f_color = o.color;
 155: v2f_diffuse = o.diffuse;
 156: v2f_light = o.light;
 157: 
 158: }

[13:33:20] [main/ERROR]: Shader compilation log for flywheel:block.frag: No errors.

[13:33:20] [main/ERROR]: Source for shader 'flywheel:block.frag':
   1: #version 110
   2: 
   3: #if defined(USE_FOG)
   4: varying float FragDistance;
   5: uniform vec4 uFogColor;
   6: #endif
   7: 
   8: #if defined(USE_FOG_LINEAR)
   9: uniform vec2 uFogRange;
  10: 
  11: float FLWFogFactor() {
  12:     return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
  13: }
  14:     #endif
  15: 
  16:     #if defined(USE_FOG_EXP2)
  17: uniform float uFogDensity;
  18: 
  19: float FLWFogFactor() {
  20:     float dist = FragDistance * uFogDensity;
  21:     return 1. / exp2(dist * dist);
  22: }
  23:     #endif
  24: // Adjust the [0,1] normalized lightmap value based on the texture matrix from LightTexture#enableLightmap
  25: vec2 shiftLight(vec2 lm) {
  26:     return lm * 0.99609375 + 0.03125;// * 255/256 + 1/32
  27: }
  28: 
  29: uniform sampler2D uBlockAtlas;
  30: uniform sampler2D uLightMap;
  31: 
  32: vec4 FLWBlockTexture(vec2 texCoords) {
  33:     return texture2D(uBlockAtlas, texCoords);
  34: }
  35: 
  36: void FLWFinalizeColor(vec4 color) {
  37:     #if defined(USE_FOG)
  38:     float a = color.a;
  39:     float fog = clamp(FLWFogFactor(), 0., 1.);
  40: 
  41:     color = mix(uFogColor, color, fog);
  42:     color.a = a;
  43:     #endif
  44: 
  45:     gl_FragColor = color;
  46: }
  47: 
  48: vec4 FLWLight(vec2 lightCoords) {
  49:     return texture2D(uLightMap, shiftLight(lightCoords));
  50: }
  51: 
  52: 
  53: 
  54: struct BlockFrag {
  55:     vec2 texCoords;
  56:     vec4 color;
  57:     float diffuse;
  58:     vec2 light;
  59: };
  60: 
  61: void FLWMain(BlockFrag r) {
  62:     vec4 tex = FLWBlockTexture(r.texCoords);
  63: 
  64:     vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;
  65: 
  66: //    flw_WorldPos = ;
  67: //    flw_Normal = ;
  68: //    flw_Albedo = tex.rgb;
  69: //    flw_Alpha = tex.a;
  70: //    flw_LightMap = r.light;
  71: //    flw_Tint = r.color;
  72:     FLWFinalizeColor(color);
  73: }
  74: 
  75: varying vec2 v2f_texCoords;
  76: varying vec4 v2f_color;
  77: varying float v2f_diffuse;
  78: varying vec2 v2f_light;
  79: 
  80: 
  81: //vec3 flw_WorldPos;
  82: //vec3 flw_Normal;
  83: //vec3 flw_Albedo;
  84: //float flw_Alpha;
  85: //vec2 flw_LightMap;
  86: //vec4 flw_Tint;
  87: 
  88: void main() {
  89:     BlockFrag f;
  90:     f.texCoords = v2f_texCoords;
  91: f.color = v2f_color;
  92: f.diffuse = v2f_diffuse;
  93: f.light = v2f_light;
  94: 
  95: 
  96:     FLWMain(f);
  97: }

[13:33:20] [main/ERROR]: Shader compilation log for create:contraption_actor.vert: No errors.

[13:33:20] [main/ERROR]: Source for shader 'create:contraption_actor.vert':
   1: #version 110
   2: #define DEBUG_NORMAL
   3: 
   4: #define PI 3.1415926538
   5: 
   6: uniform float uTime;
   7: uniform mat4 uViewProjection;
   8: uniform vec3 uCameraPos;
   9: 
  10: #if defined(USE_FOG)
  11: varying float FragDistance;
  12: #endif
  13: 
  14: void FLWFinalizeWorldPos(inout vec4 worldPos) {
  15:     #if defined(USE_FOG)
  16:     FragDistance = length(worldPos.xyz - uCameraPos);
  17:     #endif
  18: 
  19:     gl_Position = uViewProjection * worldPos;
  20: }
  21: 
  22: void FLWFinalizeNormal(inout vec3 normal) {
  23:     // noop
  24: }
  25: 
  26: 
  27: mat4 rotate(vec3 axis, float angle) {
  28:     float s = sin(angle);
  29:     float c = cos(angle);
  30:     float oc = 1. - c;
  31: 
  32:     vec3 sa = axis * s;
  33: 
  34:     mat4 mr = mat4(1.);
  35:     mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
  36:     mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
  37:     mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);
  38: 
  39:     return mr;
  40: }
  41: 
  42: mat4 rotation(vec3 rot) {
  43:     return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
  44: }
  45: 
  46: mat3 modelToNormal(mat4 mat) {
  47:     // Discard the edges. This won't be accurate for scaled or skewed matrices,
  48:     // but we don't have to work with those often.
  49:     mat3 m;
  50:     m[0] = mat[0].xyz;
  51:     m[1] = mat[1].xyz;
  52:     m[2] = mat[2].xyz;
  53:     return m;
  54: }
  55: 
  56: #define PIOVER2 1.5707963268
  57: 
  58: vec4 quat(vec3 axis, float angle) {
  59:     float halfAngle = angle * PIOVER2 / 180.0;
  60:     vec2 cs = sin(vec2(PIOVER2 - halfAngle, halfAngle)); // compute sin and cos in one instruction
  61:     return vec4(axis.xyz * cs.y,  cs.x);
  62: }
  63: 
  64: vec4 quatMult(vec4 q1, vec4 q2) {
  65:     // disgustingly vectorized quaternion multiplication
  66:     vec4 a = q1.w * q2.xyzw;
  67:     vec4 b = q1.x * q2.wzxy * vec4(1., -1., 1., -1.);
  68:     vec4 c = q1.y * q2.zwxy * vec4(1., 1., -1., -1.);
  69:     vec4 d = q1.z * q2.yxwz * vec4(-1., 1., 1., -1.);
  70: 
  71:     return a + b + c + d;
  72: }
  73: 
  74: vec3 rotateVertexByQuat(vec3 v, vec4 q) {
  75:     vec3 i = q.xyz;
  76:     return v + 2.0 * cross(i, cross(i, v) + q.w * v);
  77: }
  78: 
  79: vec3 rotateAbout(vec3 v, vec3 axis, float angle) {
  80:     return rotateVertexByQuat(v, quat(axis, angle));
  81: }
  82: 
  83: float diffuse(vec3 normal) {
  84:     vec3 n2 = normal * normal * vec3(.6, .25, .8);
  85:     return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
  86: }
  87: 
  88: 
  89: struct Actor {
  90:     vec3 pos;
  91:     vec2 light;
  92:     float offset;
  93:     vec3 axis;
  94:     vec4 rotation;
  95:     vec3 rotationCenter;
  96:     float speed;
  97: };
  98: 
  99: 
 100: struct Vertex {
 101:     vec3 pos;
 102:     vec3 normal;
 103:     vec2 texCoords;
 104: };
 105: 
 106: struct BlockFrag {
 107:     vec2 texCoords;
 108:     vec4 color;
 109:     float diffuse;
 110:     vec2 light;
 111: };
 112: 
 113: BlockFrag FLWMain(Vertex v, Actor instance) {
 114:     float degrees = instance.offset + uTime * instance.speed / 20.;
 115:     //float angle = fract(degrees / 360.) * PI * 2.;
 116: 
 117:     vec4 kineticRot = quat(instance.axis, degrees);
 118:     vec3 rotated = rotateVertexByQuat(v.pos - instance.rotationCenter, kineticRot) + instance.rotationCenter;
 119: 
 120:     vec4 worldPos = vec4(rotateVertexByQuat(rotated - .5, instance.rotation) + instance.pos + .5, 1.);
 121:     vec3 norm = rotateVertexByQuat(rotateVertexByQuat(v.normal, kineticRot), instance.rotation);
 122: 
 123:     FLWFinalizeWorldPos(worldPos);
 124:     FLWFinalizeNormal(norm);
 125: 
 126:     BlockFrag b;
 127:     b.diffuse = diffuse(norm);
 128:     b.texCoords = v.texCoords;
 129:     b.light = instance.light;
 130: 
 131:     #if defined(DEBUG_NORMAL)
 132:     b.color = vec4(norm, 1.);
 133:     #else
 134:     b.color = vec4(1.);
 135:     #endif
 136: 
 137:     return b;
 138: }
 139: attribute vec3 a_v_pos;
 140: attribute vec3 a_v_normal;
 141: attribute vec2 a_v_texCoords;
 142: 
 143: attribute vec3 a_i_pos;
 144: attribute vec2 a_i_light;
 145: attribute float a_i_offset;
 146: attribute vec3 a_i_axis;
 147: attribute vec4 a_i_rotation;
 148: attribute vec3 a_i_rotationCenter;
 149: attribute float a_i_speed;
 150: 
 151: 
 152: varying vec2 v2f_texCoords;
 153: varying vec4 v2f_color;
 154: varying float v2f_diffuse;
 155: varying vec2 v2f_light;
 156: 
 157: 
 158: void main() {
 159:     Vertex v;
 160:     v.pos = a_v_pos;
 161: v.normal = a_v_normal;
 162: v.texCoords = a_v_texCoords;
 163: 
 164: 
 165:     Actor i;
 166:     i.pos = a_i_pos;
 167: i.light = a_i_light;
 168: i.offset = a_i_offset;
 169: i.axis = a_i_axis;
 170: i.rotation = a_i_rotation;
 171: i.rotationCenter = a_i_rotationCenter;
 172: i.speed = a_i_speed;
 173: 
 174: 
 175:     BlockFrag o = FLWMain(v, i);
 176: 
 177:     v2f_texCoords = o.texCoords;
 178: v2f_color = o.color;
 179: v2f_diffuse = o.diffuse;
 180: v2f_light = o.light;
 181: 
 182: }

[13:33:20] [main/ERROR]: Shader compilation log for flywheel:block.frag: No errors.

[13:33:20] [main/ERROR]: Source for shader 'flywheel:block.frag':
   1: #version 110
   2: #define DEBUG_NORMAL
   3: 
   4: #if defined(USE_FOG)
   5: varying float FragDistance;
   6: uniform vec4 uFogColor;
   7: #endif
   8: 
   9: #if defined(USE_FOG_LINEAR)
  10: uniform vec2 uFogRange;
  11: 
  12: float FLWFogFactor() {
  13:     return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
  14: }
  15:     #endif
  16: 
  17:     #if defined(USE_FOG_EXP2)
  18: uniform float uFogDensity;
  19: 
  20: float FLWFogFactor() {
  21:     float dist = FragDistance * uFogDensity;
  22:     return 1. / exp2(dist * dist);
  23: }
  24:     #endif
  25: // Adjust the [0,1] normalized lightmap value based on the texture matrix from LightTexture#enableLightmap
  26: vec2 shiftLight(vec2 lm) {
  27:     return lm * 0.99609375 + 0.03125;// * 255/256 + 1/32
  28: }
  29: 
  30: uniform sampler2D uBlockAtlas;
  31: uniform sampler2D uLightMap;
  32: 
  33: vec4 FLWBlockTexture(vec2 texCoords) {
  34:     return texture2D(uBlockAtlas, texCoords);
  35: }
  36: 
  37: void FLWFinalizeColor(vec4 color) {
  38:     #if defined(USE_FOG)
  39:     float a = color.a;
  40:     float fog = clamp(FLWFogFactor(), 0., 1.);
  41: 
  42:     color = mix(uFogColor, color, fog);
  43:     color.a = a;
  44:     #endif
  45: 
  46:     gl_FragColor = color;
  47: }
  48: 
  49: vec4 FLWLight(vec2 lightCoords) {
  50:     return texture2D(uLightMap, shiftLight(lightCoords));
  51: }
  52: 
  53: 
  54: 
  55: struct BlockFrag {
  56:     vec2 texCoords;
  57:     vec4 color;
  58:     float diffuse;
  59:     vec2 light;
  60: };
  61: 
  62: void FLWMain(BlockFrag r) {
  63:     vec4 tex = FLWBlockTexture(r.texCoords);
  64: 
  65:     vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;
  66: 
  67: //    flw_WorldPos = ;
  68: //    flw_Normal = ;
  69: //    flw_Albedo = tex.rgb;
  70: //    flw_Alpha = tex.a;
  71: //    flw_LightMap = r.light;
  72: //    flw_Tint = r.color;
  73:     FLWFinalizeColor(color);
  74: }
  75: 
  76: varying vec2 v2f_texCoords;
  77: varying vec4 v2f_color;
  78: varying float v2f_diffuse;
  79: varying vec2 v2f_light;
  80: 
  81: 
  82: //vec3 flw_WorldPos;
  83: //vec3 flw_Normal;
  84: //vec3 flw_Albedo;
  85: //float flw_Alpha;
  86: //vec2 flw_LightMap;
  87: //vec4 flw_Tint;
  88: 
  89: void main() {
  90:     BlockFrag f;
  91:     f.texCoords = v2f_texCoords;
  92: f.color = v2f_color;
  93: f.diffuse = v2f_diffuse;
  94: f.light = v2f_light;
  95: 
  96: 
  97:     FLWMain(f);
  98: }

[13:33:20] [main/ERROR]: Shader compilation log for create:contraption_actor.vert: No errors.

[13:33:20] [main/ERROR]: Source for shader 'create:contraption_actor.vert':
   1: #version 110
   2: #define USE_FOG
   3: #define USE_FOG_LINEAR
   4: 
   5: #define PI 3.1415926538
   6: 
   7: uniform float uTime;
   8: uniform mat4 uViewProjection;
   9: uniform vec3 uCameraPos;
  10: 
  11: #if defined(USE_FOG)
  12: varying float FragDistance;
  13: #endif
  14: 
  15: void FLWFinalizeWorldPos(inout vec4 worldPos) {
  16:     #if defined(USE_FOG)
  17:     FragDistance = length(worldPos.xyz - uCameraPos);
  18:     #endif
  19: 
  20:     gl_Position = uViewProjection * worldPos;
  21: }
  22: 
  23: void FLWFinalizeNormal(inout vec3 normal) {
  24:     // noop
  25: }
  26: 
  27: 
  28: mat4 rotate(vec3 axis, float angle) {
  29:     float s = sin(angle);
  30:     float c = cos(angle);
  31:     float oc = 1. - c;
  32: 
  33:     vec3 sa = axis * s;
  34: 
  35:     mat4 mr = mat4(1.);
  36:     mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
  37:     mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
  38:     mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);
  39: 
  40:     return mr;
  41: }
  42: 
  43: mat4 rotation(vec3 rot) {
  44:     return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
  45: }
  46: 
  47: mat3 modelToNormal(mat4 mat) {
  48:     // Discard the edges. This won't be accurate for scaled or skewed matrices,
  49:     // but we don't have to work with those often.
  50:     mat3 m;
  51:     m[0] = mat[0].xyz;
  52:     m[1] = mat[1].xyz;
  53:     m[2] = mat[2].xyz;
  54:     return m;
  55: }
  56: 
  57: #define PIOVER2 1.5707963268
  58: 
  59: vec4 quat(vec3 axis, float angle) {
  60:     float halfAngle = angle * PIOVER2 / 180.0;
  61:     vec2 cs = sin(vec2(PIOVER2 - halfAngle, halfAngle)); // compute sin and cos in one instruction
  62:     return vec4(axis.xyz * cs.y,  cs.x);
  63: }
  64: 
  65: vec4 quatMult(vec4 q1, vec4 q2) {
  66:     // disgustingly vectorized quaternion multiplication
  67:     vec4 a = q1.w * q2.xyzw;
  68:     vec4 b = q1.x * q2.wzxy * vec4(1., -1., 1., -1.);
  69:     vec4 c = q1.y * q2.zwxy * vec4(1., 1., -1., -1.);
  70:     vec4 d = q1.z * q2.yxwz * vec4(-1., 1., 1., -1.);
  71: 
  72:     return a + b + c + d;
  73: }
  74: 
  75: vec3 rotateVertexByQuat(vec3 v, vec4 q) {
  76:     vec3 i = q.xyz;
  77:     return v + 2.0 * cross(i, cross(i, v) + q.w * v);
  78: }
  79: 
  80: vec3 rotateAbout(vec3 v, vec3 axis, float angle) {
  81:     return rotateVertexByQuat(v, quat(axis, angle));
  82: }
  83: 
  84: float diffuse(vec3 normal) {
  85:     vec3 n2 = normal * normal * vec3(.6, .25, .8);
  86:     return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
  87: }
  88: 
  89: 
  90: struct Actor {
  91:     vec3 pos;
  92:     vec2 light;
  93:     float offset;
  94:     vec3 axis;
  95:     vec4 rotation;
  96:     vec3 rotationCenter;
  97:     float speed;
  98: };
  99: 
 100: 
 101: struct Vertex {
 102:     vec3 pos;
 103:     vec3 normal;
 104:     vec2 texCoords;
 105: };
 106: 
 107: struct BlockFrag {
 108:     vec2 texCoords;
 109:     vec4 color;
 110:     float diffuse;
 111:     vec2 light;
 112: };
 113: 
 114: BlockFrag FLWMain(Vertex v, Actor instance) {
 115:     float degrees = instance.offset + uTime * instance.speed / 20.;
 116:     //float angle = fract(degrees / 360.) * PI * 2.;
 117: 
 118:     vec4 kineticRot = quat(instance.axis, degrees);
 119:     vec3 rotated = rotateVertexByQuat(v.pos - instance.rotationCenter, kineticRot) + instance.rotationCenter;
 120: 
 121:     vec4 worldPos = vec4(rotateVertexByQuat(rotated - .5, instance.rotation) + instance.pos + .5, 1.);
 122:     vec3 norm = rotateVertexByQuat(rotateVertexByQuat(v.normal, kineticRot), instance.rotation);
 123: 
 124:     FLWFinalizeWorldPos(worldPos);
 125:     FLWFinalizeNormal(norm);
 126: 
 127:     BlockFrag b;
 128:     b.diffuse = diffuse(norm);
 129:     b.texCoords = v.texCoords;
 130:     b.light = instance.light;
 131: 
 132:     #if defined(DEBUG_NORMAL)
 133:     b.color = vec4(norm, 1.);
 134:     #else
 135:     b.color = vec4(1.);
 136:     #endif
 137: 
 138:     return b;
 139: }
 140: attribute vec3 a_v_pos;
 141: attribute vec3 a_v_normal;
 142: attribute vec2 a_v_texCoords;
 143: 
 144: attribute vec3 a_i_pos;
 145: attribute vec2 a_i_light;
 146: attribute float a_i_offset;
 147: attribute vec3 a_i_axis;
 148: attribute vec4 a_i_rotation;
 149: attribute vec3 a_i_rotationCenter;
 150: attribute float a_i_speed;
 151: 
 152: 
 153: varying vec2 v2f_texCoords;
 154: varying vec4 v2f_color;
 155: varying float v2f_diffuse;
 156: varying vec2 v2f_light;
 157: 
 158: 
 159: void main() {
 160:     Vertex v;
 161:     v.pos = a_v_pos;
 162: v.normal = a_v_normal;
 163: v.texCoords = a_v_texCoords;
 164: 
 165: 
 166:     Actor i;
 167:     i.pos = a_i_pos;
 168: i.light = a_i_light;
 169: i.offset = a_i_offset;
 170: i.axis = a_i_axis;
 171: i.rotation = a_i_rotation;
 172: i.rotationCenter = a_i_rotationCenter;
 173: i.speed = a_i_speed;
 174: 
 175: 
 176:     BlockFrag o = FLWMain(v, i);
 177: 
 178:     v2f_texCoords = o.texCoords;
 179: v2f_color = o.color;
 180: v2f_diffuse = o.diffuse;
 181: v2f_light = o.light;
 182: 
 183: }

[13:33:20] [main/ERROR]: Shader compilation log for flywheel:block.frag: No errors.

[13:33:20] [main/ERROR]: Source for shader 'flywheel:block.frag':
   1: #version 110
   2: #define USE_FOG
   3: #define USE_FOG_LINEAR
   4: 
   5: #if defined(USE_FOG)
   6: varying float FragDistance;
   7: uniform vec4 uFogColor;
   8: #endif
   9: 
  10: #if defined(USE_FOG_LINEAR)
  11: uniform vec2 uFogRange;
  12: 
  13: float FLWFogFactor() {
  14:     return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
  15: }
  16:     #endif
  17: 
  18:     #if defined(USE_FOG_EXP2)
  19: uniform float uFogDensity;
  20: 
  21: float FLWFogFactor() {
  22:     float dist = FragDistance * uFogDensity;
  23:     return 1. / exp2(dist * dist);
  24: }
  25:     #endif
  26: // Adjust the [0,1] normalized lightmap value based on the texture matrix from LightTexture#enableLightmap
  27: vec2 shiftLight(vec2 lm) {
  28:     return lm * 0.99609375 + 0.03125;// * 255/256 + 1/32
  29: }
  30: 
  31: uniform sampler2D uBlockAtlas;
  32: uniform sampler2D uLightMap;
  33: 
  34: vec4 FLWBlockTexture(vec2 texCoords) {
  35:     return texture2D(uBlockAtlas, texCoords);
  36: }
  37: 
  38: void FLWFinalizeColor(vec4 color) {
  39:     #if defined(USE_FOG)
  40:     float a = color.a;
  41:     float fog = clamp(FLWFogFactor(), 0., 1.);
  42: 
  43:     color = mix(uFogColor, color, fog);
  44:     color.a = a;
  45:     #endif
  46: 
  47:     gl_FragColor = color;
  48: }
  49: 
  50: vec4 FLWLight(vec2 lightCoords) {
  51:     return texture2D(uLightMap, shiftLight(lightCoords));
  52: }
  53: 
  54: 
  55: 
  56: struct BlockFrag {
  57:     vec2 texCoords;
  58:     vec4 color;
  59:     float diffuse;
  60:     vec2 light;
  61: };
  62: 
  63: void FLWMain(BlockFrag r) {
  64:     vec4 tex = FLWBlockTexture(r.texCoords);
  65: 
  66:     vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;
  67: 
  68: //    flw_WorldPos = ;
  69: //    flw_Normal = ;
  70: //    flw_Albedo = tex.rgb;
  71: //    flw_Alpha = tex.a;
  72: //    flw_LightMap = r.light;
  73: //    flw_Tint = r.color;
  74:     FLWFinalizeColor(color);
  75: }
  76: 
  77: varying vec2 v2f_texCoords;
  78: varying vec4 v2f_color;
  79: varying float v2f_diffuse;
  80: varying vec2 v2f_light;
  81: 
  82: 
  83: //vec3 flw_WorldPos;
  84: //vec3 flw_Normal;
  85: //vec3 flw_Albedo;
  86: //float flw_Alpha;
  87: //vec2 flw_LightMap;
  88: //vec4 flw_Tint;
  89: 
  90: void main() {
  91:     BlockFrag f;
  92:     f.texCoords = v2f_texCoords;
  93: f.color = v2f_color;
  94: f.diffuse = v2f_diffuse;
  95: f.light = v2f_light;
  96: 
  97: 
  98:     FLWMain(f);
  99: }

[13:33:20] [main/ERROR]: Shader compilation log for create:contraption_actor.vert: No errors.

[13:33:20] [main/ERROR]: Source for shader 'create:contraption_actor.vert':
   1: #version 110
   2: #define USE_FOG
   3: #define USE_FOG_EXP2
   4: 
   5: #define PI 3.1415926538
   6: 
   7: uniform float uTime;
   8: uniform mat4 uViewProjection;
   9: uniform vec3 uCameraPos;
  10: 
  11: #if defined(USE_FOG)
  12: varying float FragDistance;
  13: #endif
  14: 
  15: void FLWFinalizeWorldPos(inout vec4 worldPos) {
  16:     #if defined(USE_FOG)
  17:     FragDistance = length(worldPos.xyz - uCameraPos);
  18:     #endif
  19: 
  20:     gl_Position = uViewProjection * worldPos;
  21: }
  22: 
  23: void FLWFinalizeNormal(inout vec3 normal) {
  24:     // noop
  25: }
  26: 
  27: 
  28: mat4 rotate(vec3 axis, float angle) {
  29:     float s = sin(angle);
  30:     float c = cos(angle);
  31:     float oc = 1. - c;
  32: 
  33:     vec3 sa = axis * s;
  34: 
  35:     mat4 mr = mat4(1.);
  36:     mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
  37:     mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
  38:     mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);
  39: 
  40:     return mr;
  41: }
  42: 
  43: mat4 rotation(vec3 rot) {
  44:     return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
  45: }
  46: 
  47: mat3 modelToNormal(mat4 mat) {
  48:     // Discard the edges. This won't be accurate for scaled or skewed matrices,
  49:     // but we don't have to work with those often.
  50:     mat3 m;
  51:     m[0] = mat[0].xyz;
  52:     m[1] = mat[1].xyz;
  53:     m[2] = mat[2].xyz;
  54:     return m;
  55: }
  56: 
  57: #define PIOVER2 1.5707963268
  58: 
  59: vec4 quat(vec3 axis, float angle) {
  60:     float halfAngle = angle * PIOVER2 / 180.0;
  61:     vec2 cs = sin(vec2(PIOVER2 - halfAngle, halfAngle)); // compute sin and cos in one instruction
  62:     return vec4(axis.xyz * cs.y,  cs.x);
  63: }
  64: 
  65: vec4 quatMult(vec4 q1, vec4 q2) {
  66:     // disgustingly vectorized quaternion multiplication
  67:     vec4 a = q1.w * q2.xyzw;
  68:     vec4 b = q1.x * q2.wzxy * vec4(1., -1., 1., -1.);
  69:     vec4 c = q1.y * q2.zwxy * vec4(1., 1., -1., -1.);
  70:     vec4 d = q1.z * q2.yxwz * vec4(-1., 1., 1., -1.);
  71: 
  72:     return a + b + c + d;
  73: }
  74: 
  75: vec3 rotateVertexByQuat(vec3 v, vec4 q) {
  76:     vec3 i = q.xyz;
  77:     return v + 2.0 * cross(i, cross(i, v) + q.w * v);
  78: }
  79: 
  80: vec3 rotateAbout(vec3 v, vec3 axis, float angle) {
  81:     return rotateVertexByQuat(v, quat(axis, angle));
  82: }
  83: 
  84: float diffuse(vec3 normal) {
  85:     vec3 n2 = normal * normal * vec3(.6, .25, .8);
  86:     return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
  87: }
  88: 
  89: 
  90: struct Actor {
  91:     vec3 pos;
  92:     vec2 light;
  93:     float offset;
  94:     vec3 axis;
  95:     vec4 rotation;
  96:     vec3 rotationCenter;
  97:     float speed;
  98: };
  99: 
 100: 
 101: struct Vertex {
 102:     vec3 pos;
 103:     vec3 normal;
 104:     vec2 texCoords;
 105: };
 106: 
 107: struct BlockFrag {
 108:     vec2 texCoords;
 109:     vec4 color;
 110:     float diffuse;
 111:     vec2 light;
 112: };
 113: 
 114: BlockFrag FLWMain(Vertex v, Actor instance) {
 115:     float degrees = instance.offset + uTime * instance.speed / 20.;
 116:     //float angle = fract(degrees / 360.) * PI * 2.;
 117: 
 118:     vec4 kineticRot = quat(instance.axis, degrees);
 119:     vec3 rotated = rotateVertexByQuat(v.pos - instance.rotationCenter, kineticRot) + instance.rotationCenter;
 120: 
 121:     vec4 worldPos = vec4(rotateVertexByQuat(rotated - .5, instance.rotation) + instance.pos + .5, 1.);
 122:     vec3 norm = rotateVertexByQuat(rotateVertexByQuat(v.normal, kineticRot), instance.rotation);
 123: 
 124:     FLWFinalizeWorldPos(worldPos);
 125:     FLWFinalizeNormal(norm);
 126: 
 127:     BlockFrag b;
 128:     b.diffuse = diffuse(norm);
 129:     b.texCoords = v.texCoords;
 130:     b.light = instance.light;
 131: 
 132:     #if defined(DEBUG_NORMAL)
 133:     b.color = vec4(norm, 1.);
 134:     #else
 135:     b.color = vec4(1.);
 136:     #endif
 137: 
 138:     return b;
 139: }
 140: attribute vec3 a_v_pos;
 141: attribute vec3 a_v_normal;
 142: attribute vec2 a_v_texCoords;
 143: 
 144: attribute vec3 a_i_pos;
 145: attribute vec2 a_i_light;
 146: attribute float a_i_offset;
 147: attribute vec3 a_i_axis;
 148: attribute vec4 a_i_rotation;
 149: attribute vec3 a_i_rotationCenter;
 150: attribute float a_i_speed;
 151: 
 152: 
 153: varying vec2 v2f_texCoords;
 154: varying vec4 v2f_color;
 155: varying float v2f_diffuse;
 156: varying vec2 v2f_light;
 157: 
 158: 
 159: void main() {
 160:     Vertex v;
 161:     v.pos = a_v_pos;
 162: v.normal = a_v_normal;
 163: v.texCoords = a_v_texCoords;
 164: 
 165: 
 166:     Actor i;
 167:     i.pos = a_i_pos;
 168: i.light = a_i_light;
 169: i.offset = a_i_offset;
 170: i.axis = a_i_axis;
 171: i.rotation = a_i_rotation;
 172: i.rotationCenter = a_i_rotationCenter;
 173: i.speed = a_i_speed;
 174: 
 175: 
 176:     BlockFrag o = FLWMain(v, i);
 177: 
 178:     v2f_texCoords = o.texCoords;
 179: v2f_color = o.color;
 180: v2f_diffuse = o.diffuse;
 181: v2f_light = o.light;
 182: 
 183: }

[13:33:20] [main/ERROR]: Shader compilation log for flywheel:block.frag: No errors.

[13:33:20] [main/ERROR]: Source for shader 'flywheel:block.frag':
   1: #version 110
   2: #define USE_FOG
   3: #define USE_FOG_EXP2
   4: 
   5: #if defined(USE_FOG)
   6: varying float FragDistance;
   7: uniform vec4 uFogColor;
   8: #endif
   9: 
  10: #if defined(USE_FOG_LINEAR)
  11: uniform vec2 uFogRange;
  12: 
  13: float FLWFogFactor() {
  14:     return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
  15: }
  16:     #endif
  17: 
  18:     #if defined(USE_FOG_EXP2)
  19: uniform float uFogDensity;
  20: 
  21: float FLWFogFactor() {
  22:     float dist = FragDistance * uFogDensity;
  23:     return 1. / exp2(dist * dist);
  24: }
  25:     #endif
  26: // Adjust the [0,1] normalized lightmap value based on the texture matrix from LightTexture#enableLightmap
  27: vec2 shiftLight(vec2 lm) {
  28:     return lm * 0.99609375 + 0.03125;// * 255/256 + 1/32
  29: }
  30: 
  31: uniform sampler2D uBlockAtlas;
  32: uniform sampler2D uLightMap;
  33: 
  34: vec4 FLWBlockTexture(vec2 texCoords) {
  35:     return texture2D(uBlockAtlas, texCoords);
  36: }
  37: 
  38: void FLWFinalizeColor(vec4 color) {
  39:     #if defined(USE_FOG)
  40:     float a = color.a;
  41:     float fog = clamp(FLWFogFactor(), 0., 1.);
  42: 
  43:     color = mix(uFogColor, color, fog);
  44:     color.a = a;
  45:     #endif
  46: 
  47:     gl_FragColor = color;
  48: }
  49: 
  50: vec4 FLWLight(vec2 lightCoords) {
  51:     return texture2D(uLightMap, shiftLight(lightCoords));
  52: }
  53: 
  54: 
  55: 
  56: struct BlockFrag {
  57:     vec2 texCoords;
  58:     vec4 color;
  59:     float diffuse;
  60:     vec2 light;
  61: };
  62: 
  63: void FLWMain(BlockFrag r) {
  64:     vec4 tex = FLWBlockTexture(r.texCoords);
  65: 
  66:     vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;
  67: 
  68: //    flw_WorldPos = ;
  69: //    flw_Normal = ;
  70: //    flw_Albedo = tex.rgb;
  71: //    flw_Alpha = tex.a;
  72: //    flw_LightMap = r.light;
  73: //    flw_Tint = r.color;
  74:     FLWFinalizeColor(color);
  75: }
  76: 
  77: varying vec2 v2f_texCoords;
  78: varying vec4 v2f_color;
  79: varying float v2f_diffuse;
  80: varying vec2 v2f_light;
  81: 
  82: 
  83: //vec3 flw_WorldPos;
  84: //vec3 flw_Normal;
  85: //vec3 flw_Albedo;
  86: //float flw_Alpha;
  87: //vec2 flw_LightMap;
  88: //vec4 flw_Tint;
  89: 
  90: void main() {
  91:     BlockFrag f;
  92:     f.texCoords = v2f_texCoords;
  93: f.color = v2f_color;
  94: f.diffuse = v2f_diffuse;
  95: f.light = v2f_light;
  96: 
  97: 
  98:     FLWMain(f);
  99: }

[13:33:20] [main/ERROR]: Shader compilation log for create:contraption_actor.vert: No errors.

[13:33:20] [main/ERROR]: Source for shader 'create:contraption_actor.vert':
   1: #version 110
   2: 
   3: #define PI 3.1415926538
   4: 
   5: uniform float uTime;
   6: uniform mat4 uViewProjection;
   7: uniform vec3 uCameraPos;
   8: 
   9: #if defined(USE_FOG)
  10: varying float FragDistance;
  11: #endif
  12: 
  13: void FLWFinalizeWorldPos(inout vec4 worldPos) {
  14:     #if defined(USE_FOG)
  15:     FragDistance = length(worldPos.xyz - uCameraPos);
  16:     #endif
  17: 
  18:     gl_Position = uViewProjection * worldPos;
  19: }
  20: 
  21: void FLWFinalizeNormal(inout vec3 normal) {
  22:     // noop
  23: }
  24: 
  25: 
  26: mat4 rotate(vec3 axis, float angle) {
  27:     float s = sin(angle);
  28:     float c = cos(angle);
  29:     float oc = 1. - c;
  30: 
  31:     vec3 sa = axis * s;
  32: 
  33:     mat4 mr = mat4(1.);
  34:     mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
  35:     mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
  36:     mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);
  37: 
  38:     return mr;
  39: }
  40: 
  41: mat4 rotation(vec3 rot) {
  42:     return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
  43: }
  44: 
  45: mat3 modelToNormal(mat4 mat) {
  46:     // Discard the edges. This won't be accurate for scaled or skewed matrices,
  47:     // but we don't have to work with those often.
  48:     mat3 m;
  49:     m[0] = mat[0].xyz;
  50:     m[1] = mat[1].xyz;
  51:     m[2] = mat[2].xyz;
  52:     return m;
  53: }
  54: 
  55: #define PIOVER2 1.5707963268
  56: 
  57: vec4 quat(vec3 axis, float angle) {
  58:     float halfAngle = angle * PIOVER2 / 180.0;
  59:     vec2 cs = sin(vec2(PIOVER2 - halfAngle, halfAngle)); // compute sin and cos in one instruction
  60:     return vec4(axis.xyz * cs.y,  cs.x);
  61: }
  62: 
  63: vec4 quatMult(vec4 q1, vec4 q2) {
  64:     // disgustingly vectorized quaternion multiplication
  65:     vec4 a = q1.w * q2.xyzw;
  66:     vec4 b = q1.x * q2.wzxy * vec4(1., -1., 1., -1.);
  67:     vec4 c = q1.y * q2.zwxy * vec4(1., 1., -1., -1.);
  68:     vec4 d = q1.z * q2.yxwz * vec4(-1., 1., 1., -1.);
  69: 
  70:     return a + b + c + d;
  71: }
  72: 
  73: vec3 rotateVertexByQuat(vec3 v, vec4 q) {
  74:     vec3 i = q.xyz;
  75:     return v + 2.0 * cross(i, cross(i, v) + q.w * v);
  76: }
  77: 
  78: vec3 rotateAbout(vec3 v, vec3 axis, float angle) {
  79:     return rotateVertexByQuat(v, quat(axis, angle));
  80: }
  81: 
  82: float diffuse(vec3 normal) {
  83:     vec3 n2 = normal * normal * vec3(.6, .25, .8);
  84:     return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
  85: }
  86: 
  87: 
  88: struct Actor {
  89:     vec3 pos;
  90:     vec2 light;
  91:     float offset;
  92:     vec3 axis;
  93:     vec4 rotation;
  94:     vec3 rotationCenter;
  95:     float speed;
  96: };
  97: 
  98: 
  99: struct Vertex {
 100:     vec3 pos;
 101:     vec3 normal;
 102:     vec2 texCoords;
 103: };
 104: 
 105: struct BlockFrag {
 106:     vec2 texCoords;
 107:     vec4 color;
 108:     float diffuse;
 109:     vec2 light;
 110: };
 111: 
 112: BlockFrag FLWMain(Vertex v, Actor instance) {
 113:     float degrees = instance.offset + uTime * instance.speed / 20.;
 114:     //float angle = fract(degrees / 360.) * PI * 2.;
 115: 
 116:     vec4 kineticRot = quat(instance.axis, degrees);
 117:     vec3 rotated = rotateVertexByQuat(v.pos - instance.rotationCenter, kineticRot) + instance.rotationCenter;
 118: 
 119:     vec4 worldPos = vec4(rotateVertexByQuat(rotated - .5, instance.rotation) + instance.pos + .5, 1.);
 120:     vec3 norm = rotateVertexByQuat(rotateVertexByQuat(v.normal, kineticRot), instance.rotation);
 121: 
 122:     FLWFinalizeWorldPos(worldPos);
 123:     FLWFinalizeNormal(norm);
 124: 
 125:     BlockFrag b;
 126:     b.diffuse = diffuse(norm);
 127:     b.texCoords = v.texCoords;
 128:     b.light = instance.light;
 129: 
 130:     #if defined(DEBUG_NORMAL)
 131:     b.color = vec4(norm, 1.);
 132:     #else
 133:     b.color = vec4(1.);
 134:     #endif
 135: 
 136:     return b;
 137: }
 138: attribute vec3 a_v_pos;
 139: attribute vec3 a_v_normal;
 140: attribute vec2 a_v_texCoords;
 141: 
 142: attribute vec3 a_i_pos;
 143: attribute vec2 a_i_light;
 144: attribute float a_i_offset;
 145: attribute vec3 a_i_axis;
 146: attribute vec4 a_i_rotation;
 147: attribute vec3 a_i_rotationCenter;
 148: attribute float a_i_speed;
 149: 
 150: 
 151: varying vec2 v2f_texCoords;
 152: varying vec4 v2f_color;
 153: varying float v2f_diffuse;
 154: varying vec2 v2f_light;
 155: 
 156: 
 157: void main() {
 158:     Vertex v;
 159:     v.pos = a_v_pos;
 160: v.normal = a_v_normal;
 161: v.texCoords = a_v_texCoords;
 162: 
 163: 
 164:     Actor i;
 165:     i.pos = a_i_pos;
 166: i.light = a_i_light;
 167: i.offset = a_i_offset;
 168: i.axis = a_i_axis;
 169: i.rotation = a_i_rotation;
 170: i.rotationCenter = a_i_rotationCenter;
 171: i.speed = a_i_speed;
 172: 
 173: 
 174:     BlockFrag o = FLWMain(v, i);
 175: 
 176:     v2f_texCoords = o.texCoords;
 177: v2f_color = o.color;
 178: v2f_diffuse = o.diffuse;
 179: v2f_light = o.light;
 180: 
 181: }

[13:33:20] [main/ERROR]: Shader compilation log for flywheel:block.frag: No errors.

[13:33:20] [main/ERROR]: Source for shader 'flywheel:block.frag':
   1: #version 110
   2: 
   3: #if defined(USE_FOG)
   4: varying float FragDistance;
   5: uniform vec4 uFogColor;
   6: #endif
   7: 
   8: #if defined(USE_FOG_LINEAR)
   9: uniform vec2 uFogRange;
  10: 
  11: float FLWFogFactor() {
  12:     return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
  13: }
  14:     #endif
  15: 
  16:     #if defined(USE_FOG_EXP2)
  17: uniform float uFogDensity;
  18: 
  19: float FLWFogFactor() {
  20:     float dist = FragDistance * uFogDensity;
  21:     return 1. / exp2(dist * dist);
  22: }
  23:     #endif
  24: // Adjust the [0,1] normalized lightmap value based on the texture matrix from LightTexture#enableLightmap
  25: vec2 shiftLight(vec2 lm) {
  26:     return lm * 0.99609375 + 0.03125;// * 255/256 + 1/32
  27: }
  28: 
  29: uniform sampler2D uBlockAtlas;
  30: uniform sampler2D uLightMap;
  31: 
  32: vec4 FLWBlockTexture(vec2 texCoords) {
  33:     return texture2D(uBlockAtlas, texCoords);
  34: }
  35: 
  36: void FLWFinalizeColor(vec4 color) {
  37:     #if defined(USE_FOG)
  38:     float a = color.a;
  39:     float fog = clamp(FLWFogFactor(), 0., 1.);
  40: 
  41:     color = mix(uFogColor, color, fog);
  42:     color.a = a;
  43:     #endif
  44: 
  45:     gl_FragColor = color;
  46: }
  47: 
  48: vec4 FLWLight(vec2 lightCoords) {
  49:     return texture2D(uLightMap, shiftLight(lightCoords));
  50: }
  51: 
  52: 
  53: 
  54: struct BlockFrag {
  55:     vec2 texCoords;
  56:     vec4 color;
  57:     float diffuse;
  58:     vec2 light;
  59: };
  60: 
  61: void FLWMain(BlockFrag r) {
  62:     vec4 tex = FLWBlockTexture(r.texCoords);
  63: 
  64:     vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;
  65: 
  66: //    flw_WorldPos = ;
  67: //    flw_Normal = ;
  68: //    flw_Albedo = tex.rgb;
  69: //    flw_Alpha = tex.a;
  70: //    flw_LightMap = r.light;
  71: //    flw_Tint = r.color;
  72:     FLWFinalizeColor(color);
  73: }
  74: 
  75: varying vec2 v2f_texCoords;
  76: varying vec4 v2f_color;
  77: varying float v2f_diffuse;
  78: varying vec2 v2f_light;
  79: 
  80: 
  81: //vec3 flw_WorldPos;
  82: //vec3 flw_Normal;
  83: //vec3 flw_Albedo;
  84: //float flw_Alpha;
  85: //vec2 flw_LightMap;
  86: //vec4 flw_Tint;
  87: 
  88: void main() {
  89:     BlockFrag f;
  90:     f.texCoords = v2f_texCoords;
  91: f.color = v2f_color;
  92: f.diffuse = v2f_diffuse;
  93: f.light = v2f_light;
  94: 
  95: 
  96:     FLWMain(f);
  97: }

[13:33:20] [main/ERROR]: Shader compilation log for create:flap.vert: No errors.

[13:33:20] [main/ERROR]: Source for shader 'create:flap.vert':
   1: #version 110
   2: #define DEBUG_NORMAL
   3: 
   4: #define PI 3.1415926538
   5: 
   6: uniform float uTime;
   7: uniform mat4 uViewProjection;
   8: uniform vec3 uCameraPos;
   9: 
  10: #if defined(USE_FOG)
  11: varying float FragDistance;
  12: #endif
  13: 
  14: void FLWFinalizeWorldPos(inout vec4 worldPos) {
  15:     #if defined(USE_FOG)
  16:     FragDistance = length(worldPos.xyz - uCameraPos);
  17:     #endif
  18: 
  19:     gl_Position = uViewProjection * worldPos;
  20: }
  21: 
  22: void FLWFinalizeNormal(inout vec3 normal) {
  23:     // noop
  24: }
  25: 
  26: 
  27: mat4 rotate(vec3 axis, float angle) {
  28:     float s = sin(angle);
  29:     float c = cos(angle);
  30:     float oc = 1. - c;
  31: 
  32:     vec3 sa = axis * s;
  33: 
  34:     mat4 mr = mat4(1.);
  35:     mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
  36:     mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
  37:     mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);
  38: 
  39:     return mr;
  40: }
  41: 
  42: mat4 rotation(vec3 rot) {
  43:     return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
  44: }
  45: 
  46: mat3 modelToNormal(mat4 mat) {
  47:     // Discard the edges. This won't be accurate for scaled or skewed matrices,
  48:     // but we don't have to work with those often.
  49:     mat3 m;
  50:     m[0] = mat[0].xyz;
  51:     m[1] = mat[1].xyz;
  52:     m[2] = mat[2].xyz;
  53:     return m;
  54: }
  55: 
  56: #define PIOVER2 1.5707963268
  57: 
  58: vec4 quat(vec3 axis, float angle) {
  59:     float halfAngle = angle * PIOVER2 / 180.0;
  60:     vec2 cs = sin(vec2(PIOVER2 - halfAngle, halfAngle)); // compute sin and cos in one instruction
  61:     return vec4(axis.xyz * cs.y,  cs.x);
  62: }
  63: 
  64: vec4 quatMult(vec4 q1, vec4 q2) {
  65:     // disgustingly vectorized quaternion multiplication
  66:     vec4 a = q1.w * q2.xyzw;
  67:     vec4 b = q1.x * q2.wzxy * vec4(1., -1., 1., -1.);
  68:     vec4 c = q1.y * q2.zwxy * vec4(1., 1., -1., -1.);
  69:     vec4 d = q1.z * q2.yxwz * vec4(-1., 1., 1., -1.);
  70: 
  71:     return a + b + c + d;
  72: }
  73: 
  74: vec3 rotateVertexByQuat(vec3 v, vec4 q) {
  75:     vec3 i = q.xyz;
  76:     return v + 2.0 * cross(i, cross(i, v) + q.w * v);
  77: }
  78: 
  79: vec3 rotateAbout(vec3 v, vec3 axis, float angle) {
  80:     return rotateVertexByQuat(v, quat(axis, angle));
  81: }
  82: 
  83: float diffuse(vec3 normal) {
  84:     vec3 n2 = normal * normal * vec3(.6, .25, .8);
  85:     return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
  86: }
  87: 
  88: 
  89: struct Flap {
  90:     vec3 instancePos;
  91:     vec2 light;
  92:     vec3 segmentOffset;
  93:     vec3 pivot;
  94:     float horizontalAngle;
  95:     float intensity;
  96:     float flapScale;
  97:     float flapness;
  98: };
  99: 
 100: 
 101: struct Vertex {
 102:     vec3 pos;
 103:     vec3 normal;
 104:     vec2 texCoords;
 105: };
 106: 
 107: struct BlockFrag {
 108:     vec2 texCoords;
 109:     vec4 color;
 110:     float diffuse;
 111:     vec2 light;
 112: };
 113: 
 114: 
 115: float toRad(float degrees) {
 116:     return fract(degrees / 360.) * PI * 2.;
 117: }
 118: 
 119: float getFlapAngle(float flapness, float intensity, float scale) {
 120:     float absFlap = abs(flapness);
 121: 
 122:     float angle = sin((1. - absFlap) * PI * intensity) * 30. * flapness * scale;
 123: 
 124:     float halfAngle = angle * 0.5;
 125: 
 126:     float which = step(0., flapness);// 0 if negative, 1 if positive
 127:     float degrees = which * halfAngle + (1. - which) * angle;// branchless conditional multiply
 128: 
 129:     return degrees;
 130: }
 131: 
 132: BlockFrag FLWMain(Vertex v, Flap flap) {
 133:     float flapAngle = getFlapAngle(flap.flapness, flap.intensity, flap.flapScale);
 134: 
 135:     vec4 orientation = quat(vec3(0., 1., 0.), -flap.horizontalAngle);
 136:     vec4 flapRotation = quat(vec3(1., 0., 0.), flapAngle);
 137: 
 138:     vec3 rotated = rotateVertexByQuat(v.pos - flap.pivot, flapRotation) + flap.pivot + flap.segmentOffset;
 139:     rotated = rotateVertexByQuat(rotated - .5, orientation) + flap.instancePos + .5;
 140: 
 141:     vec4 worldPos = vec4(rotated, 1.);
 142:     vec3 norm = rotateVertexByQuat(rotateVertexByQuat(v.normal, flapRotation), orientation);
 143: 
 144:     FLWFinalizeWorldPos(worldPos);
 145:     FLWFinalizeNormal(norm);
 146: 
 147:     BlockFrag b;
 148:     b.diffuse = diffuse(norm);
 149:     b.texCoords = v.texCoords;
 150:     b.light = flap.light;
 151:     #if defined(DEBUG_NORMAL)
 152:     b.color = vec4(norm, 1.);
 153:     #else
 154:     b.color = vec4(1.);
 155:     #endif
 156:     return b;
 157: }
 158: attribute vec3 a_v_pos;
 159: attribute vec3 a_v_normal;
 160: attribute vec2 a_v_texCoords;
 161: 
 162: attribute vec3 a_i_instancePos;
 163: attribute vec2 a_i_light;
 164: attribute vec3 a_i_segmentOffset;
 165: attribute vec3 a_i_pivot;
 166: attribute float a_i_horizontalAngle;
 167: attribute float a_i_intensity;
 168: attribute float a_i_flapScale;
 169: attribute float a_i_flapness;
 170: 
 171: 
 172: varying vec2 v2f_texCoords;
 173: varying vec4 v2f_color;
 174: varying float v2f_diffuse;
 175: varying vec2 v2f_light;
 176: 
 177: 
 178: void main() {
 179:     Vertex v;
 180:     v.pos = a_v_pos;
 181: v.normal = a_v_normal;
 182: v.texCoords = a_v_texCoords;
 183: 
 184: 
 185:     Flap i;
 186:     i.instancePos = a_i_instancePos;
 187: i.light = a_i_light;
 188: i.segmentOffset = a_i_segmentOffset;
 189: i.pivot = a_i_pivot;
 190: i.horizontalAngle = a_i_horizontalAngle;
 191: i.intensity = a_i_intensity;
 192: i.flapScale = a_i_flapScale;
 193: i.flapness = a_i_flapness;
 194: 
 195: 
 196:     BlockFrag o = FLWMain(v, i);
 197: 
 198:     v2f_texCoords = o.texCoords;
 199: v2f_color = o.color;
 200: v2f_diffuse = o.diffuse;
 201: v2f_light = o.light;
 202: 
 203: }

[13:33:20] [main/ERROR]: Shader compilation log for flywheel:block.frag: No errors.

[13:33:20] [main/ERROR]: Source for shader 'flywheel:block.frag':
   1: #version 110
   2: #define DEBUG_NORMAL
   3: 
   4: #if defined(USE_FOG)
   5: varying float FragDistance;
   6: uniform vec4 uFogColor;
   7: #endif
   8: 
   9: #if defined(USE_FOG_LINEAR)
  10: uniform vec2 uFogRange;
  11: 
  12: float FLWFogFactor() {
  13:     return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
  14: }
  15:     #endif
  16: 
  17:     #if defined(USE_FOG_EXP2)
  18: uniform float uFogDensity;
  19: 
  20: float FLWFogFactor() {
  21:     float dist = FragDistance * uFogDensity;
  22:     return 1. / exp2(dist * dist);
  23: }
  24:     #endif
  25: // Adjust the [0,1] normalized lightmap value based on the texture matrix from LightTexture#enableLightmap
  26: vec2 shiftLight(vec2 lm) {
  27:     return lm * 0.99609375 + 0.03125;// * 255/256 + 1/32
  28: }
  29: 
  30: uniform sampler2D uBlockAtlas;
  31: uniform sampler2D uLightMap;
  32: 
  33: vec4 FLWBlockTexture(vec2 texCoords) {
  34:     return texture2D(uBlockAtlas, texCoords);
  35: }
  36: 
  37: void FLWFinalizeColor(vec4 color) {
  38:     #if defined(USE_FOG)
  39:     float a = color.a;
  40:     float fog = clamp(FLWFogFactor(), 0., 1.);
  41: 
  42:     color = mix(uFogColor, color, fog);
  43:     color.a = a;
  44:     #endif
  45: 
  46:     gl_FragColor = color;
  47: }
  48: 
  49: vec4 FLWLight(vec2 lightCoords) {
  50:     return texture2D(uLightMap, shiftLight(lightCoords));
  51: }
  52: 
  53: 
  54: 
  55: struct BlockFrag {
  56:     vec2 texCoords;
  57:     vec4 color;
  58:     float diffuse;
  59:     vec2 light;
  60: };
  61: 
  62: void FLWMain(BlockFrag r) {
  63:     vec4 tex = FLWBlockTexture(r.texCoords);
  64: 
  65:     vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;
  66: 
  67: //    flw_WorldPos = ;
  68: //    flw_Normal = ;
  69: //    flw_Albedo = tex.rgb;
  70: //    flw_Alpha = tex.a;
  71: //    flw_LightMap = r.light;
  72: //    flw_Tint = r.color;
  73:     FLWFinalizeColor(color);
  74: }
  75: 
  76: varying vec2 v2f_texCoords;
  77: varying vec4 v2f_color;
  78: varying float v2f_diffuse;
  79: varying vec2 v2f_light;
  80: 
  81: 
  82: //vec3 flw_WorldPos;
  83: //vec3 flw_Normal;
  84: //vec3 flw_Albedo;
  85: //float flw_Alpha;
  86: //vec2 flw_LightMap;
  87: //vec4 flw_Tint;
  88: 
  89: void main() {
  90:     BlockFrag f;
  91:     f.texCoords = v2f_texCoords;
  92: f.color = v2f_color;
  93: f.diffuse = v2f_diffuse;
  94: f.light = v2f_light;
  95: 
  96: 
  97:     FLWMain(f);
  98: }

[13:33:20] [main/ERROR]: Shader compilation log for create:flap.vert: No errors.

[13:33:20] [main/ERROR]: Source for shader 'create:flap.vert':
   1: #version 110
   2: #define USE_FOG
   3: #define USE_FOG_LINEAR
   4: 
   5: #define PI 3.1415926538
   6: 
   7: uniform float uTime;
   8: uniform mat4 uViewProjection;
   9: uniform vec3 uCameraPos;
  10: 
  11: #if defined(USE_FOG)
  12: varying float FragDistance;
  13: #endif
  14: 
  15: void FLWFinalizeWorldPos(inout vec4 worldPos) {
  16:     #if defined(USE_FOG)
  17:     FragDistance = length(worldPos.xyz - uCameraPos);
  18:     #endif
  19: 
  20:     gl_Position = uViewProjection * worldPos;
  21: }
  22: 
  23: void FLWFinalizeNormal(inout vec3 normal) {
  24:     // noop
  25: }
  26: 
  27: 
  28: mat4 rotate(vec3 axis, float angle) {
  29:     float s = sin(angle);
  30:     float c = cos(angle);
  31:     float oc = 1. - c;
  32: 
  33:     vec3 sa = axis * s;
  34: 
  35:     mat4 mr = mat4(1.);
  36:     mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
  37:     mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
  38:     mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);
  39: 
  40:     return mr;
  41: }
  42: 
  43: mat4 rotation(vec3 rot) {
  44:     return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
  45: }
  46: 
  47: mat3 modelToNormal(mat4 mat) {
  48:     // Discard the edges. This won't be accurate for scaled or skewed matrices,
  49:     // but we don't have to work with those often.
  50:     mat3 m;
  51:     m[0] = mat[0].xyz;
  52:     m[1] = mat[1].xyz;
  53:     m[2] = mat[2].xyz;
  54:     return m;
  55: }
  56: 
  57: #define PIOVER2 1.5707963268
  58: 
  59: vec4 quat(vec3 axis, float angle) {
  60:     float halfAngle = angle * PIOVER2 / 180.0;
  61:     vec2 cs = sin(vec2(PIOVER2 - halfAngle, halfAngle)); // compute sin and cos in one instruction
  62:     return vec4(axis.xyz * cs.y,  cs.x);
  63: }
  64: 
  65: vec4 quatMult(vec4 q1, vec4 q2) {
  66:     // disgustingly vectorized quaternion multiplication
  67:     vec4 a = q1.w * q2.xyzw;
  68:     vec4 b = q1.x * q2.wzxy * vec4(1., -1., 1., -1.);
  69:     vec4 c = q1.y * q2.zwxy * vec4(1., 1., -1., -1.);
  70:     vec4 d = q1.z * q2.yxwz * vec4(-1., 1., 1., -1.);
  71: 
  72:     return a + b + c + d;
  73: }
  74: 
  75: vec3 rotateVertexByQuat(vec3 v, vec4 q) {
  76:     vec3 i = q.xyz;
  77:     return v + 2.0 * cross(i, cross(i, v) + q.w * v);
  78: }
  79: 
  80: vec3 rotateAbout(vec3 v, vec3 axis, float angle) {
  81:     return rotateVertexByQuat(v, quat(axis, angle));
  82: }
  83: 
  84: float diffuse(vec3 normal) {
  85:     vec3 n2 = normal * normal * vec3(.6, .25, .8);
  86:     return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
  87: }
  88: 
  89: 
  90: struct Flap {
  91:     vec3 instancePos;
  92:     vec2 light;
  93:     vec3 segmentOffset;
  94:     vec3 pivot;
  95:     float horizontalAngle;
  96:     float intensity;
  97:     float flapScale;
  98:     float flapness;
  99: };
 100: 
 101: 
 102: struct Vertex {
 103:     vec3 pos;
 104:     vec3 normal;
 105:     vec2 texCoords;
 106: };
 107: 
 108: struct BlockFrag {
 109:     vec2 texCoords;
 110:     vec4 color;
 111:     float diffuse;
 112:     vec2 light;
 113: };
 114: 
 115: 
 116: float toRad(float degrees) {
 117:     return fract(degrees / 360.) * PI * 2.;
 118: }
 119: 
 120: float getFlapAngle(float flapness, float intensity, float scale) {
 121:     float absFlap = abs(flapness);
 122: 
 123:     float angle = sin((1. - absFlap) * PI * intensity) * 30. * flapness * scale;
 124: 
 125:     float halfAngle = angle * 0.5;
 126: 
 127:     float which = step(0., flapness);// 0 if negative, 1 if positive
 128:     float degrees = which * halfAngle + (1. - which) * angle;// branchless conditional multiply
 129: 
 130:     return degrees;
 131: }
 132: 
 133: BlockFrag FLWMain(Vertex v, Flap flap) {
 134:     float flapAngle = getFlapAngle(flap.flapness, flap.intensity, flap.flapScale);
 135: 
 136:     vec4 orientation = quat(vec3(0., 1., 0.), -flap.horizontalAngle);
 137:     vec4 flapRotation = quat(vec3(1., 0., 0.), flapAngle);
 138: 
 139:     vec3 rotated = rotateVertexByQuat(v.pos - flap.pivot, flapRotation) + flap.pivot + flap.segmentOffset;
 140:     rotated = rotateVertexByQuat(rotated - .5, orientation) + flap.instancePos + .5;
 141: 
 142:     vec4 worldPos = vec4(rotated, 1.);
 143:     vec3 norm = rotateVertexByQuat(rotateVertexByQuat(v.normal, flapRotation), orientation);
 144: 
 145:     FLWFinalizeWorldPos(worldPos);
 146:     FLWFinalizeNormal(norm);
 147: 
 148:     BlockFrag b;
 149:     b.diffuse = diffuse(norm);
 150:     b.texCoords = v.texCoords;
 151:     b.light = flap.light;
 152:     #if defined(DEBUG_NORMAL)
 153:     b.color = vec4(norm, 1.);
 154:     #else
 155:     b.color = vec4(1.);
 156:     #endif
 157:     return b;
 158: }
 159: attribute vec3 a_v_pos;
 160: attribute vec3 a_v_normal;
 161: attribute vec2 a_v_texCoords;
 162: 
 163: attribute vec3 a_i_instancePos;
 164: attribute vec2 a_i_light;
 165: attribute vec3 a_i_segmentOffset;
 166: attribute vec3 a_i_pivot;
 167: attribute float a_i_horizontalAngle;
 168: attribute float a_i_intensity;
 169: attribute float a_i_flapScale;
 170: attribute float a_i_flapness;
 171: 
 172: 
 173: varying vec2 v2f_texCoords;
 174: varying vec4 v2f_color;
 175: varying float v2f_diffuse;
 176: varying vec2 v2f_light;
 177: 
 178: 
 179: void main() {
 180:     Vertex v;
 181:     v.pos = a_v_pos;
 182: v.normal = a_v_normal;
 183: v.texCoords = a_v_texCoords;
 184: 
 185: 
 186:     Flap i;
 187:     i.instancePos = a_i_instancePos;
 188: i.light = a_i_light;
 189: i.segmentOffset = a_i_segmentOffset;
 190: i.pivot = a_i_pivot;
 191: i.horizontalAngle = a_i_horizontalAngle;
 192: i.intensity = a_i_intensity;
 193: i.flapScale = a_i_flapScale;
 194: i.flapness = a_i_flapness;
 195: 
 196: 
 197:     BlockFrag o = FLWMain(v, i);
 198: 
 199:     v2f_texCoords = o.texCoords;
 200: v2f_color = o.color;
 201: v2f_diffuse = o.diffuse;
 202: v2f_light = o.light;
 203: 
 204: }

[13:33:21] [main/ERROR]: Shader compilation log for flywheel:block.frag: No errors.

[13:33:21] [main/ERROR]: Source for shader 'flywheel:block.frag':
   1: #version 110
   2: #define USE_FOG
   3: #define USE_FOG_LINEAR
   4: 
   5: #if defined(USE_FOG)
   6: varying float FragDistance;
   7: uniform vec4 uFogColor;
   8: #endif
   9: 
  10: #if defined(USE_FOG_LINEAR)
  11: uniform vec2 uFogRange;
  12: 
  13: float FLWFogFactor() {
  14:     return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
  15: }
  16:     #endif
  17: 
  18:     #if defined(USE_FOG_EXP2)
  19: uniform float uFogDensity;
  20: 
  21: float FLWFogFactor() {
  22:     float dist = FragDistance * uFogDensity;
  23:     return 1. / exp2(dist * dist);
  24: }
  25:     #endif
  26: // Adjust the [0,1] normalized lightmap value based on the texture matrix from LightTexture#enableLightmap
  27: vec2 shiftLight(vec2 lm) {
  28:     return lm * 0.99609375 + 0.03125;// * 255/256 + 1/32
  29: }
  30: 
  31: uniform sampler2D uBlockAtlas;
  32: uniform sampler2D uLightMap;
  33: 
  34: vec4 FLWBlockTexture(vec2 texCoords) {
  35:     return texture2D(uBlockAtlas, texCoords);
  36: }
  37: 
  38: void FLWFinalizeColor(vec4 color) {
  39:     #if defined(USE_FOG)
  40:     float a = color.a;
  41:     float fog = clamp(FLWFogFactor(), 0., 1.);
  42: 
  43:     color = mix(uFogColor, color, fog);
  44:     color.a = a;
  45:     #endif
  46: 
  47:     gl_FragColor = color;
  48: }
  49: 
  50: vec4 FLWLight(vec2 lightCoords) {
  51:     return texture2D(uLightMap, shiftLight(lightCoords));
  52: }
  53: 
  54: 
  55: 
  56: struct BlockFrag {
  57:     vec2 texCoords;
  58:     vec4 color;
  59:     float diffuse;
  60:     vec2 light;
  61: };
  62: 
  63: void FLWMain(BlockFrag r) {
  64:     vec4 tex = FLWBlockTexture(r.texCoords);
  65: 
  66:     vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;
  67: 
  68: //    flw_WorldPos = ;
  69: //    flw_Normal = ;
  70: //    flw_Albedo = tex.rgb;
  71: //    flw_Alpha = tex.a;
  72: //    flw_LightMap = r.light;
  73: //    flw_Tint = r.color;
  74:     FLWFinalizeColor(color);
  75: }
  76: 
  77: varying vec2 v2f_texCoords;
  78: varying vec4 v2f_color;
  79: varying float v2f_diffuse;
  80: varying vec2 v2f_light;
  81: 
  82: 
  83: //vec3 flw_WorldPos;
  84: //vec3 flw_Normal;
  85: //vec3 flw_Albedo;
  86: //float flw_Alpha;
  87: //vec2 flw_LightMap;
  88: //vec4 flw_Tint;
  89: 
  90: void main() {
  91:     BlockFrag f;
  92:     f.texCoords = v2f_texCoords;
  93: f.color = v2f_color;
  94: f.diffuse = v2f_diffuse;
  95: f.light = v2f_light;
  96: 
  97: 
  98:     FLWMain(f);
  99: }

[13:33:21] [main/ERROR]: Shader compilation log for create:flap.vert: No errors.

[13:33:21] [main/ERROR]: Source for shader 'create:flap.vert':
   1: #version 110
   2: #define USE_FOG
   3: #define USE_FOG_EXP2
   4: 
   5: #define PI 3.1415926538
   6: 
   7: uniform float uTime;
   8: uniform mat4 uViewProjection;
   9: uniform vec3 uCameraPos;
  10: 
  11: #if defined(USE_FOG)
  12: varying float FragDistance;
  13: #endif
  14: 
  15: void FLWFinalizeWorldPos(inout vec4 worldPos) {
  16:     #if defined(USE_FOG)
  17:     FragDistance = length(worldPos.xyz - uCameraPos);
  18:     #endif
  19: 
  20:     gl_Position = uViewProjection * worldPos;
  21: }
  22: 
  23: void FLWFinalizeNormal(inout vec3 normal) {
  24:     // noop
  25: }
  26: 
  27: 
  28: mat4 rotate(vec3 axis, float angle) {
  29:     float s = sin(angle);
  30:     float c = cos(angle);
  31:     float oc = 1. - c;
  32: 
  33:     vec3 sa = axis * s;
  34: 
  35:     mat4 mr = mat4(1.);
  36:     mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
  37:     mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
  38:     mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);
  39: 
  40:     return mr;
  41: }
  42: 
  43: mat4 rotation(vec3 rot) {
  44:     return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
  45: }
  46: 
  47: mat3 modelToNormal(mat4 mat) {
  48:     // Discard the edges. This won't be accurate for scaled or skewed matrices,
  49:     // but we don't have to work with those often.
  50:     mat3 m;
  51:     m[0] = mat[0].xyz;
  52:     m[1] = mat[1].xyz;
  53:     m[2] = mat[2].xyz;
  54:     return m;
  55: }
  56: 
  57: #define PIOVER2 1.5707963268
  58: 
  59: vec4 quat(vec3 axis, float angle) {
  60:     float halfAngle = angle * PIOVER2 / 180.0;
  61:     vec2 cs = sin(vec2(PIOVER2 - halfAngle, halfAngle)); // compute sin and cos in one instruction
  62:     return vec4(axis.xyz * cs.y,  cs.x);
  63: }
  64: 
  65: vec4 quatMult(vec4 q1, vec4 q2) {
  66:     // disgustingly vectorized quaternion multiplication
  67:     vec4 a = q1.w * q2.xyzw;
  68:     vec4 b = q1.x * q2.wzxy * vec4(1., -1., 1., -1.);
  69:     vec4 c = q1.y * q2.zwxy * vec4(1., 1., -1., -1.);
  70:     vec4 d = q1.z * q2.yxwz * vec4(-1., 1., 1., -1.);
  71: 
  72:     return a + b + c + d;
  73: }
  74: 
  75: vec3 rotateVertexByQuat(vec3 v, vec4 q) {
  76:     vec3 i = q.xyz;
  77:     return v + 2.0 * cross(i, cross(i, v) + q.w * v);
  78: }
  79: 
  80: vec3 rotateAbout(vec3 v, vec3 axis, float angle) {
  81:     return rotateVertexByQuat(v, quat(axis, angle));
  82: }
  83: 
  84: float diffuse(vec3 normal) {
  85:     vec3 n2 = normal * normal * vec3(.6, .25, .8);
  86:     return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
  87: }
  88: 
  89: 
  90: struct Flap {
  91:     vec3 instancePos;
  92:     vec2 light;
  93:     vec3 segmentOffset;
  94:     vec3 pivot;
  95:     float horizontalAngle;
  96:     float intensity;
  97:     float flapScale;
  98:     float flapness;
  99: };
 100: 
 101: 
 102: struct Vertex {
 103:     vec3 pos;
 104:     vec3 normal;
 105:     vec2 texCoords;
 106: };
 107: 
 108: struct BlockFrag {
 109:     vec2 texCoords;
 110:     vec4 color;
 111:     float diffuse;
 112:     vec2 light;
 113: };
 114: 
 115: 
 116: float toRad(float degrees) {
 117:     return fract(degrees / 360.) * PI * 2.;
 118: }
 119: 
 120: float getFlapAngle(float flapness, float intensity, float scale) {
 121:     float absFlap = abs(flapness);
 122: 
 123:     float angle = sin((1. - absFlap) * PI * intensity) * 30. * flapness * scale;
 124: 
 125:     float halfAngle = angle * 0.5;
 126: 
 127:     float which = step(0., flapness);// 0 if negative, 1 if positive
 128:     float degrees = which * halfAngle + (1. - which) * angle;// branchless conditional multiply
 129: 
 130:     return degrees;
 131: }
 132: 
 133: BlockFrag FLWMain(Vertex v, Flap flap) {
 134:     float flapAngle = getFlapAngle(flap.flapness, flap.intensity, flap.flapScale);
 135: 
 136:     vec4 orientation = quat(vec3(0., 1., 0.), -flap.horizontalAngle);
 137:     vec4 flapRotation = quat(vec3(1., 0., 0.), flapAngle);
 138: 
 139:     vec3 rotated = rotateVertexByQuat(v.pos - flap.pivot, flapRotation) + flap.pivot + flap.segmentOffset;
 140:     rotated = rotateVertexByQuat(rotated - .5, orientation) + flap.instancePos + .5;
 141: 
 142:     vec4 worldPos = vec4(rotated, 1.);
 143:     vec3 norm = rotateVertexByQuat(rotateVertexByQuat(v.normal, flapRotation), orientation);
 144: 
 145:     FLWFinalizeWorldPos(worldPos);
 146:     FLWFinalizeNormal(norm);
 147: 
 148:     BlockFrag b;
 149:     b.diffuse = diffuse(norm);
 150:     b.texCoords = v.texCoords;
 151:     b.light = flap.light;
 152:     #if defined(DEBUG_NORMAL)
 153:     b.color = vec4(norm, 1.);
 154:     #else
 155:     b.color = vec4(1.);
 156:     #endif
 157:     return b;
 158: }
 159: attribute vec3 a_v_pos;
 160: attribute vec3 a_v_normal;
 161: attribute vec2 a_v_texCoords;
 162: 
 163: attribute vec3 a_i_instancePos;
 164: attribute vec2 a_i_light;
 165: attribute vec3 a_i_segmentOffset;
 166: attribute vec3 a_i_pivot;
 167: attribute float a_i_horizontalAngle;
 168: attribute float a_i_intensity;
 169: attribute float a_i_flapScale;
 170: attribute float a_i_flapness;
 171: 
 172: 
 173: varying vec2 v2f_texCoords;
 174: varying vec4 v2f_color;
 175: varying float v2f_diffuse;
 176: varying vec2 v2f_light;
 177: 
 178: 
 179: void main() {
 180:     Vertex v;
 181:     v.pos = a_v_pos;
 182: v.normal = a_v_normal;
 183: v.texCoords = a_v_texCoords;
 184: 
 185: 
 186:     Flap i;
 187:     i.instancePos = a_i_instancePos;
 188: i.light = a_i_light;
 189: i.segmentOffset = a_i_segmentOffset;
 190: i.pivot = a_i_pivot;
 191: i.horizontalAngle = a_i_horizontalAngle;
 192: i.intensity = a_i_intensity;
 193: i.flapScale = a_i_flapScale;
 194: i.flapness = a_i_flapness;
 195: 
 196: 
 197:     BlockFrag o = FLWMain(v, i);
 198: 
 199:     v2f_texCoords = o.texCoords;
 200: v2f_color = o.color;
 201: v2f_diffuse = o.diffuse;
 202: v2f_light = o.light;
 203: 
 204: }

[13:33:21] [main/ERROR]: Shader compilation log for flywheel:block.frag: No errors.

[13:33:21] [main/ERROR]: Source for shader 'flywheel:block.frag':
   1: #version 110
   2: #define USE_FOG
   3: #define USE_FOG_EXP2
   4: 
   5: #if defined(USE_FOG)
   6: varying float FragDistance;
   7: uniform vec4 uFogColor;
   8: #endif
   9: 
  10: #if defined(USE_FOG_LINEAR)
  11: uniform vec2 uFogRange;
  12: 
  13: float FLWFogFactor() {
  14:     return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
  15: }
  16:     #endif
  17: 
  18:     #if defined(USE_FOG_EXP2)
  19: uniform float uFogDensity;
  20: 
  21: float FLWFogFactor() {
  22:     float dist = FragDistance * uFogDensity;
  23:     return 1. / exp2(dist * dist);
  24: }
  25:     #endif
  26: // Adjust the [0,1] normalized lightmap value based on the texture matrix from LightTexture#enableLightmap
  27: vec2 shiftLight(vec2 lm) {
  28:     return lm * 0.99609375 + 0.03125;// * 255/256 + 1/32
  29: }
  30: 
  31: uniform sampler2D uBlockAtlas;
  32: uniform sampler2D uLightMap;
  33: 
  34: vec4 FLWBlockTexture(vec2 texCoords) {
  35:     return texture2D(uBlockAtlas, texCoords);
  36: }
  37: 
  38: void FLWFinalizeColor(vec4 color) {
  39:     #if defined(USE_FOG)
  40:     float a = color.a;
  41:     float fog = clamp(FLWFogFactor(), 0., 1.);
  42: 
  43:     color = mix(uFogColor, color, fog);
  44:     color.a = a;
  45:     #endif
  46: 
  47:     gl_FragColor = color;
  48: }
  49: 
  50: vec4 FLWLight(vec2 lightCoords) {
  51:     return texture2D(uLightMap, shiftLight(lightCoords));
  52: }
  53: 
  54: 
  55: 
  56: struct BlockFrag {
  57:     vec2 texCoords;
  58:     vec4 color;
  59:     float diffuse;
  60:     vec2 light;
  61: };
  62: 
  63: void FLWMain(BlockFrag r) {
  64:     vec4 tex = FLWBlockTexture(r.texCoords);
  65: 
  66:     vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;
  67: 
  68: //    flw_WorldPos = ;
  69: //    flw_Normal = ;
  70: //    flw_Albedo = tex.rgb;
  71: //    flw_Alpha = tex.a;
  72: //    flw_LightMap = r.light;
  73: //    flw_Tint = r.color;
  74:     FLWFinalizeColor(color);
  75: }
  76: 
  77: varying vec2 v2f_texCoords;
  78: varying vec4 v2f_color;
  79: varying float v2f_diffuse;
  80: varying vec2 v2f_light;
  81: 
  82: 
  83: //vec3 flw_WorldPos;
  84: //vec3 flw_Normal;
  85: //vec3 flw_Albedo;
  86: //float flw_Alpha;
  87: //vec2 flw_LightMap;
  88: //vec4 flw_Tint;
  89: 
  90: void main() {
  91:     BlockFrag f;
  92:     f.texCoords = v2f_texCoords;
  93: f.color = v2f_color;
  94: f.diffuse = v2f_diffuse;
  95: f.light = v2f_light;
  96: 
  97: 
  98:     FLWMain(f);
  99: }

[13:33:21] [main/ERROR]: Shader compilation log for create:flap.vert: No errors.

[13:33:21] [main/ERROR]: Source for shader 'create:flap.vert':
   1: #version 110
   2: 
   3: #define PI 3.1415926538
   4: 
   5: uniform float uTime;
   6: uniform mat4 uViewProjection;
   7: uniform vec3 uCameraPos;
   8: 
   9: #if defined(USE_FOG)
  10: varying float FragDistance;
  11: #endif
  12: 
  13: void FLWFinalizeWorldPos(inout vec4 worldPos) {
  14:     #if defined(USE_FOG)
  15:     FragDistance = length(worldPos.xyz - uCameraPos);
  16:     #endif
  17: 
  18:     gl_Position = uViewProjection * worldPos;
  19: }
  20: 
  21: void FLWFinalizeNormal(inout vec3 normal) {
  22:     // noop
  23: }
  24: 
  25: 
  26: mat4 rotate(vec3 axis, float angle) {
  27:     float s = sin(angle);
  28:     float c = cos(angle);
  29:     float oc = 1. - c;
  30: 
  31:     vec3 sa = axis * s;
  32: 
  33:     mat4 mr = mat4(1.);
  34:     mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
  35:     mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
  36:     mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);
  37: 
  38:     return mr;
  39: }
  40: 
  41: mat4 rotation(vec3 rot) {
  42:     return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
  43: }
  44: 
  45: mat3 modelToNormal(mat4 mat) {
  46:     // Discard the edges. This won't be accurate for scaled or skewed matrices,
  47:     // but we don't have to work with those often.
  48:     mat3 m;
  49:     m[0] = mat[0].xyz;
  50:     m[1] = mat[1].xyz;
  51:     m[2] = mat[2].xyz;
  52:     return m;
  53: }
  54: 
  55: #define PIOVER2 1.5707963268
  56: 
  57: vec4 quat(vec3 axis, float angle) {
  58:     float halfAngle = angle * PIOVER2 / 180.0;
  59:     vec2 cs = sin(vec2(PIOVER2 - halfAngle, halfAngle)); // compute sin and cos in one instruction
  60:     return vec4(axis.xyz * cs.y,  cs.x);
  61: }
  62: 
  63: vec4 quatMult(vec4 q1, vec4 q2) {
  64:     // disgustingly vectorized quaternion multiplication
  65:     vec4 a = q1.w * q2.xyzw;
  66:     vec4 b = q1.x * q2.wzxy * vec4(1., -1., 1., -1.);
  67:     vec4 c = q1.y * q2.zwxy * vec4(1., 1., -1., -1.);
  68:     vec4 d = q1.z * q2.yxwz * vec4(-1., 1., 1., -1.);
  69: 
  70:     return a + b + c + d;
  71: }
  72: 
  73: vec3 rotateVertexByQuat(vec3 v, vec4 q) {
  74:     vec3 i = q.xyz;
  75:     return v + 2.0 * cross(i, cross(i, v) + q.w * v);
  76: }
  77: 
  78: vec3 rotateAbout(vec3 v, vec3 axis, float angle) {
  79:     return rotateVertexByQuat(v, quat(axis, angle));
  80: }
  81: 
  82: float diffuse(vec3 normal) {
  83:     vec3 n2 = normal * normal * vec3(.6, .25, .8);
  84:     return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
  85: }
  86: 
  87: 
  88: struct Flap {
  89:     vec3 instancePos;
  90:     vec2 light;
  91:     vec3 segmentOffset;
  92:     vec3 pivot;
  93:     float horizontalAngle;
  94:     float intensity;
  95:     float flapScale;
  96:     float flapness;
  97: };
  98: 
  99: 
 100: struct Vertex {
 101:     vec3 pos;
 102:     vec3 normal;
 103:     vec2 texCoords;
 104: };
 105: 
 106: struct BlockFrag {
 107:     vec2 texCoords;
 108:     vec4 color;
 109:     float diffuse;
 110:     vec2 light;
 111: };
 112: 
 113: 
 114: float toRad(float degrees) {
 115:     return fract(degrees / 360.) * PI * 2.;
 116: }
 117: 
 118: float getFlapAngle(float flapness, float intensity, float scale) {
 119:     float absFlap = abs(flapness);
 120: 
 121:     float angle = sin((1. - absFlap) * PI * intensity) * 30. * flapness * scale;
 122: 
 123:     float halfAngle = angle * 0.5;
 124: 
 125:     float which = step(0., flapness);// 0 if negative, 1 if positive
 126:     float degrees = which * halfAngle + (1. - which) * angle;// branchless conditional multiply
 127: 
 128:     return degrees;
 129: }
 130: 
 131: BlockFrag FLWMain(Vertex v, Flap flap) {
 132:     float flapAngle = getFlapAngle(flap.flapness, flap.intensity, flap.flapScale);
 133: 
 134:     vec4 orientation = quat(vec3(0., 1., 0.), -flap.horizontalAngle);
 135:     vec4 flapRotation = quat(vec3(1., 0., 0.), flapAngle);
 136: 
 137:     vec3 rotated = rotateVertexByQuat(v.pos - flap.pivot, flapRotation) + flap.pivot + flap.segmentOffset;
 138:     rotated = rotateVertexByQuat(rotated - .5, orientation) + flap.instancePos + .5;
 139: 
 140:     vec4 worldPos = vec4(rotated, 1.);
 141:     vec3 norm = rotateVertexByQuat(rotateVertexByQuat(v.normal, flapRotation), orientation);
 142: 
 143:     FLWFinalizeWorldPos(worldPos);
 144:     FLWFinalizeNormal(norm);
 145: 
 146:     BlockFrag b;
 147:     b.diffuse = diffuse(norm);
 148:     b.texCoords = v.texCoords;
 149:     b.light = flap.light;
 150:     #if defined(DEBUG_NORMAL)
 151:     b.color = vec4(norm, 1.);
 152:     #else
 153:     b.color = vec4(1.);
 154:     #endif
 155:     return b;
 156: }
 157: attribute vec3 a_v_pos;
 158: attribute vec3 a_v_normal;
 159: attribute vec2 a_v_texCoords;
 160: 
 161: attribute vec3 a_i_instancePos;
 162: attribute vec2 a_i_light;
 163: attribute vec3 a_i_segmentOffset;
 164: attribute vec3 a_i_pivot;
 165: attribute float a_i_horizontalAngle;
 166: attribute float a_i_intensity;
 167: attribute float a_i_flapScale;
 168: attribute float a_i_flapness;
 169: 
 170: 
 171: varying vec2 v2f_texCoords;
 172: varying vec4 v2f_color;
 173: varying float v2f_diffuse;
 174: varying vec2 v2f_light;
 175: 
 176: 
 177: void main() {
 178:     Vertex v;
 179:     v.pos = a_v_pos;
 180: v.normal = a_v_normal;
 181: v.texCoords = a_v_texCoords;
 182: 
 183: 
 184:     Flap i;
 185:     i.instancePos = a_i_instancePos;
 186: i.light = a_i_light;
 187: i.segmentOffset = a_i_segmentOffset;
 188: i.pivot = a_i_pivot;
 189: i.horizontalAngle = a_i_horizontalAngle;
 190: i.intensity = a_i_intensity;
 191: i.flapScale = a_i_flapScale;
 192: i.flapness = a_i_flapness;
 193: 
 194: 
 195:     BlockFrag o = FLWMain(v, i);
 196: 
 197:     v2f_texCoords = o.texCoords;
 198: v2f_color = o.color;
 199: v2f_diffuse = o.diffuse;
 200: v2f_light = o.light;
 201: 
 202: }

[13:33:21] [main/ERROR]: Shader compilation log for flywheel:block.frag: No errors.

[13:33:21] [main/ERROR]: Source for shader 'flywheel:block.frag':
   1: #version 110
   2: 
   3: #if defined(USE_FOG)
   4: varying float FragDistance;
   5: uniform vec4 uFogColor;
   6: #endif
   7: 
   8: #if defined(USE_FOG_LINEAR)
   9: uniform vec2 uFogRange;
  10: 
  11: float FLWFogFactor() {
  12:     return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
  13: }
  14:     #endif
  15: 
  16:     #if defined(USE_FOG_EXP2)
  17: uniform float uFogDensity;
  18: 
  19: float FLWFogFactor() {
  20:     float dist = FragDistance * uFogDensity;
  21:     return 1. / exp2(dist * dist);
  22: }
  23:     #endif
  24: // Adjust the [0,1] normalized lightmap value based on the texture matrix from LightTexture#enableLightmap
  25: vec2 shiftLight(vec2 lm) {
  26:     return lm * 0.99609375 + 0.03125;// * 255/256 + 1/32
  27: }
  28: 
  29: uniform sampler2D uBlockAtlas;
  30: uniform sampler2D uLightMap;
  31: 
  32: vec4 FLWBlockTexture(vec2 texCoords) {
  33:     return texture2D(uBlockAtlas, texCoords);
  34: }
  35: 
  36: void FLWFinalizeColor(vec4 color) {
  37:     #if defined(USE_FOG)
  38:     float a = color.a;
  39:     float fog = clamp(FLWFogFactor(), 0., 1.);
  40: 
  41:     color = mix(uFogColor, color, fog);
  42:     color.a = a;
  43:     #endif
  44: 
  45:     gl_FragColor = color;
  46: }
  47: 
  48: vec4 FLWLight(vec2 lightCoords) {
  49:     return texture2D(uLightMap, shiftLight(lightCoords));
  50: }
  51: 
  52: 
  53: 
  54: struct BlockFrag {
  55:     vec2 texCoords;
  56:     vec4 color;
  57:     float diffuse;
  58:     vec2 light;
  59: };
  60: 
  61: void FLWMain(BlockFrag r) {
  62:     vec4 tex = FLWBlockTexture(r.texCoords);
  63: 
  64:     vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;
  65: 
  66: //    flw_WorldPos = ;
  67: //    flw_Normal = ;
  68: //    flw_Albedo = tex.rgb;
  69: //    flw_Alpha = tex.a;
  70: //    flw_LightMap = r.light;
  71: //    flw_Tint = r.color;
  72:     FLWFinalizeColor(color);
  73: }
  74: 
  75: varying vec2 v2f_texCoords;
  76: varying vec4 v2f_color;
  77: varying float v2f_diffuse;
  78: varying vec2 v2f_light;
  79: 
  80: 
  81: //vec3 flw_WorldPos;
  82: //vec3 flw_Normal;
  83: //vec3 flw_Albedo;
  84: //float flw_Alpha;
  85: //vec2 flw_LightMap;
  86: //vec4 flw_Tint;
  87: 
  88: void main() {
  89:     BlockFrag f;
  90:     f.texCoords = v2f_texCoords;
  91: f.color = v2f_color;
  92: f.diffuse = v2f_diffuse;
  93: f.light = v2f_light;
  94: 
  95: 
  96:     FLWMain(f);
  97: }

[13:33:21] [main/ERROR]: Shader compilation log for create:belt.vert: No errors.

[13:33:21] [main/ERROR]: Source for shader 'create:belt.vert':
   1: #version 110
   2: #define DEBUG_RAINBOW
   3: 
   4: #define PI 3.1415926538
   5: 
   6: uniform float uTime;
   7: uniform mat4 uViewProjection;
   8: uniform vec3 uCameraPos;
   9: 
  10: #if defined(USE_FOG)
  11: varying float FragDistance;
  12: #endif
  13: 
  14: void FLWFinalizeWorldPos(inout vec4 worldPos) {
  15:     #if defined(USE_FOG)
  16:     FragDistance = length(worldPos.xyz - uCameraPos);
  17:     #endif
  18: 
  19:     gl_Position = uViewProjection * worldPos;
  20: }
  21: 
  22: void FLWFinalizeNormal(inout vec3 normal) {
  23:     // noop
  24: }
  25: 
  26: 
  27: #define PIOVER2 1.5707963268
  28: 
  29: vec4 quat(vec3 axis, float angle) {
  30:     float halfAngle = angle * PIOVER2 / 180.0;
  31:     vec2 cs = sin(vec2(PIOVER2 - halfAngle, halfAngle)); // compute sin and cos in one instruction
  32:     return vec4(axis.xyz * cs.y,  cs.x);
  33: }
  34: 
  35: vec4 quatMult(vec4 q1, vec4 q2) {
  36:     // disgustingly vectorized quaternion multiplication
  37:     vec4 a = q1.w * q2.xyzw;
  38:     vec4 b = q1.x * q2.wzxy * vec4(1., -1., 1., -1.);
  39:     vec4 c = q1.y * q2.zwxy * vec4(1., 1., -1., -1.);
  40:     vec4 d = q1.z * q2.yxwz * vec4(-1., 1., 1., -1.);
  41: 
  42:     return a + b + c + d;
  43: }
  44: 
  45: vec3 rotateVertexByQuat(vec3 v, vec4 q) {
  46:     vec3 i = q.xyz;
  47:     return v + 2.0 * cross(i, cross(i, v) + q.w * v);
  48: }
  49: 
  50: vec3 rotateAbout(vec3 v, vec3 axis, float angle) {
  51:     return rotateVertexByQuat(v, quat(axis, angle));
  52: }
  53: 
  54: mat4 rotate(vec3 axis, float angle) {
  55:     float s = sin(angle);
  56:     float c = cos(angle);
  57:     float oc = 1. - c;
  58: 
  59:     vec3 sa = axis * s;
  60: 
  61:     mat4 mr = mat4(1.);
  62:     mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
  63:     mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
  64:     mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);
  65: 
  66:     return mr;
  67: }
  68: 
  69: mat4 rotation(vec3 rot) {
  70:     return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
  71: }
  72: 
  73: mat3 modelToNormal(mat4 mat) {
  74:     // Discard the edges. This won't be accurate for scaled or skewed matrices,
  75:     // but we don't have to work with those often.
  76:     mat3 m;
  77:     m[0] = mat[0].xyz;
  78:     m[1] = mat[1].xyz;
  79:     m[2] = mat[2].xyz;
  80:     return m;
  81: }
  82: 
  83: float diffuse(vec3 normal) {
  84:     vec3 n2 = normal * normal * vec3(.6, .25, .8);
  85:     return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
  86: }
  87: 
  88: 
  89: struct Belt {
  90:     vec2 light;
  91:     vec4 color;
  92:     vec3 pos;
  93:     float speed;
  94:     float offset;
  95:     vec4 rotation;
  96:     vec2 sourceTexture;
  97:     vec4 scrollTexture;
  98:     float scrollMult;
  99: };
 100: 
 101: 
 102: struct Vertex {
 103:     vec3 pos;
 104:     vec3 normal;
 105:     vec2 texCoords;
 106: };
 107: 
 108: struct BlockFrag {
 109:     vec2 texCoords;
 110:     vec4 color;
 111:     float diffuse;
 112:     vec2 light;
 113: };
 114: 
 115: BlockFrag FLWMain(Vertex v, Belt instance) {
 116:     vec3 rotated = rotateVertexByQuat(v.pos - .5, instance.rotation) + instance.pos + .5;
 117: 
 118:     vec4 worldPos = vec4(rotated, 1.);
 119: 
 120:     vec3 norm = rotateVertexByQuat(v.normal, instance.rotation);
 121: 
 122:     FLWFinalizeWorldPos(worldPos);
 123:     FLWFinalizeNormal(norm);
 124: 
 125:     float scrollSize = instance.scrollTexture.w - instance.scrollTexture.y;
 126:     float scroll = fract(instance.speed * uTime / (31.5 * 16.) + instance.offset) * scrollSize * instance.scrollMult;
 127: 
 128:     BlockFrag b;
 129:     b.diffuse = diffuse(norm);
 130:     b.texCoords = v.texCoords - instance.sourceTexture + instance.scrollTexture.xy + vec2(0, scroll);
 131:     b.light = instance.light;
 132: 
 133:     #if defined(DEBUG_RAINBOW)
 134:     b.color = instance.color;
 135:     #elif defined(DEBUG_NORMAL)
 136:     b.color = vec4(norm, 1.);
 137:     #else
 138:     b.color = vec4(1.);
 139:     #endif
 140: 
 141:     return b;
 142: }
 143: attribute vec3 a_v_pos;
 144: attribute vec3 a_v_normal;
 145: attribute vec2 a_v_texCoords;
 146: 
 147: attribute vec2 a_i_light;
 148: attribute vec4 a_i_color;
 149: attribute vec3 a_i_pos;
 150: attribute float a_i_speed;
 151: attribute float a_i_offset;
 152: attribute vec4 a_i_rotation;
 153: attribute vec2 a_i_sourceTexture;
 154: attribute vec4 a_i_scrollTexture;
 155: attribute float a_i_scrollMult;
 156: 
 157: 
 158: varying vec2 v2f_texCoords;
 159: varying vec4 v2f_color;
 160: varying float v2f_diffuse;
 161: varying vec2 v2f_light;
 162: 
 163: 
 164: void main() {
 165:     Vertex v;
 166:     v.pos = a_v_pos;
 167: v.normal = a_v_normal;
 168: v.texCoords = a_v_texCoords;
 169: 
 170: 
 171:     Belt i;
 172:     i.light = a_i_light;
 173: i.color = a_i_color;
 174: i.pos = a_i_pos;
 175: i.speed = a_i_speed;
 176: i.offset = a_i_offset;
 177: i.rotation = a_i_rotation;
 178: i.sourceTexture = a_i_sourceTexture;
 179: i.scrollTexture = a_i_scrollTexture;
 180: i.scrollMult = a_i_scrollMult;
 181: 
 182: 
 183:     BlockFrag o = FLWMain(v, i);
 184: 
 185:     v2f_texCoords = o.texCoords;
 186: v2f_color = o.color;
 187: v2f_diffuse = o.diffuse;
 188: v2f_light = o.light;
 189: 
 190: }

[13:33:21] [main/ERROR]: Shader compilation log for flywheel:block.frag: No errors.

[13:33:21] [main/ERROR]: Source for shader 'flywheel:block.frag':
   1: #version 110
   2: #define DEBUG_RAINBOW
   3: 
   4: #if defined(USE_FOG)
   5: varying float FragDistance;
   6: uniform vec4 uFogColor;
   7: #endif
   8: 
   9: #if defined(USE_FOG_LINEAR)
  10: uniform vec2 uFogRange;
  11: 
  12: float FLWFogFactor() {
  13:     return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
  14: }
  15:     #endif
  16: 
  17:     #if defined(USE_FOG_EXP2)
  18: uniform float uFogDensity;
  19: 
  20: float FLWFogFactor() {
  21:     float dist = FragDistance * uFogDensity;
  22:     return 1. / exp2(dist * dist);
  23: }
  24:     #endif
  25: // Adjust the [0,1] normalized lightmap value based on the texture matrix from LightTexture#enableLightmap
  26: vec2 shiftLight(vec2 lm) {
  27:     return lm * 0.99609375 + 0.03125;// * 255/256 + 1/32
  28: }
  29: 
  30: uniform sampler2D uBlockAtlas;
  31: uniform sampler2D uLightMap;
  32: 
  33: vec4 FLWBlockTexture(vec2 texCoords) {
  34:     return texture2D(uBlockAtlas, texCoords);
  35: }
  36: 
  37: void FLWFinalizeColor(vec4 color) {
  38:     #if defined(USE_FOG)
  39:     float a = color.a;
  40:     float fog = clamp(FLWFogFactor(), 0., 1.);
  41: 
  42:     color = mix(uFogColor, color, fog);
  43:     color.a = a;
  44:     #endif
  45: 
  46:     gl_FragColor = color;
  47: }
  48: 
  49: vec4 FLWLight(vec2 lightCoords) {
  50:     return texture2D(uLightMap, shiftLight(lightCoords));
  51: }
  52: 
  53: 
  54: 
  55: struct BlockFrag {
  56:     vec2 texCoords;
  57:     vec4 color;
  58:     float diffuse;
  59:     vec2 light;
  60: };
  61: 
  62: void FLWMain(BlockFrag r) {
  63:     vec4 tex = FLWBlockTexture(r.texCoords);
  64: 
  65:     vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;
  66: 
  67: //    flw_WorldPos = ;
  68: //    flw_Normal = ;
  69: //    flw_Albedo = tex.rgb;
  70: //    flw_Alpha = tex.a;
  71: //    flw_LightMap = r.light;
  72: //    flw_Tint = r.color;
  73:     FLWFinalizeColor(color);
  74: }
  75: 
  76: varying vec2 v2f_texCoords;
  77: varying vec4 v2f_color;
  78: varying float v2f_diffuse;
  79: varying vec2 v2f_light;
  80: 
  81: 
  82: //vec3 flw_WorldPos;
  83: //vec3 flw_Normal;
  84: //vec3 flw_Albedo;
  85: //float flw_Alpha;
  86: //vec2 flw_LightMap;
  87: //vec4 flw_Tint;
  88: 
  89: void main() {
  90:     BlockFrag f;
  91:     f.texCoords = v2f_texCoords;
  92: f.color = v2f_color;
  93: f.diffuse = v2f_diffuse;
  94: f.light = v2f_light;
  95: 
  96: 
  97:     FLWMain(f);
  98: }

[13:33:21] [main/ERROR]: Shader compilation log for create:belt.vert: No errors.

[13:33:21] [main/ERROR]: Source for shader 'create:belt.vert':
   1: #version 110
   2: #define DEBUG_NORMAL
   3: 
   4: #define PI 3.1415926538
   5: 
   6: uniform float uTime;
   7: uniform mat4 uViewProjection;
   8: uniform vec3 uCameraPos;
   9: 
  10: #if defined(USE_FOG)
  11: varying float FragDistance;
  12: #endif
  13: 
  14: void FLWFinalizeWorldPos(inout vec4 worldPos) {
  15:     #if defined(USE_FOG)
  16:     FragDistance = length(worldPos.xyz - uCameraPos);
  17:     #endif
  18: 
  19:     gl_Position = uViewProjection * worldPos;
  20: }
  21: 
  22: void FLWFinalizeNormal(inout vec3 normal) {
  23:     // noop
  24: }
  25: 
  26: 
  27: #define PIOVER2 1.5707963268
  28: 
  29: vec4 quat(vec3 axis, float angle) {
  30:     float halfAngle = angle * PIOVER2 / 180.0;
  31:     vec2 cs = sin(vec2(PIOVER2 - halfAngle, halfAngle)); // compute sin and cos in one instruction
  32:     return vec4(axis.xyz * cs.y,  cs.x);
  33: }
  34: 
  35: vec4 quatMult(vec4 q1, vec4 q2) {
  36:     // disgustingly vectorized quaternion multiplication
  37:     vec4 a = q1.w * q2.xyzw;
  38:     vec4 b = q1.x * q2.wzxy * vec4(1., -1., 1., -1.);
  39:     vec4 c = q1.y * q2.zwxy * vec4(1., 1., -1., -1.);
  40:     vec4 d = q1.z * q2.yxwz * vec4(-1., 1., 1., -1.);
  41: 
  42:     return a + b + c + d;
  43: }
  44: 
  45: vec3 rotateVertexByQuat(vec3 v, vec4 q) {
  46:     vec3 i = q.xyz;
  47:     return v + 2.0 * cross(i, cross(i, v) + q.w * v);
  48: }
  49: 
  50: vec3 rotateAbout(vec3 v, vec3 axis, float angle) {
  51:     return rotateVertexByQuat(v, quat(axis, angle));
  52: }
  53: 
  54: mat4 rotate(vec3 axis, float angle) {
  55:     float s = sin(angle);
  56:     float c = cos(angle);
  57:     float oc = 1. - c;
  58: 
  59:     vec3 sa = axis * s;
  60: 
  61:     mat4 mr = mat4(1.);
  62:     mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
  63:     mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
  64:     mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);
  65: 
  66:     return mr;
  67: }
  68: 
  69: mat4 rotation(vec3 rot) {
  70:     return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
  71: }
  72: 
  73: mat3 modelToNormal(mat4 mat) {
  74:     // Discard the edges. This won't be accurate for scaled or skewed matrices,
  75:     // but we don't have to work with those often.
  76:     mat3 m;
  77:     m[0] = mat[0].xyz;
  78:     m[1] = mat[1].xyz;
  79:     m[2] = mat[2].xyz;
  80:     return m;
  81: }
  82: 
  83: float diffuse(vec3 normal) {
  84:     vec3 n2 = normal * normal * vec3(.6, .25, .8);
  85:     return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
  86: }
  87: 
  88: 
  89: struct Belt {
  90:     vec2 light;
  91:     vec4 color;
  92:     vec3 pos;
  93:     float speed;
  94:     float offset;
  95:     vec4 rotation;
  96:     vec2 sourceTexture;
  97:     vec4 scrollTexture;
  98:     float scrollMult;
  99: };
 100: 
 101: 
 102: struct Vertex {
 103:     vec3 pos;
 104:     vec3 normal;
 105:     vec2 texCoords;
 106: };
 107: 
 108: struct BlockFrag {
 109:     vec2 texCoords;
 110:     vec4 color;
 111:     float diffuse;
 112:     vec2 light;
 113: };
 114: 
 115: BlockFrag FLWMain(Vertex v, Belt instance) {
 116:     vec3 rotated = rotateVertexByQuat(v.pos - .5, instance.rotation) + instance.pos + .5;
 117: 
 118:     vec4 worldPos = vec4(rotated, 1.);
 119: 
 120:     vec3 norm = rotateVertexByQuat(v.normal, instance.rotation);
 121: 
 122:     FLWFinalizeWorldPos(worldPos);
 123:     FLWFinalizeNormal(norm);
 124: 
 125:     float scrollSize = instance.scrollTexture.w - instance.scrollTexture.y;
 126:     float scroll = fract(instance.speed * uTime / (31.5 * 16.) + instance.offset) * scrollSize * instance.scrollMult;
 127: 
 128:     BlockFrag b;
 129:     b.diffuse = diffuse(norm);
 130:     b.texCoords = v.texCoords - instance.sourceTexture + instance.scrollTexture.xy + vec2(0, scroll);
 131:     b.light = instance.light;
 132: 
 133:     #if defined(DEBUG_RAINBOW)
 134:     b.color = instance.color;
 135:     #elif defined(DEBUG_NORMAL)
 136:     b.color = vec4(norm, 1.);
 137:     #else
 138:     b.color = vec4(1.);
 139:     #endif
 140: 
 141:     return b;
 142: }
 143: attribute vec3 a_v_pos;
 144: attribute vec3 a_v_normal;
 145: attribute vec2 a_v_texCoords;
 146: 
 147: attribute vec2 a_i_light;
 148: attribute vec4 a_i_color;
 149: attribute vec3 a_i_pos;
 150: attribute float a_i_speed;
 151: attribute float a_i_offset;
 152: attribute vec4 a_i_rotation;
 153: attribute vec2 a_i_sourceTexture;
 154: attribute vec4 a_i_scrollTexture;
 155: attribute float a_i_scrollMult;
 156: 
 157: 
 158: varying vec2 v2f_texCoords;
 159: varying vec4 v2f_color;
 160: varying float v2f_diffuse;
 161: varying vec2 v2f_light;
 162: 
 163: 
 164: void main() {
 165:     Vertex v;
 166:     v.pos = a_v_pos;
 167: v.normal = a_v_normal;
 168: v.texCoords = a_v_texCoords;
 169: 
 170: 
 171:     Belt i;
 172:     i.light = a_i_light;
 173: i.color = a_i_color;
 174: i.pos = a_i_pos;
 175: i.speed = a_i_speed;
 176: i.offset = a_i_offset;
 177: i.rotation = a_i_rotation;
 178: i.sourceTexture = a_i_sourceTexture;
 179: i.scrollTexture = a_i_scrollTexture;
 180: i.scrollMult = a_i_scrollMult;
 181: 
 182: 
 183:     BlockFrag o = FLWMain(v, i);
 184: 
 185:     v2f_texCoords = o.texCoords;
 186: v2f_color = o.color;
 187: v2f_diffuse = o.diffuse;
 188: v2f_light = o.light;
 189: 
 190: }

[13:33:21] [main/ERROR]: Shader compilation log for flywheel:block.frag: No errors.

[13:33:21] [main/ERROR]: Source for shader 'flywheel:block.frag':
   1: #version 110
   2: #define DEBUG_NORMAL
   3: 
   4: #if defined(USE_FOG)
   5: varying float FragDistance;
   6: uniform vec4 uFogColor;
   7: #endif
   8: 
   9: #if defined(USE_FOG_LINEAR)
  10: uniform vec2 uFogRange;
  11: 
  12: float FLWFogFactor() {
  13:     return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
  14: }
  15:     #endif
  16: 
  17:     #if defined(USE_FOG_EXP2)
  18: uniform float uFogDensity;
  19: 
  20: float FLWFogFactor() {
  21:     float dist = FragDistance * uFogDensity;
  22:     return 1. / exp2(dist * dist);
  23: }
  24:     #endif
  25: // Adjust the [0,1] normalized lightmap value based on the texture matrix from LightTexture#enableLightmap
  26: vec2 shiftLight(vec2 lm) {
  27:     return lm * 0.99609375 + 0.03125;// * 255/256 + 1/32
  28: }
  29: 
  30: uniform sampler2D uBlockAtlas;
  31: uniform sampler2D uLightMap;
  32: 
  33: vec4 FLWBlockTexture(vec2 texCoords) {
  34:     return texture2D(uBlockAtlas, texCoords);
  35: }
  36: 
  37: void FLWFinalizeColor(vec4 color) {
  38:     #if defined(USE_FOG)
  39:     float a = color.a;
  40:     float fog = clamp(FLWFogFactor(), 0., 1.);
  41: 
  42:     color = mix(uFogColor, color, fog);
  43:     color.a = a;
  44:     #endif
  45: 
  46:     gl_FragColor = color;
  47: }
  48: 
  49: vec4 FLWLight(vec2 lightCoords) {
  50:     return texture2D(uLightMap, shiftLight(lightCoords));
  51: }
  52: 
  53: 
  54: 
  55: struct BlockFrag {
  56:     vec2 texCoords;
  57:     vec4 color;
  58:     float diffuse;
  59:     vec2 light;
  60: };
  61: 
  62: void FLWMain(BlockFrag r) {
  63:     vec4 tex = FLWBlockTexture(r.texCoords);
  64: 
  65:     vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;
  66: 
  67: //    flw_WorldPos = ;
  68: //    flw_Normal = ;
  69: //    flw_Albedo = tex.rgb;
  70: //    flw_Alpha = tex.a;
  71: //    flw_LightMap = r.light;
  72: //    flw_Tint = r.color;
  73:     FLWFinalizeColor(color);
  74: }
  75: 
  76: varying vec2 v2f_texCoords;
  77: varying vec4 v2f_color;
  78: varying float v2f_diffuse;
  79: varying vec2 v2f_light;
  80: 
  81: 
  82: //vec3 flw_WorldPos;
  83: //vec3 flw_Normal;
  84: //vec3 flw_Albedo;
  85: //float flw_Alpha;
  86: //vec2 flw_LightMap;
  87: //vec4 flw_Tint;
  88: 
  89: void main() {
  90:     BlockFrag f;
  91:     f.texCoords = v2f_texCoords;
  92: f.color = v2f_color;
  93: f.diffuse = v2f_diffuse;
  94: f.light = v2f_light;
  95: 
  96: 
  97:     FLWMain(f);
  98: }

[13:33:21] [main/ERROR]: Shader compilation log for create:belt.vert: No errors.

[13:33:21] [main/ERROR]: Source for shader 'create:belt.vert':
   1: #version 110
   2: #define USE_FOG
   3: #define USE_FOG_LINEAR
   4: 
   5: #define PI 3.1415926538
   6: 
   7: uniform float uTime;
   8: uniform mat4 uViewProjection;
   9: uniform vec3 uCameraPos;
  10: 
  11: #if defined(USE_FOG)
  12: varying float FragDistance;
  13: #endif
  14: 
  15: void FLWFinalizeWorldPos(inout vec4 worldPos) {
  16:     #if defined(USE_FOG)
  17:     FragDistance = length(worldPos.xyz - uCameraPos);
  18:     #endif
  19: 
  20:     gl_Position = uViewProjection * worldPos;
  21: }
  22: 
  23: void FLWFinalizeNormal(inout vec3 normal) {
  24:     // noop
  25: }
  26: 
  27: 
  28: #define PIOVER2 1.5707963268
  29: 
  30: vec4 quat(vec3 axis, float angle) {
  31:     float halfAngle = angle * PIOVER2 / 180.0;
  32:     vec2 cs = sin(vec2(PIOVER2 - halfAngle, halfAngle)); // compute sin and cos in one instruction
  33:     return vec4(axis.xyz * cs.y,  cs.x);
  34: }
  35: 
  36: vec4 quatMult(vec4 q1, vec4 q2) {
  37:     // disgustingly vectorized quaternion multiplication
  38:     vec4 a = q1.w * q2.xyzw;
  39:     vec4 b = q1.x * q2.wzxy * vec4(1., -1., 1., -1.);
  40:     vec4 c = q1.y * q2.zwxy * vec4(1., 1., -1., -1.);
  41:     vec4 d = q1.z * q2.yxwz * vec4(-1., 1., 1., -1.);
  42: 
  43:     return a + b + c + d;
  44: }
  45: 
  46: vec3 rotateVertexByQuat(vec3 v, vec4 q) {
  47:     vec3 i = q.xyz;
  48:     return v + 2.0 * cross(i, cross(i, v) + q.w * v);
  49: }
  50: 
  51: vec3 rotateAbout(vec3 v, vec3 axis, float angle) {
  52:     return rotateVertexByQuat(v, quat(axis, angle));
  53: }
  54: 
  55: mat4 rotate(vec3 axis, float angle) {
  56:     float s = sin(angle);
  57:     float c = cos(angle);
  58:     float oc = 1. - c;
  59: 
  60:     vec3 sa = axis * s;
  61: 
  62:     mat4 mr = mat4(1.);
  63:     mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
  64:     mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
  65:     mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);
  66: 
  67:     return mr;
  68: }
  69: 
  70: mat4 rotation(vec3 rot) {
  71:     return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
  72: }
  73: 
  74: mat3 modelToNormal(mat4 mat) {
  75:     // Discard the edges. This won't be accurate for scaled or skewed matrices,
  76:     // but we don't have to work with those often.
  77:     mat3 m;
  78:     m[0] = mat[0].xyz;
  79:     m[1] = mat[1].xyz;
  80:     m[2] = mat[2].xyz;
  81:     return m;
  82: }
  83: 
  84: float diffuse(vec3 normal) {
  85:     vec3 n2 = normal * normal * vec3(.6, .25, .8);
  86:     return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
  87: }
  88: 
  89: 
  90: struct Belt {
  91:     vec2 light;
  92:     vec4 color;
  93:     vec3 pos;
  94:     float speed;
  95:     float offset;
  96:     vec4 rotation;
  97:     vec2 sourceTexture;
  98:     vec4 scrollTexture;
  99:     float scrollMult;
 100: };
 101: 
 102: 
 103: struct Vertex {
 104:     vec3 pos;
 105:     vec3 normal;
 106:     vec2 texCoords;
 107: };
 108: 
 109: struct BlockFrag {
 110:     vec2 texCoords;
 111:     vec4 color;
 112:     float diffuse;
 113:     vec2 light;
 114: };
 115: 
 116: BlockFrag FLWMain(Vertex v, Belt instance) {
 117:     vec3 rotated = rotateVertexByQuat(v.pos - .5, instance.rotation) + instance.pos + .5;
 118: 
 119:     vec4 worldPos = vec4(rotated, 1.);
 120: 
 121:     vec3 norm = rotateVertexByQuat(v.normal, instance.rotation);
 122: 
 123:     FLWFinalizeWorldPos(worldPos);
 124:     FLWFinalizeNormal(norm);
 125: 
 126:     float scrollSize = instance.scrollTexture.w - instance.scrollTexture.y;
 127:     float scroll = fract(instance.speed * uTime / (31.5 * 16.) + instance.offset) * scrollSize * instance.scrollMult;
 128: 
 129:     BlockFrag b;
 130:     b.diffuse = diffuse(norm);
 131:     b.texCoords = v.texCoords - instance.sourceTexture + instance.scrollTexture.xy + vec2(0, scroll);
 132:     b.light = instance.light;
 133: 
 134:     #if defined(DEBUG_RAINBOW)
 135:     b.color = instance.color;
 136:     #elif defined(DEBUG_NORMAL)
 137:     b.color = vec4(norm, 1.);
 138:     #else
 139:     b.color = vec4(1.);
 140:     #endif
 141: 
 142:     return b;
 143: }
 144: attribute vec3 a_v_pos;
 145: attribute vec3 a_v_normal;
 146: attribute vec2 a_v_texCoords;
 147: 
 148: attribute vec2 a_i_light;
 149: attribute vec4 a_i_color;
 150: attribute vec3 a_i_pos;
 151: attribute float a_i_speed;
 152: attribute float a_i_offset;
 153: attribute vec4 a_i_rotation;
 154: attribute vec2 a_i_sourceTexture;
 155: attribute vec4 a_i_scrollTexture;
 156: attribute float a_i_scrollMult;
 157: 
 158: 
 159: varying vec2 v2f_texCoords;
 160: varying vec4 v2f_color;
 161: varying float v2f_diffuse;
 162: varying vec2 v2f_light;
 163: 
 164: 
 165: void main() {
 166:     Vertex v;
 167:     v.pos = a_v_pos;
 168: v.normal = a_v_normal;
 169: v.texCoords = a_v_texCoords;
 170: 
 171: 
 172:     Belt i;
 173:     i.light = a_i_light;
 174: i.color = a_i_color;
 175: i.pos = a_i_pos;
 176: i.speed = a_i_speed;
 177: i.offset = a_i_offset;
 178: i.rotation = a_i_rotation;
 179: i.sourceTexture = a_i_sourceTexture;
 180: i.scrollTexture = a_i_scrollTexture;
 181: i.scrollMult = a_i_scrollMult;
 182: 
 183: 
 184:     BlockFrag o = FLWMain(v, i);
 185: 
 186:     v2f_texCoords = o.texCoords;
 187: v2f_color = o.color;
 188: v2f_diffuse = o.diffuse;
 189: v2f_light = o.light;
 190: 
 191: }

[13:33:21] [main/ERROR]: Shader compilation log for flywheel:block.frag: No errors.

[13:33:21] [main/ERROR]: Source for shader 'flywheel:block.frag':
   1: #version 110
   2: #define USE_FOG
   3: #define USE_FOG_LINEAR
   4: 
   5: #if defined(USE_FOG)
   6: varying float FragDistance;
   7: uniform vec4 uFogColor;
   8: #endif
   9: 
  10: #if defined(USE_FOG_LINEAR)
  11: uniform vec2 uFogRange;
  12: 
  13: float FLWFogFactor() {
  14:     return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
  15: }
  16:     #endif
  17: 
  18:     #if defined(USE_FOG_EXP2)
  19: uniform float uFogDensity;
  20: 
  21: float FLWFogFactor() {
  22:     float dist = FragDistance * uFogDensity;
  23:     return 1. / exp2(dist * dist);
  24: }
  25:     #endif
  26: // Adjust the [0,1] normalized lightmap value based on the texture matrix from LightTexture#enableLightmap
  27: vec2 shiftLight(vec2 lm) {
  28:     return lm * 0.99609375 + 0.03125;// * 255/256 + 1/32
  29: }
  30: 
  31: uniform sampler2D uBlockAtlas;
  32: uniform sampler2D uLightMap;
  33: 
  34: vec4 FLWBlockTexture(vec2 texCoords) {
  35:     return texture2D(uBlockAtlas, texCoords);
  36: }
  37: 
  38: void FLWFinalizeColor(vec4 color) {
  39:     #if defined(USE_FOG)
  40:     float a = color.a;
  41:     float fog = clamp(FLWFogFactor(), 0., 1.);
  42: 
  43:     color = mix(uFogColor, color, fog);
  44:     color.a = a;
  45:     #endif
  46: 
  47:     gl_FragColor = color;
  48: }
  49: 
  50: vec4 FLWLight(vec2 lightCoords) {
  51:     return texture2D(uLightMap, shiftLight(lightCoords));
  52: }
  53: 
  54: 
  55: 
  56: struct BlockFrag {
  57:     vec2 texCoords;
  58:     vec4 color;
  59:     float diffuse;
  60:     vec2 light;
  61: };
  62: 
  63: void FLWMain(BlockFrag r) {
  64:     vec4 tex = FLWBlockTexture(r.texCoords);
  65: 
  66:     vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;
  67: 
  68: //    flw_WorldPos = ;
  69: //    flw_Normal = ;
  70: //    flw_Albedo = tex.rgb;
  71: //    flw_Alpha = tex.a;
  72: //    flw_LightMap = r.light;
  73: //    flw_Tint = r.color;
  74:     FLWFinalizeColor(color);
  75: }
  76: 
  77: varying vec2 v2f_texCoords;
  78: varying vec4 v2f_color;
  79: varying float v2f_diffuse;
  80: varying vec2 v2f_light;
  81: 
  82: 
  83: //vec3 flw_WorldPos;
  84: //vec3 flw_Normal;
  85: //vec3 flw_Albedo;
  86: //float flw_Alpha;
  87: //vec2 flw_LightMap;
  88: //vec4 flw_Tint;
  89: 
  90: void main() {
  91:     BlockFrag f;
  92:     f.texCoords = v2f_texCoords;
  93: f.color = v2f_color;
  94: f.diffuse = v2f_diffuse;
  95: f.light = v2f_light;
  96: 
  97: 
  98:     FLWMain(f);
  99: }

[13:33:21] [main/ERROR]: Shader compilation log for create:belt.vert: No errors.

[13:33:21] [main/ERROR]: Source for shader 'create:belt.vert':
   1: #version 110
   2: #define USE_FOG
   3: #define USE_FOG_EXP2
   4: 
   5: #define PI 3.1415926538
   6: 
   7: uniform float uTime;
   8: uniform mat4 uViewProjection;
   9: uniform vec3 uCameraPos;
  10: 
  11: #if defined(USE_FOG)
  12: varying float FragDistance;
  13: #endif
  14: 
  15: void FLWFinalizeWorldPos(inout vec4 worldPos) {
  16:     #if defined(USE_FOG)
  17:     FragDistance = length(worldPos.xyz - uCameraPos);
  18:     #endif
  19: 
  20:     gl_Position = uViewProjection * worldPos;
  21: }
  22: 
  23: void FLWFinalizeNormal(inout vec3 normal) {
  24:     // noop
  25: }
  26: 
  27: 
  28: #define PIOVER2 1.5707963268
  29: 
  30: vec4 quat(vec3 axis, float angle) {
  31:     float halfAngle = angle * PIOVER2 / 180.0;
  32:     vec2 cs = sin(vec2(PIOVER2 - halfAngle, halfAngle)); // compute sin and cos in one instruction
  33:     return vec4(axis.xyz * cs.y,  cs.x);
  34: }
  35: 
  36: vec4 quatMult(vec4 q1, vec4 q2) {
  37:     // disgustingly vectorized quaternion multiplication
  38:     vec4 a = q1.w * q2.xyzw;
  39:     vec4 b = q1.x * q2.wzxy * vec4(1., -1., 1., -1.);
  40:     vec4 c = q1.y * q2.zwxy * vec4(1., 1., -1., -1.);
  41:     vec4 d = q1.z * q2.yxwz * vec4(-1., 1., 1., -1.);
  42: 
  43:     return a + b + c + d;
  44: }
  45: 
  46: vec3 rotateVertexByQuat(vec3 v, vec4 q) {
  47:     vec3 i = q.xyz;
  48:     return v + 2.0 * cross(i, cross(i, v) + q.w * v);
  49: }
  50: 
  51: vec3 rotateAbout(vec3 v, vec3 axis, float angle) {
  52:     return rotateVertexByQuat(v, quat(axis, angle));
  53: }
  54: 
  55: mat4 rotate(vec3 axis, float angle) {
  56:     float s = sin(angle);
  57:     float c = cos(angle);
  58:     float oc = 1. - c;
  59: 
  60:     vec3 sa = axis * s;
  61: 
  62:     mat4 mr = mat4(1.);
  63:     mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
  64:     mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
  65:     mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);
  66: 
  67:     return mr;
  68: }
  69: 
  70: mat4 rotation(vec3 rot) {
  71:     return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
  72: }
  73: 
  74: mat3 modelToNormal(mat4 mat) {
  75:     // Discard the edges. This won't be accurate for scaled or skewed matrices,
  76:     // but we don't have to work with those often.
  77:     mat3 m;
  78:     m[0] = mat[0].xyz;
  79:     m[1] = mat[1].xyz;
  80:     m[2] = mat[2].xyz;
  81:     return m;
  82: }
  83: 
  84: float diffuse(vec3 normal) {
  85:     vec3 n2 = normal * normal * vec3(.6, .25, .8);
  86:     return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
  87: }
  88: 
  89: 
  90: struct Belt {
  91:     vec2 light;
  92:     vec4 color;
  93:     vec3 pos;
  94:     float speed;
  95:     float offset;
  96:     vec4 rotation;
  97:     vec2 sourceTexture;
  98:     vec4 scrollTexture;
  99:     float scrollMult;
 100: };
 101: 
 102: 
 103: struct Vertex {
 104:     vec3 pos;
 105:     vec3 normal;
 106:     vec2 texCoords;
 107: };
 108: 
 109: struct BlockFrag {
 110:     vec2 texCoords;
 111:     vec4 color;
 112:     float diffuse;
 113:     vec2 light;
 114: };
 115: 
 116: BlockFrag FLWMain(Vertex v, Belt instance) {
 117:     vec3 rotated = rotateVertexByQuat(v.pos - .5, instance.rotation) + instance.pos + .5;
 118: 
 119:     vec4 worldPos = vec4(rotated, 1.);
 120: 
 121:     vec3 norm = rotateVertexByQuat(v.normal, instance.rotation);
 122: 
 123:     FLWFinalizeWorldPos(worldPos);
 124:     FLWFinalizeNormal(norm);
 125: 
 126:     float scrollSize = instance.scrollTexture.w - instance.scrollTexture.y;
 127:     float scroll = fract(instance.speed * uTime / (31.5 * 16.) + instance.offset) * scrollSize * instance.scrollMult;
 128: 
 129:     BlockFrag b;
 130:     b.diffuse = diffuse(norm);
 131:     b.texCoords = v.texCoords - instance.sourceTexture + instance.scrollTexture.xy + vec2(0, scroll);
 132:     b.light = instance.light;
 133: 
 134:     #if defined(DEBUG_RAINBOW)
 135:     b.color = instance.color;
 136:     #elif defined(DEBUG_NORMAL)
 137:     b.color = vec4(norm, 1.);
 138:     #else
 139:     b.color = vec4(1.);
 140:     #endif
 141: 
 142:     return b;
 143: }
 144: attribute vec3 a_v_pos;
 145: attribute vec3 a_v_normal;
 146: attribute vec2 a_v_texCoords;
 147: 
 148: attribute vec2 a_i_light;
 149: attribute vec4 a_i_color;
 150: attribute vec3 a_i_pos;
 151: attribute float a_i_speed;
 152: attribute float a_i_offset;
 153: attribute vec4 a_i_rotation;
 154: attribute vec2 a_i_sourceTexture;
 155: attribute vec4 a_i_scrollTexture;
 156: attribute float a_i_scrollMult;
 157: 
 158: 
 159: varying vec2 v2f_texCoords;
 160: varying vec4 v2f_color;
 161: varying float v2f_diffuse;
 162: varying vec2 v2f_light;
 163: 
 164: 
 165: void main() {
 166:     Vertex v;
 167:     v.pos = a_v_pos;
 168: v.normal = a_v_normal;
 169: v.texCoords = a_v_texCoords;
 170: 
 171: 
 172:     Belt i;
 173:     i.light = a_i_light;
 174: i.color = a_i_color;
 175: i.pos = a_i_pos;
 176: i.speed = a_i_speed;
 177: i.offset = a_i_offset;
 178: i.rotation = a_i_rotation;
 179: i.sourceTexture = a_i_sourceTexture;
 180: i.scrollTexture = a_i_scrollTexture;
 181: i.scrollMult = a_i_scrollMult;
 182: 
 183: 
 184:     BlockFrag o = FLWMain(v, i);
 185: 
 186:     v2f_texCoords = o.texCoords;
 187: v2f_color = o.color;
 188: v2f_diffuse = o.diffuse;
 189: v2f_light = o.light;
 190: 
 191: }

[13:33:21] [main/ERROR]: Shader compilation log for flywheel:block.frag: No errors.

[13:33:21] [main/ERROR]: Source for shader 'flywheel:block.frag':
   1: #version 110
   2: #define USE_FOG
   3: #define USE_FOG_EXP2
   4: 
   5: #if defined(USE_FOG)
   6: varying float FragDistance;
   7: uniform vec4 uFogColor;
   8: #endif
   9: 
  10: #if defined(USE_FOG_LINEAR)
  11: uniform vec2 uFogRange;
  12: 
  13: float FLWFogFactor() {
  14:     return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
  15: }
  16:     #endif
  17: 
  18:     #if defined(USE_FOG_EXP2)
  19: uniform float uFogDensity;
  20: 
  21: float FLWFogFactor() {
  22:     float dist = FragDistance * uFogDensity;
  23:     return 1. / exp2(dist * dist);
  24: }
  25:     #endif
  26: // Adjust the [0,1] normalized lightmap value based on the texture matrix from LightTexture#enableLightmap
  27: vec2 shiftLight(vec2 lm) {
  28:     return lm * 0.99609375 + 0.03125;// * 255/256 + 1/32
  29: }
  30: 
  31: uniform sampler2D uBlockAtlas;
  32: uniform sampler2D uLightMap;
  33: 
  34: vec4 FLWBlockTexture(vec2 texCoords) {
  35:     return texture2D(uBlockAtlas, texCoords);
  36: }
  37: 
  38: void FLWFinalizeColor(vec4 color) {
  39:     #if defined(USE_FOG)
  40:     float a = color.a;
  41:     float fog = clamp(FLWFogFactor(), 0., 1.);
  42: 
  43:     color = mix(uFogColor, color, fog);
  44:     color.a = a;
  45:     #endif
  46: 
  47:     gl_FragColor = color;
  48: }
  49: 
  50: vec4 FLWLight(vec2 lightCoords) {
  51:     return texture2D(uLightMap, shiftLight(lightCoords));
  52: }
  53: 
  54: 
  55: 
  56: struct BlockFrag {
  57:     vec2 texCoords;
  58:     vec4 color;
  59:     float diffuse;
  60:     vec2 light;
  61: };
  62: 
  63: void FLWMain(BlockFrag r) {
  64:     vec4 tex = FLWBlockTexture(r.texCoords);
  65: 
  66:     vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;
  67: 
  68: //    flw_WorldPos = ;
  69: //    flw_Normal = ;
  70: //    flw_Albedo = tex.rgb;
  71: //    flw_Alpha = tex.a;
  72: //    flw_LightMap = r.light;
  73: //    flw_Tint = r.color;
  74:     FLWFinalizeColor(color);
  75: }
  76: 
  77: varying vec2 v2f_texCoords;
  78: varying vec4 v2f_color;
  79: varying float v2f_diffuse;
  80: varying vec2 v2f_light;
  81: 
  82: 
  83: //vec3 flw_WorldPos;
  84: //vec3 flw_Normal;
  85: //vec3 flw_Albedo;
  86: //float flw_Alpha;
  87: //vec2 flw_LightMap;
  88: //vec4 flw_Tint;
  89: 
  90: void main() {
  91:     BlockFrag f;
  92:     f.texCoords = v2f_texCoords;
  93: f.color = v2f_color;
  94: f.diffuse = v2f_diffuse;
  95: f.light = v2f_light;
  96: 
  97: 
  98:     FLWMain(f);
  99: }

[13:33:21] [main/ERROR]: Shader compilation log for create:belt.vert: No errors.

[13:33:21] [main/ERROR]: Source for shader 'create:belt.vert':
   1: #version 110
   2: 
   3: #define PI 3.1415926538
   4: 
   5: uniform float uTime;
   6: uniform mat4 uViewProjection;
   7: uniform vec3 uCameraPos;
   8: 
   9: #if defined(USE_FOG)
  10: varying float FragDistance;
  11: #endif
  12: 
  13: void FLWFinalizeWorldPos(inout vec4 worldPos) {
  14:     #if defined(USE_FOG)
  15:     FragDistance = length(worldPos.xyz - uCameraPos);
  16:     #endif
  17: 
  18:     gl_Position = uViewProjection * worldPos;
  19: }
  20: 
  21: void FLWFinalizeNormal(inout vec3 normal) {
  22:     // noop
  23: }
  24: 
  25: 
  26: #define PIOVER2 1.5707963268
  27: 
  28: vec4 quat(vec3 axis, float angle) {
  29:     float halfAngle = angle * PIOVER2 / 180.0;
  30:     vec2 cs = sin(vec2(PIOVER2 - halfAngle, halfAngle)); // compute sin and cos in one instruction
  31:     return vec4(axis.xyz * cs.y,  cs.x);
  32: }
  33: 
  34: vec4 quatMult(vec4 q1, vec4 q2) {
  35:     // disgustingly vectorized quaternion multiplication
  36:     vec4 a = q1.w * q2.xyzw;
  37:     vec4 b = q1.x * q2.wzxy * vec4(1., -1., 1., -1.);
  38:     vec4 c = q1.y * q2.zwxy * vec4(1., 1., -1., -1.);
  39:     vec4 d = q1.z * q2.yxwz * vec4(-1., 1., 1., -1.);
  40: 
  41:     return a + b + c + d;
  42: }
  43: 
  44: vec3 rotateVertexByQuat(vec3 v, vec4 q) {
  45:     vec3 i = q.xyz;
  46:     return v + 2.0 * cross(i, cross(i, v) + q.w * v);
  47: }
  48: 
  49: vec3 rotateAbout(vec3 v, vec3 axis, float angle) {
  50:     return rotateVertexByQuat(v, quat(axis, angle));
  51: }
  52: 
  53: mat4 rotate(vec3 axis, float angle) {
  54:     float s = sin(angle);
  55:     float c = cos(angle);
  56:     float oc = 1. - c;
  57: 
  58:     vec3 sa = axis * s;
  59: 
  60:     mat4 mr = mat4(1.);
  61:     mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
  62:     mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
  63:     mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);
  64: 
  65:     return mr;
  66: }
  67: 
  68: mat4 rotation(vec3 rot) {
  69:     return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
  70: }
  71: 
  72: mat3 modelToNormal(mat4 mat) {
  73:     // Discard the edges. This won't be accurate for scaled or skewed matrices,
  74:     // but we don't have to work with those often.
  75:     mat3 m;
  76:     m[0] = mat[0].xyz;
  77:     m[1] = mat[1].xyz;
  78:     m[2] = mat[2].xyz;
  79:     return m;
  80: }
  81: 
  82: float diffuse(vec3 normal) {
  83:     vec3 n2 = normal * normal * vec3(.6, .25, .8);
  84:     return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
  85: }
  86: 
  87: 
  88: struct Belt {
  89:     vec2 light;
  90:     vec4 color;
  91:     vec3 pos;
  92:     float speed;
  93:     float offset;
  94:     vec4 rotation;
  95:     vec2 sourceTexture;
  96:     vec4 scrollTexture;
  97:     float scrollMult;
  98: };
  99: 
 100: 
 101: struct Vertex {
 102:     vec3 pos;
 103:     vec3 normal;
 104:     vec2 texCoords;
 105: };
 106: 
 107: struct BlockFrag {
 108:     vec2 texCoords;
 109:     vec4 color;
 110:     float diffuse;
 111:     vec2 light;
 112: };
 113: 
 114: BlockFrag FLWMain(Vertex v, Belt instance) {
 115:     vec3 rotated = rotateVertexByQuat(v.pos - .5, instance.rotation) + instance.pos + .5;
 116: 
 117:     vec4 worldPos = vec4(rotated, 1.);
 118: 
 119:     vec3 norm = rotateVertexByQuat(v.normal, instance.rotation);
 120: 
 121:     FLWFinalizeWorldPos(worldPos);
 122:     FLWFinalizeNormal(norm);
 123: 
 124:     float scrollSize = instance.scrollTexture.w - instance.scrollTexture.y;
 125:     float scroll = fract(instance.speed * uTime / (31.5 * 16.) + instance.offset) * scrollSize * instance.scrollMult;
 126: 
 127:     BlockFrag b;
 128:     b.diffuse = diffuse(norm);
 129:     b.texCoords = v.texCoords - instance.sourceTexture + instance.scrollTexture.xy + vec2(0, scroll);
 130:     b.light = instance.light;
 131: 
 132:     #if defined(DEBUG_RAINBOW)
 133:     b.color = instance.color;
 134:     #elif defined(DEBUG_NORMAL)
 135:     b.color = vec4(norm, 1.);
 136:     #else
 137:     b.color = vec4(1.);
 138:     #endif
 139: 
 140:     return b;
 141: }
 142: attribute vec3 a_v_pos;
 143: attribute vec3 a_v_normal;
 144: attribute vec2 a_v_texCoords;
 145: 
 146: attribute vec2 a_i_light;
 147: attribute vec4 a_i_color;
 148: attribute vec3 a_i_pos;
 149: attribute float a_i_speed;
 150: attribute float a_i_offset;
 151: attribute vec4 a_i_rotation;
 152: attribute vec2 a_i_sourceTexture;
 153: attribute vec4 a_i_scrollTexture;
 154: attribute float a_i_scrollMult;
 155: 
 156: 
 157: varying vec2 v2f_texCoords;
 158: varying vec4 v2f_color;
 159: varying float v2f_diffuse;
 160: varying vec2 v2f_light;
 161: 
 162: 
 163: void main() {
 164:     Vertex v;
 165:     v.pos = a_v_pos;
 166: v.normal = a_v_normal;
 167: v.texCoords = a_v_texCoords;
 168: 
 169: 
 170:     Belt i;
 171:     i.light = a_i_light;
 172: i.color = a_i_color;
 173: i.pos = a_i_pos;
 174: i.speed = a_i_speed;
 175: i.offset = a_i_offset;
 176: i.rotation = a_i_rotation;
 177: i.sourceTexture = a_i_sourceTexture;
 178: i.scrollTexture = a_i_scrollTexture;
 179: i.scrollMult = a_i_scrollMult;
 180: 
 181: 
 182:     BlockFrag o = FLWMain(v, i);
 183: 
 184:     v2f_texCoords = o.texCoords;
 185: v2f_color = o.color;
 186: v2f_diffuse = o.diffuse;
 187: v2f_light = o.light;
 188: 
 189: }

[13:33:21] [main/ERROR]: Shader compilation log for flywheel:block.frag: No errors.

[13:33:21] [main/ERROR]: Source for shader 'flywheel:block.frag':
   1: #version 110
   2: 
   3: #if defined(USE_FOG)
   4: varying float FragDistance;
   5: uniform vec4 uFogColor;
   6: #endif
   7: 
   8: #if defined(USE_FOG_LINEAR)
   9: uniform vec2 uFogRange;
  10: 
  11: float FLWFogFactor() {
  12:     return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
  13: }
  14:     #endif
  15: 
  16:     #if defined(USE_FOG_EXP2)
  17: uniform float uFogDensity;
  18: 
  19: float FLWFogFactor() {
  20:     float dist = FragDistance * uFogDensity;
  21:     return 1. / exp2(dist * dist);
  22: }
  23:     #endif
  24: // Adjust the [0,1] normalized lightmap value based on the texture matrix from LightTexture#enableLightmap
  25: vec2 shiftLight(vec2 lm) {
  26:     return lm * 0.99609375 + 0.03125;// * 255/256 + 1/32
  27: }
  28: 
  29: uniform sampler2D uBlockAtlas;
  30: uniform sampler2D uLightMap;
  31: 
  32: vec4 FLWBlockTexture(vec2 texCoords) {
  33:     return texture2D(uBlockAtlas, texCoords);
  34: }
  35: 
  36: void FLWFinalizeColor(vec4 color) {
  37:     #if defined(USE_FOG)
  38:     float a = color.a;
  39:     float fog = clamp(FLWFogFactor(), 0., 1.);
  40: 
  41:     color = mix(uFogColor, color, fog);
  42:     color.a = a;
  43:     #endif
  44: 
  45:     gl_FragColor = color;
  46: }
  47: 
  48: vec4 FLWLight(vec2 lightCoords) {
  49:     return texture2D(uLightMap, shiftLight(lightCoords));
  50: }
  51: 
  52: 
  53: 
  54: struct BlockFrag {
  55:     vec2 texCoords;
  56:     vec4 color;
  57:     float diffuse;
  58:     vec2 light;
  59: };
  60: 
  61: void FLWMain(BlockFrag r) {
  62:     vec4 tex = FLWBlockTexture(r.texCoords);
  63: 
  64:     vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;
  65: 
  66: //    flw_WorldPos = ;
  67: //    flw_Normal = ;
  68: //    flw_Albedo = tex.rgb;
  69: //    flw_Alpha = tex.a;
  70: //    flw_LightMap = r.light;
  71: //    flw_Tint = r.color;
  72:     FLWFinalizeColor(color);
  73: }
  74: 
  75: varying vec2 v2f_texCoords;
  76: varying vec4 v2f_color;
  77: varying float v2f_diffuse;
  78: varying vec2 v2f_light;
  79: 
  80: 
  81: //vec3 flw_WorldPos;
  82: //vec3 flw_Normal;
  83: //vec3 flw_Albedo;
  84: //float flw_Alpha;
  85: //vec2 flw_LightMap;
  86: //vec4 flw_Tint;
  87: 
  88: void main() {
  89:     BlockFrag f;
  90:     f.texCoords = v2f_texCoords;
  91: f.color = v2f_color;
  92: f.diffuse = v2f_diffuse;
  93: f.light = v2f_light;
  94: 
  95: 
  96:     FLWMain(f);
  97: }

[13:33:21] [main/ERROR]: Shader compilation log for flywheel:oriented.vert: No errors.

[13:33:21] [main/ERROR]: Source for shader 'flywheel:oriented.vert':
   1: #version 110
   2: #define DEBUG_NORMAL
   3: 
   4: uniform float uTime;
   5: uniform mat4 uViewProjection;
   6: uniform vec3 uCameraPos;
   7: 
   8: #if defined(USE_FOG)
   9: varying float FragDistance;
  10: #endif
  11: 
  12: void FLWFinalizeWorldPos(inout vec4 worldPos) {
  13:     #if defined(USE_FOG)
  14:     FragDistance = length(worldPos.xyz - uCameraPos);
  15:     #endif
  16: 
  17:     gl_Position = uViewProjection * worldPos;
  18: }
  19: 
  20: void FLWFinalizeNormal(inout vec3 normal) {
  21:     // noop
  22: }
  23: 
  24: 
  25: mat4 rotate(vec3 axis, float angle) {
  26:     float s = sin(angle);
  27:     float c = cos(angle);
  28:     float oc = 1. - c;
  29: 
  30:     vec3 sa = axis * s;
  31: 
  32:     mat4 mr = mat4(1.);
  33:     mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
  34:     mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
  35:     mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);
  36: 
  37:     return mr;
  38: }
  39: 
  40: mat4 rotation(vec3 rot) {
  41:     return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
  42: }
  43: 
  44: mat3 modelToNormal(mat4 mat) {
  45:     // Discard the edges. This won't be accurate for scaled or skewed matrices,
  46:     // but we don't have to work with those often.
  47:     mat3 m;
  48:     m[0] = mat[0].xyz;
  49:     m[1] = mat[1].xyz;
  50:     m[2] = mat[2].xyz;
  51:     return m;
  52: }
  53: 
  54: #define PIOVER2 1.5707963268
  55: 
  56: vec4 quat(vec3 axis, float angle) {
  57:     float halfAngle = angle * PIOVER2 / 180.0;
  58:     vec2 cs = sin(vec2(PIOVER2 - halfAngle, halfAngle)); // compute sin and cos in one instruction
  59:     return vec4(axis.xyz * cs.y,  cs.x);
  60: }
  61: 
  62: vec4 quatMult(vec4 q1, vec4 q2) {
  63:     // disgustingly vectorized quaternion multiplication
  64:     vec4 a = q1.w * q2.xyzw;
  65:     vec4 b = q1.x * q2.wzxy * vec4(1., -1., 1., -1.);
  66:     vec4 c = q1.y * q2.zwxy * vec4(1., 1., -1., -1.);
  67:     vec4 d = q1.z * q2.yxwz * vec4(-1., 1., 1., -1.);
  68: 
  69:     return a + b + c + d;
  70: }
  71: 
  72: vec3 rotateVertexByQuat(vec3 v, vec4 q) {
  73:     vec3 i = q.xyz;
  74:     return v + 2.0 * cross(i, cross(i, v) + q.w * v);
  75: }
  76: 
  77: vec3 rotateAbout(vec3 v, vec3 axis, float angle) {
  78:     return rotateVertexByQuat(v, quat(axis, angle));
  79: }
  80: 
  81: float diffuse(vec3 normal) {
  82:     vec3 n2 = normal * normal * vec3(.6, .25, .8);
  83:     return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
  84: }
  85: 
  86: 
  87: struct Oriented {
  88:     vec2 light;
  89:     vec4 color;
  90:     vec3 pos;
  91:     vec3 pivot;
  92:     vec4 rotation;
  93: };
  94: 
  95: 
  96: struct Vertex {
  97:     vec3 pos;
  98:     vec3 normal;
  99:     vec2 texCoords;
 100: };
 101: 
 102: struct BlockFrag {
 103:     vec2 texCoords;
 104:     vec4 color;
 105:     float diffuse;
 106:     vec2 light;
 107: };
 108: 
 109: BlockFrag FLWMain(Vertex v, Oriented o) {
 110:     vec4 worldPos = vec4(rotateVertexByQuat(v.pos - o.pivot, o.rotation) + o.pivot + o.pos, 1.);
 111: 
 112:     vec3 norm = rotateVertexByQuat(v.normal, o.rotation);
 113: 
 114:     FLWFinalizeWorldPos(worldPos);
 115:     FLWFinalizeNormal(norm);
 116: 
 117:     BlockFrag b;
 118:     b.diffuse = diffuse(norm);
 119:     b.texCoords = v.texCoords;
 120:     b.light = o.light;
 121:     #if defined(DEBUG_NORMAL)
 122:     b.color = vec4(norm, 1.);
 123:     #else
 124:     b.color = o.color;
 125:     #endif
 126:     return b;
 127: }
 128: attribute vec3 a_v_pos;
 129: attribute vec3 a_v_normal;
 130: attribute vec2 a_v_texCoords;
 131: 
 132: attribute vec2 a_i_light;
 133: attribute vec4 a_i_color;
 134: attribute vec3 a_i_pos;
 135: attribute vec3 a_i_pivot;
 136: attribute vec4 a_i_rotation;
 137: 
 138: 
 139: varying vec2 v2f_texCoords;
 140: varying vec4 v2f_color;
 141: varying float v2f_diffuse;
 142: varying vec2 v2f_light;
 143: 
 144: 
 145: void main() {
 146:     Vertex v;
 147:     v.pos = a_v_pos;
 148: v.normal = a_v_normal;
 149: v.texCoords = a_v_texCoords;
 150: 
 151: 
 152:     Oriented i;
 153:     i.light = a_i_light;
 154: i.color = a_i_color;
 155: i.pos = a_i_pos;
 156: i.pivot = a_i_pivot;
 157: i.rotation = a_i_rotation;
 158: 
 159: 
 160:     BlockFrag o = FLWMain(v, i);
 161: 
 162:     v2f_texCoords = o.texCoords;
 163: v2f_color = o.color;
 164: v2f_diffuse = o.diffuse;
 165: v2f_light = o.light;
 166: 
 167: }

[13:33:21] [main/ERROR]: Shader compilation log for flywheel:block.frag: No errors.

[13:33:21] [main/ERROR]: Source for shader 'flywheel:block.frag':
   1: #version 110
   2: #define DEBUG_NORMAL
   3: 
   4: #if defined(USE_FOG)
   5: varying float FragDistance;
   6: uniform vec4 uFogColor;
   7: #endif
   8: 
   9: #if defined(USE_FOG_LINEAR)
  10: uniform vec2 uFogRange;
  11: 
  12: float FLWFogFactor() {
  13:     return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
  14: }
  15:     #endif
  16: 
  17:     #if defined(USE_FOG_EXP2)
  18: uniform float uFogDensity;
  19: 
  20: float FLWFogFactor() {
  21:     float dist = FragDistance * uFogDensity;
  22:     return 1. / exp2(dist * dist);
  23: }
  24:     #endif
  25: // Adjust the [0,1] normalized lightmap value based on the texture matrix from LightTexture#enableLightmap
  26: vec2 shiftLight(vec2 lm) {
  27:     return lm * 0.99609375 + 0.03125;// * 255/256 + 1/32
  28: }
  29: 
  30: uniform sampler2D uBlockAtlas;
  31: uniform sampler2D uLightMap;
  32: 
  33: vec4 FLWBlockTexture(vec2 texCoords) {
  34:     return texture2D(uBlockAtlas, texCoords);
  35: }
  36: 
  37: void FLWFinalizeColor(vec4 color) {
  38:     #if defined(USE_FOG)
  39:     float a = color.a;
  40:     float fog = clamp(FLWFogFactor(), 0., 1.);
  41: 
  42:     color = mix(uFogColor, color, fog);
  43:     color.a = a;
  44:     #endif
  45: 
  46:     gl_FragColor = color;
  47: }
  48: 
  49: vec4 FLWLight(vec2 lightCoords) {
  50:     return texture2D(uLightMap, shiftLight(lightCoords));
  51: }
  52: 
  53: 
  54: 
  55: struct BlockFrag {
  56:     vec2 texCoords;
  57:     vec4 color;
  58:     float diffuse;
  59:     vec2 light;
  60: };
  61: 
  62: void FLWMain(BlockFrag r) {
  63:     vec4 tex = FLWBlockTexture(r.texCoords);
  64: 
  65:     vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;
  66: 
  67: //    flw_WorldPos = ;
  68: //    flw_Normal = ;
  69: //    flw_Albedo = tex.rgb;
  70: //    flw_Alpha = tex.a;
  71: //    flw_LightMap = r.light;
  72: //    flw_Tint = r.color;
  73:     FLWFinalizeColor(color);
  74: }
  75: 
  76: varying vec2 v2f_texCoords;
  77: varying vec4 v2f_color;
  78: varying float v2f_diffuse;
  79: varying vec2 v2f_light;
  80: 
  81: 
  82: //vec3 flw_WorldPos;
  83: //vec3 flw_Normal;
  84: //vec3 flw_Albedo;
  85: //float flw_Alpha;
  86: //vec2 flw_LightMap;
  87: //vec4 flw_Tint;
  88: 
  89: void main() {
  90:     BlockFrag f;
  91:     f.texCoords = v2f_texCoords;
  92: f.color = v2f_color;
  93: f.diffuse = v2f_diffuse;
  94: f.light = v2f_light;
  95: 
  96: 
  97:     FLWMain(f);
  98: }

[13:33:21] [main/ERROR]: Shader compilation log for flywheel:oriented.vert: No errors.

[13:33:21] [main/ERROR]: Source for shader 'flywheel:oriented.vert':
   1: #version 110
   2: #define USE_FOG
   3: #define USE_FOG_LINEAR
   4: 
   5: uniform float uTime;
   6: uniform mat4 uViewProjection;
   7: uniform vec3 uCameraPos;
   8: 
   9: #if defined(USE_FOG)
  10: varying float FragDistance;
  11: #endif
  12: 
  13: void FLWFinalizeWorldPos(inout vec4 worldPos) {
  14:     #if defined(USE_FOG)
  15:     FragDistance = length(worldPos.xyz - uCameraPos);
  16:     #endif
  17: 
  18:     gl_Position = uViewProjection * worldPos;
  19: }
  20: 
  21: void FLWFinalizeNormal(inout vec3 normal) {
  22:     // noop
  23: }
  24: 
  25: 
  26: mat4 rotate(vec3 axis, float angle) {
  27:     float s = sin(angle);
  28:     float c = cos(angle);
  29:     float oc = 1. - c;
  30: 
  31:     vec3 sa = axis * s;
  32: 
  33:     mat4 mr = mat4(1.);
  34:     mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
  35:     mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
  36:     mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);
  37: 
  38:     return mr;
  39: }
  40: 
  41: mat4 rotation(vec3 rot) {
  42:     return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
  43: }
  44: 
  45: mat3 modelToNormal(mat4 mat) {
  46:     // Discard the edges. This won't be accurate for scaled or skewed matrices,
  47:     // but we don't have to work with those often.
  48:     mat3 m;
  49:     m[0] = mat[0].xyz;
  50:     m[1] = mat[1].xyz;
  51:     m[2] = mat[2].xyz;
  52:     return m;
  53: }
  54: 
  55: #define PIOVER2 1.5707963268
  56: 
  57: vec4 quat(vec3 axis, float angle) {
  58:     float halfAngle = angle * PIOVER2 / 180.0;
  59:     vec2 cs = sin(vec2(PIOVER2 - halfAngle, halfAngle)); // compute sin and cos in one instruction
  60:     return vec4(axis.xyz * cs.y,  cs.x);
  61: }
  62: 
  63: vec4 quatMult(vec4 q1, vec4 q2) {
  64:     // disgustingly vectorized quaternion multiplication
  65:     vec4 a = q1.w * q2.xyzw;
  66:     vec4 b = q1.x * q2.wzxy * vec4(1., -1., 1., -1.);
  67:     vec4 c = q1.y * q2.zwxy * vec4(1., 1., -1., -1.);
  68:     vec4 d = q1.z * q2.yxwz * vec4(-1., 1., 1., -1.);
  69: 
  70:     return a + b + c + d;
  71: }
  72: 
  73: vec3 rotateVertexByQuat(vec3 v, vec4 q) {
  74:     vec3 i = q.xyz;
  75:     return v + 2.0 * cross(i, cross(i, v) + q.w * v);
  76: }
  77: 
  78: vec3 rotateAbout(vec3 v, vec3 axis, float angle) {
  79:     return rotateVertexByQuat(v, quat(axis, angle));
  80: }
  81: 
  82: float diffuse(vec3 normal) {
  83:     vec3 n2 = normal * normal * vec3(.6, .25, .8);
  84:     return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
  85: }
  86: 
  87: 
  88: struct Oriented {
  89:     vec2 light;
  90:     vec4 color;
  91:     vec3 pos;
  92:     vec3 pivot;
  93:     vec4 rotation;
  94: };
  95: 
  96: 
  97: struct Vertex {
  98:     vec3 pos;
  99:     vec3 normal;
 100:     vec2 texCoords;
 101: };
 102: 
 103: struct BlockFrag {
 104:     vec2 texCoords;
 105:     vec4 color;
 106:     float diffuse;
 107:     vec2 light;
 108: };
 109: 
 110: BlockFrag FLWMain(Vertex v, Oriented o) {
 111:     vec4 worldPos = vec4(rotateVertexByQuat(v.pos - o.pivot, o.rotation) + o.pivot + o.pos, 1.);
 112: 
 113:     vec3 norm = rotateVertexByQuat(v.normal, o.rotation);
 114: 
 115:     FLWFinalizeWorldPos(worldPos);
 116:     FLWFinalizeNormal(norm);
 117: 
 118:     BlockFrag b;
 119:     b.diffuse = diffuse(norm);
 120:     b.texCoords = v.texCoords;
 121:     b.light = o.light;
 122:     #if defined(DEBUG_NORMAL)
 123:     b.color = vec4(norm, 1.);
 124:     #else
 125:     b.color = o.color;
 126:     #endif
 127:     return b;
 128: }
 129: attribute vec3 a_v_pos;
 130: attribute vec3 a_v_normal;
 131: attribute vec2 a_v_texCoords;
 132: 
 133: attribute vec2 a_i_light;
 134: attribute vec4 a_i_color;
 135: attribute vec3 a_i_pos;
 136: attribute vec3 a_i_pivot;
 137: attribute vec4 a_i_rotation;
 138: 
 139: 
 140: varying vec2 v2f_texCoords;
 141: varying vec4 v2f_color;
 142: varying float v2f_diffuse;
 143: varying vec2 v2f_light;
 144: 
 145: 
 146: void main() {
 147:     Vertex v;
 148:     v.pos = a_v_pos;
 149: v.normal = a_v_normal;
 150: v.texCoords = a_v_texCoords;
 151: 
 152: 
 153:     Oriented i;
 154:     i.light = a_i_light;
 155: i.color = a_i_color;
 156: i.pos = a_i_pos;
 157: i.pivot = a_i_pivot;
 158: i.rotation = a_i_rotation;
 159: 
 160: 
 161:     BlockFrag o = FLWMain(v, i);
 162: 
 163:     v2f_texCoords = o.texCoords;
 164: v2f_color = o.color;
 165: v2f_diffuse = o.diffuse;
 166: v2f_light = o.light;
 167: 
 168: }

[13:33:21] [main/ERROR]: Shader compilation log for flywheel:block.frag: No errors.

[13:33:21] [main/ERROR]: Source for shader 'flywheel:block.frag':
   1: #version 110
   2: #define USE_FOG
   3: #define USE_FOG_LINEAR
   4: 
   5: #if defined(USE_FOG)
   6: varying float FragDistance;
   7: uniform vec4 uFogColor;
   8: #endif
   9: 
  10: #if defined(USE_FOG_LINEAR)
  11: uniform vec2 uFogRange;
  12: 
  13: float FLWFogFactor() {
  14:     return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
  15: }
  16:     #endif
  17: 
  18:     #if defined(USE_FOG_EXP2)
  19: uniform float uFogDensity;
  20: 
  21: float FLWFogFactor() {
  22:     float dist = FragDistance * uFogDensity;
  23:     return 1. / exp2(dist * dist);
  24: }
  25:     #endif
  26: // Adjust the [0,1] normalized lightmap value based on the texture matrix from LightTexture#enableLightmap
  27: vec2 shiftLight(vec2 lm) {
  28:     return lm * 0.99609375 + 0.03125;// * 255/256 + 1/32
  29: }
  30: 
  31: uniform sampler2D uBlockAtlas;
  32: uniform sampler2D uLightMap;
  33: 
  34: vec4 FLWBlockTexture(vec2 texCoords) {
  35:     return texture2D(uBlockAtlas, texCoords);
  36: }
  37: 
  38: void FLWFinalizeColor(vec4 color) {
  39:     #if defined(USE_FOG)
  40:     float a = color.a;
  41:     float fog = clamp(FLWFogFactor(), 0., 1.);
  42: 
  43:     color = mix(uFogColor, color, fog);
  44:     color.a = a;
  45:     #endif
  46: 
  47:     gl_FragColor = color;
  48: }
  49: 
  50: vec4 FLWLight(vec2 lightCoords) {
  51:     return texture2D(uLightMap, shiftLight(lightCoords));
  52: }
  53: 
  54: 
  55: 
  56: struct BlockFrag {
  57:     vec2 texCoords;
  58:     vec4 color;
  59:     float diffuse;
  60:     vec2 light;
  61: };
  62: 
  63: void FLWMain(BlockFrag r) {
  64:     vec4 tex = FLWBlockTexture(r.texCoords);
  65: 
  66:     vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;
  67: 
  68: //    flw_WorldPos = ;
  69: //    flw_Normal = ;
  70: //    flw_Albedo = tex.rgb;
  71: //    flw_Alpha = tex.a;
  72: //    flw_LightMap = r.light;
  73: //    flw_Tint = r.color;
  74:     FLWFinalizeColor(color);
  75: }
  76: 
  77: varying vec2 v2f_texCoords;
  78: varying vec4 v2f_color;
  79: varying float v2f_diffuse;
  80: varying vec2 v2f_light;
  81: 
  82: 
  83: //vec3 flw_WorldPos;
  84: //vec3 flw_Normal;
  85: //vec3 flw_Albedo;
  86: //float flw_Alpha;
  87: //vec2 flw_LightMap;
  88: //vec4 flw_Tint;
  89: 
  90: void main() {
  91:     BlockFrag f;
  92:     f.texCoords = v2f_texCoords;
  93: f.color = v2f_color;
  94: f.diffuse = v2f_diffuse;
  95: f.light = v2f_light;
  96: 
  97: 
  98:     FLWMain(f);
  99: }

[13:33:21] [main/ERROR]: Shader compilation log for flywheel:oriented.vert: No errors.

[13:33:21] [main/ERROR]: Source for shader 'flywheel:oriented.vert':
   1: #version 110
   2: #define USE_FOG
   3: #define USE_FOG_EXP2
   4: 
   5: uniform float uTime;
   6: uniform mat4 uViewProjection;
   7: uniform vec3 uCameraPos;
   8: 
   9: #if defined(USE_FOG)
  10: varying float FragDistance;
  11: #endif
  12: 
  13: void FLWFinalizeWorldPos(inout vec4 worldPos) {
  14:     #if defined(USE_FOG)
  15:     FragDistance = length(worldPos.xyz - uCameraPos);
  16:     #endif
  17: 
  18:     gl_Position = uViewProjection * worldPos;
  19: }
  20: 
  21: void FLWFinalizeNormal(inout vec3 normal) {
  22:     // noop
  23: }
  24: 
  25: 
  26: mat4 rotate(vec3 axis, float angle) {
  27:     float s = sin(angle);
  28:     float c = cos(angle);
  29:     float oc = 1. - c;
  30: 
  31:     vec3 sa = axis * s;
  32: 
  33:     mat4 mr = mat4(1.);
  34:     mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
  35:     mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
  36:     mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);
  37: 
  38:     return mr;
  39: }
  40: 
  41: mat4 rotation(vec3 rot) {
  42:     return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
  43: }
  44: 
  45: mat3 modelToNormal(mat4 mat) {
  46:     // Discard the edges. This won't be accurate for scaled or skewed matrices,
  47:     // but we don't have to work with those often.
  48:     mat3 m;
  49:     m[0] = mat[0].xyz;
  50:     m[1] = mat[1].xyz;
  51:     m[2] = mat[2].xyz;
  52:     return m;
  53: }
  54: 
  55: #define PIOVER2 1.5707963268
  56: 
  57: vec4 quat(vec3 axis, float angle) {
  58:     float halfAngle = angle * PIOVER2 / 180.0;
  59:     vec2 cs = sin(vec2(PIOVER2 - halfAngle, halfAngle)); // compute sin and cos in one instruction
  60:     return vec4(axis.xyz * cs.y,  cs.x);
  61: }
  62: 
  63: vec4 quatMult(vec4 q1, vec4 q2) {
  64:     // disgustingly vectorized quaternion multiplication
  65:     vec4 a = q1.w * q2.xyzw;
  66:     vec4 b = q1.x * q2.wzxy * vec4(1., -1., 1., -1.);
  67:     vec4 c = q1.y * q2.zwxy * vec4(1., 1., -1., -1.);
  68:     vec4 d = q1.z * q2.yxwz * vec4(-1., 1., 1., -1.);
  69: 
  70:     return a + b + c + d;
  71: }
  72: 
  73: vec3 rotateVertexByQuat(vec3 v, vec4 q) {
  74:     vec3 i = q.xyz;
  75:     return v + 2.0 * cross(i, cross(i, v) + q.w * v);
  76: }
  77: 
  78: vec3 rotateAbout(vec3 v, vec3 axis, float angle) {
  79:     return rotateVertexByQuat(v, quat(axis, angle));
  80: }
  81: 
  82: float diffuse(vec3 normal) {
  83:     vec3 n2 = normal * normal * vec3(.6, .25, .8);
  84:     return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
  85: }
  86: 
  87: 
  88: struct Oriented {
  89:     vec2 light;
  90:     vec4 color;
  91:     vec3 pos;
  92:     vec3 pivot;
  93:     vec4 rotation;
  94: };
  95: 
  96: 
  97: struct Vertex {
  98:     vec3 pos;
  99:     vec3 normal;
 100:     vec2 texCoords;
 101: };
 102: 
 103: struct BlockFrag {
 104:     vec2 texCoords;
 105:     vec4 color;
 106:     float diffuse;
 107:     vec2 light;
 108: };
 109: 
 110: BlockFrag FLWMain(Vertex v, Oriented o) {
 111:     vec4 worldPos = vec4(rotateVertexByQuat(v.pos - o.pivot, o.rotation) + o.pivot + o.pos, 1.);
 112: 
 113:     vec3 norm = rotateVertexByQuat(v.normal, o.rotation);
 114: 
 115:     FLWFinalizeWorldPos(worldPos);
 116:     FLWFinalizeNormal(norm);
 117: 
 118:     BlockFrag b;
 119:     b.diffuse = diffuse(norm);
 120:     b.texCoords = v.texCoords;
 121:     b.light = o.light;
 122:     #if defined(DEBUG_NORMAL)
 123:     b.color = vec4(norm, 1.);
 124:     #else
 125:     b.color = o.color;
 126:     #endif
 127:     return b;
 128: }
 129: attribute vec3 a_v_pos;
 130: attribute vec3 a_v_normal;
 131: attribute vec2 a_v_texCoords;
 132: 
 133: attribute vec2 a_i_light;
 134: attribute vec4 a_i_color;
 135: attribute vec3 a_i_pos;
 136: attribute vec3 a_i_pivot;
 137: attribute vec4 a_i_rotation;
 138: 
 139: 
 140: varying vec2 v2f_texCoords;
 141: varying vec4 v2f_color;
 142: varying float v2f_diffuse;
 143: varying vec2 v2f_light;
 144: 
 145: 
 146: void main() {
 147:     Vertex v;
 148:     v.pos = a_v_pos;
 149: v.normal = a_v_normal;
 150: v.texCoords = a_v_texCoords;
 151: 
 152: 
 153:     Oriented i;
 154:     i.light = a_i_light;
 155: i.color = a_i_color;
 156: i.pos = a_i_pos;
 157: i.pivot = a_i_pivot;
 158: i.rotation = a_i_rotation;
 159: 
 160: 
 161:     BlockFrag o = FLWMain(v, i);
 162: 
 163:     v2f_texCoords = o.texCoords;
 164: v2f_color = o.color;
 165: v2f_diffuse = o.diffuse;
 166: v2f_light = o.light;
 167: 
 168: }

[13:33:21] [main/ERROR]: Shader compilation log for flywheel:block.frag: No errors.

[13:33:21] [main/ERROR]: Source for shader 'flywheel:block.frag':
   1: #version 110
   2: #define USE_FOG
   3: #define USE_FOG_EXP2
   4: 
   5: #if defined(USE_FOG)
   6: varying float FragDistance;
   7: uniform vec4 uFogColor;
   8: #endif
   9: 
  10: #if defined(USE_FOG_LINEAR)
  11: uniform vec2 uFogRange;
  12: 
  13: float FLWFogFactor() {
  14:     return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
  15: }
  16:     #endif
  17: 
  18:     #if defined(USE_FOG_EXP2)
  19: uniform float uFogDensity;
  20: 
  21: float FLWFogFactor() {
  22:     float dist = FragDistance * uFogDensity;
  23:     return 1. / exp2(dist * dist);
  24: }
  25:     #endif
  26: // Adjust the [0,1] normalized lightmap value based on the texture matrix from LightTexture#enableLightmap
  27: vec2 shiftLight(vec2 lm) {
  28:     return lm * 0.99609375 + 0.03125;// * 255/256 + 1/32
  29: }
  30: 
  31: uniform sampler2D uBlockAtlas;
  32: uniform sampler2D uLightMap;
  33: 
  34: vec4 FLWBlockTexture(vec2 texCoords) {
  35:     return texture2D(uBlockAtlas, texCoords);
  36: }
  37: 
  38: void FLWFinalizeColor(vec4 color) {
  39:     #if defined(USE_FOG)
  40:     float a = color.a;
  41:     float fog = clamp(FLWFogFactor(), 0., 1.);
  42: 
  43:     color = mix(uFogColor, color, fog);
  44:     color.a = a;
  45:     #endif
  46: 
  47:     gl_FragColor = color;
  48: }
  49: 
  50: vec4 FLWLight(vec2 lightCoords) {
  51:     return texture2D(uLightMap, shiftLight(lightCoords));
  52: }
  53: 
  54: 
  55: 
  56: struct BlockFrag {
  57:     vec2 texCoords;
  58:     vec4 color;
  59:     float diffuse;
  60:     vec2 light;
  61: };
  62: 
  63: void FLWMain(BlockFrag r) {
  64:     vec4 tex = FLWBlockTexture(r.texCoords);
  65: 
  66:     vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;
  67: 
  68: //    flw_WorldPos = ;
  69: //    flw_Normal = ;
  70: //    flw_Albedo = tex.rgb;
  71: //    flw_Alpha = tex.a;
  72: //    flw_LightMap = r.light;
  73: //    flw_Tint = r.color;
  74:     FLWFinalizeColor(color);
  75: }
  76: 
  77: varying vec2 v2f_texCoords;
  78: varying vec4 v2f_color;
  79: varying float v2f_diffuse;
  80: varying vec2 v2f_light;
  81: 
  82: 
  83: //vec3 flw_WorldPos;
  84: //vec3 flw_Normal;
  85: //vec3 flw_Albedo;
  86: //float flw_Alpha;
  87: //vec2 flw_LightMap;
  88: //vec4 flw_Tint;
  89: 
  90: void main() {
  91:     BlockFrag f;
  92:     f.texCoords = v2f_texCoords;
  93: f.color = v2f_color;
  94: f.diffuse = v2f_diffuse;
  95: f.light = v2f_light;
  96: 
  97: 
  98:     FLWMain(f);
  99: }

[13:33:21] [main/ERROR]: Shader compilation log for flywheel:oriented.vert: No errors.

[13:33:21] [main/ERROR]: Source for shader 'flywheel:oriented.vert':
   1: #version 110
   2: 
   3: uniform float uTime;
   4: uniform mat4 uViewProjection;
   5: uniform vec3 uCameraPos;
   6: 
   7: #if defined(USE_FOG)
   8: varying float FragDistance;
   9: #endif
  10: 
  11: void FLWFinalizeWorldPos(inout vec4 worldPos) {
  12:     #if defined(USE_FOG)
  13:     FragDistance = length(worldPos.xyz - uCameraPos);
  14:     #endif
  15: 
  16:     gl_Position = uViewProjection * worldPos;
  17: }
  18: 
  19: void FLWFinalizeNormal(inout vec3 normal) {
  20:     // noop
  21: }
  22: 
  23: 
  24: mat4 rotate(vec3 axis, float angle) {
  25:     float s = sin(angle);
  26:     float c = cos(angle);
  27:     float oc = 1. - c;
  28: 
  29:     vec3 sa = axis * s;
  30: 
  31:     mat4 mr = mat4(1.);
  32:     mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
  33:     mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
  34:     mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);
  35: 
  36:     return mr;
  37: }
  38: 
  39: mat4 rotation(vec3 rot) {
  40:     return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
  41: }
  42: 
  43: mat3 modelToNormal(mat4 mat) {
  44:     // Discard the edges. This won't be accurate for scaled or skewed matrices,
  45:     // but we don't have to work with those often.
  46:     mat3 m;
  47:     m[0] = mat[0].xyz;
  48:     m[1] = mat[1].xyz;
  49:     m[2] = mat[2].xyz;
  50:     return m;
  51: }
  52: 
  53: #define PIOVER2 1.5707963268
  54: 
  55: vec4 quat(vec3 axis, float angle) {
  56:     float halfAngle = angle * PIOVER2 / 180.0;
  57:     vec2 cs = sin(vec2(PIOVER2 - halfAngle, halfAngle)); // compute sin and cos in one instruction
  58:     return vec4(axis.xyz * cs.y,  cs.x);
  59: }
  60: 
  61: vec4 quatMult(vec4 q1, vec4 q2) {
  62:     // disgustingly vectorized quaternion multiplication
  63:     vec4 a = q1.w * q2.xyzw;
  64:     vec4 b = q1.x * q2.wzxy * vec4(1., -1., 1., -1.);
  65:     vec4 c = q1.y * q2.zwxy * vec4(1., 1., -1., -1.);
  66:     vec4 d = q1.z * q2.yxwz * vec4(-1., 1., 1., -1.);
  67: 
  68:     return a + b + c + d;
  69: }
  70: 
  71: vec3 rotateVertexByQuat(vec3 v, vec4 q) {
  72:     vec3 i = q.xyz;
  73:     return v + 2.0 * cross(i, cross(i, v) + q.w * v);
  74: }
  75: 
  76: vec3 rotateAbout(vec3 v, vec3 axis, float angle) {
  77:     return rotateVertexByQuat(v, quat(axis, angle));
  78: }
  79: 
  80: float diffuse(vec3 normal) {
  81:     vec3 n2 = normal * normal * vec3(.6, .25, .8);
  82:     return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
  83: }
  84: 
  85: 
  86: struct Oriented {
  87:     vec2 light;
  88:     vec4 color;
  89:     vec3 pos;
  90:     vec3 pivot;
  91:     vec4 rotation;
  92: };
  93: 
  94: 
  95: struct Vertex {
  96:     vec3 pos;
  97:     vec3 normal;
  98:     vec2 texCoords;
  99: };
 100: 
 101: struct BlockFrag {
 102:     vec2 texCoords;
 103:     vec4 color;
 104:     float diffuse;
 105:     vec2 light;
 106: };
 107: 
 108: BlockFrag FLWMain(Vertex v, Oriented o) {
 109:     vec4 worldPos = vec4(rotateVertexByQuat(v.pos - o.pivot, o.rotation) + o.pivot + o.pos, 1.);
 110: 
 111:     vec3 norm = rotateVertexByQuat(v.normal, o.rotation);
 112: 
 113:     FLWFinalizeWorldPos(worldPos);
 114:     FLWFinalizeNormal(norm);
 115: 
 116:     BlockFrag b;
 117:     b.diffuse = diffuse(norm);
 118:     b.texCoords = v.texCoords;
 119:     b.light = o.light;
 120:     #if defined(DEBUG_NORMAL)
 121:     b.color = vec4(norm, 1.);
 122:     #else
 123:     b.color = o.color;
 124:     #endif
 125:     return b;
 126: }
 127: attribute vec3 a_v_pos;
 128: attribute vec3 a_v_normal;
 129: attribute vec2 a_v_texCoords;
 130: 
 131: attribute vec2 a_i_light;
 132: attribute vec4 a_i_color;
 133: attribute vec3 a_i_pos;
 134: attribute vec3 a_i_pivot;
 135: attribute vec4 a_i_rotation;
 136: 
 137: 
 138: varying vec2 v2f_texCoords;
 139: varying vec4 v2f_color;
 140: varying float v2f_diffuse;
 141: varying vec2 v2f_light;
 142: 
 143: 
 144: void main() {
 145:     Vertex v;
 146:     v.pos = a_v_pos;
 147: v.normal = a_v_normal;
 148: v.texCoords = a_v_texCoords;
 149: 
 150: 
 151:     Oriented i;
 152:     i.light = a_i_light;
 153: i.color = a_i_color;
 154: i.pos = a_i_pos;
 155: i.pivot = a_i_pivot;
 156: i.rotation = a_i_rotation;
 157: 
 158: 
 159:     BlockFrag o = FLWMain(v, i);
 160: 
 161:     v2f_texCoords = o.texCoords;
 162: v2f_color = o.color;
 163: v2f_diffuse = o.diffuse;
 164: v2f_light = o.light;
 165: 
 166: }

[13:33:21] [main/ERROR]: Shader compilation log for flywheel:block.frag: No errors.

[13:33:21] [main/ERROR]: Source for shader 'flywheel:block.frag':
   1: #version 110
   2: 
   3: #if defined(USE_FOG)
   4: varying float FragDistance;
   5: uniform vec4 uFogColor;
   6: #endif
   7: 
   8: #if defined(USE_FOG_LINEAR)
   9: uniform vec2 uFogRange;
  10: 
  11: float FLWFogFactor() {
  12:     return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
  13: }
  14:     #endif
  15: 
  16:     #if defined(USE_FOG_EXP2)
  17: uniform float uFogDensity;
  18: 
  19: float FLWFogFactor() {
  20:     float dist = FragDistance * uFogDensity;
  21:     return 1. / exp2(dist * dist);
  22: }
  23:     #endif
  24: // Adjust the [0,1] normalized lightmap value based on the texture matrix from LightTexture#enableLightmap
  25: vec2 shiftLight(vec2 lm) {
  26:     return lm * 0.99609375 + 0.03125;// * 255/256 + 1/32
  27: }
  28: 
  29: uniform sampler2D uBlockAtlas;
  30: uniform sampler2D uLightMap;
  31: 
  32: vec4 FLWBlockTexture(vec2 texCoords) {
  33:     return texture2D(uBlockAtlas, texCoords);
  34: }
  35: 
  36: void FLWFinalizeColor(vec4 color) {
  37:     #if defined(USE_FOG)
  38:     float a = color.a;
  39:     float fog = clamp(FLWFogFactor(), 0., 1.);
  40: 
  41:     color = mix(uFogColor, color, fog);
  42:     color.a = a;
  43:     #endif
  44: 
  45:     gl_FragColor = color;
  46: }
  47: 
  48: vec4 FLWLight(vec2 lightCoords) {
  49:     return texture2D(uLightMap, shiftLight(lightCoords));
  50: }
  51: 
  52: 
  53: 
  54: struct BlockFrag {
  55:     vec2 texCoords;
  56:     vec4 color;
  57:     float diffuse;
  58:     vec2 light;
  59: };
  60: 
  61: void FLWMain(BlockFrag r) {
  62:     vec4 tex = FLWBlockTexture(r.texCoords);
  63: 
  64:     vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;
  65: 
  66: //    flw_WorldPos = ;
  67: //    flw_Normal = ;
  68: //    flw_Albedo = tex.rgb;
  69: //    flw_Alpha = tex.a;
  70: //    flw_LightMap = r.light;
  71: //    flw_Tint = r.color;
  72:     FLWFinalizeColor(color);
  73: }
  74: 
  75: varying vec2 v2f_texCoords;
  76: varying vec4 v2f_color;
  77: varying float v2f_diffuse;
  78: varying vec2 v2f_light;
  79: 
  80: 
  81: //vec3 flw_WorldPos;
  82: //vec3 flw_Normal;
  83: //vec3 flw_Albedo;
  84: //float flw_Alpha;
  85: //vec2 flw_LightMap;
  86: //vec4 flw_Tint;
  87: 
  88: void main() {
  89:     BlockFrag f;
  90:     f.texCoords = v2f_texCoords;
  91: f.color = v2f_color;
  92: f.diffuse = v2f_diffuse;
  93: f.light = v2f_light;
  94: 
  95: 
  96:     FLWMain(f);
  97: }

[13:33:21] [main/ERROR]: Shader compilation log for flywheel:model.vert: No errors.

[13:33:21] [main/ERROR]: Source for shader 'flywheel:model.vert':
   1: #version 110
   2: #define DEBUG_NORMAL
   3: 
   4: uniform float uTime;
   5: uniform mat4 uViewProjection;
   6: uniform vec3 uCameraPos;
   7: 
   8: #if defined(USE_FOG)
   9: varying float FragDistance;
  10: #endif
  11: 
  12: void FLWFinalizeWorldPos(inout vec4 worldPos) {
  13:     #if defined(USE_FOG)
  14:     FragDistance = length(worldPos.xyz - uCameraPos);
  15:     #endif
  16: 
  17:     gl_Position = uViewProjection * worldPos;
  18: }
  19: 
  20: void FLWFinalizeNormal(inout vec3 normal) {
  21:     // noop
  22: }
  23: 
  24: 
  25: float diffuse(vec3 normal) {
  26:     vec3 n2 = normal * normal * vec3(.6, .25, .8);
  27:     return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
  28: }
  29: 
  30: 
  31: struct Vertex {
  32:     vec3 pos;
  33:     vec3 normal;
  34:     vec2 texCoords;
  35: };
  36: 
  37: struct BlockFrag {
  38:     vec2 texCoords;
  39:     vec4 color;
  40:     float diffuse;
  41:     vec2 light;
  42: };
  43: 
  44: 
  45: struct Instance {
  46:     vec2 light;
  47:     vec4 color;
  48:     mat4 transform;
  49:     mat3 normalMat;
  50: };
  51: 
  52: BlockFrag FLWMain(Vertex v, Instance i) {
  53:     vec4 worldPos = i.transform * vec4(v.pos, 1.);
  54: 
  55:     vec3 norm = i.normalMat * v.normal;
  56: 
  57:     FLWFinalizeWorldPos(worldPos);
  58:     FLWFinalizeNormal(norm);
  59: 
  60:     norm = normalize(norm);
  61: 
  62:     BlockFrag b;
  63:     b.diffuse = diffuse(norm);
  64:     b.texCoords = v.texCoords;
  65:     b.light = i.light;
  66:     #if defined(DEBUG_NORMAL)
  67:     b.color = vec4(norm, 1.);
  68:     #else
  69:     b.color = i.color;
  70:     #endif
  71:     return b;
  72: }
  73: attribute vec3 a_v_pos;
  74: attribute vec3 a_v_normal;
  75: attribute vec2 a_v_texCoords;
  76: 
  77: attribute vec2 a_i_light;
  78: attribute vec4 a_i_color;
  79: attribute mat4 a_i_transform;
  80: attribute mat3 a_i_normalMat;
  81: 
  82: 
  83: varying vec2 v2f_texCoords;
  84: varying vec4 v2f_color;
  85: varying float v2f_diffuse;
  86: varying vec2 v2f_light;
  87: 
  88: 
  89: void main() {
  90:     Vertex v;
  91:     v.pos = a_v_pos;
  92: v.normal = a_v_normal;
  93: v.texCoords = a_v_texCoords;
  94: 
  95: 
  96:     Instance i;
  97:     i.light = a_i_light;
  98: i.color = a_i_color;
  99: i.transform = a_i_transform;
 100: i.normalMat = a_i_normalMat;
 101: 
 102: 
 103:     BlockFrag o = FLWMain(v, i);
 104: 
 105:     v2f_texCoords = o.texCoords;
 106: v2f_color = o.color;
 107: v2f_diffuse = o.diffuse;
 108: v2f_light = o.light;
 109: 
 110: }

[13:33:21] [main/ERROR]: Shader compilation log for flywheel:block.frag: No errors.

[13:33:21] [main/ERROR]: Source for shader 'flywheel:block.frag':
   1: #version 110
   2: #define DEBUG_NORMAL
   3: 
   4: #if defined(USE_FOG)
   5: varying float FragDistance;
   6: uniform vec4 uFogColor;
   7: #endif
   8: 
   9: #if defined(USE_FOG_LINEAR)
  10: uniform vec2 uFogRange;
  11: 
  12: float FLWFogFactor() {
  13:     return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
  14: }
  15:     #endif
  16: 
  17:     #if defined(USE_FOG_EXP2)
  18: uniform float uFogDensity;
  19: 
  20: float FLWFogFactor() {
  21:     float dist = FragDistance * uFogDensity;
  22:     return 1. / exp2(dist * dist);
  23: }
  24:     #endif
  25: // Adjust the [0,1] normalized lightmap value based on the texture matrix from LightTexture#enableLightmap
  26: vec2 shiftLight(vec2 lm) {
  27:     return lm * 0.99609375 + 0.03125;// * 255/256 + 1/32
  28: }
  29: 
  30: uniform sampler2D uBlockAtlas;
  31: uniform sampler2D uLightMap;
  32: 
  33: vec4 FLWBlockTexture(vec2 texCoords) {
  34:     return texture2D(uBlockAtlas, texCoords);
  35: }
  36: 
  37: void FLWFinalizeColor(vec4 color) {
  38:     #if defined(USE_FOG)
  39:     float a = color.a;
  40:     float fog = clamp(FLWFogFactor(), 0., 1.);
  41: 
  42:     color = mix(uFogColor, color, fog);
  43:     color.a = a;
  44:     #endif
  45: 
  46:     gl_FragColor = color;
  47: }
  48: 
  49: vec4 FLWLight(vec2 lightCoords) {
  50:     return texture2D(uLightMap, shiftLight(lightCoords));
  51: }
  52: 
  53: 
  54: 
  55: struct BlockFrag {
  56:     vec2 texCoords;
  57:     vec4 color;
  58:     float diffuse;
  59:     vec2 light;
  60: };
  61: 
  62: void FLWMain(BlockFrag r) {
  63:     vec4 tex = FLWBlockTexture(r.texCoords);
  64: 
  65:     vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;
  66: 
  67: //    flw_WorldPos = ;
  68: //    flw_Normal = ;
  69: //    flw_Albedo = tex.rgb;
  70: //    flw_Alpha = tex.a;
  71: //    flw_LightMap = r.light;
  72: //    flw_Tint = r.color;
  73:     FLWFinalizeColor(color);
  74: }
  75: 
  76: varying vec2 v2f_texCoords;
  77: varying vec4 v2f_color;
  78: varying float v2f_diffuse;
  79: varying vec2 v2f_light;
  80: 
  81: 
  82: //vec3 flw_WorldPos;
  83: //vec3 flw_Normal;
  84: //vec3 flw_Albedo;
  85: //float flw_Alpha;
  86: //vec2 flw_LightMap;
  87: //vec4 flw_Tint;
  88: 
  89: void main() {
  90:     BlockFrag f;
  91:     f.texCoords = v2f_texCoords;
  92: f.color = v2f_color;
  93: f.diffuse = v2f_diffuse;
  94: f.light = v2f_light;
  95: 
  96: 
  97:     FLWMain(f);
  98: }

[13:33:21] [main/ERROR]: Shader compilation log for flywheel:model.vert: No errors.

[13:33:21] [main/ERROR]: Source for shader 'flywheel:model.vert':
   1: #version 110
   2: #define USE_FOG
   3: #define USE_FOG_LINEAR
   4: 
   5: uniform float uTime;
   6: uniform mat4 uViewProjection;
   7: uniform vec3 uCameraPos;
   8: 
   9: #if defined(USE_FOG)
  10: varying float FragDistance;
  11: #endif
  12: 
  13: void FLWFinalizeWorldPos(inout vec4 worldPos) {
  14:     #if defined(USE_FOG)
  15:     FragDistance = length(worldPos.xyz - uCameraPos);
  16:     #endif
  17: 
  18:     gl_Position = uViewProjection * worldPos;
  19: }
  20: 
  21: void FLWFinalizeNormal(inout vec3 normal) {
  22:     // noop
  23: }
  24: 
  25: 
  26: float diffuse(vec3 normal) {
  27:     vec3 n2 = normal * normal * vec3(.6, .25, .8);
  28:     return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
  29: }
  30: 
  31: 
  32: struct Vertex {
  33:     vec3 pos;
  34:     vec3 normal;
  35:     vec2 texCoords;
  36: };
  37: 
  38: struct BlockFrag {
  39:     vec2 texCoords;
  40:     vec4 color;
  41:     float diffuse;
  42:     vec2 light;
  43: };
  44: 
  45: 
  46: struct Instance {
  47:     vec2 light;
  48:     vec4 color;
  49:     mat4 transform;
  50:     mat3 normalMat;
  51: };
  52: 
  53: BlockFrag FLWMain(Vertex v, Instance i) {
  54:     vec4 worldPos = i.transform * vec4(v.pos, 1.);
  55: 
  56:     vec3 norm = i.normalMat * v.normal;
  57: 
  58:     FLWFinalizeWorldPos(worldPos);
  59:     FLWFinalizeNormal(norm);
  60: 
  61:     norm = normalize(norm);
  62: 
  63:     BlockFrag b;
  64:     b.diffuse = diffuse(norm);
  65:     b.texCoords = v.texCoords;
  66:     b.light = i.light;
  67:     #if defined(DEBUG_NORMAL)
  68:     b.color = vec4(norm, 1.);
  69:     #else
  70:     b.color = i.color;
  71:     #endif
  72:     return b;
  73: }
  74: attribute vec3 a_v_pos;
  75: attribute vec3 a_v_normal;
  76: attribute vec2 a_v_texCoords;
  77: 
  78: attribute vec2 a_i_light;
  79: attribute vec4 a_i_color;
  80: attribute mat4 a_i_transform;
  81: attribute mat3 a_i_normalMat;
  82: 
  83: 
  84: varying vec2 v2f_texCoords;
  85: varying vec4 v2f_color;
  86: varying float v2f_diffuse;
  87: varying vec2 v2f_light;
  88: 
  89: 
  90: void main() {
  91:     Vertex v;
  92:     v.pos = a_v_pos;
  93: v.normal = a_v_normal;
  94: v.texCoords = a_v_texCoords;
  95: 
  96: 
  97:     Instance i;
  98:     i.light = a_i_light;
  99: i.color = a_i_color;
 100: i.transform = a_i_transform;
 101: i.normalMat = a_i_normalMat;
 102: 
 103: 
 104:     BlockFrag o = FLWMain(v, i);
 105: 
 106:     v2f_texCoords = o.texCoords;
 107: v2f_color = o.color;
 108: v2f_diffuse = o.diffuse;
 109: v2f_light = o.light;
 110: 
 111: }

[13:33:21] [main/ERROR]: Shader compilation log for flywheel:block.frag: No errors.

[13:33:21] [main/ERROR]: Source for shader 'flywheel:block.frag':
   1: #version 110
   2: #define USE_FOG
   3: #define USE_FOG_LINEAR
   4: 
   5: #if defined(USE_FOG)
   6: varying float FragDistance;
   7: uniform vec4 uFogColor;
   8: #endif
   9: 
  10: #if defined(USE_FOG_LINEAR)
  11: uniform vec2 uFogRange;
  12: 
  13: float FLWFogFactor() {
  14:     return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
  15: }
  16:     #endif
  17: 
  18:     #if defined(USE_FOG_EXP2)
  19: uniform float uFogDensity;
  20: 
  21: float FLWFogFactor() {
  22:     float dist = FragDistance * uFogDensity;
  23:     return 1. / exp2(dist * dist);
  24: }
  25:     #endif
  26: // Adjust the [0,1] normalized lightmap value based on the texture matrix from LightTexture#enableLightmap
  27: vec2 shiftLight(vec2 lm) {
  28:     return lm * 0.99609375 + 0.03125;// * 255/256 + 1/32
  29: }
  30: 
  31: uniform sampler2D uBlockAtlas;
  32: uniform sampler2D uLightMap;
  33: 
  34: vec4 FLWBlockTexture(vec2 texCoords) {
  35:     return texture2D(uBlockAtlas, texCoords);
  36: }
  37: 
  38: void FLWFinalizeColor(vec4 color) {
  39:     #if defined(USE_FOG)
  40:     float a = color.a;
  41:     float fog = clamp(FLWFogFactor(), 0., 1.);
  42: 
  43:     color = mix(uFogColor, color, fog);
  44:     color.a = a;
  45:     #endif
  46: 
  47:     gl_FragColor = color;
  48: }
  49: 
  50: vec4 FLWLight(vec2 lightCoords) {
  51:     return texture2D(uLightMap, shiftLight(lightCoords));
  52: }
  53: 
  54: 
  55: 
  56: struct BlockFrag {
  57:     vec2 texCoords;
  58:     vec4 color;
  59:     float diffuse;
  60:     vec2 light;
  61: };
  62: 
  63: void FLWMain(BlockFrag r) {
  64:     vec4 tex = FLWBlockTexture(r.texCoords);
  65: 
  66:     vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;
  67: 
  68: //    flw_WorldPos = ;
  69: //    flw_Normal = ;
  70: //    flw_Albedo = tex.rgb;
  71: //    flw_Alpha = tex.a;
  72: //    flw_LightMap = r.light;
  73: //    flw_Tint = r.color;
  74:     FLWFinalizeColor(color);
  75: }
  76: 
  77: varying vec2 v2f_texCoords;
  78: varying vec4 v2f_color;
  79: varying float v2f_diffuse;
  80: varying vec2 v2f_light;
  81: 
  82: 
  83: //vec3 flw_WorldPos;
  84: //vec3 flw_Normal;
  85: //vec3 flw_Albedo;
  86: //float flw_Alpha;
  87: //vec2 flw_LightMap;
  88: //vec4 flw_Tint;
  89: 
  90: void main() {
  91:     BlockFrag f;
  92:     f.texCoords = v2f_texCoords;
  93: f.color = v2f_color;
  94: f.diffuse = v2f_diffuse;
  95: f.light = v2f_light;
  96: 
  97: 
  98:     FLWMain(f);
  99: }

[13:33:21] [main/ERROR]: Shader compilation log for flywheel:model.vert: No errors.

[13:33:21] [main/ERROR]: Source for shader 'flywheel:model.vert':
   1: #version 110
   2: #define USE_FOG
   3: #define USE_FOG_EXP2
   4: 
   5: uniform float uTime;
   6: uniform mat4 uViewProjection;
   7: uniform vec3 uCameraPos;
   8: 
   9: #if defined(USE_FOG)
  10: varying float FragDistance;
  11: #endif
  12: 
  13: void FLWFinalizeWorldPos(inout vec4 worldPos) {
  14:     #if defined(USE_FOG)
  15:     FragDistance = length(worldPos.xyz - uCameraPos);
  16:     #endif
  17: 
  18:     gl_Position = uViewProjection * worldPos;
  19: }
  20: 
  21: void FLWFinalizeNormal(inout vec3 normal) {
  22:     // noop
  23: }
  24: 
  25: 
  26: float diffuse(vec3 normal) {
  27:     vec3 n2 = normal * normal * vec3(.6, .25, .8);
  28:     return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
  29: }
  30: 
  31: 
  32: struct Vertex {
  33:     vec3 pos;
  34:     vec3 normal;
  35:     vec2 texCoords;
  36: };
  37: 
  38: struct BlockFrag {
  39:     vec2 texCoords;
  40:     vec4 color;
  41:     float diffuse;
  42:     vec2 light;
  43: };
  44: 
  45: 
  46: struct Instance {
  47:     vec2 light;
  48:     vec4 color;
  49:     mat4 transform;
  50:     mat3 normalMat;
  51: };
  52: 
  53: BlockFrag FLWMain(Vertex v, Instance i) {
  54:     vec4 worldPos = i.transform * vec4(v.pos, 1.);
  55: 
  56:     vec3 norm = i.normalMat * v.normal;
  57: 
  58:     FLWFinalizeWorldPos(worldPos);
  59:     FLWFinalizeNormal(norm);
  60: 
  61:     norm = normalize(norm);
  62: 
  63:     BlockFrag b;
  64:     b.diffuse = diffuse(norm);
  65:     b.texCoords = v.texCoords;
  66:     b.light = i.light;
  67:     #if defined(DEBUG_NORMAL)
  68:     b.color = vec4(norm, 1.);
  69:     #else
  70:     b.color = i.color;
  71:     #endif
  72:     return b;
  73: }
  74: attribute vec3 a_v_pos;
  75: attribute vec3 a_v_normal;
  76: attribute vec2 a_v_texCoords;
  77: 
  78: attribute vec2 a_i_light;
  79: attribute vec4 a_i_color;
  80: attribute mat4 a_i_transform;
  81: attribute mat3 a_i_normalMat;
  82: 
  83: 
  84: varying vec2 v2f_texCoords;
  85: varying vec4 v2f_color;
  86: varying float v2f_diffuse;
  87: varying vec2 v2f_light;
  88: 
  89: 
  90: void main() {
  91:     Vertex v;
  92:     v.pos = a_v_pos;
  93: v.normal = a_v_normal;
  94: v.texCoords = a_v_texCoords;
  95: 
  96: 
  97:     Instance i;
  98:     i.light = a_i_light;
  99: i.color = a_i_color;
 100: i.transform = a_i_transform;
 101: i.normalMat = a_i_normalMat;
 102: 
 103: 
 104:     BlockFrag o = FLWMain(v, i);
 105: 
 106:     v2f_texCoords = o.texCoords;
 107: v2f_color = o.color;
 108: v2f_diffuse = o.diffuse;
 109: v2f_light = o.light;
 110: 
 111: }

[13:33:21] [main/ERROR]: Shader compilation log for flywheel:block.frag: No errors.

[13:33:21] [main/ERROR]: Source for shader 'flywheel:block.frag':
   1: #version 110
   2: #define USE_FOG
   3: #define USE_FOG_EXP2
   4: 
   5: #if defined(USE_FOG)
   6: varying float FragDistance;
   7: uniform vec4 uFogColor;
   8: #endif
   9: 
  10: #if defined(USE_FOG_LINEAR)
  11: uniform vec2 uFogRange;
  12: 
  13: float FLWFogFactor() {
  14:     return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
  15: }
  16:     #endif
  17: 
  18:     #if defined(USE_FOG_EXP2)
  19: uniform float uFogDensity;
  20: 
  21: float FLWFogFactor() {
  22:     float dist = FragDistance * uFogDensity;
  23:     return 1. / exp2(dist * dist);
  24: }
  25:     #endif
  26: // Adjust the [0,1] normalized lightmap value based on the texture matrix from LightTexture#enableLightmap
  27: vec2 shiftLight(vec2 lm) {
  28:     return lm * 0.99609375 + 0.03125;// * 255/256 + 1/32
  29: }
  30: 
  31: uniform sampler2D uBlockAtlas;
  32: uniform sampler2D uLightMap;
  33: 
  34: vec4 FLWBlockTexture(vec2 texCoords) {
  35:     return texture2D(uBlockAtlas, texCoords);
  36: }
  37: 
  38: void FLWFinalizeColor(vec4 color) {
  39:     #if defined(USE_FOG)
  40:     float a = color.a;
  41:     float fog = clamp(FLWFogFactor(), 0., 1.);
  42: 
  43:     color = mix(uFogColor, color, fog);
  44:     color.a = a;
  45:     #endif
  46: 
  47:     gl_FragColor = color;
  48: }
  49: 
  50: vec4 FLWLight(vec2 lightCoords) {
  51:     return texture2D(uLightMap, shiftLight(lightCoords));
  52: }
  53: 
  54: 
  55: 
  56: struct BlockFrag {
  57:     vec2 texCoords;
  58:     vec4 color;
  59:     float diffuse;
  60:     vec2 light;
  61: };
  62: 
  63: void FLWMain(BlockFrag r) {
  64:     vec4 tex = FLWBlockTexture(r.texCoords);
  65: 
  66:     vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;
  67: 
  68: //    flw_WorldPos = ;
  69: //    flw_Normal = ;
  70: //    flw_Albedo = tex.rgb;
  71: //    flw_Alpha = tex.a;
  72: //    flw_LightMap = r.light;
  73: //    flw_Tint = r.color;
  74:     FLWFinalizeColor(color);
  75: }
  76: 
  77: varying vec2 v2f_texCoords;
  78: varying vec4 v2f_color;
  79: varying float v2f_diffuse;
  80: varying vec2 v2f_light;
  81: 
  82: 
  83: //vec3 flw_WorldPos;
  84: //vec3 flw_Normal;
  85: //vec3 flw_Albedo;
  86: //float flw_Alpha;
  87: //vec2 flw_LightMap;
  88: //vec4 flw_Tint;
  89: 
  90: void main() {
  91:     BlockFrag f;
  92:     f.texCoords = v2f_texCoords;
  93: f.color = v2f_color;
  94: f.diffuse = v2f_diffuse;
  95: f.light = v2f_light;
  96: 
  97: 
  98:     FLWMain(f);
  99: }

[13:33:21] [main/ERROR]: Shader compilation log for flywheel:model.vert: No errors.

[13:33:21] [main/ERROR]: Source for shader 'flywheel:model.vert':
   1: #version 110
   2: 
   3: uniform float uTime;
   4: uniform mat4 uViewProjection;
   5: uniform vec3 uCameraPos;
   6: 
   7: #if defined(USE_FOG)
   8: varying float FragDistance;
   9: #endif
  10: 
  11: void FLWFinalizeWorldPos(inout vec4 worldPos) {
  12:     #if defined(USE_FOG)
  13:     FragDistance = length(worldPos.xyz - uCameraPos);
  14:     #endif
  15: 
  16:     gl_Position = uViewProjection * worldPos;
  17: }
  18: 
  19: void FLWFinalizeNormal(inout vec3 normal) {
  20:     // noop
  21: }
  22: 
  23: 
  24: float diffuse(vec3 normal) {
  25:     vec3 n2 = normal * normal * vec3(.6, .25, .8);
  26:     return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
  27: }
  28: 
  29: 
  30: struct Vertex {
  31:     vec3 pos;
  32:     vec3 normal;
  33:     vec2 texCoords;
  34: };
  35: 
  36: struct BlockFrag {
  37:     vec2 texCoords;
  38:     vec4 color;
  39:     float diffuse;
  40:     vec2 light;
  41: };
  42: 
  43: 
  44: struct Instance {
  45:     vec2 light;
  46:     vec4 color;
  47:     mat4 transform;
  48:     mat3 normalMat;
  49: };
  50: 
  51: BlockFrag FLWMain(Vertex v, Instance i) {
  52:     vec4 worldPos = i.transform * vec4(v.pos, 1.);
  53: 
  54:     vec3 norm = i.normalMat * v.normal;
  55: 
  56:     FLWFinalizeWorldPos(worldPos);
  57:     FLWFinalizeNormal(norm);
  58: 
  59:     norm = normalize(norm);
  60: 
  61:     BlockFrag b;
  62:     b.diffuse = diffuse(norm);
  63:     b.texCoords = v.texCoords;
  64:     b.light = i.light;
  65:     #if defined(DEBUG_NORMAL)
  66:     b.color = vec4(norm, 1.);
  67:     #else
  68:     b.color = i.color;
  69:     #endif
  70:     return b;
  71: }
  72: attribute vec3 a_v_pos;
  73: attribute vec3 a_v_normal;
  74: attribute vec2 a_v_texCoords;
  75: 
  76: attribute vec2 a_i_light;
  77: attribute vec4 a_i_color;
  78: attribute mat4 a_i_transform;
  79: attribute mat3 a_i_normalMat;
  80: 
  81: 
  82: varying vec2 v2f_texCoords;
  83: varying vec4 v2f_color;
  84: varying float v2f_diffuse;
  85: varying vec2 v2f_light;
  86: 
  87: 
  88: void main() {
  89:     Vertex v;
  90:     v.pos = a_v_pos;
  91: v.normal = a_v_normal;
  92: v.texCoords = a_v_texCoords;
  93: 
  94: 
  95:     Instance i;
  96:     i.light = a_i_light;
  97: i.color = a_i_color;
  98: i.transform = a_i_transform;
  99: i.normalMat = a_i_normalMat;
 100: 
 101: 
 102:     BlockFrag o = FLWMain(v, i);
 103: 
 104:     v2f_texCoords = o.texCoords;
 105: v2f_color = o.color;
 106: v2f_diffuse = o.diffuse;
 107: v2f_light = o.light;
 108: 
 109: }

[13:33:21] [main/ERROR]: Shader compilation log for flywheel:block.frag: No errors.

[13:33:21] [main/ERROR]: Source for shader 'flywheel:block.frag':
   1: #version 110
   2: 
   3: #if defined(USE_FOG)
   4: varying float FragDistance;
   5: uniform vec4 uFogColor;
   6: #endif
   7: 
   8: #if defined(USE_FOG_LINEAR)
   9: uniform vec2 uFogRange;
  10: 
  11: float FLWFogFactor() {
  12:     return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
  13: }
  14:     #endif
  15: 
  16:     #if defined(USE_FOG_EXP2)
  17: uniform float uFogDensity;
  18: 
  19: float FLWFogFactor() {
  20:     float dist = FragDistance * uFogDensity;
  21:     return 1. / exp2(dist * dist);
  22: }
  23:     #endif
  24: // Adjust the [0,1] normalized lightmap value based on the texture matrix from LightTexture#enableLightmap
  25: vec2 shiftLight(vec2 lm) {
  26:     return lm * 0.99609375 + 0.03125;// * 255/256 + 1/32
  27: }
  28: 
  29: uniform sampler2D uBlockAtlas;
  30: uniform sampler2D uLightMap;
  31: 
  32: vec4 FLWBlockTexture(vec2 texCoords) {
  33:     return texture2D(uBlockAtlas, texCoords);
  34: }
  35: 
  36: void FLWFinalizeColor(vec4 color) {
  37:     #if defined(USE_FOG)
  38:     float a = color.a;
  39:     float fog = clamp(FLWFogFactor(), 0., 1.);
  40: 
  41:     color = mix(uFogColor, color, fog);
  42:     color.a = a;
  43:     #endif
  44: 
  45:     gl_FragColor = color;
  46: }
  47: 
  48: vec4 FLWLight(vec2 lightCoords) {
  49:     return texture2D(uLightMap, shiftLight(lightCoords));
  50: }
  51: 
  52: 
  53: 
  54: struct BlockFrag {
  55:     vec2 texCoords;
  56:     vec4 color;
  57:     float diffuse;
  58:     vec2 light;
  59: };
  60: 
  61: void FLWMain(BlockFrag r) {
  62:     vec4 tex = FLWBlockTexture(r.texCoords);
  63: 
  64:     vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;
  65: 
  66: //    flw_WorldPos = ;
  67: //    flw_Normal = ;
  68: //    flw_Albedo = tex.rgb;
  69: //    flw_Alpha = tex.a;
  70: //    flw_LightMap = r.light;
  71: //    flw_Tint = r.color;
  72:     FLWFinalizeColor(color);
  73: }
  74: 
  75: varying vec2 v2f_texCoords;
  76: varying vec4 v2f_color;
  77: varying float v2f_diffuse;
  78: varying vec2 v2f_light;
  79: 
  80: 
  81: //vec3 flw_WorldPos;
  82: //vec3 flw_Normal;
  83: //vec3 flw_Albedo;
  84: //float flw_Alpha;
  85: //vec2 flw_LightMap;
  86: //vec4 flw_Tint;
  87: 
  88: void main() {
  89:     BlockFrag f;
  90:     f.texCoords = v2f_texCoords;
  91: f.color = v2f_color;
  92: f.diffuse = v2f_diffuse;
  93: f.light = v2f_light;
  94: 
  95: 
  96:     FLWMain(f);
  97: }

[13:33:21] [main/INFO]: Loaded all shader programs.
[13:33:42] [Server thread/WARN]: Can't keep up! Is the server overloaded? Running 5495ms or 109 ticks behind
[13:33:53] [main/INFO]: OpenAL initialized.
[13:33:53] [main/INFO]: Sound engine started
[13:33:54] [main/INFO]: Created: 256x256x0 jei:textures/atlas/gui.png-atlas
[13:33:54] [main/INFO]: [OptiFine] Animated sprites: 2
[13:33:54] [main/INFO]: Created: 256x128x0 mekanism:textures/atlas/robit.png-atlas
[13:33:54] [main/INFO]: [OptiFine] Animated sprites: 2
[13:33:55] [main/INFO]: Created: 2048x2048x4 minecraft:textures/atlas/blocks.png-atlas
[13:34:04] [main/INFO]: [OptiFine] Animated sprites: 223
[13:34:05] [main/INFO]: Created: 256x128x4 minecraft:textures/atlas/signs.png-atlas
[13:34:05] [main/INFO]: [OptiFine] Animated sprites: 2
[13:34:05] [main/INFO]: Created: 512x512x4 minecraft:textures/atlas/banner_patterns.png-atlas
[13:34:05] [main/INFO]: [OptiFine] Animated sprites: 2
[13:34:05] [main/INFO]: Created: 512x512x4 minecraft:textures/atlas/shield_patterns.png-atlas
[13:34:05] [main/INFO]: [OptiFine] Animated sprites: 2
[13:34:05] [main/INFO]: Created: 512x256x4 minecraft:textures/atlas/chest.png-atlas
[13:34:05] [main/INFO]: [OptiFine] Animated sprites: 2
[13:34:05] [main/INFO]: Created: 512x256x4 minecraft:textures/atlas/beds.png-atlas
[13:34:05] [main/INFO]: [OptiFine] Animated sprites: 2
[13:34:05] [main/INFO]: Created: 512x256x4 minecraft:textures/atlas/shulker_boxes.png-atlas
[13:34:05] [main/INFO]: [OptiFine] Animated sprites: 2
[13:34:11] [Server thread/WARN]: Can't keep up! Is the server overloaded? Running 5636ms or 112 ticks behind
[13:34:34] [Server thread/WARN]: Can't keep up! Is the server overloaded? Running 5153ms or 103 ticks behind
[13:36:05] [main/INFO]: Created: 256x256x0 minecraft:textures/atlas/particles.png-atlas
[13:36:06] [main/INFO]: [OptiFine] Animated sprites: 2
[13:36:06] [main/INFO]: Created: 256x256x0 minecraft:textures/atlas/paintings.png-atlas
[13:36:06] [main/INFO]: [OptiFine] Animated sprites: 2
[13:36:06] [main/INFO]: Created: 256x256x0 minecraft:textures/atlas/mob_effects.png-atlas
[13:36:06] [main/INFO]: [OptiFine] Animated sprites: 2
[13:36:06] [main/INFO]: [OptiFine] *** Reloading custom textures ***
[13:36:07] [main/WARN]: [OptiFine] Unknown resource pack file: mod_resources
[13:36:08] [main/WARN]: [OptiFine] Unknown resource pack file: mod_resources
[13:36:08] [main/WARN]: [OptiFine] Unknown resource pack file: mod_resources
[13:37:07] [main/WARN]: [OptiFine] Unknown resource pack file: mod_resources
[13:37:09] [main/WARN]: [OptiFine] Unknown resource pack file: mod_resources
[13:37:10] [main/WARN]: [OptiFine] Unknown resource pack file: mod_resources
[13:37:10] [main/INFO]: [OptiFine] Disable Forge light pipeline
[13:37:10] [main/INFO]: [OptiFine] Set ForgeConfig.CLIENT.forgeLightPipelineEnabled=false
[13:37:10] [main/INFO]: Starting JEI...
[13:37:10] [main/INFO]: Registering item subtypes: jei:minecraft ...
[13:37:10] [main/INFO]: Registering item subtypes: jei:minecraft took 107.9 ?s
[13:37:11] [main/INFO]: Registering item subtypes: cgm:crafting ...
[13:37:11] [main/INFO]: Registering item subtypes: cgm:crafting took 121.4 ms
[13:37:11] [main/INFO]: Registering item subtypes: jei:debug ...
[13:37:11] [main/INFO]: Registering item subtypes: jei:debug took 12.30 ?s
[13:37:11] [main/INFO]: Registering item subtypes: cookingforblockheads:jei ...
[13:37:11] [main/INFO]: Registering item subtypes: cookingforblockheads:jei took 17.00 ?s
[13:37:11] [main/INFO]: Registering item subtypes: appliedenergistics2:core ...
[13:37:11] [main/INFO]: Registering item subtypes: appliedenergistics2:core took 103.0 ms
[13:37:11] [main/INFO]: Registering item subtypes: artifacts:main ...
[13:37:11] [main/INFO]: Registering item subtypes: artifacts:main took 11.00 ?s
[13:37:11] [main/INFO]: Registering item subtypes: compactmachines:main ...
[13:37:11] [main/INFO]: Registering item subtypes: compactmachines:main took 16.90 ?s
[13:37:11] [main/INFO]: Registering item subtypes: sophisticatedbackpacks:default ...
[13:37:11] [main/INFO]: Registering item subtypes: sophisticatedbackpacks:default took 209.4 ?s
[13:37:11] [main/INFO]: Registering item subtypes: darkutils:jei_support ...
[13:37:11] [main/INFO]: Registering item subtypes: darkutils:jei_support took 9.400 ?s
[13:37:11] [main/INFO]: Registering item subtypes: mekanismgenerators:jei_plugin ...
[13:37:12] [main/INFO]: Registering item subtypes: mekanismgenerators:jei_plugin took 1.046 s
[13:37:12] [main/INFO]: Registering item subtypes: mekanism:jei_plugin ...
[13:37:14] [main/INFO]: Registering item subtypes: mekanism:jei_plugin took 2.618 s
[13:37:14] [main/INFO]: Registering item subtypes: cofh_core:default ...
[13:37:14] [main/INFO]: Registering item subtypes: cofh_core:default took 18.40 ?s
[13:37:14] [main/INFO]: Registering item subtypes: industrialforegoing:default ...
[13:37:14] [main/INFO]: Registering item subtypes: industrialforegoing:default took 32.70 ?s
[13:37:15] [main/INFO]: Registering item subtypes: titanium:default ...
[13:37:15] [main/INFO]: Registering item subtypes: titanium:default took 12.00 ?s
[13:37:15] [main/INFO]: Registering item subtypes: lollipop:main ...
[13:37:15] [main/INFO]: Registering item subtypes: lollipop:main took 16.80 ?s
[13:37:15] [main/INFO]: Registering item subtypes: krate:main ...
[13:37:15] [main/INFO]: Registering item subtypes: krate:main took 9.400 ?s
[13:37:15] [main/INFO]: Registering item subtypes: create:jei_plugin ...
[13:37:15] [main/INFO]: Registering item subtypes: create:jei_plugin took 9.500 ?s
[13:37:15] [main/INFO]: Registering item subtypes: curios:curios ...
[13:37:15] [main/INFO]: Registering item subtypes: curios:curios took 17.80 ?s
[13:37:15] [main/INFO]: Registering item subtypes: securitycraft:securitycraft ...
[13:37:15] [main/INFO]: Registering item subtypes: securitycraft:securitycraft took 14.50 ?s
[13:37:15] [main/INFO]: Registering item subtypes: fluxnetworks:jei ...
[13:37:15] [main/INFO]: Registering item subtypes: fluxnetworks:jei took 12.80 ?s
[13:37:15] [main/INFO]: Registering item subtypes: mekanismtools:jei_plugin ...
[13:37:15] [main/INFO]: Registering item subtypes: mekanismtools:jei_plugin took 43.50 ?s
[13:37:15] [main/INFO]: Registering item subtypes: constructionwand:constructionwand ...
[13:37:15] [main/INFO]: Registering item subtypes: constructionwand:constructionwand took 15.70 ?s
[13:37:15] [main/INFO]: Registering item subtypes: ftblibrary:jei ...
[13:37:15] [main/INFO]: Registering item subtypes: ftblibrary:jei took 50.27 ms
[13:37:15] [main/INFO]: Registering item subtypes: ftbquests:jei ...
[13:37:15] [main/INFO]: Registering item subtypes: ftbquests:jei took 114.9 ms
[13:37:15] [main/INFO]: Registering item subtypes: trashcans:jei_plugin ...
[13:37:15] [main/INFO]: Registering item subtypes: trashcans:jei_plugin took 11.40 ?s
[13:37:15] [main/INFO]: Registering item subtypes: jei:internal ...
[13:37:15] [main/INFO]: Registering item subtypes: jei:internal took 9.600 ?s
[13:37:15] [main/INFO]: Registering fluid subtypes: jei:minecraft ...
[13:37:15] [main/INFO]: Registering fluid subtypes: jei:minecraft took 51.60 ?s
[13:37:15] [main/INFO]: Registering fluid subtypes: cgm:crafting ...
[13:37:15] [main/INFO]: Registering fluid subtypes: cgm:crafting took 13.00 ?s
[13:37:15] [main/INFO]: Registering fluid subtypes: jei:debug ...
[13:37:15] [main/INFO]: Registering fluid subtypes: jei:debug took 64.40 ?s
[13:37:15] [main/INFO]: Registering fluid subtypes: cookingforblockheads:jei ...
[13:37:15] [main/INFO]: Registering fluid subtypes: cookingforblockheads:jei took 12.30 ?s
[13:37:15] [main/INFO]: Registering fluid subtypes: appliedenergistics2:core ...
[13:37:15] [main/INFO]: Registering fluid subtypes: appliedenergistics2:core took 11.90 ?s
[13:37:15] [main/INFO]: Registering fluid subtypes: artifacts:main ...
[13:37:15] [main/INFO]: Registering fluid subtypes: artifacts:main took 12.20 ?s
[13:37:15] [main/INFO]: Registering fluid subtypes: compactmachines:main ...
[13:37:15] [main/INFO]: Registering fluid subtypes: compactmachines:main took 13.10 ?s
[13:37:15] [main/INFO]: Registering fluid subtypes: sophisticatedbackpacks:default ...
[13:37:15] [main/INFO]: Registering fluid subtypes: sophisticatedbackpacks:default took 11.00 ?s
[13:37:15] [main/INFO]: Registering fluid subtypes: darkutils:jei_support ...
[13:37:15] [main/INFO]: Registering fluid subtypes: darkutils:jei_support took 11.90 ?s
[13:37:15] [main/INFO]: Registering fluid subtypes: mekanismgenerators:jei_plugin ...
[13:37:15] [main/INFO]: Registering fluid subtypes: mekanismgenerators:jei_plugin took 11.50 ?s
[13:37:15] [main/INFO]: Registering fluid subtypes: mekanism:jei_plugin ...
[13:37:15] [main/INFO]: Registering fluid subtypes: mekanism:jei_plugin took 11.70 ?s
[13:37:15] [main/INFO]: Registering fluid subtypes: cofh_core:default ...
[13:37:15] [main/INFO]: Registering fluid subtypes: cofh_core:default took 10.90 ?s
[13:37:15] [main/INFO]: Registering fluid subtypes: industrialforegoing:default ...
[13:37:15] [main/INFO]: Registering fluid subtypes: industrialforegoing:default took 11.10 ?s
[13:37:15] [main/INFO]: Registering fluid subtypes: titanium:default ...
[13:37:15] [main/INFO]: Registering fluid subtypes: titanium:default took 11.90 ?s
[13:37:15] [main/INFO]: Registering fluid subtypes: lollipop:main ...
[13:37:15] [main/INFO]: Registering fluid subtypes: lollipop:main took 11.60 ?s
[13:37:15] [main/INFO]: Registering fluid subtypes: krate:main ...
[13:37:15] [main/INFO]: Registering fluid subtypes: krate:main took 9.699 ?s
[13:37:15] [main/INFO]: Registering fluid subtypes: create:jei_plugin ...
[13:37:16] [main/INFO]: Registering fluid subtypes: create:jei_plugin took 78.17 ms
[13:37:16] [main/INFO]: Registering fluid subtypes: curios:curios ...
[13:37:16] [main/INFO]: Registering fluid subtypes: curios:curios took 11.40 ?s
[13:37:16] [main/INFO]: Registering fluid subtypes: securitycraft:securitycraft ...
[13:37:16] [main/INFO]: Registering fluid subtypes: securitycraft:securitycraft took 9.400 ?s
[13:37:16] [main/INFO]: Registering fluid subtypes: fluxnetworks:jei ...
[13:37:16] [main/INFO]: Registering fluid subtypes: fluxnetworks:jei took 23.10 ?s
[13:37:16] [main/INFO]: Registering fluid subtypes: mekanismtools:jei_plugin ...
[13:37:16] [main/INFO]: Registering fluid subtypes: mekanismtools:jei_plugin took 9.500 ?s
[13:37:16] [main/INFO]: Registering fluid subtypes: constructionwand:constructionwand ...
[13:37:16] [main/INFO]: Registering fluid subtypes: constructionwand:constructionwand took 9.701 ?s
[13:37:16] [main/INFO]: Registering fluid subtypes: ftblibrary:jei ...
[13:37:16] [main/INFO]: Registering fluid subtypes: ftblibrary:jei took 9.101 ?s
[13:37:16] [main/INFO]: Registering fluid subtypes: ftbquests:jei ...
[13:37:16] [main/INFO]: Registering fluid subtypes: ftbquests:jei took 22.90 ?s
[13:37:16] [main/INFO]: Registering fluid subtypes: trashcans:jei_plugin ...
[13:37:16] [main/INFO]: Registering fluid subtypes: trashcans:jei_plugin took 9.199 ?s
[13:37:16] [main/INFO]: Registering fluid subtypes: jei:internal ...
[13:37:16] [main/INFO]: Registering fluid subtypes: jei:internal took 10.50 ?s
[13:37:16] [main/INFO]: Registering ingredients: jei:minecraft ...
[13:37:21] [main/INFO]: Registering ingredients: jei:minecraft took 5.699 s
[13:37:21] [main/INFO]: Registering ingredients: cgm:crafting ...
[13:37:21] [main/INFO]: Registering ingredients: cgm:crafting took 26.36 ms
[13:37:21] [main/INFO]: Registering ingredients: jei:debug ...
[13:37:21] [main/INFO]: Registering ingredients: jei:debug took 17.70 ?s
[13:37:21] [main/INFO]: Registering ingredients: cookingforblockheads:jei ...
[13:37:21] [main/INFO]: Registering ingredients: cookingforblockheads:jei took 9.301 ?s
[13:37:21] [main/INFO]: Registering ingredients: appliedenergistics2:core ...
[13:37:21] [main/INFO]: Registering ingredients: appliedenergistics2:core took 9.500 ?s
[13:37:21] [main/INFO]: Registering ingredients: artifacts:main ...
[13:37:21] [main/INFO]: Registering ingredients: artifacts:main took 9.200 ?s
[13:37:21] [main/INFO]: Registering ingredients: compactmachines:main ...
[13:37:21] [main/INFO]: Registering ingredients: compactmachines:main took 9.300 ?s
[13:37:21] [main/INFO]: Registering ingredients: sophisticatedbackpacks:default ...
[13:37:21] [main/INFO]: Registering ingredients: sophisticatedbackpacks:default took 9.200 ?s
[13:37:21] [main/INFO]: Registering ingredients: darkutils:jei_support ...
[13:37:21] [main/INFO]: Registering ingredients: darkutils:jei_support took 9.200 ?s
[13:37:21] [main/INFO]: Registering ingredients: mekanismgenerators:jei_plugin ...
[13:37:21] [main/INFO]: Registering ingredients: mekanismgenerators:jei_plugin took 9.300 ?s
[13:37:21] [main/INFO]: Registering ingredients: mekanism:jei_plugin ...
[13:37:21] [main/INFO]: Registering ingredients: mekanism:jei_plugin took 112.5 ms
[13:37:21] [main/INFO]: Registering ingredients: cofh_core:default ...
[13:37:21] [main/INFO]: Registering ingredients: cofh_core:default took 11.70 ?s
[13:37:21] [main/INFO]: Registering ingredients: industrialforegoing:default ...
[13:37:21] [main/INFO]: Registering ingredients: industrialforegoing:default took 9.700 ?s
[13:37:21] [main/INFO]: Registering ingredients: titanium:default ...
[13:37:21] [main/INFO]: Registering ingredients: titanium:default took 11.20 ?s
[13:37:21] [main/INFO]: Registering ingredients: lollipop:main ...
[13:37:21] [main/INFO]: Registering ingredients: lollipop:main took 9.200 ?s
[13:37:21] [main/INFO]: Registering ingredients: krate:main ...
[13:37:21] [main/INFO]: Registering ingredients: krate:main took 9.000 ?s
[13:37:21] [main/INFO]: Registering ingredients: create:jei_plugin ...
[13:37:21] [main/INFO]: Registering ingredients: create:jei_plugin took 9.300 ?s
[13:37:21] [main/INFO]: Registering ingredients: curios:curios ...
[13:37:21] [main/INFO]: Registering ingredients: curios:curios took 9.400 ?s
[13:37:21] [main/INFO]: Registering ingredients: securitycraft:securitycraft ...
[13:37:21] [main/INFO]: Registering ingredients: securitycraft:securitycraft took 9.600 ?s
[13:37:21] [main/INFO]: Registering ingredients: fluxnetworks:jei ...
[13:37:21] [main/INFO]: Registering ingredients: fluxnetworks:jei took 9.600 ?s
[13:37:22] [main/INFO]: Registering ingredients: mekanismtools:jei_plugin ...
[13:37:22] [main/INFO]: Registering ingredients: mekanismtools:jei_plugin took 17.00 ?s
[13:37:22] [main/INFO]: Registering ingredients: constructionwand:constructionwand ...
[13:37:22] [main/INFO]: Registering ingredients: constructionwand:constructionwand took 9.600 ?s
[13:37:22] [main/INFO]: Registering ingredients: ftblibrary:jei ...
[13:37:22] [main/INFO]: Registering ingredients: ftblibrary:jei took 9.500 ?s
[13:37:22] [main/INFO]: Registering ingredients: ftbquests:jei ...
[13:37:22] [main/INFO]: Registering ingredients: ftbquests:jei took 9.300 ?s
[13:37:22] [main/INFO]: Registering ingredients: trashcans:jei_plugin ...
[13:37:22] [main/INFO]: Registering ingredients: trashcans:jei_plugin took 9.300 ?s
[13:37:22] [main/INFO]: Registering ingredients: jei:internal ...
[13:37:22] [main/INFO]: Registering ingredients: jei:internal took 9.299 ?s
[13:37:22] [main/INFO]: Registering categories: jei:minecraft ...
[13:37:22] [main/INFO]: Registering categories: jei:minecraft took 325.1 ms
[13:37:22] [main/INFO]: Registering categories: cgm:crafting ...
[13:37:22] [main/INFO]: Registering categories: cgm:crafting took 56.41 ms
[13:37:22] [main/INFO]: Registering categories: jei:debug ...
[13:37:22] [main/INFO]: Registering categories: jei:debug took 16.30 ?s
[13:37:22] [main/INFO]: Registering categories: cookingforblockheads:jei ...
[13:37:22] [main/INFO]: Registering categories: cookingforblockheads:jei took 115.8 ?s
[13:37:22] [main/INFO]: Registering categories: appliedenergistics2:core ...
[13:37:22] [main/INFO]: Registering categories: appliedenergistics2:core took 202.3 ms
[13:37:22] [main/INFO]: Registering categories: artifacts:main ...
[13:37:22] [main/INFO]: Registering categories: artifacts:main took 13.30 ?s
[13:37:22] [main/INFO]: Registering categories: compactmachines:main ...
[13:37:22] [main/INFO]: Registering categories: compactmachines:main took 11.70 ?s
[13:37:22] [main/INFO]: Registering categories: sophisticatedbackpacks:default ...
[13:37:22] [main/INFO]: Registering categories: sophisticatedbackpacks:default took 10.80 ?s
[13:37:22] [main/INFO]: Registering categories: darkutils:jei_support ...
[13:37:22] [main/INFO]: Registering categories: darkutils:jei_support took 11.10 ?s
[13:37:22] [main/INFO]: Registering categories: mekanismgenerators:jei_plugin ...
[13:37:23] [main/INFO]: Registering categories: mekanismgenerators:jei_plugin took 433.9 ms
[13:37:23] [main/INFO]: Registering categories: mekanism:jei_plugin ...
[13:37:24] [main/INFO]: Registering categories: mekanism:jei_plugin took 822.1 ms
[13:37:24] [main/INFO]: Registering categories: cofh_core:default ...
[13:37:24] [main/INFO]: Registering categories: cofh_core:default took 11.60 ?s
[13:37:24] [main/INFO]: Registering categories: industrialforegoing:default ...
[13:37:24] [main/INFO]: Registering categories: industrialforegoing:default took 154.6 ms
[13:37:24] [main/INFO]: Registering categories: titanium:default ...
[13:37:24] [main/INFO]: Registering categories: titanium:default took 10.80 ?s
[13:37:24] [main/INFO]: Registering categories: lollipop:main ...
[13:37:24] [main/INFO]: Registering categories: lollipop:main took 9.600 ?s
[13:37:24] [main/INFO]: Registering categories: krate:main ...
[13:37:24] [main/INFO]: Registering categories: krate:main took 9.099 ?s
[13:37:24] [main/INFO]: Registering categories: create:jei_plugin ...
[13:37:24] [main/INFO]: Registering categories: create:jei_plugin took 139.9 ms
[13:37:24] [main/INFO]: Registering categories: curios:curios ...
[13:37:24] [main/INFO]: Registering categories: curios:curios took 11.60 ?s
[13:37:24] [main/INFO]: Registering categories: securitycraft:securitycraft ...
[13:37:24] [main/INFO]: Registering categories: securitycraft:securitycraft took 61.40 ?s
[13:37:24] [main/INFO]: Registering categories: fluxnetworks:jei ...
[13:37:24] [main/INFO]: Registering categories: fluxnetworks:jei took 132.7 ?s
[13:37:24] [main/INFO]: Registering categories: mekanismtools:jei_plugin ...
[13:37:24] [main/INFO]: Registering categories: mekanismtools:jei_plugin took 9.500 ?s
[13:37:24] [main/INFO]: Registering categories: constructionwand:constructionwand ...
[13:37:24] [main/INFO]: Registering categories: constructionwand:constructionwand took 9.300 ?s
[13:37:24] [main/INFO]: Registering categories: ftblibrary:jei ...
[13:37:24] [main/INFO]: Registering categories: ftblibrary:jei took 9.200 ?s
[13:37:24] [main/INFO]: Registering categories: ftbquests:jei ...
[13:37:24] [main/INFO]: Registering categories: ftbquests:jei took 9.300 ?s
[13:37:24] [main/INFO]: Registering categories: trashcans:jei_plugin ...
[13:37:24] [main/INFO]: Registering categories: trashcans:jei_plugin took 9.099 ?s
[13:37:24] [main/INFO]: Registering categories: jei:internal ...
[13:37:24] [main/INFO]: Registering categories: jei:internal took 92.50 ?s
[13:37:25] [main/INFO]: Registering vanilla category extensions: jei:minecraft ...
[13:37:25] [main/INFO]: Registering vanilla category extensions: jei:minecraft took 50.28 ms
[13:37:25] [main/INFO]: Registering vanilla category extensions: cgm:crafting ...
[13:37:25] [main/INFO]: Registering vanilla category extensions: cgm:crafting took 11.20 ?s
[13:37:25] [main/INFO]: Registering vanilla category extensions: jei:debug ...
[13:37:25] [main/INFO]: Registering vanilla category extensions: jei:debug took 9.400 ?s
[13:37:25] [main/INFO]: Registering vanilla category extensions: cookingforblockheads:jei ...
[13:37:25] [main/INFO]: Registering vanilla category extensions: cookingforblockheads:jei took 9.100 ?s
[13:37:25] [main/INFO]: Registering vanilla category extensions: appliedenergistics2:core ...
[13:37:25] [main/INFO]: Registering vanilla category extensions: appliedenergistics2:core took 9.300 ?s
[13:37:25] [main/INFO]: Registering vanilla category extensions: artifacts:main ...
[13:37:25] [main/INFO]: Registering vanilla category extensions: artifacts:main took 9.299 ?s
[13:37:25] [main/INFO]: Registering vanilla category extensions: compactmachines:main ...
[13:37:25] [main/INFO]: Registering vanilla category extensions: compactmachines:main took 9.200 ?s
[13:37:25] [main/INFO]: Registering vanilla category extensions: sophisticatedbackpacks:default ...
[13:37:25] [main/INFO]: Registering vanilla category extensions: sophisticatedbackpacks:default took 14.00 ?s
[13:37:25] [main/INFO]: Registering vanilla category extensions: darkutils:jei_support ...
[13:37:25] [main/INFO]: Registering vanilla category extensions: darkutils:jei_support took 12.10 ?s
[13:37:25] [main/INFO]: Registering vanilla category extensions: mekanismgenerators:jei_plugin ...
[13:37:25] [main/INFO]: Registering vanilla category extensions: mekanismgenerators:jei_plugin took 18.80 ?s
[13:37:25] [main/INFO]: Registering vanilla category extensions: mekanism:jei_plugin ...
[13:37:25] [main/INFO]: Registering vanilla category extensions: mekanism:jei_plugin took 9.299 ?s
[13:37:25] [main/INFO]: Registering vanilla category extensions: cofh_core:default ...
[13:37:25] [main/INFO]: Registering vanilla category extensions: cofh_core:default took 9.200 ?s
[13:37:25] [main/INFO]: Registering vanilla category extensions: industrialforegoing:default ...
[13:37:25] [main/INFO]: Registering vanilla category extensions: industrialforegoing:default took 9.101 ?s
[13:37:25] [main/INFO]: Registering vanilla category extensions: titanium:default ...
[13:37:25] [main/INFO]: Registering vanilla category extensions: titanium:default took 11.40 ?s
[13:37:25] [main/INFO]: Registering vanilla category extensions: lollipop:main ...
[13:37:25] [main/INFO]: Registering vanilla category extensions: lollipop:main took 9.100 ?s
[13:37:25] [main/INFO]: Registering vanilla category extensions: krate:main ...
[13:37:25] [main/INFO]: Registering vanilla category extensions: krate:main took 8.999 ?s
[13:37:25] [main/INFO]: Registering vanilla category extensions: create:jei_plugin ...
[13:37:25] [main/INFO]: Registering vanilla category extensions: create:jei_plugin took 9.100 ?s
[13:37:25] [main/INFO]: Registering vanilla category extensions: curios:curios ...
[13:37:25] [main/INFO]: Registering vanilla category extensions: curios:curios took 9.099 ?s
[13:37:25] [main/INFO]: Registering vanilla category extensions: securitycraft:securitycraft ...
[13:37:25] [main/INFO]: Registering vanilla category extensions: securitycraft:securitycraft took 17.90 ?s
[13:37:25] [main/INFO]: Registering vanilla category extensions: fluxnetworks:jei ...
[13:37:25] [main/INFO]: Registering vanilla category extensions: fluxnetworks:jei took 9.200 ?s
[13:37:25] [main/INFO]: Registering vanilla category extensions: mekanismtools:jei_plugin ...
[13:37:25] [main/INFO]: Registering vanilla category extensions: mekanismtools:jei_plugin took 9.301 ?s
[13:37:25] [main/INFO]: Registering vanilla category extensions: constructionwand:constructionwand ...
[13:37:25] [main/INFO]: Registering vanilla category extensions: constructionwand:constructionwand took 9.199 ?s
[13:37:25] [main/INFO]: Registering vanilla category extensions: ftblibrary:jei ...
[13:37:25] [main/INFO]: Registering vanilla category extensions: ftblibrary:jei took 9.500 ?s
[13:37:25] [main/INFO]: Registering vanilla category extensions: ftbquests:jei ...
[13:37:25] [main/INFO]: Registering vanilla category extensions: ftbquests:jei took 9.300 ?s
[13:37:25] [main/INFO]: Registering vanilla category extensions: trashcans:jei_plugin ...
[13:37:25] [main/INFO]: Registering vanilla category extensions: trashcans:jei_plugin took 9.400 ?s
[13:37:25] [main/INFO]: Registering vanilla category extensions: jei:internal ...
[13:37:25] [main/INFO]: Registering vanilla category extensions: jei:internal took 9.200 ?s
[13:37:25] [main/INFO]: Registering recipes: jei:minecraft ...
[13:37:32] [main/INFO]: Registering recipes: jei:minecraft took 6.276 s
[13:37:32] [main/INFO]: Registering recipes: cgm:crafting ...
[13:37:32] [main/INFO]: Registering recipes: cgm:crafting took 727.7 ms
[13:37:32] [main/INFO]: Registering recipes: jei:debug ...
[13:37:32] [main/INFO]: Registering recipes: jei:debug took 21.80 ?s
[13:37:32] [main/INFO]: Registering recipes: cookingforblockheads:jei ...
[13:37:32] [main/INFO]: Registering recipes: cookingforblockheads:jei took 37.91 ms
[13:37:32] [main/INFO]: Registering recipes: appliedenergistics2:core ...
[13:37:33] [main/INFO]: Registering recipes: appliedenergistics2:core took 413.9 ms
[13:37:33] [main/INFO]: Registering recipes: artifacts:main ...
[13:37:33] [main/INFO]: Registering recipes: artifacts:main took 4.260 ms
[13:37:33] [main/INFO]: Registering recipes: compactmachines:main ...
[13:37:33] [main/INFO]: Registering recipes: compactmachines:main took 19.00 ?s
[13:37:33] [main/INFO]: Registering recipes: sophisticatedbackpacks:default ...
[13:37:33] [main/INFO]: Registering recipes: sophisticatedbackpacks:default took 65.87 ms
[13:37:33] [main/INFO]: Registering recipes: darkutils:jei_support ...
[13:37:33] [main/INFO]: Registering recipes: darkutils:jei_support took 105.3 ms
[13:37:33] [main/INFO]: Registering recipes: mekanismgenerators:jei_plugin ...
[13:37:33] [main/INFO]: Registering recipes: mekanismgenerators:jei_plugin took 138.5 ms
[13:37:33] [main/INFO]: Registering recipes: mekanism:jei_plugin ...
[13:37:33] [main/INFO]: Registering recipes: mekanism:jei_plugin took 418.3 ms
[13:37:33] [main/INFO]: Registering recipes: cofh_core:default ...
[13:37:33] [main/INFO]: Registering recipes: cofh_core:default took 13.20 ?s
[13:37:33] [main/INFO]: Registering recipes: industrialforegoing:default ...
[13:37:36] [main/INFO]: Registering recipes: industrialforegoing:default took 2.934 s
[13:37:36] [main/INFO]: Registering recipes: titanium:default ...
[13:37:36] [main/INFO]: Registering recipes: titanium:default took 12.30 ?s
[13:37:36] [main/INFO]: Registering recipes: lollipop:main ...
[13:37:36] [main/INFO]: Registering recipes: lollipop:main took 9.301 ?s
[13:37:36] [main/INFO]: Registering recipes: krate:main ...
[13:37:36] [main/INFO]: Registering recipes: krate:main took 531.0 ?s
[13:37:36] [main/INFO]: Registering recipes: create:jei_plugin ...
[13:37:50] [main/INFO]: Registering recipes: create:jei_plugin took 14.06 s
[13:37:50] [main/INFO]: Registering recipes: curios:curios ...
[13:37:50] [main/INFO]: Registering recipes: curios:curios took 16.80 ?s
[13:37:50] [main/INFO]: Registering recipes: securitycraft:securitycraft ...
[13:37:51] [main/INFO]: Registering recipes: securitycraft:securitycraft took 452.1 ms
[13:37:51] [main/INFO]: Registering recipes: fluxnetworks:jei ...
[13:37:51] [main/INFO]: Registering recipes: fluxnetworks:jei took 36.50 ?s
[13:37:51] [main/INFO]: Registering recipes: mekanismtools:jei_plugin ...
[13:37:52] [main/INFO]: Registering recipes: mekanismtools:jei_plugin took 1.340 s
[13:37:52] [main/INFO]: Registering recipes: constructionwand:constructionwand ...
[13:37:53] [main/INFO]: Registering recipes: constructionwand:constructionwand took 618.9 ms
[13:37:53] [main/INFO]: Registering recipes: ftblibrary:jei ...
[13:37:53] [main/INFO]: Registering recipes: ftblibrary:jei took 14.50 ?s
[13:37:53] [main/INFO]: Registering recipes: ftbquests:jei ...
[13:37:53] [main/INFO]: Registering recipes: ftbquests:jei took 11.90 ?s
[13:37:53] [main/INFO]: Registering recipes: trashcans:jei_plugin ...
[13:37:53] [main/INFO]: Registering recipes: trashcans:jei_plugin took 11.70 ?s
[13:37:53] [main/INFO]: Registering recipes: jei:internal ...
[13:37:53] [main/INFO]: Registering recipes: jei:internal took 12.50 ?s
[13:37:53] [main/INFO]: Registering recipes transfer handlers: jei:minecraft ...
[13:37:53] [main/INFO]: Registering recipes transfer handlers: jei:minecraft took 48.53 ms
[13:37:53] [main/INFO]: Registering recipes transfer handlers: cgm:crafting ...
[13:37:53] [main/INFO]: Registering recipes transfer handlers: cgm:crafting took 11.00 ?s
[13:37:53] [main/INFO]: Registering recipes transfer handlers: jei:debug ...
[13:37:53] [main/INFO]: Registering recipes transfer handlers: jei:debug took 9.300 ?s
[13:37:53] [main/INFO]: Registering recipes transfer handlers: cookingforblockheads:jei ...
[13:37:53] [main/INFO]: Registering recipes transfer handlers: cookingforblockheads:jei took 9.300 ?s
[13:37:53] [main/INFO]: Registering recipes transfer handlers: appliedenergistics2:core ...
[13:37:53] [main/INFO]: Registering recipes transfer handlers: appliedenergistics2:core took 243.9 ms
[13:37:53] [main/INFO]: Registering recipes transfer handlers: artifacts:main ...
[13:37:53] [main/INFO]: Registering recipes transfer handlers: artifacts:main took 11.30 ?s
[13:37:53] [main/INFO]: Registering recipes transfer handlers: compactmachines:main ...
[13:37:53] [main/INFO]: Registering recipes transfer handlers: compactmachines:main took 9.800 ?s
[13:37:53] [main/INFO]: Registering recipes transfer handlers: sophisticatedbackpacks:default ...
[13:37:53] [main/INFO]: Registering recipes transfer handlers: sophisticatedbackpacks:default took 42.50 ?s
[13:37:53] [main/INFO]: Registering recipes transfer handlers: darkutils:jei_support ...
[13:37:53] [main/INFO]: Registering recipes transfer handlers: darkutils:jei_support took 9.400 ?s
[13:37:53] [main/INFO]: Registering recipes transfer handlers: mekanismgenerators:jei_plugin ...
[13:37:53] [main/INFO]: Registering recipes transfer handlers: mekanismgenerators:jei_plugin took 9.500 ?s
[13:37:53] [main/INFO]: Registering recipes transfer handlers: mekanism:jei_plugin ...
[13:37:53] [main/INFO]: Registering recipes transfer handlers: mekanism:jei_plugin took 39.49 ms
[13:37:53] [main/INFO]: Registering recipes transfer handlers: cofh_core:default ...
[13:37:53] [main/INFO]: Registering recipes transfer handlers: cofh_core:default took 10.70 ?s
[13:37:53] [main/INFO]: Registering recipes transfer handlers: industrialforegoing:default ...
[13:37:53] [main/INFO]: Registering recipes transfer handlers: industrialforegoing:default took 9.099 ?s
[13:37:53] [main/INFO]: Registering recipes transfer handlers: titanium:default ...
[13:37:53] [main/INFO]: Registering recipes transfer handlers: titanium:default took 22.40 ?s
[13:37:53] [main/INFO]: Registering recipes transfer handlers: lollipop:main ...
[13:37:53] [main/INFO]: Registering recipes transfer handlers: lollipop:main took 9.700 ?s
[13:37:53] [main/INFO]: Registering recipes transfer handlers: krate:main ...
[13:37:53] [main/INFO]: Registering recipes transfer handlers: krate:main took 9.500 ?s
[13:37:53] [main/INFO]: Registering recipes transfer handlers: create:jei_plugin ...
[13:37:53] [main/INFO]: Registering recipes transfer handlers: create:jei_plugin took 73.80 ?s
[13:37:53] [main/INFO]: Registering recipes transfer handlers: curios:curios ...
[13:37:53] [main/INFO]: Registering recipes transfer handlers: curios:curios took 12.10 ?s
[13:37:53] [main/INFO]: Registering recipes transfer handlers: securitycraft:securitycraft ...
[13:37:53] [main/INFO]: Registering recipes transfer handlers: securitycraft:securitycraft took 9.400 ?s
[13:37:53] [main/INFO]: Registering recipes transfer handlers: fluxnetworks:jei ...
[13:37:53] [main/INFO]: Registering recipes transfer handlers: fluxnetworks:jei took 9.400 ?s
[13:37:53] [main/INFO]: Registering recipes transfer handlers: mekanismtools:jei_plugin ...
[13:37:53] [main/INFO]: Registering recipes transfer handlers: mekanismtools:jei_plugin took 9.301 ?s
[13:37:53] [main/INFO]: Registering recipes transfer handlers: constructionwand:constructionwand ...
[13:37:53] [main/INFO]: Registering recipes transfer handlers: constructionwand:constructionwand took 9.001 ?s
[13:37:53] [main/INFO]: Registering recipes transfer handlers: ftblibrary:jei ...
[13:37:53] [main/INFO]: Registering recipes transfer handlers: ftblibrary:jei took 48.00 ?s
[13:37:53] [main/INFO]: Registering recipes transfer handlers: ftbquests:jei ...
[13:37:53] [main/INFO]: Registering recipes transfer handlers: ftbquests:jei took 9.500 ?s
[13:37:53] [main/INFO]: Registering recipes transfer handlers: trashcans:jei_plugin ...
[13:37:53] [main/INFO]: Registering recipes transfer handlers: trashcans:jei_plugin took 9.300 ?s
[13:37:53] [main/INFO]: Registering recipes transfer handlers: jei:internal ...
[13:37:53] [main/INFO]: Registering recipes transfer handlers: jei:internal took 9.199 ?s
[13:37:54] [main/INFO]: Registering recipe catalysts: jei:minecraft ...
[13:37:54] [main/INFO]: Registering recipe catalysts: jei:minecraft took 90.50 ?s
[13:37:54] [main/INFO]: Registering recipe catalysts: cgm:crafting ...
[13:37:54] [main/INFO]: Registering recipe catalysts: cgm:crafting took 24.90 ?s
[13:37:54] [main/INFO]: Registering recipe catalysts: jei:debug ...
[13:37:54] [main/INFO]: Registering recipe catalysts: jei:debug took 19.70 ?s
[13:37:54] [main/INFO]: Registering recipe catalysts: cookingforblockheads:jei ...
[13:37:54] [main/INFO]: Registering recipe catalysts: cookingforblockheads:jei took 24.70 ?s
[13:37:54] [main/INFO]: Registering recipe catalysts: appliedenergistics2:core ...
[13:37:54] [main/INFO]: Registering recipe catalysts: appliedenergistics2:core took 80.80 ?s
[13:37:54] [main/INFO]: Registering recipe catalysts: artifacts:main ...
[13:37:54] [main/INFO]: Registering recipe catalysts: artifacts:main took 11.80 ?s
[13:37:54] [main/INFO]: Registering recipe catalysts: compactmachines:main ...
[13:37:54] [main/INFO]: Registering recipe catalysts: compactmachines:main took 11.60 ?s
[13:37:54] [main/INFO]: Registering recipe catalysts: sophisticatedbackpacks:default ...
[13:37:54] [main/INFO]: Registering recipe catalysts: sophisticatedbackpacks:default took 135.7 ms
[13:37:54] [main/INFO]: Registering recipe catalysts: darkutils:jei_support ...
[13:37:54] [main/INFO]: Registering recipe catalysts: darkutils:jei_support took 10.60 ?s
[13:37:54] [main/INFO]: Registering recipe catalysts: mekanismgenerators:jei_plugin ...
[13:37:54] [main/INFO]: Registering recipe catalysts: mekanismgenerators:jei_plugin took 35.90 ?s
[13:37:54] [main/INFO]: Registering recipe catalysts: mekanism:jei_plugin ...
[13:37:55] [main/INFO]: Registering recipe catalysts: mekanism:jei_plugin took 425.3 ms
[13:37:55] [main/INFO]: Registering recipe catalysts: cofh_core:default ...
[13:37:55] [main/INFO]: Registering recipe catalysts: cofh_core:default took 11.40 ?s
[13:37:55] [main/INFO]: Registering recipe catalysts: industrialforegoing:default ...
[13:37:55] [main/INFO]: Registering recipe catalysts: industrialforegoing:default took 28.38 ms
[13:37:55] [main/INFO]: Registering recipe catalysts: titanium:default ...
[13:37:55] [main/INFO]: Registering recipe catalysts: titanium:default took 10.70 ?s
[13:37:55] [main/INFO]: Registering recipe catalysts: lollipop:main ...
[13:37:55] [main/INFO]: Registering recipe catalysts: lollipop:main took 9.600 ?s
[13:37:55] [main/INFO]: Registering recipe catalysts: krate:main ...
[13:37:55] [main/INFO]: Registering recipe catalysts: krate:main took 9.300 ?s
[13:37:55] [main/INFO]: Registering recipe catalysts: create:jei_plugin ...
[13:37:56] [main/INFO]: Registering recipe catalysts: create:jei_plugin took 1.527 s
[13:37:56] [main/INFO]: Registering recipe catalysts: curios:curios ...
[13:37:56] [main/INFO]: Registering recipe catalysts: curios:curios took 11.60 ?s
[13:37:56] [main/INFO]: Registering recipe catalysts: securitycraft:securitycraft ...
[13:37:56] [main/INFO]: Registering recipe catalysts: securitycraft:securitycraft took 32.90 ?s
[13:37:56] [main/INFO]: Registering recipe catalysts: fluxnetworks:jei ...
[13:37:56] [main/INFO]: Registering recipe catalysts: fluxnetworks:jei took 30.10 ?s
[13:37:56] [main/INFO]: Registering recipe catalysts: mekanismtools:jei_plugin ...
[13:37:56] [main/INFO]: Registering recipe catalysts: mekanismtools:jei_plugin took 9.599 ?s
[13:37:56] [main/INFO]: Registering recipe catalysts: constructionwand:constructionwand ...
[13:37:56] [main/INFO]: Registering recipe catalysts: constructionwand:constructionwand took 9.200 ?s
[13:37:56] [main/INFO]: Registering recipe catalysts: ftblibrary:jei ...
[13:37:56] [main/INFO]: Registering recipe catalysts: ftblibrary:jei took 9.200 ?s
[13:37:56] [main/INFO]: Registering recipe catalysts: ftbquests:jei ...
[13:37:56] [main/INFO]: Registering recipe catalysts: ftbquests:jei took 9.700 ?s
[13:37:56] [main/INFO]: Registering recipe catalysts: trashcans:jei_plugin ...
[13:37:56] [main/INFO]: Registering recipe catalysts: trashcans:jei_plugin took 11.70 ?s
[13:37:56] [main/INFO]: Registering recipe catalysts: jei:internal ...
[13:37:56] [main/INFO]: Registering recipe catalysts: jei:internal took 9.301 ?s
[13:37:56] [main/INFO]: Registering gui handlers: jei:minecraft ...
[13:37:56] [main/INFO]: Registering gui handlers: jei:minecraft took 65.39 ms
[13:37:56] [main/INFO]: Registering gui handlers: cgm:crafting ...
[13:37:56] [main/INFO]: Registering gui handlers: cgm:crafting took 11.80 ?s
[13:37:56] [main/INFO]: Registering gui handlers: jei:debug ...
[13:37:56] [main/INFO]: Registering gui handlers: jei:debug took 20.20 ?s
[13:37:56] [main/INFO]: Registering gui handlers: cookingforblockheads:jei ...
[13:37:56] [main/INFO]: Registering gui handlers: cookingforblockheads:jei took 28.10 ?s
[13:37:56] [main/INFO]: Registering gui handlers: appliedenergistics2:core ...
[13:37:56] [main/INFO]: Registering gui handlers: appliedenergistics2:core took 95.70 ?s
[13:37:56] [main/INFO]: Registering gui handlers: artifacts:main ...
[13:37:56] [main/INFO]: Registering gui handlers: artifacts:main took 9.600 ?s
[13:37:56] [main/INFO]: Registering gui handlers: compactmachines:main ...
[13:37:56] [main/INFO]: Registering gui handlers: compactmachines:main took 9.500 ?s
[13:37:56] [main/INFO]: Registering gui handlers: sophisticatedbackpacks:default ...
[13:37:56] [main/INFO]: Registering gui handlers: sophisticatedbackpacks:default took 37.60 ?s
[13:37:56] [main/INFO]: Registering gui handlers: darkutils:jei_support ...
[13:37:56] [main/INFO]: Registering gui handlers: darkutils:jei_support took 13.40 ?s
[13:37:56] [main/INFO]: Registering gui handlers: mekanismgenerators:jei_plugin ...
[13:37:56] [main/INFO]: Registering gui handlers: mekanismgenerators:jei_plugin took 9.700 ?s
[13:37:56] [main/INFO]: Registering gui handlers: mekanism:jei_plugin ...
[13:37:56] [main/INFO]: Registering gui handlers: mekanism:jei_plugin took 61.90 ?s
[13:37:56] [main/INFO]: Registering gui handlers: cofh_core:default ...
[13:37:56] [main/INFO]: Registering gui handlers: cofh_core:default took 21.50 ?s
[13:37:56] [main/INFO]: Registering gui handlers: industrialforegoing:default ...
[13:37:56] [main/INFO]: Registering gui handlers: industrialforegoing:default took 24.40 ?s
[13:37:56] [main/INFO]: Registering gui handlers: titanium:default ...
[13:37:56] [main/INFO]: Registering gui handlers: titanium:default took 31.70 ?s
[13:37:56] [main/INFO]: Registering gui handlers: lollipop:main ...
[13:37:56] [main/INFO]: Registering gui handlers: lollipop:main took 22.50 ?s
[13:37:56] [main/INFO]: Registering gui handlers: krate:main ...
[13:37:56] [main/INFO]: Registering gui handlers: krate:main took 17.10 ?s
[13:37:56] [main/INFO]: Registering gui handlers: create:jei_plugin ...
[13:37:57] [main/INFO]: Registering gui handlers: create:jei_plugin took 198.0 ms
[13:37:57] [main/INFO]: Registering gui handlers: curios:curios ...
[13:37:57] [main/INFO]: Registering gui handlers: curios:curios took 57.80 ?s
[13:37:57] [main/INFO]: Registering gui handlers: securitycraft:securitycraft ...
[13:37:57] [main/INFO]: Registering gui handlers: securitycraft:securitycraft took 22.70 ?s
[13:37:57] [main/INFO]: Registering gui handlers: fluxnetworks:jei ...
[13:37:57] [main/INFO]: Registering gui handlers: fluxnetworks:jei took 10.50 ?s
[13:37:57] [main/INFO]: Registering gui handlers: mekanismtools:jei_plugin ...
[13:37:57] [main/INFO]: Registering gui handlers: mekanismtools:jei_plugin took 9.400 ?s
[13:37:57] [main/INFO]: Registering gui handlers: constructionwand:constructionwand ...
[13:37:57] [main/INFO]: Registering gui handlers: constructionwand:constructionwand took 9.300 ?s
[13:37:57] [main/INFO]: Registering gui handlers: ftblibrary:jei ...
[13:37:57] [main/INFO]: Registering gui handlers: ftblibrary:jei took 15.50 ?s
[13:37:57] [main/INFO]: Registering gui handlers: ftbquests:jei ...
[13:37:57] [main/INFO]: Registering gui handlers: ftbquests:jei took 9.600 ?s
[13:37:57] [main/INFO]: Registering gui handlers: trashcans:jei_plugin ...
[13:37:57] [main/INFO]: Registering gui handlers: trashcans:jei_plugin took 104.1 ?s
[13:37:57] [main/INFO]: Registering gui handlers: jei:internal ...
[13:37:57] [main/INFO]: Registering gui handlers: jei:internal took 158.9 ?s
[13:37:57] [main/INFO]: Registering advanced plugins: jei:minecraft ...
[13:37:57] [main/INFO]: Registering advanced plugins: jei:minecraft took 16.40 ?s
[13:37:57] [main/INFO]: Registering advanced plugins: cgm:crafting ...
[13:37:57] [main/INFO]: Registering advanced plugins: cgm:crafting took 9.900 ?s
[13:37:57] [main/INFO]: Registering advanced plugins: jei:debug ...
[13:37:57] [main/INFO]: Registering advanced plugins: jei:debug took 13.50 ?s
[13:37:57] [main/INFO]: Registering advanced plugins: cookingforblockheads:jei ...
[13:37:57] [main/INFO]: Registering advanced plugins: cookingforblockheads:jei took 9.400 ?s
[13:37:57] [main/INFO]: Registering advanced plugins: appliedenergistics2:core ...
[13:37:57] [main/INFO]: Added recipe manager plugin: class appeng.integration.modules.jei.FacadeRegistryPlugin
[13:37:57] [main/INFO]: Registering advanced plugins: appliedenergistics2:core took 320.3 ms
[13:37:57] [main/INFO]: Registering advanced plugins: artifacts:main ...
[13:37:57] [main/INFO]: Registering advanced plugins: artifacts:main took 12.50 ?s
[13:37:57] [main/INFO]: Registering advanced plugins: compactmachines:main ...
[13:37:57] [main/INFO]: Registering advanced plugins: compactmachines:main took 9.500 ?s
[13:37:57] [main/INFO]: Registering advanced plugins: sophisticatedbackpacks:default ...
[13:37:57] [main/INFO]: Registering advanced plugins: sophisticatedbackpacks:default took 9.400 ?s
[13:37:57] [main/INFO]: Registering advanced plugins: darkutils:jei_support ...
[13:37:57] [main/INFO]: Registering advanced plugins: darkutils:jei_support took 13.20 ?s
[13:37:57] [main/INFO]: Registering advanced plugins: mekanismgenerators:jei_plugin ...
[13:37:57] [main/INFO]: Registering advanced plugins: mekanismgenerators:jei_plugin took 9.600 ?s
[13:37:57] [main/INFO]: Registering advanced plugins: mekanism:jei_plugin ...
[13:37:57] [main/INFO]: Registering advanced plugins: mekanism:jei_plugin took 9.900 ?s
[13:37:57] [main/INFO]: Registering advanced plugins: cofh_core:default ...
[13:37:57] [main/INFO]: Registering advanced plugins: cofh_core:default took 9.300 ?s
[13:37:57] [main/INFO]: Registering advanced plugins: industrialforegoing:default ...
[13:37:57] [main/INFO]: Registering advanced plugins: industrialforegoing:default took 9.200 ?s
[13:37:57] [main/INFO]: Registering advanced plugins: titanium:default ...
[13:37:57] [main/INFO]: Registering advanced plugins: titanium:default took 12.50 ?s
[13:37:57] [main/INFO]: Registering advanced plugins: lollipop:main ...
[13:37:57] [main/INFO]: Registering advanced plugins: lollipop:main took 9.600 ?s
[13:37:57] [main/INFO]: Registering advanced plugins: krate:main ...
[13:37:57] [main/INFO]: Registering advanced plugins: krate:main took 9.100 ?s
[13:37:57] [main/INFO]: Registering advanced plugins: create:jei_plugin ...
[13:37:57] [main/INFO]: Registering advanced plugins: create:jei_plugin took 8.899 ?s
[13:37:57] [main/INFO]: Registering advanced plugins: curios:curios ...
[13:37:57] [main/INFO]: Registering advanced plugins: curios:curios took 20.90 ?s
[13:37:57] [main/INFO]: Registering advanced plugins: securitycraft:securitycraft ...
[13:37:57] [main/INFO]: Registering advanced plugins: securitycraft:securitycraft took 9.900 ?s
[13:37:57] [main/INFO]: Registering advanced plugins: fluxnetworks:jei ...
[13:37:57] [main/INFO]: Registering advanced plugins: fluxnetworks:jei took 9.600 ?s
[13:37:57] [main/INFO]: Registering advanced plugins: mekanismtools:jei_plugin ...
[13:37:57] [main/INFO]: Registering advanced plugins: mekanismtools:jei_plugin took 9.400 ?s
[13:37:57] [main/INFO]: Registering advanced plugins: constructionwand:constructionwand ...
[13:37:57] [main/INFO]: Registering advanced plugins: constructionwand:constructionwand took 9.300 ?s
[13:37:57] [main/INFO]: Registering advanced plugins: ftblibrary:jei ...
[13:37:57] [main/INFO]: Registering advanced plugins: ftblibrary:jei took 9.199 ?s
[13:37:57] [main/INFO]: Registering advanced plugins: ftbquests:jei ...
[13:37:57] [main/INFO]: Registering advanced plugins: ftbquests:jei took 10.00 ?s
[13:37:57] [main/INFO]: Registering advanced plugins: trashcans:jei_plugin ...
[13:37:57] [main/INFO]: Registering advanced plugins: trashcans:jei_plugin took 9.400 ?s
[13:37:57] [main/INFO]: Registering advanced plugins: jei:internal ...
[13:37:57] [main/INFO]: Registering advanced plugins: jei:internal took 9.200 ?s
[13:37:57] [main/INFO]: Building ingredient list...
[13:37:58] [main/INFO]: Building ingredient list took 152.4 ms
[13:37:58] [main/INFO]: Building ingredient filter...
[13:38:10] [Server thread/WARN]: Can't keep up! Is the server overloaded? Running 9735ms or 194 ticks behind
[13:38:21] [main/INFO]: Building ingredient filter took 23.89 s
[13:38:21] [main/INFO]: Building bookmarks...
[13:38:22] [main/INFO]: Building bookmarks took 179.0 ms
[13:38:22] [main/INFO]: Building recipe registry...
[13:58:51] [Server thread/WARN]: Can't keep up! Is the server overloaded? Running 1225495ms or 24509 ticks behind
[13:59:53] [main/INFO]: Building recipe registry took 21.51 min
[13:59:54] [main/INFO]: Building runtime...
[13:59:58] [main/INFO]: Building runtime took 3.864 s
[13:59:58] [main/INFO]: Sending Runtime: jei:minecraft ...
[13:59:58] [main/INFO]: Sending Runtime: jei:minecraft took 94.07 ms
[13:59:58] [main/INFO]: Sending Runtime: cgm:crafting ...
[13:59:58] [main/INFO]: Sending Runtime: cgm:crafting took 16.10 ?s
[13:59:59] [main/INFO]: Sending Runtime: jei:debug ...
[13:59:59] [main/INFO]: Sending Runtime: jei:debug took 280.1 ms
[13:59:59] [main/INFO]: Sending Runtime: cookingforblockheads:jei ...
[13:59:59] [main/INFO]: Sending Runtime: cookingforblockheads:jei took 16.20 ?s
[13:59:59] [main/INFO]: Sending Runtime: appliedenergistics2:core ...
[14:00:00] [main/INFO]: Ingredients are being removed at runtime: 10 net.minecraft.item.ItemStack
[14:00:04] [main/ERROR]: Could not find any matching ingredients to remove: 1 FluidDummyItem[dummy_fluid_item] appliedenergistics2:dummy_fluid_item
[14:00:04] [main/INFO]: Sending Runtime: appliedenergistics2:core took 4.770 s
[14:00:04] [main/INFO]: Sending Runtime: artifacts:main ...
[14:00:04] [main/INFO]: Sending Runtime: artifacts:main took 20.40 ?s
[14:00:04] [main/INFO]: Sending Runtime: compactmachines:main ...
[14:00:04] [main/INFO]: Sending Runtime: compactmachines:main took 9.700 ?s
[14:00:04] [main/INFO]: Sending Runtime: sophisticatedbackpacks:default ...
[14:00:04] [main/INFO]: Sending Runtime: sophisticatedbackpacks:default took 8.500 ?s
[14:00:04] [main/INFO]: Sending Runtime: darkutils:jei_support ...
[14:00:04] [main/INFO]: Sending Runtime: darkutils:jei_support took 8.500 ?s
[14:00:04] [main/INFO]: Sending Runtime: mekanismgenerators:jei_plugin ...
[14:00:04] [main/INFO]: Sending Runtime: mekanismgenerators:jei_plugin took 17.30 ?s
[14:00:04] [main/INFO]: Sending Runtime: mekanism:jei_plugin ...
[14:00:04] [main/INFO]: Sending Runtime: mekanism:jei_plugin took 9.300 ?s
[14:00:04] [main/INFO]: Sending Runtime: cofh_core:default ...
[14:00:04] [main/INFO]: Sending Runtime: cofh_core:default took 8.800 ?s
[14:00:04] [main/INFO]: Sending Runtime: industrialforegoing:default ...
[14:00:04] [main/INFO]: Sending Runtime: industrialforegoing:default took 14.60 ?s
[14:00:04] [main/INFO]: Sending Runtime: titanium:default ...
[14:00:04] [main/INFO]: Sending Runtime: titanium:default took 15.70 ?s
[14:00:04] [main/INFO]: Sending Runtime: lollipop:main ...
[14:00:04] [main/INFO]: Sending Runtime: lollipop:main took 9.700 ?s
[14:00:04] [main/INFO]: Sending Runtime: krate:main ...
[14:00:04] [main/INFO]: Sending Runtime: krate:main took 17.30 ?s
[14:00:04] [main/INFO]: Sending Runtime: create:jei_plugin ...
[14:00:04] [main/INFO]: Sending Runtime: create:jei_plugin took 11.00 ?s
[14:00:04] [main/INFO]: Sending Runtime: curios:curios ...
[14:00:04] [main/INFO]: Sending Runtime: curios:curios took 16.30 ?s
[14:00:04] [main/INFO]: Sending Runtime: securitycraft:securitycraft ...
[14:00:04] [main/INFO]: Sending Runtime: securitycraft:securitycraft took 19.60 ?s
[14:00:04] [main/INFO]: Sending Runtime: fluxnetworks:jei ...
[14:00:04] [main/INFO]: Sending Runtime: fluxnetworks:jei took 23.40 ?s
[14:00:05] [main/INFO]: Sending Runtime: mekanismtools:jei_plugin ...
[14:00:05] [main/INFO]: Sending Runtime: mekanismtools:jei_plugin took 16.80 ?s
[14:00:05] [main/INFO]: Sending Runtime: constructionwand:constructionwand ...
[14:00:05] [main/INFO]: Sending Runtime: constructionwand:constructionwand took 8.800 ?s
[14:00:05] [main/INFO]: Sending Runtime: ftblibrary:jei ...
[14:00:05] [main/INFO]: Sending Runtime: ftblibrary:jei took 14.70 ?s
[14:00:05] [main/INFO]: Sending Runtime: ftbquests:jei ...
[14:00:05] [main/INFO]: Sending Runtime: ftbquests:jei took 33.30 ?s
[14:00:05] [main/INFO]: Sending Runtime: trashcans:jei_plugin ...
[14:00:05] [main/INFO]: Sending Runtime: trashcans:jei_plugin took 9.600 ?s
[14:00:05] [main/INFO]: Sending Runtime: jei:internal ...
[14:00:05] [main/INFO]: Sending Runtime: jei:internal took 19.10 ?s
[14:00:15] [main/INFO]: Starting JEI took 23.09 min
[14:00:40] [Server thread/WARN]: Can't keep up! Is the server overloaded? Running 2947ms or 58 ticks behind
[14:01:10] [main/INFO]: No shader config found.
[14:01:36] [main/INFO]: [FANCYMENU] Updating animation sizes..
[14:02:15] [Server thread/WARN]: Can't keep up! Is the server overloaded? Running 37497ms or 749 ticks behind
[14:02:38] [Server thread/WARN]: Can't keep up! Is the server overloaded? Running 3370ms or 67 ticks behind
[14:18:01] [Server thread/WARN]: Can't keep up! Is the server overloaded? Running 2099ms or 41 ticks behind
[15:40:56] [Server thread/WARN]: Can't keep up! Is the server overloaded? Running 7380ms or 147 ticks behind
[15:41:04] [main/WARN]: TileDrawStep.updateRegionTexture was slow: 91.5836 (Warning limit reached)
[15:41:05] [main/WARN]: TileDrawStep.updateRegionTexture: Avg:     0,05ms, Min:        0ms, Max:    1007,88ms, Total:          3 sec, Count:    77457, Canceled:        0, Slow:       10
[15:41:17] [Server thread/WARN]: Can't keep up! Is the server overloaded? Running 6021ms or 120 ticks behind
[15:41:54] [main/INFO]: [CHAT] [Mekanismo] Modo Vlvula alterado para: Sada de Resduos
[15:41:57] [main/INFO]: [CHAT] [Mekanismo] Modo Vlvula alterado para: Sada de Resfriamento
[15:41:59] [main/INFO]: [CHAT] [Mekanismo] Modo Vlvula alterado para: entrada apenas
[15:42:04] [main/INFO]: [CHAT] [Mekanismo] Modo Vlvula alterado para: Sada de Resduos
[15:42:07] [main/INFO]: [CHAT] [Mekanismo] Modo Vlvula alterado para: Sada de Resduos
[15:42:08] [main/INFO]: [CHAT] [Mekanismo] Modo Vlvula alterado para: Sada de Resfriamento
[15:42:09] [main/INFO]: [CHAT] [Mekanismo] Modo Vlvula alterado para: entrada apenas
[15:42:25] [Server thread/WARN]: Can't keep up! Is the server overloaded? Running 15149ms or 302 ticks behind
[15:42:25] [main/INFO]: [CHAT] [Mekanismo] Modo Vlvula alterado para: Sada de Resduos
[15:42:25] [main/INFO]: [CHAT] [Mekanismo] Modo Vlvula alterado para: Sada de Resfriamento
[15:42:25] [main/INFO]: [CHAT] [Mekanismo] Modo Vlvula alterado para: entrada apenas
[15:42:25] [main/INFO]: [CHAT] [Mekanismo] Modo Vlvula alterado para: Sada de Resduos
[15:42:25] [main/INFO]: [CHAT] [Mekanismo] Modo Vlvula alterado para: Sada de Resfriamento
[15:42:25] [main/INFO]: [CHAT] [Mekanismo] Modo Vlvula alterado para: Sada de Resfriamento
[15:42:29] [main/INFO]: [CHAT] [Mekanismo] Modo Vlvula alterado para: entrada apenas
[15:42:31] [main/INFO]: [CHAT] [Mekanismo] Modo Vlvula alterado para: Sada de Resduos
[15:43:01] [Server thread/INFO]: [kaues: kaues recebeu 1 [Caixa de shulker]]
[15:43:01] [main/INFO]: [CHAT] kaues recebeu 1 [Caixa de shulker]
[15:43:53] [Server thread/INFO]: [kaues: kaues recebeu 64 [Bloco de Evaporo Trmica]]
[15:43:53] [main/INFO]: [CHAT] kaues recebeu 64 [Bloco de Evaporo Trmica]
[15:43:56] [Server thread/INFO]: [kaues: kaues recebeu 64 [Bloco de Evaporo Trmica]]
[15:43:56] [main/INFO]: [CHAT] kaues recebeu 64 [Bloco de Evaporo Trmica]
[15:44:01] [Server thread/INFO]: [kaues: kaues recebeu 1 [Valve de Evaporao Trmica]]
[15:44:01] [main/INFO]: [CHAT] kaues recebeu 1 [Valve de Evaporao Trmica]
[15:44:01] [Server thread/INFO]: [kaues: kaues recebeu 1 [Valve de Evaporao Trmica]]
[15:44:01] [main/INFO]: [CHAT] kaues recebeu 1 [Valve de Evaporao Trmica]
[15:44:04] [Server thread/INFO]: [kaues: kaues recebeu 1 [Controlador de Evaporo Trmica]]
[15:44:04] [main/INFO]: [CHAT] kaues recebeu 1 [Controlador de Evaporo Trmica]
[15:44:08] [Server thread/INFO]: [kaues: kaues recebeu 1 [Valve de Evaporao Trmica]]
[15:44:08] [main/INFO]: [CHAT] kaues recebeu 1 [Valve de Evaporao Trmica]
[15:44:08] [Server thread/INFO]: [kaues: kaues recebeu 1 [Valve de Evaporao Trmica]]
[15:44:09] [main/INFO]: [CHAT] kaues recebeu 1 [Valve de Evaporao Trmica]
[15:44:22] [Server thread/INFO]: [kaues: kaues recebeu 64 [Tubo Mecnico Ultimate]]
[15:44:22] [main/INFO]: [CHAT] kaues recebeu 64 [Tubo Mecnico Ultimate]
[15:44:33] [Server thread/INFO]: [kaues: kaues recebeu 1 [Sink]]
[15:44:33] [main/INFO]: [CHAT] kaues recebeu 1 [Sink]
[15:44:41] [Server thread/INFO]: [kaues: kaues recebeu 1 [Configurador]]
[15:44:41] [main/INFO]: [CHAT] kaues recebeu 1 [Configurador]
[15:46:52] [Server thread/INFO]: [kaues: kaues recebeu 1 [Bloco de Evaporo Trmica]]
[15:46:52] [main/INFO]: [CHAT] kaues recebeu 1 [Bloco de Evaporo Trmica]
[15:46:52] [Server thread/INFO]: [kaues: kaues recebeu 1 [Bloco de Evaporo Trmica]]
[15:46:52] [main/INFO]: [CHAT] kaues recebeu 1 [Bloco de Evaporo Trmica]
[15:46:52] [Server thread/INFO]: [kaues: kaues recebeu 1 [Bloco de Evaporo Trmica]]
[15:46:53] [main/INFO]: [CHAT] kaues recebeu 1 [Bloco de Evaporo Trmica]
[15:47:37] [Server thread/INFO]: [kaues: O modo de jogo foi definido para Modo Criativo]
[15:47:37] [main/INFO]: [CHAT] O modo de jogo foi definido para Modo Criativo
[15:48:39] [Server thread/INFO]: [kaues: O modo de jogo foi definido para Modo Sobrevivncia]
[15:48:39] [main/INFO]: [CHAT] O modo de jogo foi definido para Modo Sobrevivncia
[15:49:16] [main/INFO]: [CHAT] Tipo de conexo alterada para: Pressione
[15:49:16] [main/INFO]: [CHAT] Tipo de conexo alterada para: Puxar
[15:50:12] [main/WARN]: Recipe registry plugin is slow, took 28.97 ms. class mezz.jei.recipes.InternalRecipeManagerPlugin
[15:51:13] [Server thread/INFO]: [kaues: kaues recebeu 1 [Calor Resistivo]]
[15:51:13] [main/INFO]: [CHAT] kaues recebeu 1 [Calor Resistivo]
[15:51:16] [Server thread/INFO]: [kaues: kaues recebeu 1 [Cubo de Energia Criativo]]
[15:51:16] [main/INFO]: [CHAT] kaues recebeu 1 [Cubo de Energia Criativo]
[15:51:28] [Server thread/INFO]: [kaues: kaues recebeu 64 [Condutor Termodinmica Ultimate]]
[15:51:28] [main/INFO]: [CHAT] kaues recebeu 64 [Condutor Termodinmica Ultimate]
[15:53:18] [Server thread/INFO]: [kaues: kaues recebeu 1 [Valve de Evaporao Trmica]]
[15:53:18] [main/INFO]: [CHAT] kaues recebeu 1 [Valve de Evaporao Trmica]
[15:53:25] [Server thread/INFO]: [kaues: kaues recebeu 1 [Calor Resistivo]]
[15:53:25] [main/INFO]: [CHAT] kaues recebeu 1 [Calor Resistivo]
[15:53:33] [Server thread/INFO]: [kaues: kaues recebeu 1 [Calor Resistivo]]
[15:53:33] [main/INFO]: [CHAT] kaues recebeu 1 [Calor Resistivo]
[15:53:36] [Server thread/INFO]: [kaues: kaues recebeu 1 [Calor Resistivo]]
[15:53:36] [main/INFO]: [CHAT] kaues recebeu 1 [Calor Resistivo]
[15:53:48] [Server thread/INFO]: [kaues: O modo de jogo foi definido para Modo Criativo]
[15:53:48] [main/INFO]: [CHAT] O modo de jogo foi definido para Modo Criativo
[15:53:54] [Server thread/INFO]: [kaues: O modo de jogo foi definido para Modo Sobrevivncia]
[15:53:54] [main/INFO]: [CHAT] O modo de jogo foi definido para Modo Sobrevivncia
[15:56:05] [Server thread/INFO]: [kaues: kaues recebeu 1 [Balde de Sdio Lquido]]
[15:56:05] [main/INFO]: [CHAT] kaues recebeu 1 [Balde de Sdio Lquido]
[15:56:47] [Server thread/INFO]: [kaues: kaues recebeu 1 [Separador Eletroltico]]
[15:56:47] [main/INFO]: [CHAT] kaues recebeu 1 [Separador Eletroltico]
[15:57:38] [main/INFO]: [CHAT] Tipo de conexo alterada para: Pressione
[15:57:38] [main/INFO]: [CHAT] Tipo de conexo alterada para: Puxar
[15:58:24] [Server thread/INFO]: [kaues: kaues recebeu 64 [Cabo Universal Ultimate]]
[15:58:24] [main/INFO]: [CHAT] kaues recebeu 64 [Cabo Universal Ultimate]
[15:58:33] [Server thread/INFO]: [kaues: O modo de jogo foi definido para Modo Criativo]
[15:58:33] [main/INFO]: [CHAT] O modo de jogo foi definido para Modo Criativo
[15:58:35] [Server thread/INFO]: [kaues: O modo de jogo foi definido para Modo Sobrevivncia]
[15:58:35] [main/INFO]: [CHAT] O modo de jogo foi definido para Modo Sobrevivncia
[15:59:37] [Server thread/INFO]: [kaues: kaues recebeu 1 [Tubo Ultimate Pressurizado]]
[15:59:37] [main/INFO]: [CHAT] kaues recebeu 1 [Tubo Ultimate Pressurizado]
[15:59:38] [Server thread/INFO]: [kaues: kaues recebeu 63 [Tubo Ultimate Pressurizado]]
[15:59:38] [main/INFO]: [CHAT] kaues recebeu 63 [Tubo Ultimate Pressurizado]
[16:01:24] [Server thread/INFO]: [kaues: O modo de jogo foi definido para Modo Criativo]
[16:01:24] [main/INFO]: [CHAT] O modo de jogo foi definido para Modo Criativo
[16:01:36] [Server thread/INFO]: [kaues: O modo de jogo foi definido para Modo Sobrevivncia]
[16:01:37] [main/INFO]: [CHAT] O modo de jogo foi definido para Modo Sobrevivncia
[16:01:52] [Server thread/INFO]: [kaues: kaues recebeu 8 [Melhoria de Velocidade]]
[16:01:52] [main/INFO]: [CHAT] kaues recebeu 8 [Melhoria de Velocidade]
[16:01:54] [Server thread/INFO]: [kaues: kaues recebeu 8 [Melhoria de Energia]]
[16:01:55] [main/INFO]: [CHAT] kaues recebeu 8 [Melhoria de Energia]
[16:01:57] [Server thread/INFO]: [kaues: kaues recebeu 4 [Melhoria de Ampliao]]
[16:01:57] [main/INFO]: [CHAT] kaues recebeu 4 [Melhoria de Ampliao]
[16:02:37] [Server thread/INFO]: [kaues: O modo de jogo foi definido para Modo Criativo]
[16:02:37] [main/INFO]: [CHAT] O modo de jogo foi definido para Modo Criativo
[16:04:28] [Server thread/INFO]: [kaues: O modo de jogo foi definido para Modo Sobrevivncia]
[16:04:28] [main/INFO]: [CHAT] O modo de jogo foi definido para Modo Sobrevivncia
[16:04:30] [main/INFO]: [CHAT] Tipo de conexo alterada para: Pressione
[16:04:31] [main/INFO]: [CHAT] Tipo de conexo alterada para: Puxar
[16:04:32] [main/INFO]: [CHAT] Tipo de conexo alterada para: Pressione
[16:05:14] [Server thread/INFO]: [kaues: O modo de jogo foi definido para Modo Criativo]
[16:05:14] [main/INFO]: [CHAT] O modo de jogo foi definido para Modo Criativo
[16:05:58] [Server thread/INFO]: Saving and pausing game...
[16:05:58] [Server thread/INFO]: Saving chunks for level 'ServerLevel[Novo mundo]'/minecraft:overworld
[16:05:58] [Server thread/INFO]: Saving chunks for level 'ServerLevel[Novo mundo]'/minecraft:the_nether
[16:05:58] [Server thread/INFO]: Saving chunks for level 'ServerLevel[Novo mundo]'/minecraft:the_end
[16:05:58] [Server thread/INFO]: Saving chunks for level 'ServerLevel[Novo mundo]'/compactmachines:compact_world
[16:05:58] [Server thread/INFO]: Saving chunks for level 'ServerLevel[Novo mundo]'/allthemodium:mining
[16:05:58] [Server thread/INFO]: Saving chunks for level 'ServerLevel[Novo mundo]'/mining_dimension:mining
[16:05:58] [Server thread/INFO]: Saving chunks for level 'ServerLevel[Novo mundo]'/mahoutsukai:reality_marble
[16:05:58] [Server thread/INFO]: Saving chunks for level 'ServerLevel[Novo mundo]'/allthemodium:the_other
[16:06:29] [Server thread/INFO]: [kaues: O modo de jogo foi definido para Modo Sobrevivncia]
[16:06:30] [main/INFO]: [CHAT] O modo de jogo foi definido para Modo Sobrevivncia
[16:07:12] [Server thread/INFO]: Saving and pausing game...
[16:07:12] [Server thread/INFO]: Saving chunks for level 'ServerLevel[Novo mundo]'/minecraft:overworld
[16:07:13] [Server thread/INFO]: Saving chunks for level 'ServerLevel[Novo mundo]'/minecraft:the_nether
[16:07:13] [Server thread/INFO]: Saving chunks for level 'ServerLevel[Novo mundo]'/minecraft:the_end
[16:07:13] [Server thread/INFO]: Saving chunks for level 'ServerLevel[Novo mundo]'/compactmachines:compact_world
[16:07:13] [Server thread/INFO]: Saving chunks for level 'ServerLevel[Novo mundo]'/allthemodium:mining
[16:07:13] [Server thread/INFO]: Saving chunks for level 'ServerLevel[Novo mundo]'/mining_dimension:mining
[16:07:13] [Server thread/INFO]: Saving chunks for level 'ServerLevel[Novo mundo]'/mahoutsukai:reality_marble
[16:07:13] [Server thread/INFO]: Saving chunks for level 'ServerLevel[Novo mundo]'/allthemodium:the_other
[16:55:10] [Server thread/INFO]: [kaues: kaues recebeu 64 [Bloco de Evaporo Trmica]]
[16:55:10] [main/INFO]: [CHAT] kaues recebeu 64 [Bloco de Evaporo Trmica]
[16:55:24] [Server thread/INFO]: [kaues: O modo de jogo foi definido para Modo Criativo]
[16:55:24] [main/INFO]: [CHAT] O modo de jogo foi definido para Modo Criativo
[16:56:00] [main/INFO]: [CHAT] Tipo de conexo alterada para: Pressione
[16:56:00] [main/INFO]: [CHAT] Tipo de conexo alterada para: Puxar
[16:56:29] [main/INFO]: Update tile packet received for position: BlockPos{x=6, y=50, z=-1021} in world: compactmachines:compact_world, but no valid tile was found.
[16:57:43] [main/INFO]: Update tile packet received for position: BlockPos{x=7, y=46, z=-1017} in world: compactmachines:compact_world, but no valid tile was found.
[16:58:42] [main/INFO]: [CHAT] Tipo de conexo alterada para: Pressione
[16:58:43] [main/INFO]: [CHAT] Tipo de conexo alterada para: Puxar
[16:59:04] [Server thread/WARN]: Can't keep up! Is the server overloaded? Running 2024ms or 40 ticks behind
[17:02:38] [Server thread/WARN]: Can't keep up! Is the server overloaded? Running 60396ms or 1207 ticks behind
[17:03:10] [main/INFO]: [CHAT] Tipo de conexo alterada para: Pressione
[17:03:12] [main/INFO]: [CHAT] Tipo de conexo alterada para: Puxar
[17:03:15] [main/INFO]: [CHAT] Tipo de conexo alterada para: Pressione
[17:04:52] [Server thread/WARN]: Can't keep up! Is the server overloaded? Running 52386ms or 1047 ticks behind
[17:05:58] [Server thread/WARN]: Can't keep up! Is the server overloaded? Running 2248ms or 44 ticks behind
[17:06:55] [Server thread/WARN]: Can't keep up! Is the server overloaded? Running 2417ms or 48 ticks behind
[17:09:32] [Server thread/WARN]: Can't keep up! Is the server overloaded? Running 131178ms or 2623 ticks behind
[17:10:30] [main/INFO]: Update tile packet received for position: BlockPos{x=5, y=42, z=-1028} in world: compactmachines:compact_world, but no valid tile was found.
[17:11:24] [main/INFO]: [CHAT] Tipo de conexo alterada para: Pressione
[17:11:24] [main/INFO]: [CHAT] Tipo de conexo alterada para: Puxar
[17:12:17] [Server thread/WARN]: Can't keep up! Is the server overloaded? Running 8614ms or 172 ticks behind
[17:12:26] [main/WARN]: MiniMap1.Circle was slow: 1360.812 (Warning limit reached)
[17:12:27] [main/WARN]: MiniMap1.Circle: Avg:     2,82ms, Min:     1,44ms, Max:    3972,81ms, Total:        161 sec, Count:    57387, Canceled:        0, Slow:       10
[17:14:30] [main/INFO]: [CHAT] Tipo de conexo alterada para: Pressione
[17:14:30] [main/INFO]: [CHAT] Tipo de conexo alterada para: Puxar
[17:22:25] [main/INFO]: [CHAT] Tipo de conexo alterada para: Pressione
[17:22:27] [main/INFO]: [CHAT] Tipo de conexo alterada para: Puxar
[17:22:56] [main/INFO]: [CHAT] Tipo de conexo alterada para: Nenhuma
[17:22:59] [main/INFO]: [CHAT] Tipo de conexo alterada para: Pressione
[17:22:59] [main/INFO]: [CHAT] Tipo de conexo alterada para: Puxar
[17:23:02] [main/INFO]: [CHAT] Tipo de conexo alterada para: Nenhuma
[17:23:02] [main/INFO]: [CHAT] Tipo de conexo alterada para: normal
[17:23:11] [main/INFO]: [CHAT] Tipo de conexo alterada para: normal
[17:23:18] [main/INFO]: [CHAT] Tipo de conexo alterada para: Pressione
[17:23:49] [main/INFO]: [CHAT] Tipo de conexo alterada para: Pressione
[17:23:49] [main/INFO]: [CHAT] Tipo de conexo alterada para: Puxar
[17:24:00] [main/INFO]: [CHAT] [Mekanismo] No foi possvel descobrir qualquer vibrao
[17:26:20] [main/INFO]: [CHAT] Tipo de conexo alterada para: Pressione
[17:26:21] [main/INFO]: [CHAT] Tipo de conexo alterada para: Puxar
[17:38:55] [main/WARN]: Recipe registry plugin is slow, took 12.39 ms. class mezz.jei.recipes.InternalRecipeManagerPlugin
[17:38:55] [main/WARN]: Recipe registry plugin is slow, took 41.21 ms. class mezz.jei.recipes.InternalRecipeManagerPlugin
[17:50:06] [Server thread/WARN]: Can't keep up! Is the server overloaded? Running 118045ms or 2360 ticks behind
[17:50:15] [Server thread/INFO]: Saving and pausing game...
[17:50:18] [Server thread/INFO]: Saving chunks for level 'ServerLevel[Novo mundo]'/minecraft:overworld
[17:50:19] [Server thread/INFO]: Saving chunks for level 'ServerLevel[Novo mundo]'/minecraft:the_nether
[17:50:19] [Server thread/INFO]: Saving chunks for level 'ServerLevel[Novo mundo]'/minecraft:the_end
[17:50:19] [Server thread/INFO]: Saving chunks for level 'ServerLevel[Novo mundo]'/compactmachines:compact_world
[17:50:19] [Server thread/INFO]: Saving chunks for level 'ServerLevel[Novo mundo]'/allthemodium:mining
[17:50:19] [Server thread/INFO]: Saving chunks for level 'ServerLevel[Novo mundo]'/mining_dimension:mining
[17:50:19] [Server thread/INFO]: Saving chunks for level 'ServerLevel[Novo mundo]'/mahoutsukai:reality_marble
[17:50:19] [Server thread/INFO]: Saving chunks for level 'ServerLevel[Novo mundo]'/allthemodium:the_other
[17:52:00] [main/INFO]: Stopping!
[17:52:04] [Server thread/INFO]: kaues lost connection: Desconectado
[17:52:04] [main/INFO]: Mapping halted in C:\Users\kaues\AppData\Roaming\.minecraft\versions\Ender Tech\journeymap\data\mp\offline\compactmachines:compact_world
[17:52:04] [Server thread/INFO]: kaues saiu do jogo
[17:52:06] [Server thread/INFO]: Stopping singleplayer server as player logged out
[17:52:08] [Server thread/INFO]: Stopping server
[17:52:11] [Server thread/INFO]: Saving players
[17:52:11] [Server thread/INFO]: Saving worlds
[17:52:11] [Server thread/INFO]: Saving chunks for level 'ServerLevel[Novo mundo]'/minecraft:overworld
[17:52:14] [Server thread/INFO]: ThreadedAnvilChunkStorage (Novo mundo (2)): All chunks are saved
[17:52:14] [Server thread/INFO]: Saving chunks for level 'ServerLevel[Novo mundo]'/minecraft:the_nether
[17:52:14] [Server thread/INFO]: ThreadedAnvilChunkStorage (DIM-1): All chunks are saved
[17:52:14] [Server thread/INFO]: Saving chunks for level 'ServerLevel[Novo mundo]'/minecraft:the_end
[17:52:14] [Server thread/INFO]: ThreadedAnvilChunkStorage (DIM1): All chunks are saved
[17:52:14] [Server thread/INFO]: Saving chunks for level 'ServerLevel[Novo mundo]'/compactmachines:compact_world
[17:52:15] [Server thread/INFO]: ThreadedAnvilChunkStorage (compact_world): All chunks are saved
[17:52:15] [Server thread/INFO]: Saving chunks for level 'ServerLevel[Novo mundo]'/allthemodium:mining
[17:52:15] [Server thread/INFO]: ThreadedAnvilChunkStorage (mining): All chunks are saved
[17:52:15] [Server thread/INFO]: Saving chunks for level 'ServerLevel[Novo mundo]'/mining_dimension:mining
[17:52:15] [Server thread/INFO]: ThreadedAnvilChunkStorage (mining): All chunks are saved
[17:52:15] [Server thread/INFO]: Saving chunks for level 'ServerLevel[Novo mundo]'/mahoutsukai:reality_marble
[17:52:15] [Server thread/INFO]: ThreadedAnvilChunkStorage (reality_marble): All chunks are saved
[17:52:15] [Server thread/INFO]: Saving chunks for level 'ServerLevel[Novo mundo]'/allthemodium:the_other
[17:52:15] [Server thread/INFO]: ThreadedAnvilChunkStorage (the_other): All chunks are saved
[17:52:18] [Server thread/INFO]: ThreadedAnvilChunkStorage (Novo mundo (2)): All chunks are saved
