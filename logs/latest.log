[13:58:45] [main/INFO]: ModLauncher running: args [--username, kaues, --version, Ender Tech, --gameDir, C:\Users\kaues\AppData\Roaming\.minecraft\versions\Ender Tech, --assetsDir, C:\Users\kaues\AppData\Roaming\.minecraft\assets, --assetIndex, 1.16, --uuid, cb2a9bf2973042ff957579d48c089416, --accessToken, ????????, --userType, mojang, --versionType, release, --width, 925, --height, 530, --launchTarget, fmlclient, --fml.forgeVersion, 36.2.33, --fml.mcVersion, 1.16.5, --fml.forgeGroup, net.minecraftforge, --fml.mcpVersion, 20210115.111550]
[13:58:45] [main/INFO]: ModLauncher 8.1.3+8.1.3+main-8.1.x.c94d18ec starting: java version 1.8.0_51 by Oracle Corporation
[13:58:45] [main/WARN]: LEGACY JDK DETECTED, SECURED JAR HANDLING DISABLED
[13:58:46] [main/INFO]: OptiFineTransformationService.onLoad
[13:58:46] [main/INFO]: OptiFine ZIP file: C:\Users\kaues\AppData\Roaming\.minecraft\versions\Ender Tech\mods\OptiFine-1.16.5_HD_U_G8_pre2.jar
[13:58:46] [main/INFO]: Target.PRE_CLASS is available
[13:58:46] [main/INFO]: Added Lets Encrypt root certificates as additional trust
[13:58:47] [main/INFO]: SpongePowered MIXIN Subsystem Version=0.8.4 Source=file:/C:/Users/kaues/AppData/Roaming/.minecraft/libraries/org/spongepowered/mixin/0.8.4/mixin-0.8.4.jar Service=ModLauncher Env=CLIENT
[13:58:47] [main/INFO]: OptiFineTransformationService.initialize
[13:58:52] [main/INFO]: OptiFineTransformationService.transformers
[13:58:52] [main/INFO]: Targets: 308
[13:58:54] [main/INFO]: additionalClassesLocator: [optifine., net.optifine.]
[13:58:56] [main/INFO]: Successfully loaded Mixin Connector [de.maxhenkel.miningdimension.mixin.MixinConnector]
[13:58:56] [main/INFO]: Launching target 'fmlclient' with arguments [--version, Ender Tech, --gameDir, C:\Users\kaues\AppData\Roaming\.minecraft\versions\Ender Tech, --assetsDir, C:\Users\kaues\AppData\Roaming\.minecraft\assets, --uuid, cb2a9bf2973042ff957579d48c089416, --username, kaues, --assetIndex, 1.16, --accessToken, ????????, --userType, mojang, --versionType, release, --width, 925, --height, 530]
[13:58:59] [main/INFO]: [FANCYMENU] APPLYING MIXIN: de.keksuccino.fancymenu.mixin.client.MixinWidget | TO TARGET: net.minecraft.client.gui.widget.Widget
[13:58:59] [main/INFO]: [FANCYMENU] APPLYING MIXIN: de.keksuccino.fancymenu.mixin.client.MixinImageButton | TO TARGET: net.minecraft.client.gui.widget.button.ImageButton
[13:58:59] [main/INFO]: [FANCYMENU] APPLYING MIXIN: de.keksuccino.fancymenu.mixin.client.MixinAbstractList | TO TARGET: net.minecraft.client.gui.widget.list.AbstractList
[13:58:59] [main/INFO]: [FANCYMENU] APPLYING MIXIN: de.keksuccino.fancymenu.mixin.client.MixinScreen | TO TARGET: net.minecraft.client.gui.screen.Screen
[13:58:59] [main/INFO]: [FANCYMENU] APPLYING MIXIN: de.keksuccino.fancymenu.mixin.client.MixinMinecraft | TO TARGET: net.minecraft.client.Minecraft
[13:58:59] [main/INFO]: [FANCYMENU] APPLYING MIXIN: de.keksuccino.fancymenu.mixin.client.MixinResourceLoadProgressGui | TO TARGET: net.minecraft.client.gui.ResourceLoadProgressGui
[13:58:59] [main/INFO]: [FANCYMENU] APPLYING MIXIN: de.keksuccino.fancymenu.mixin.client.MixinAbstractGui | TO TARGET: net.minecraft.client.gui.AbstractGui
[13:58:59] [main/INFO]: [FANCYMENU] APPLYING MIXIN: de.keksuccino.fancymenu.mixin.client.MixinOnlineServerEntry | TO TARGET: net.minecraft.client.gui.screen.ServerSelectionList$NormalEntry
[13:58:59] [main/INFO]: [FANCYMENU] APPLYING MIXIN: de.keksuccino.fancymenu.mixin.client.MixinWorldListEntry | TO TARGET: net.minecraft.client.gui.screen.WorldSelectionList$Entry
[13:59:30] [main/INFO]: Environment: authHost='https://authserver.mojang.com', accountsHost='https://api.mojang.com', sessionHost='https://sessionserver.mojang.com', servicesHost='https://api.minecraftservices.com', name='PROD'
[13:59:30] [main/INFO]: Setting user: kaues
[13:59:30] [main/INFO]: [OptiFine] (Reflector) Class not present: net.minecraft.launchwrapper.Launch
[13:59:31] [main/INFO]: Backend library: LWJGL version 3.2.2 build 10
[13:59:31] [main/INFO]: [OptiFine] 
[13:59:31] [main/INFO]: [OptiFine] OptiFine_1.16.5_HD_U_G8_pre2
[13:59:31] [main/INFO]: [OptiFine] Build: 20210305-002749
[13:59:31] [main/INFO]: [OptiFine] OS: Windows 10 (amd64) version 10.0
[13:59:31] [main/INFO]: [OptiFine] Java: 1.8.0_51, Oracle Corporation
[13:59:31] [main/INFO]: [OptiFine] VM: Java HotSpot(TM) 64-Bit Server VM (mixed mode), Oracle Corporation
[13:59:31] [main/INFO]: [OptiFine] LWJGL: 3.3.0 Win32 WGL EGL OSMesa VisualC DLL
[13:59:31] [main/INFO]: [OptiFine] OpenGL: Intel(R) HD Graphics, version 2.1.0 - Build 8.15.10.2900, Intel
[13:59:31] [main/INFO]: [OptiFine] OpenGL Version: 2.1.0
[13:59:31] [main/INFO]: [OptiFine] OpenGL Fancy fog: Not available (GL_NV_fog_distance)
[13:59:31] [main/INFO]: [OptiFine] Maximum texture size: 8192x8192
[13:59:32] [main/INFO]: [Shaders] OpenGL Version: 2.1.0 - Build 8.15.10.2900
[13:59:32] [main/INFO]: [Shaders] Vendor:  Intel
[13:59:32] [main/INFO]: [Shaders] Renderer: Intel(R) HD Graphics
[13:59:32] [main/INFO]: [Shaders] Capabilities:  2.0  2.1  -  -  - 
[13:59:32] [main/INFO]: [Shaders] GL_MAX_DRAW_BUFFERS: 8
[13:59:32] [main/INFO]: [Shaders] GL_MAX_COLOR_ATTACHMENTS_EXT: 8
[13:59:32] [main/INFO]: [Shaders] GL_MAX_TEXTURE_IMAGE_UNITS: 16
[13:59:32] [main/INFO]: [Shaders] Load shaders configuration.
[13:59:32] [main/INFO]: [Shaders] Save shaders configuration.
[13:59:32] [main/INFO]: [Shaders] No shaderpack loaded.
[13:59:32] [VersionCheck/INFO]: [OptiFine] Checking for new version
[13:59:32] [main/INFO]: [OptiFine] (Reflector) Class not present: net.minecraftforge.fml.common.Loader
[13:59:33] [VersionCheck/INFO]: [OptiFine] Version found: G7
[13:59:34] [main/INFO]: Potentially Dangerous alternative prefix `mining_dimension` for name `teleporter`, expected `minecraft`. This could be a intended override, but in most cases indicates a broken mod.
[13:59:36] [modloading-worker-2/INFO]: Here we go! Launching Dungeon Crawl 2.3.5...
[13:59:37] [modloading-worker-2/INFO]: Forge mod loading, version 36.2.33, for MC 1.16.5 with MCP 20210115.111550
[13:59:37] [modloading-worker-2/INFO]: MinecraftForge v36.2.33 Initialized
[13:59:38] [modloading-worker-1/INFO]: [KONKRETE] Optifine detected! ###############################
[13:59:38] [modloading-worker-1/INFO]: [KONKRETE] Successfully initialized!
[13:59:38] [modloading-worker-1/INFO]: [KONKRETE] Server-side libs ready to use!
[13:59:39] [modloading-worker-1/INFO]: Optifine detected.
[13:59:39] [modloading-worker-1/INFO]: No shader config found.
[13:59:40] [modloading-worker-0/INFO]: Detected new forge version, registering events reflectively.
[13:59:41] [modloading-worker-1/INFO]: [FANCYMENU] Optifine compatibility mode!
[13:59:48] [modloading-worker-3/INFO]: ExpandAbility here, who dis?
[14:00:02] [main/INFO]: Registered 45 Block entries in 0,97ms.
[14:00:09] [main/INFO]: Registered 53 Item entries in 1,36ms.
[14:00:10] [main/INFO]: Potentially Dangerous alternative prefix `minecraft` for name `iron_horse_armor`, expected `cofh_core`. This could be a intended override, but in most cases indicates a broken mod.
[14:00:10] [main/INFO]: Potentially Dangerous alternative prefix `minecraft` for name `golden_horse_armor`, expected `cofh_core`. This could be a intended override, but in most cases indicates a broken mod.
[14:00:10] [main/INFO]: Potentially Dangerous alternative prefix `minecraft` for name `diamond_horse_armor`, expected `cofh_core`. This could be a intended override, but in most cases indicates a broken mod.
[14:00:10] [main/INFO]: Potentially Dangerous alternative prefix `minecraft` for name `leather_horse_armor`, expected `cofh_core`. This could be a intended override, but in most cases indicates a broken mod.
[14:00:10] [main/INFO]: Potentially Dangerous alternative prefix `minecraft` for name `shield`, expected `cofh_core`. This could be a intended override, but in most cases indicates a broken mod.
[14:00:11] [main/INFO]: Registered 11 GlobalLootModifierSerializer entries in 0,21ms.
[14:00:11] [main/INFO]: Registered 2 TileEntityType entries in 0,06ms.
[14:00:11] [main/INFO]: Potentially Dangerous alternative prefix `minecraft` for name `protection`, expected `ensorcellation`. This could be a intended override, but in most cases indicates a broken mod.
[14:00:11] [main/INFO]: Potentially Dangerous alternative prefix `minecraft` for name `blast_protection`, expected `ensorcellation`. This could be a intended override, but in most cases indicates a broken mod.
[14:00:11] [main/INFO]: Potentially Dangerous alternative prefix `minecraft` for name `feather_falling`, expected `ensorcellation`. This could be a intended override, but in most cases indicates a broken mod.
[14:00:11] [main/INFO]: Potentially Dangerous alternative prefix `minecraft` for name `fire_protection`, expected `ensorcellation`. This could be a intended override, but in most cases indicates a broken mod.
[14:00:11] [main/INFO]: Potentially Dangerous alternative prefix `minecraft` for name `projectile_protection`, expected `ensorcellation`. This could be a intended override, but in most cases indicates a broken mod.
[14:00:11] [main/INFO]: Potentially Dangerous alternative prefix `minecraft` for name `fire_aspect`, expected `ensorcellation`. This could be a intended override, but in most cases indicates a broken mod.
[14:00:11] [main/INFO]: Potentially Dangerous alternative prefix `minecraft` for name `frost_walker`, expected `ensorcellation`. This could be a intended override, but in most cases indicates a broken mod.
[14:00:11] [main/INFO]: Potentially Dangerous alternative prefix `minecraft` for name `knockback`, expected `ensorcellation`. This could be a intended override, but in most cases indicates a broken mod.
[14:00:11] [main/INFO]: Potentially Dangerous alternative prefix `minecraft` for name `looting`, expected `ensorcellation`. This could be a intended override, but in most cases indicates a broken mod.
[14:00:11] [main/INFO]: Potentially Dangerous alternative prefix `minecraft` for name `thorns`, expected `ensorcellation`. This could be a intended override, but in most cases indicates a broken mod.
[14:00:11] [main/INFO]: Potentially Dangerous alternative prefix `minecraft` for name `mending`, expected `ensorcellation`. This could be a intended override, but in most cases indicates a broken mod.
[14:00:11] [main/INFO]: Potentially Dangerous alternative prefix `minecraft` for name `milk`, expected `forge`. This could be a intended override, but in most cases indicates a broken mod.
[14:00:11] [main/INFO]: Potentially Dangerous alternative prefix `minecraft` for name `flowing_milk`, expected `forge`. This could be a intended override, but in most cases indicates a broken mod.
[14:00:14] [main/INFO]: Registered 22 ingredient serializers.
[14:00:14] [main/INFO]: Registered 5 IRecipeSerializer entries in 0,17ms.
[14:00:22] [main/INFO]: Narrator library for x64 successfully loaded
[14:00:23] [main/INFO]: Reloading ResourceManager: Default, Mod Resources
[14:00:23] [main/INFO]: [OptiFine] *** Reloading textures ***
[14:00:23] [main/INFO]: [OptiFine] Resource packs: Mod Resources
[14:00:24] [main/INFO]: [OptiFine] *** Reflector Forge ***
[14:00:24] [main/INFO]: [OptiFine] (Reflector) Class not present: mods.betterfoliage.client.BetterFoliageClient
[14:00:24] [main/WARN]: [OptiFine] (Reflector) More than one method found: net.minecraftforge.client.ForgeHooksClient.renderMainMenu
[14:00:24] [main/WARN]: [OptiFine] (Reflector)  - public static void net.minecraftforge.client.ForgeHooksClient.renderMainMenu(net.minecraft.client.gui.screen.MainMenuScreen,com.mojang.blaze3d.matrix.MatrixStack,net.minecraft.client.gui.FontRenderer,int,int,int)
[14:00:24] [main/WARN]: [OptiFine] (Reflector)  - public static void net.minecraftforge.client.ForgeHooksClient.renderMainMenu(net.minecraft.client.gui.screen.MainMenuScreen,com.mojang.blaze3d.matrix.MatrixStack,net.minecraft.client.gui.FontRenderer,int,int)
[14:00:24] [main/INFO]: [OptiFine] (Reflector) Field not present: net.minecraftforge.client.model.pipeline.LightUtil.itemConsumer
[14:00:24] [main/INFO]: [OptiFine] (Reflector) Field not present: net.minecraftforge.client.model.pipeline.LightUtil.tessellator
[14:00:24] [main/INFO]: [OptiFine] (Reflector) Class not present: net.minecraftforge.fml.common.ModContainer
[14:00:24] [Worker-Main-5/INFO]: [OptiFine] Multitexture: false
[14:00:24] [main/INFO]: [OptiFine] *** Reflector Vanilla ***
[14:00:25] [modloading-worker-0/INFO]: CLIENT CONFIG LOADED
[14:00:26] [modloading-worker-0/INFO]: BLACKLIST RELOADED
[14:00:26] [modloading-worker-0/INFO]: COMMON CONFIG LOADED
[14:00:28] [Worker-Main-7/INFO]: [OptiFine] Multitexture: false
[14:00:32] [Worker-Main-6/INFO]: Version 10.1.2 initializing...
[14:00:33] [Worker-Main-6/INFO]: Fake player readout: UUID = 46e82cd0-d480-3d48-800a-77431ede078e, name = [Mekanism]
[14:00:33] [Worker-Main-6/INFO]: Loading complete.
[14:00:33] [Worker-Main-6/INFO]: Mod loaded.
[14:00:49] [Worker-Main-6/WARN]: Exception loading blockstate definition: 'vehicle:blockstates/vehicle_crate.json' missing model for variant: 'vehicle:vehicle_crate#facing=west'
[14:00:49] [Worker-Main-6/WARN]: Exception loading blockstate definition: 'vehicle:blockstates/vehicle_crate.json' missing model for variant: 'vehicle:vehicle_crate#facing=north'
[14:00:49] [Worker-Main-6/WARN]: Exception loading blockstate definition: 'vehicle:blockstates/vehicle_crate.json' missing model for variant: 'vehicle:vehicle_crate#facing=south'
[14:00:49] [Worker-Main-6/WARN]: Exception loading blockstate definition: 'vehicle:blockstates/vehicle_crate.json' missing model for variant: 'vehicle:vehicle_crate#facing=east'
[14:00:49] [Worker-Main-6/WARN]: Exception loading blockstate definition: 'vehicle:blockstates/vehicle_crate.json' in resourcepack: 'Mod Resources': Missing model, expected to find a string
[14:01:02] [Worker-Main-6/WARN]: [OptiFine] Unknown resource pack file: mod_resources
[14:01:02] [Worker-Main-6/WARN]: [OptiFine] Unknown resource pack file: mod_resources
[14:01:02] [Worker-Main-6/WARN]: [OptiFine] Unknown resource pack file: mod_resources
[14:01:02] [Worker-Main-6/WARN]: [OptiFine] Unknown resource pack file: mod_resources
[14:01:12] [Worker-Main-6/WARN]: Unable to resolve texture reference: #missing in vehicle:vehicle/dirt_bike_body
[14:01:12] [Worker-Main-6/INFO]: [OptiFine] Multitexture: false
[14:01:13] [Worker-Main-6/WARN]: [OptiFine] Unknown resource pack file: mod_resources
[14:01:13] [Worker-Main-6/INFO]: [OptiFine] Multipass connected textures: false
[14:01:13] [Worker-Main-6/INFO]: [OptiFine] ConnectedTextures: optifine/ctm/default/00_glass_white/glass_pane_white.properties
[14:01:13] [Worker-Main-6/INFO]: [OptiFine] ConnectedTextures: optifine/ctm/default/00_glass_white/glass_white.properties
[14:01:14] [Worker-Main-6/INFO]: [OptiFine] ConnectedTextures: optifine/ctm/default/01_glass_orange/glass_orange.properties
[14:01:14] [Worker-Main-6/INFO]: [OptiFine] ConnectedTextures: optifine/ctm/default/01_glass_orange/glass_pane_orange.properties
[14:01:14] [Worker-Main-6/INFO]: [OptiFine] ConnectedTextures: optifine/ctm/default/02_glass_magenta/glass_magenta.properties
[14:01:15] [Worker-Main-6/INFO]: [OptiFine] ConnectedTextures: optifine/ctm/default/02_glass_magenta/glass_pane_magenta.properties
[14:01:15] [Worker-Main-6/INFO]: [OptiFine] ConnectedTextures: optifine/ctm/default/03_glass_light_blue/glass_light_blue.properties
[14:01:16] [Worker-Main-6/INFO]: [OptiFine] ConnectedTextures: optifine/ctm/default/03_glass_light_blue/glass_pane_light_blue.properties
[14:01:16] [Worker-Main-6/INFO]: [OptiFine] ConnectedTextures: optifine/ctm/default/04_glass_yellow/glass_pane_yellow.properties
[14:01:17] [Worker-Main-6/INFO]: [OptiFine] ConnectedTextures: optifine/ctm/default/04_glass_yellow/glass_yellow.properties
[14:01:17] [Worker-Main-6/INFO]: [OptiFine] ConnectedTextures: optifine/ctm/default/05_glass_lime/glass_lime.properties
[14:01:17] [Worker-Main-6/INFO]: [OptiFine] ConnectedTextures: optifine/ctm/default/05_glass_lime/glass_pane_lime.properties
[14:01:18] [Worker-Main-6/INFO]: [OptiFine] ConnectedTextures: optifine/ctm/default/06_glass_pink/glass_pane_pink.properties
[14:01:18] [Worker-Main-6/INFO]: [OptiFine] ConnectedTextures: optifine/ctm/default/06_glass_pink/glass_pink.properties
[14:01:18] [Worker-Main-6/INFO]: [OptiFine] ConnectedTextures: optifine/ctm/default/07_glass_gray/glass_gray.properties
[14:01:18] [Worker-Main-6/INFO]: [OptiFine] ConnectedTextures: optifine/ctm/default/07_glass_gray/glass_pane_gray.properties
[14:01:19] [Worker-Main-6/INFO]: [OptiFine] ConnectedTextures: optifine/ctm/default/08_glass_light_gray/glass_light_gray.properties
[14:01:19] [Worker-Main-6/INFO]: [OptiFine] ConnectedTextures: optifine/ctm/default/08_glass_light_gray/glass_pane_light_gray.properties
[14:01:19] [Worker-Main-6/INFO]: [OptiFine] ConnectedTextures: optifine/ctm/default/09_glass_cyan/glass_cyan.properties
[14:01:19] [Worker-Main-6/INFO]: [OptiFine] ConnectedTextures: optifine/ctm/default/09_glass_cyan/glass_pane_cyan.properties
[14:01:20] [Worker-Main-6/INFO]: [OptiFine] ConnectedTextures: optifine/ctm/default/10_glass_purple/glass_pane_purple.properties
[14:01:20] [Worker-Main-6/INFO]: [OptiFine] ConnectedTextures: optifine/ctm/default/10_glass_purple/glass_purple.properties
[14:01:20] [Worker-Main-6/INFO]: [OptiFine] ConnectedTextures: optifine/ctm/default/11_glass_blue/glass_blue.properties
[14:01:21] [Worker-Main-6/INFO]: [OptiFine] ConnectedTextures: optifine/ctm/default/11_glass_blue/glass_pane_blue.properties
[14:01:22] [Worker-Main-6/INFO]: [OptiFine] ConnectedTextures: optifine/ctm/default/12_glass_brown/glass_brown.properties
[14:01:22] [Worker-Main-6/INFO]: [OptiFine] ConnectedTextures: optifine/ctm/default/12_glass_brown/glass_pane_brown.properties
[14:01:22] [Worker-Main-6/INFO]: [OptiFine] ConnectedTextures: optifine/ctm/default/13_glass_green/glass_green.properties
[14:01:23] [Worker-Main-6/INFO]: [OptiFine] ConnectedTextures: optifine/ctm/default/13_glass_green/glass_pane_green.properties
[14:01:23] [Worker-Main-6/INFO]: [OptiFine] ConnectedTextures: optifine/ctm/default/14_glass_red/glass_pane_red.properties
[14:01:23] [Worker-Main-6/INFO]: [OptiFine] ConnectedTextures: optifine/ctm/default/14_glass_red/glass_red.properties
[14:01:24] [Worker-Main-6/INFO]: [OptiFine] ConnectedTextures: optifine/ctm/default/15_glass_black/glass_black.properties
[14:01:24] [Worker-Main-6/INFO]: [OptiFine] ConnectedTextures: optifine/ctm/default/15_glass_black/glass_pane_black.properties
[14:01:24] [Worker-Main-6/INFO]: [OptiFine] ConnectedTextures: optifine/ctm/default/20_glass/glass.properties
[14:01:24] [Worker-Main-6/INFO]: [OptiFine] ConnectedTextures: optifine/ctm/default/20_glass/glass_pane.properties
[14:01:25] [Worker-Main-6/INFO]: [OptiFine] ConnectedTextures: optifine/ctm/default/30_bookshelf/bookshelf.properties
[14:01:25] [Worker-Main-6/INFO]: [OptiFine] ConnectedTextures: optifine/ctm/default/40_sandstone/sandstone.properties
[14:01:25] [Worker-Main-6/INFO]: [OptiFine] ConnectedTextures: optifine/ctm/default/41_red_sandstone/red_sandstone.properties
[14:01:25] [Worker-Main-6/INFO]: [OptiFine] Multipass connected textures: false
[14:01:25] [Worker-Main-6/INFO]: [OptiFine] BetterGrass: Parsing default configuration optifine/bettergrass.properties
[14:02:25] [Worker-Main-6/INFO]: [OptiFine] Mipmap levels: 4
[14:02:26] [Worker-Main-8/INFO]: No plugins for JourneyMap API discovered.
[14:02:27] [Worker-Main-8/INFO]: Post Initialization ( started )
[14:02:27] [Worker-Main-8/INFO]: Post Initialization ( ended after 137ms )
[14:02:27] [Worker-Main-8/INFO]: Common Setup
[14:02:27] [Worker-Main-8/WARN]: Configuration file C:\Users\kaues\AppData\Roaming\.minecraft\versions\Ender Tech\config\dungeon_crawl.toml is not correct. Correcting
[14:02:27] [Worker-Main-8/WARN]: Incorrect key Miscellaneous Settings was corrected from null to its default, SimpleCommentedConfig:{}. 
[14:02:27] [Worker-Main-8/WARN]: Incorrect key Miscellaneous Settings.enable_tools was corrected from null to its default, false. 
[14:02:27] [Worker-Main-8/WARN]: Incorrect key Miscellaneous Settings.extended_debug was corrected from null to its default, true. 
[14:02:27] [Worker-Main-8/WARN]: Incorrect key Miscellaneous Settings.Print Biome Categories was corrected from null to its default, false. 
[14:02:27] [Worker-Main-8/WARN]: Incorrect key World Generation was corrected from null to its default, SimpleCommentedConfig:{}. 
[14:02:27] [Worker-Main-8/WARN]: Incorrect key World Generation.solid was corrected from null to its default, false. 
[14:02:27] [Worker-Main-8/WARN]: Incorrect key World Generation.tick_falling_blocks was corrected from null to its default, true. 
[14:02:27] [Worker-Main-8/WARN]: Incorrect key Dungeon Placement was corrected from null to its default, SimpleCommentedConfig:{}. 
[14:02:27] [Worker-Main-8/WARN]: Incorrect key Dungeon Placement.spacing was corrected from null to its default, 24. 
[14:02:27] [Worker-Main-8/WARN]: Incorrect key Dungeon Placement.separation was corrected from null to its default, 12. 
[14:02:27] [Worker-Main-8/WARN]: Incorrect key Dungeon Placement.Biomes was corrected from null to its default, SimpleCommentedConfig:{}. 
[14:02:27] [Worker-Main-8/WARN]: Incorrect key Dungeon Placement.Biomes.Biome Whitelist was corrected from null to its default, . 
[14:02:27] [Worker-Main-8/WARN]: Incorrect key Dungeon Placement.Biomes.Biome Blacklist was corrected from null to its default, . 
[14:02:27] [Worker-Main-8/WARN]: Incorrect key Dungeon Placement.Biomes.Biome Categories was corrected from null to its default, desert, extreme_hills, forest, icy, jungle, mesa, plains, savanna, swamp, taiga. 
[14:02:27] [Worker-Main-8/WARN]: Incorrect key Dungeon Placement.Dimensions was corrected from null to its default, SimpleCommentedConfig:{}. 
[14:02:27] [Worker-Main-8/WARN]: Incorrect key Dungeon Placement.Dimensions.Dimension Whitelist was corrected from null to its default, minecraft:overworld. 
[14:02:27] [Worker-Main-8/WARN]: Incorrect key Dungeon Settings was corrected from null to its default, SimpleCommentedConfig:{}. 
[14:02:27] [Worker-Main-8/WARN]: Incorrect key Dungeon Settings.secret_rooms was corrected from null to its default, true. 
[14:02:27] [Worker-Main-8/WARN]: Incorrect key Dungeon Settings.overwrite_entity_loot_tables was corrected from null to its default, true. 
[14:02:27] [Worker-Main-8/WARN]: Incorrect key Dungeon Settings.no_nether_blocks was corrected from null to its default, false. 
[14:02:27] [Worker-Main-8/WARN]: Incorrect key Dungeon Settings.spawner_activation_range was corrected from null to its default, 12. 
[14:02:27] [Worker-Main-8/WARN]: Incorrect key Dungeon Settings.spawner_entities was corrected from null to its default, 6. 
[14:02:27] [Worker-Main-8/WARN]: Incorrect key Dungeon Settings.custom_spawners was corrected from null to its default, true. 
[14:02:27] [Worker-Main-8/WARN]: Incorrect key Dungeon Settings.natural_despawn was corrected from null to its default, true. 
[14:02:27] [Worker-Main-8/INFO]: Whitelisted Dimensions:
[14:02:27] [Worker-Main-8/INFO]: minecraft:overworld
[14:02:27] [Worker-Main-8/INFO]: Registering 3 command argument types.
[14:02:27] [Worker-Main-8/INFO]: Registering 13 loot conditions.
[14:02:28] [Worker-Main-8/INFO]: Loaded 'Mekanism Generators' module.
[14:02:28] [Forge Version Check/INFO]: [cgm] Starting version check at https://raw.githubusercontent.com/MrCrayfish/ModUpdates/master/cgm/update.json
[14:02:28] [Worker-Main-5/INFO]: [OptiFine] Scaled non power of 2: jei:gui/icons/recipe_transfer, 7 -> 14
[14:02:29] [Worker-Main-8/INFO]: New compacting rule 4 clay_ball = 1 clay
[14:02:29] [Worker-Main-8/INFO]: New compacting rule 4 snowball = 1 snow_block
[14:02:29] [Worker-Main-8/INFO]: New compacting rule 4 glowstone_dust = 1 glowstone
[14:02:29] [Worker-Main-8/INFO]: New compacting rule 4 brick = 1 bricks
[14:02:29] [Worker-Main-8/INFO]: New compacting rule 4 nether_brick = 1 nether_bricks
[14:02:29] [Worker-Main-8/INFO]: New compacting rule 9 nether_wart = 1 nether_wart_block
[14:02:29] [Worker-Main-8/INFO]: New compacting rule 4 quartz = 1 quartz_block
[14:02:29] [Worker-Main-8/INFO]: New compacting rule 9 melon_slice = 1 melon
[14:02:29] [Worker-Main-8/INFO]: New compacting rule 4 sand = 1 sandstone
[14:02:29] [Worker-Main-8/INFO]: New compacting rule 4 red_sand = 1 red_sandstone
[14:02:29] [Worker-Main-8/INFO]: New compacting rule 4 clay_ball = 1 clay
[14:02:30] [Worker-Main-8/INFO]: Loaded 'Mekanism: Tools' module.
[14:02:30] [Worker-Main-8/INFO]: ConstructionWand says hello - may the odds be ever in your favor.
[14:02:32] [Forge Version Check/INFO]: [cgm] Found status: BETA Current: 1.1.0 Target: null
[14:02:32] [Forge Version Check/INFO]: [clumps] Starting version check at https://updates.blamejared.com/get?n=clumps&gv=1.16.5
[14:02:33] [Worker-Main-8/INFO]: [OptiFine] Multitexture: false
[14:02:33] [Worker-Main-5/INFO]: [OptiFine] Multitexture: false
[14:02:33] [Worker-Main-9/INFO]: [OptiFine] Multitexture: false
[14:02:33] [Forge Version Check/INFO]: [clumps] Found status: BETA Current: 6.0.0.28 Target: 6.0.0.28
[14:02:33] [Forge Version Check/INFO]: [journeymap] Starting version check at https://forge.curseupdate.com/32274/journeymap
[14:02:34] [Forge Version Check/INFO]: [journeymap] Found status: UP_TO_DATE Current: 5.8.0 Target: null
[14:02:34] [Forge Version Check/INFO]: [bookshelf] Starting version check at https://updates.blamejared.com/get?n=bookshelf&gv=1.16.5
[14:02:34] [Forge Version Check/INFO]: [bookshelf] Found status: BETA Current: 10.4.31 Target: 10.4.31
[14:02:34] [Forge Version Check/INFO]: [darkutils] Starting version check at https://updates.blamejared.com/get?n=darkutils&gv=1.16.4
[14:02:34] [main/INFO]: Initializing Packet Registries
[14:02:35] [main/INFO]: Registering Structure Piece Types
[14:02:35] [Forge Version Check/INFO]: [darkutils] Found status: BETA Current: 8.0.11 Target: null
[14:02:35] [Forge Version Check/INFO]: [forge] Starting version check at https://files.minecraftforge.net/net/minecraftforge/forge/promotions_slim.json
[14:02:35] [Worker-Main-10/INFO]: Initialized HolidayManager.
[14:02:35] [Worker-Main-8/INFO]: [KONKRETE] Client-side libs ready to use!
[14:02:35] [Worker-Main-8/INFO]: [de.keksuccino.konkrete.PostLoadingHandler:runPostLoadingEvents:14]: [KONKRETE] Running PostLoadingEvents for mod: assets/fancymenu
[14:02:36] [Forge Version Check/INFO]: [forge] Found status: AHEAD Current: 36.2.33 Target: null
[14:02:36] [Forge Version Check/INFO]: [cofh_core] Starting version check at https://raw.github.com/cofh/version/master/cofh_core/update.json
[14:02:36] [Worker-Main-8/INFO]: [de.keksuccino.konkrete.PostLoadingHandler:runPostLoadingEvents:20]: [KONKRETE] PostLoadingEvents completed for mod: assets/fancymenu
[14:02:36] [Forge Version Check/INFO]: [cofh_core] Found status: AHEAD Current: 1.4.2.9 Target: null
[14:02:36] [Forge Version Check/INFO]: [ensorcellation] Starting version check at https://raw.github.com/cofh/version/master/ensorcellation/update.json
[14:02:37] [Forge Version Check/INFO]: [ensorcellation] Found status: AHEAD Current: 1.4.1.2 Target: null
[14:02:37] [Forge Version Check/INFO]: [mining_dimension] Starting version check at https://maxhenkel.de/update/mining_dimension.json
[14:02:37] [main/INFO]: Journeymap Initializing
[14:02:39] [main/INFO]: JourneyMap log initialized.
[14:02:39] [main/INFO]: initialize ENTER
[14:02:39] [main/INFO]: [ClientAPI] built with JourneyMap API 1.8-SNAPSHOT
[14:02:39] [main/INFO]: Initializing plugins with Client API: journeymap.client.api.impl.ClientAPI
[14:02:40] [main/WARN]: core (Initialized) Bad configField entry during updateFrom(): optionsManagerViewed=null
[14:02:40] [main/WARN]: core (Initialized) Bad configField entry during updateFrom(): splashViewed=null
[14:02:40] [Forge Version Check/INFO]: [mining_dimension] Found status: UP_TO_DATE Current: 1.16.5-1.0.6 Target: null
[14:02:40] [Forge Version Check/INFO]: [gravestone] Starting version check at https://maxhenkel.de/update/gravestone.json
[14:02:41] [main/INFO]: initialize EXIT, elapsed count 1 avg 3199,03ms
[14:02:41] [main/WARN]: Mod 'journeymap' took 3.309 s to run a deferred task.
[14:02:41] [Worker-Main-6/INFO]: [OptiFine] Multitexture: false
[14:02:41] [Worker-Main-6/INFO]: [OptiFine] Sprite size: 64
[14:02:41] [Worker-Main-6/INFO]: [OptiFine] Mipmap levels: 6
[14:02:41] [Worker-Main-6/INFO]: [OptiFine] Multitexture: false
[14:02:41] [Worker-Main-6/INFO]: [OptiFine] Sprite size: 64
[14:02:41] [Worker-Main-6/INFO]: [OptiFine] Mipmap levels: 6
[14:02:41] [Worker-Main-6/INFO]: [OptiFine] Multitexture: false
[14:02:42] [Worker-Main-6/INFO]: [OptiFine] Sprite size: 64
[14:02:42] [Worker-Main-6/INFO]: [OptiFine] Mipmap levels: 6
[14:02:42] [Worker-Main-6/INFO]: [OptiFine] Multitexture: false
[14:02:42] [Worker-Main-6/INFO]: [OptiFine] Sprite size: 64
[14:02:42] [Worker-Main-6/INFO]: [OptiFine] Mipmap levels: 6
[14:02:42] [Worker-Main-6/INFO]: [OptiFine] Multitexture: false
[14:02:42] [Worker-Main-6/INFO]: [OptiFine] Sprite size: 64
[14:02:42] [Worker-Main-6/INFO]: [OptiFine] Mipmap levels: 6
[14:02:42] [Worker-Main-6/INFO]: [OptiFine] Multitexture: false
[14:02:42] [Worker-Main-6/INFO]: [OptiFine] Sprite size: 64
[14:02:42] [Worker-Main-6/INFO]: [OptiFine] Mipmap levels: 6
[14:02:42] [Forge Version Check/INFO]: [gravestone] Found status: AHEAD Current: 1.16.5-1.0.7 Target: null
[14:02:42] [Forge Version Check/INFO]: [securitycraft] Starting version check at https://www.github.com/Geforce132/SecurityCraft/raw/master/Updates/Forge.json
[14:02:42] [main/INFO]: [stepsword.mahoutsukai.render.shader.ShaderHelper:shadersOn:146]: config found
[14:02:42] [main/INFO]: [stepsword.mahoutsukai.render.shader.ShaderHelper:shadersOn:153]: not isShaders
[14:02:43] [Forge Version Check/INFO]: [securitycraft] Found status: OUTDATED Current: v1.8.23 Target: v1.9.1
[14:02:43] [Forge Version Check/INFO]: [obfuscate] Starting version check at https://mrcrayfish.com/modupdatejson?id=obfuscate
[14:02:43] [main/INFO]: No shader config found.
[14:02:43] [Forge Version Check/INFO]: [obfuscate] Found status: BETA Current: 0.6.2 Target: 0.6.2
[14:02:43] [Forge Version Check/INFO]: [vehicle] Starting version check at https://raw.githubusercontent.com/MrCrayfish/ModUpdates/master/vehicle/update.json
[14:02:44] [Forge Version Check/INFO]: [vehicle] Found status: BETA Current: 0.45.2 Target: null
[14:02:44] [Forge Version Check/INFO]: [runelic] Starting version check at https://updates.blamejared.com/get?n=runelic&gv=1.16.5
[14:02:44] [main/INFO]: Loading context 'create:context/contraption'
[14:02:44] [main/ERROR]: Shader compilation log for create:rotating.vert: No errors.

[14:02:44] [main/ERROR]: Source for shader 'create:rotating.vert':
   1: #version 110
   2: #define DEBUG_RAINBOW
   3: 
   4: #define PI 3.1415926538
   5: 
   6: #if defined(USE_FOG)
   7: varying float FragDistance;
   8: #endif
   9: 
  10: varying vec3 BoxCoord;
  11: 
  12: uniform vec3 uLightBoxSize;
  13: uniform vec3 uLightBoxMin;
  14: uniform mat4 uModel;
  15: 
  16: uniform float uTime;
  17: uniform mat4 uViewProjection;
  18: uniform vec3 uCameraPos;
  19: 
  20: void FLWFinalizeWorldPos(inout vec4 worldPos) {
  21:     worldPos = uModel * worldPos;
  22: 
  23:     BoxCoord = (worldPos.xyz - uLightBoxMin) / uLightBoxSize;
  24: 
  25:     #if defined(USE_FOG)
  26:     FragDistance = length(worldPos.xyz);
  27:     #endif
  28: 
  29:     gl_Position = uViewProjection * worldPos;
  30: }
  31: 
  32: void FLWFinalizeNormal(inout vec3 normal) {
  33:     mat3 m;
  34:     m[0] = uModel[0].xyz;
  35:     m[1] = uModel[1].xyz;
  36:     m[2] = uModel[2].xyz;
  37:     normal = m * normal;
  38: }
  39: 
  40: 
  41: 
  42: mat4 rotate(vec3 axis, float angle) {
  43:     float s = sin(angle);
  44:     float c = cos(angle);
  45:     float oc = 1. - c;
  46: 
  47:     vec3 sa = axis * s;
  48: 
  49:     mat4 mr = mat4(1.);
  50:     mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
  51:     mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
  52:     mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);
  53: 
  54:     return mr;
  55: }
  56: 
  57: mat4 rotation(vec3 rot) {
  58:     return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
  59: }
  60: 
  61: mat3 modelToNormal(mat4 mat) {
  62:     // Discard the edges. This won't be accurate for scaled or skewed matrices,
  63:     // but we don't have to work with those often.
  64:     mat3 m;
  65:     m[0] = mat[0].xyz;
  66:     m[1] = mat[1].xyz;
  67:     m[2] = mat[2].xyz;
  68:     return m;
  69: }
  70: 
  71: float diffuse(vec3 normal) {
  72:     vec3 n2 = normal * normal * vec3(.6, .25, .8);
  73:     return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
  74: }
  75: 
  76: 
  77: struct Rotating {
  78:     vec2 light;
  79:     vec4 color;
  80:     vec3 pos;
  81:     float speed;
  82:     float offset;
  83:     vec3 axis;
  84: };
  85: 
  86: 
  87: struct Vertex {
  88:     vec3 pos;
  89:     vec3 normal;
  90:     vec2 texCoords;
  91: };
  92: 
  93: struct BlockFrag {
  94:     vec2 texCoords;
  95:     vec4 color;
  96:     float diffuse;
  97:     vec2 light;
  98: };
  99: 
 100: mat4 kineticRotation(float offset, float speed, vec3 axis) {
 101:     float degrees = offset + uTime * speed * 3./10.;
 102:     float angle = fract(degrees / 360.) * PI * 2.;
 103: 
 104:     return rotate(axis, angle);
 105: }
 106: 
 107: BlockFrag FLWMain(Vertex v, Rotating instance) {
 108:     mat4 spin = kineticRotation(instance.offset, instance.speed, instance.axis);
 109: 
 110:     vec4 worldPos = spin * vec4(v.pos - .5, 1.);
 111:     worldPos += vec4(instance.pos + .5, 0.);
 112: 
 113:     vec3 norm = modelToNormal(spin) * v.normal;
 114: 
 115:     FLWFinalizeWorldPos(worldPos);
 116:     FLWFinalizeNormal(norm);
 117: 
 118:     BlockFrag b;
 119:     b.diffuse = diffuse(norm);
 120:     b.texCoords = v.texCoords;
 121:     b.light = instance.light;
 122: 
 123:     #if defined(DEBUG_RAINBOW)
 124:     b.color = instance.color;
 125:     #elif defined(DEBUG_NORMAL)
 126:     b.color = vec4(norm, 1.);
 127:     #else
 128:     b.color = vec4(1.);
 129:     #endif
 130: 
 131:     return b;
 132: }
 133: attribute vec3 a_v_pos;
 134: attribute vec3 a_v_normal;
 135: attribute vec2 a_v_texCoords;
 136: 
 137: attribute vec2 a_i_light;
 138: attribute vec4 a_i_color;
 139: attribute vec3 a_i_pos;
 140: attribute float a_i_speed;
 141: attribute float a_i_offset;
 142: attribute vec3 a_i_axis;
 143: 
 144: 
 145: varying vec2 v2f_texCoords;
 146: varying vec4 v2f_color;
 147: varying float v2f_diffuse;
 148: varying vec2 v2f_light;
 149: 
 150: 
 151: void main() {
 152:     Vertex v;
 153:     v.pos = a_v_pos;
 154: v.normal = a_v_normal;
 155: v.texCoords = a_v_texCoords;
 156: 
 157: 
 158:     Rotating i;
 159:     i.light = a_i_light;
 160: i.color = a_i_color;
 161: i.pos = a_i_pos;
 162: i.speed = a_i_speed;
 163: i.offset = a_i_offset;
 164: i.axis = a_i_axis;
 165: 
 166: 
 167:     BlockFrag o = FLWMain(v, i);
 168: 
 169:     v2f_texCoords = o.texCoords;
 170: v2f_color = o.color;
 171: v2f_diffuse = o.diffuse;
 172: v2f_light = o.light;
 173: 
 174: }

[14:02:44] [main/ERROR]: Shader compilation log for flywheel:block.frag: No errors.

[14:02:44] [main/ERROR]: Source for shader 'flywheel:block.frag':
   1: #version 110
   2: #define DEBUG_RAINBOW
   3: 
   4: #if defined(USE_FOG)
   5: varying float FragDistance;
   6: uniform vec4 uFogColor;
   7: #endif
   8: 
   9: #if defined(USE_FOG_LINEAR)
  10: uniform vec2 uFogRange;
  11: 
  12: float FLWFogFactor() {
  13:     return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
  14: }
  15:     #endif
  16: 
  17:     #if defined(USE_FOG_EXP2)
  18: uniform float uFogDensity;
  19: 
  20: float FLWFogFactor() {
  21:     float dist = FragDistance * uFogDensity;
  22:     return 1. / exp2(dist * dist);
  23: }
  24:     #endif
  25: // Adjust the [0,1] normalized lightmap value based on the texture matrix from LightTexture#enableLightmap
  26: vec2 shiftLight(vec2 lm) {
  27:     return lm * 0.99609375 + 0.03125;// * 255/256 + 1/32
  28: }
  29: 
  30: varying vec3 BoxCoord;
  31: varying vec2 BoxLight;
  32: uniform sampler3D uLightVolume;
  33: 
  34: uniform sampler2D uBlockAtlas;
  35: uniform sampler2D uLightMap;
  36: 
  37: vec4 FLWBlockTexture(vec2 texCoords) {
  38:     return texture2D(uBlockAtlas, texCoords);
  39: }
  40: 
  41: void FLWFinalizeColor(vec4 color) {
  42:     #if defined(USE_FOG)
  43:     float a = color.a;
  44:     float fog = clamp(FLWFogFactor(), 0., 1.);
  45: 
  46:     color = mix(uFogColor, color, fog);
  47:     color.a = a;
  48:     #endif
  49: 
  50:     gl_FragColor = color;
  51: }
  52: 
  53: vec4 FLWLight(vec2 lightCoords) {
  54:     lightCoords = max(lightCoords, texture3D(uLightVolume, BoxCoord).rg);
  55: 
  56:     return texture2D(uLightMap, shiftLight(lightCoords));
  57: }
  58: 
  59: 
  60: 
  61: struct BlockFrag {
  62:     vec2 texCoords;
  63:     vec4 color;
  64:     float diffuse;
  65:     vec2 light;
  66: };
  67: 
  68: void FLWMain(BlockFrag r) {
  69:     vec4 tex = FLWBlockTexture(r.texCoords);
  70: 
  71:     vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;
  72: 
  73: //    flw_WorldPos = ;
  74: //    flw_Normal = ;
  75: //    flw_Albedo = tex.rgb;
  76: //    flw_Alpha = tex.a;
  77: //    flw_LightMap = r.light;
  78: //    flw_Tint = r.color;
  79:     FLWFinalizeColor(color);
  80: }
  81: 
  82: varying vec2 v2f_texCoords;
  83: varying vec4 v2f_color;
  84: varying float v2f_diffuse;
  85: varying vec2 v2f_light;
  86: 
  87: 
  88: //vec3 flw_WorldPos;
  89: //vec3 flw_Normal;
  90: //vec3 flw_Albedo;
  91: //float flw_Alpha;
  92: //vec2 flw_LightMap;
  93: //vec4 flw_Tint;
  94: 
  95: void main() {
  96:     BlockFrag f;
  97:     f.texCoords = v2f_texCoords;
  98: f.color = v2f_color;
  99: f.diffuse = v2f_diffuse;
 100: f.light = v2f_light;
 101: 
 102: 
 103:     FLWMain(f);
 104: }

[14:02:44] [main/ERROR]: Shader compilation log for create:rotating.vert: No errors.

[14:02:44] [main/ERROR]: Source for shader 'create:rotating.vert':
   1: #version 110
   2: #define DEBUG_NORMAL
   3: 
   4: #define PI 3.1415926538
   5: 
   6: #if defined(USE_FOG)
   7: varying float FragDistance;
   8: #endif
   9: 
  10: varying vec3 BoxCoord;
  11: 
  12: uniform vec3 uLightBoxSize;
  13: uniform vec3 uLightBoxMin;
  14: uniform mat4 uModel;
  15: 
  16: uniform float uTime;
  17: uniform mat4 uViewProjection;
  18: uniform vec3 uCameraPos;
  19: 
  20: void FLWFinalizeWorldPos(inout vec4 worldPos) {
  21:     worldPos = uModel * worldPos;
  22: 
  23:     BoxCoord = (worldPos.xyz - uLightBoxMin) / uLightBoxSize;
  24: 
  25:     #if defined(USE_FOG)
  26:     FragDistance = length(worldPos.xyz);
  27:     #endif
  28: 
  29:     gl_Position = uViewProjection * worldPos;
  30: }
  31: 
  32: void FLWFinalizeNormal(inout vec3 normal) {
  33:     mat3 m;
  34:     m[0] = uModel[0].xyz;
  35:     m[1] = uModel[1].xyz;
  36:     m[2] = uModel[2].xyz;
  37:     normal = m * normal;
  38: }
  39: 
  40: 
  41: 
  42: mat4 rotate(vec3 axis, float angle) {
  43:     float s = sin(angle);
  44:     float c = cos(angle);
  45:     float oc = 1. - c;
  46: 
  47:     vec3 sa = axis * s;
  48: 
  49:     mat4 mr = mat4(1.);
  50:     mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
  51:     mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
  52:     mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);
  53: 
  54:     return mr;
  55: }
  56: 
  57: mat4 rotation(vec3 rot) {
  58:     return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
  59: }
  60: 
  61: mat3 modelToNormal(mat4 mat) {
  62:     // Discard the edges. This won't be accurate for scaled or skewed matrices,
  63:     // but we don't have to work with those often.
  64:     mat3 m;
  65:     m[0] = mat[0].xyz;
  66:     m[1] = mat[1].xyz;
  67:     m[2] = mat[2].xyz;
  68:     return m;
  69: }
  70: 
  71: float diffuse(vec3 normal) {
  72:     vec3 n2 = normal * normal * vec3(.6, .25, .8);
  73:     return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
  74: }
  75: 
  76: 
  77: struct Rotating {
  78:     vec2 light;
  79:     vec4 color;
  80:     vec3 pos;
  81:     float speed;
  82:     float offset;
  83:     vec3 axis;
  84: };
  85: 
  86: 
  87: struct Vertex {
  88:     vec3 pos;
  89:     vec3 normal;
  90:     vec2 texCoords;
  91: };
  92: 
  93: struct BlockFrag {
  94:     vec2 texCoords;
  95:     vec4 color;
  96:     float diffuse;
  97:     vec2 light;
  98: };
  99: 
 100: mat4 kineticRotation(float offset, float speed, vec3 axis) {
 101:     float degrees = offset + uTime * speed * 3./10.;
 102:     float angle = fract(degrees / 360.) * PI * 2.;
 103: 
 104:     return rotate(axis, angle);
 105: }
 106: 
 107: BlockFrag FLWMain(Vertex v, Rotating instance) {
 108:     mat4 spin = kineticRotation(instance.offset, instance.speed, instance.axis);
 109: 
 110:     vec4 worldPos = spin * vec4(v.pos - .5, 1.);
 111:     worldPos += vec4(instance.pos + .5, 0.);
 112: 
 113:     vec3 norm = modelToNormal(spin) * v.normal;
 114: 
 115:     FLWFinalizeWorldPos(worldPos);
 116:     FLWFinalizeNormal(norm);
 117: 
 118:     BlockFrag b;
 119:     b.diffuse = diffuse(norm);
 120:     b.texCoords = v.texCoords;
 121:     b.light = instance.light;
 122: 
 123:     #if defined(DEBUG_RAINBOW)
 124:     b.color = instance.color;
 125:     #elif defined(DEBUG_NORMAL)
 126:     b.color = vec4(norm, 1.);
 127:     #else
 128:     b.color = vec4(1.);
 129:     #endif
 130: 
 131:     return b;
 132: }
 133: attribute vec3 a_v_pos;
 134: attribute vec3 a_v_normal;
 135: attribute vec2 a_v_texCoords;
 136: 
 137: attribute vec2 a_i_light;
 138: attribute vec4 a_i_color;
 139: attribute vec3 a_i_pos;
 140: attribute float a_i_speed;
 141: attribute float a_i_offset;
 142: attribute vec3 a_i_axis;
 143: 
 144: 
 145: varying vec2 v2f_texCoords;
 146: varying vec4 v2f_color;
 147: varying float v2f_diffuse;
 148: varying vec2 v2f_light;
 149: 
 150: 
 151: void main() {
 152:     Vertex v;
 153:     v.pos = a_v_pos;
 154: v.normal = a_v_normal;
 155: v.texCoords = a_v_texCoords;
 156: 
 157: 
 158:     Rotating i;
 159:     i.light = a_i_light;
 160: i.color = a_i_color;
 161: i.pos = a_i_pos;
 162: i.speed = a_i_speed;
 163: i.offset = a_i_offset;
 164: i.axis = a_i_axis;
 165: 
 166: 
 167:     BlockFrag o = FLWMain(v, i);
 168: 
 169:     v2f_texCoords = o.texCoords;
 170: v2f_color = o.color;
 171: v2f_diffuse = o.diffuse;
 172: v2f_light = o.light;
 173: 
 174: }

[14:02:44] [main/ERROR]: Shader compilation log for flywheel:block.frag: No errors.

[14:02:44] [main/ERROR]: Source for shader 'flywheel:block.frag':
   1: #version 110
   2: #define DEBUG_NORMAL
   3: 
   4: #if defined(USE_FOG)
   5: varying float FragDistance;
   6: uniform vec4 uFogColor;
   7: #endif
   8: 
   9: #if defined(USE_FOG_LINEAR)
  10: uniform vec2 uFogRange;
  11: 
  12: float FLWFogFactor() {
  13:     return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
  14: }
  15:     #endif
  16: 
  17:     #if defined(USE_FOG_EXP2)
  18: uniform float uFogDensity;
  19: 
  20: float FLWFogFactor() {
  21:     float dist = FragDistance * uFogDensity;
  22:     return 1. / exp2(dist * dist);
  23: }
  24:     #endif
  25: // Adjust the [0,1] normalized lightmap value based on the texture matrix from LightTexture#enableLightmap
  26: vec2 shiftLight(vec2 lm) {
  27:     return lm * 0.99609375 + 0.03125;// * 255/256 + 1/32
  28: }
  29: 
  30: varying vec3 BoxCoord;
  31: varying vec2 BoxLight;
  32: uniform sampler3D uLightVolume;
  33: 
  34: uniform sampler2D uBlockAtlas;
  35: uniform sampler2D uLightMap;
  36: 
  37: vec4 FLWBlockTexture(vec2 texCoords) {
  38:     return texture2D(uBlockAtlas, texCoords);
  39: }
  40: 
  41: void FLWFinalizeColor(vec4 color) {
  42:     #if defined(USE_FOG)
  43:     float a = color.a;
  44:     float fog = clamp(FLWFogFactor(), 0., 1.);
  45: 
  46:     color = mix(uFogColor, color, fog);
  47:     color.a = a;
  48:     #endif
  49: 
  50:     gl_FragColor = color;
  51: }
  52: 
  53: vec4 FLWLight(vec2 lightCoords) {
  54:     lightCoords = max(lightCoords, texture3D(uLightVolume, BoxCoord).rg);
  55: 
  56:     return texture2D(uLightMap, shiftLight(lightCoords));
  57: }
  58: 
  59: 
  60: 
  61: struct BlockFrag {
  62:     vec2 texCoords;
  63:     vec4 color;
  64:     float diffuse;
  65:     vec2 light;
  66: };
  67: 
  68: void FLWMain(BlockFrag r) {
  69:     vec4 tex = FLWBlockTexture(r.texCoords);
  70: 
  71:     vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;
  72: 
  73: //    flw_WorldPos = ;
  74: //    flw_Normal = ;
  75: //    flw_Albedo = tex.rgb;
  76: //    flw_Alpha = tex.a;
  77: //    flw_LightMap = r.light;
  78: //    flw_Tint = r.color;
  79:     FLWFinalizeColor(color);
  80: }
  81: 
  82: varying vec2 v2f_texCoords;
  83: varying vec4 v2f_color;
  84: varying float v2f_diffuse;
  85: varying vec2 v2f_light;
  86: 
  87: 
  88: //vec3 flw_WorldPos;
  89: //vec3 flw_Normal;
  90: //vec3 flw_Albedo;
  91: //float flw_Alpha;
  92: //vec2 flw_LightMap;
  93: //vec4 flw_Tint;
  94: 
  95: void main() {
  96:     BlockFrag f;
  97:     f.texCoords = v2f_texCoords;
  98: f.color = v2f_color;
  99: f.diffuse = v2f_diffuse;
 100: f.light = v2f_light;
 101: 
 102: 
 103:     FLWMain(f);
 104: }

[14:02:44] [main/ERROR]: Shader compilation log for create:rotating.vert: No errors.

[14:02:44] [main/ERROR]: Source for shader 'create:rotating.vert':
   1: #version 110
   2: #define USE_FOG
   3: #define USE_FOG_LINEAR
   4: 
   5: #define PI 3.1415926538
   6: 
   7: #if defined(USE_FOG)
   8: varying float FragDistance;
   9: #endif
  10: 
  11: varying vec3 BoxCoord;
  12: 
  13: uniform vec3 uLightBoxSize;
  14: uniform vec3 uLightBoxMin;
  15: uniform mat4 uModel;
  16: 
  17: uniform float uTime;
  18: uniform mat4 uViewProjection;
  19: uniform vec3 uCameraPos;
  20: 
  21: void FLWFinalizeWorldPos(inout vec4 worldPos) {
  22:     worldPos = uModel * worldPos;
  23: 
  24:     BoxCoord = (worldPos.xyz - uLightBoxMin) / uLightBoxSize;
  25: 
  26:     #if defined(USE_FOG)
  27:     FragDistance = length(worldPos.xyz);
  28:     #endif
  29: 
  30:     gl_Position = uViewProjection * worldPos;
  31: }
  32: 
  33: void FLWFinalizeNormal(inout vec3 normal) {
  34:     mat3 m;
  35:     m[0] = uModel[0].xyz;
  36:     m[1] = uModel[1].xyz;
  37:     m[2] = uModel[2].xyz;
  38:     normal = m * normal;
  39: }
  40: 
  41: 
  42: 
  43: mat4 rotate(vec3 axis, float angle) {
  44:     float s = sin(angle);
  45:     float c = cos(angle);
  46:     float oc = 1. - c;
  47: 
  48:     vec3 sa = axis * s;
  49: 
  50:     mat4 mr = mat4(1.);
  51:     mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
  52:     mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
  53:     mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);
  54: 
  55:     return mr;
  56: }
  57: 
  58: mat4 rotation(vec3 rot) {
  59:     return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
  60: }
  61: 
  62: mat3 modelToNormal(mat4 mat) {
  63:     // Discard the edges. This won't be accurate for scaled or skewed matrices,
  64:     // but we don't have to work with those often.
  65:     mat3 m;
  66:     m[0] = mat[0].xyz;
  67:     m[1] = mat[1].xyz;
  68:     m[2] = mat[2].xyz;
  69:     return m;
  70: }
  71: 
  72: float diffuse(vec3 normal) {
  73:     vec3 n2 = normal * normal * vec3(.6, .25, .8);
  74:     return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
  75: }
  76: 
  77: 
  78: struct Rotating {
  79:     vec2 light;
  80:     vec4 color;
  81:     vec3 pos;
  82:     float speed;
  83:     float offset;
  84:     vec3 axis;
  85: };
  86: 
  87: 
  88: struct Vertex {
  89:     vec3 pos;
  90:     vec3 normal;
  91:     vec2 texCoords;
  92: };
  93: 
  94: struct BlockFrag {
  95:     vec2 texCoords;
  96:     vec4 color;
  97:     float diffuse;
  98:     vec2 light;
  99: };
 100: 
 101: mat4 kineticRotation(float offset, float speed, vec3 axis) {
 102:     float degrees = offset + uTime * speed * 3./10.;
 103:     float angle = fract(degrees / 360.) * PI * 2.;
 104: 
 105:     return rotate(axis, angle);
 106: }
 107: 
 108: BlockFrag FLWMain(Vertex v, Rotating instance) {
 109:     mat4 spin = kineticRotation(instance.offset, instance.speed, instance.axis);
 110: 
 111:     vec4 worldPos = spin * vec4(v.pos - .5, 1.);
 112:     worldPos += vec4(instance.pos + .5, 0.);
 113: 
 114:     vec3 norm = modelToNormal(spin) * v.normal;
 115: 
 116:     FLWFinalizeWorldPos(worldPos);
 117:     FLWFinalizeNormal(norm);
 118: 
 119:     BlockFrag b;
 120:     b.diffuse = diffuse(norm);
 121:     b.texCoords = v.texCoords;
 122:     b.light = instance.light;
 123: 
 124:     #if defined(DEBUG_RAINBOW)
 125:     b.color = instance.color;
 126:     #elif defined(DEBUG_NORMAL)
 127:     b.color = vec4(norm, 1.);
 128:     #else
 129:     b.color = vec4(1.);
 130:     #endif
 131: 
 132:     return b;
 133: }
 134: attribute vec3 a_v_pos;
 135: attribute vec3 a_v_normal;
 136: attribute vec2 a_v_texCoords;
 137: 
 138: attribute vec2 a_i_light;
 139: attribute vec4 a_i_color;
 140: attribute vec3 a_i_pos;
 141: attribute float a_i_speed;
 142: attribute float a_i_offset;
 143: attribute vec3 a_i_axis;
 144: 
 145: 
 146: varying vec2 v2f_texCoords;
 147: varying vec4 v2f_color;
 148: varying float v2f_diffuse;
 149: varying vec2 v2f_light;
 150: 
 151: 
 152: void main() {
 153:     Vertex v;
 154:     v.pos = a_v_pos;
 155: v.normal = a_v_normal;
 156: v.texCoords = a_v_texCoords;
 157: 
 158: 
 159:     Rotating i;
 160:     i.light = a_i_light;
 161: i.color = a_i_color;
 162: i.pos = a_i_pos;
 163: i.speed = a_i_speed;
 164: i.offset = a_i_offset;
 165: i.axis = a_i_axis;
 166: 
 167: 
 168:     BlockFrag o = FLWMain(v, i);
 169: 
 170:     v2f_texCoords = o.texCoords;
 171: v2f_color = o.color;
 172: v2f_diffuse = o.diffuse;
 173: v2f_light = o.light;
 174: 
 175: }

[14:02:44] [main/ERROR]: Shader compilation log for flywheel:block.frag: No errors.

[14:02:44] [main/ERROR]: Source for shader 'flywheel:block.frag':
   1: #version 110
   2: #define USE_FOG
   3: #define USE_FOG_LINEAR
   4: 
   5: #if defined(USE_FOG)
   6: varying float FragDistance;
   7: uniform vec4 uFogColor;
   8: #endif
   9: 
  10: #if defined(USE_FOG_LINEAR)
  11: uniform vec2 uFogRange;
  12: 
  13: float FLWFogFactor() {
  14:     return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
  15: }
  16:     #endif
  17: 
  18:     #if defined(USE_FOG_EXP2)
  19: uniform float uFogDensity;
  20: 
  21: float FLWFogFactor() {
  22:     float dist = FragDistance * uFogDensity;
  23:     return 1. / exp2(dist * dist);
  24: }
  25:     #endif
  26: // Adjust the [0,1] normalized lightmap value based on the texture matrix from LightTexture#enableLightmap
  27: vec2 shiftLight(vec2 lm) {
  28:     return lm * 0.99609375 + 0.03125;// * 255/256 + 1/32
  29: }
  30: 
  31: varying vec3 BoxCoord;
  32: varying vec2 BoxLight;
  33: uniform sampler3D uLightVolume;
  34: 
  35: uniform sampler2D uBlockAtlas;
  36: uniform sampler2D uLightMap;
  37: 
  38: vec4 FLWBlockTexture(vec2 texCoords) {
  39:     return texture2D(uBlockAtlas, texCoords);
  40: }
  41: 
  42: void FLWFinalizeColor(vec4 color) {
  43:     #if defined(USE_FOG)
  44:     float a = color.a;
  45:     float fog = clamp(FLWFogFactor(), 0., 1.);
  46: 
  47:     color = mix(uFogColor, color, fog);
  48:     color.a = a;
  49:     #endif
  50: 
  51:     gl_FragColor = color;
  52: }
  53: 
  54: vec4 FLWLight(vec2 lightCoords) {
  55:     lightCoords = max(lightCoords, texture3D(uLightVolume, BoxCoord).rg);
  56: 
  57:     return texture2D(uLightMap, shiftLight(lightCoords));
  58: }
  59: 
  60: 
  61: 
  62: struct BlockFrag {
  63:     vec2 texCoords;
  64:     vec4 color;
  65:     float diffuse;
  66:     vec2 light;
  67: };
  68: 
  69: void FLWMain(BlockFrag r) {
  70:     vec4 tex = FLWBlockTexture(r.texCoords);
  71: 
  72:     vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;
  73: 
  74: //    flw_WorldPos = ;
  75: //    flw_Normal = ;
  76: //    flw_Albedo = tex.rgb;
  77: //    flw_Alpha = tex.a;
  78: //    flw_LightMap = r.light;
  79: //    flw_Tint = r.color;
  80:     FLWFinalizeColor(color);
  81: }
  82: 
  83: varying vec2 v2f_texCoords;
  84: varying vec4 v2f_color;
  85: varying float v2f_diffuse;
  86: varying vec2 v2f_light;
  87: 
  88: 
  89: //vec3 flw_WorldPos;
  90: //vec3 flw_Normal;
  91: //vec3 flw_Albedo;
  92: //float flw_Alpha;
  93: //vec2 flw_LightMap;
  94: //vec4 flw_Tint;
  95: 
  96: void main() {
  97:     BlockFrag f;
  98:     f.texCoords = v2f_texCoords;
  99: f.color = v2f_color;
 100: f.diffuse = v2f_diffuse;
 101: f.light = v2f_light;
 102: 
 103: 
 104:     FLWMain(f);
 105: }

[14:02:44] [main/ERROR]: Shader compilation log for create:rotating.vert: No errors.

[14:02:44] [main/ERROR]: Source for shader 'create:rotating.vert':
   1: #version 110
   2: #define USE_FOG
   3: #define USE_FOG_EXP2
   4: 
   5: #define PI 3.1415926538
   6: 
   7: #if defined(USE_FOG)
   8: varying float FragDistance;
   9: #endif
  10: 
  11: varying vec3 BoxCoord;
  12: 
  13: uniform vec3 uLightBoxSize;
  14: uniform vec3 uLightBoxMin;
  15: uniform mat4 uModel;
  16: 
  17: uniform float uTime;
  18: uniform mat4 uViewProjection;
  19: uniform vec3 uCameraPos;
  20: 
  21: void FLWFinalizeWorldPos(inout vec4 worldPos) {
  22:     worldPos = uModel * worldPos;
  23: 
  24:     BoxCoord = (worldPos.xyz - uLightBoxMin) / uLightBoxSize;
  25: 
  26:     #if defined(USE_FOG)
  27:     FragDistance = length(worldPos.xyz);
  28:     #endif
  29: 
  30:     gl_Position = uViewProjection * worldPos;
  31: }
  32: 
  33: void FLWFinalizeNormal(inout vec3 normal) {
  34:     mat3 m;
  35:     m[0] = uModel[0].xyz;
  36:     m[1] = uModel[1].xyz;
  37:     m[2] = uModel[2].xyz;
  38:     normal = m * normal;
  39: }
  40: 
  41: 
  42: 
  43: mat4 rotate(vec3 axis, float angle) {
  44:     float s = sin(angle);
  45:     float c = cos(angle);
  46:     float oc = 1. - c;
  47: 
  48:     vec3 sa = axis * s;
  49: 
  50:     mat4 mr = mat4(1.);
  51:     mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
  52:     mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
  53:     mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);
  54: 
  55:     return mr;
  56: }
  57: 
  58: mat4 rotation(vec3 rot) {
  59:     return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
  60: }
  61: 
  62: mat3 modelToNormal(mat4 mat) {
  63:     // Discard the edges. This won't be accurate for scaled or skewed matrices,
  64:     // but we don't have to work with those often.
  65:     mat3 m;
  66:     m[0] = mat[0].xyz;
  67:     m[1] = mat[1].xyz;
  68:     m[2] = mat[2].xyz;
  69:     return m;
  70: }
  71: 
  72: float diffuse(vec3 normal) {
  73:     vec3 n2 = normal * normal * vec3(.6, .25, .8);
  74:     return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
  75: }
  76: 
  77: 
  78: struct Rotating {
  79:     vec2 light;
  80:     vec4 color;
  81:     vec3 pos;
  82:     float speed;
  83:     float offset;
  84:     vec3 axis;
  85: };
  86: 
  87: 
  88: struct Vertex {
  89:     vec3 pos;
  90:     vec3 normal;
  91:     vec2 texCoords;
  92: };
  93: 
  94: struct BlockFrag {
  95:     vec2 texCoords;
  96:     vec4 color;
  97:     float diffuse;
  98:     vec2 light;
  99: };
 100: 
 101: mat4 kineticRotation(float offset, float speed, vec3 axis) {
 102:     float degrees = offset + uTime * speed * 3./10.;
 103:     float angle = fract(degrees / 360.) * PI * 2.;
 104: 
 105:     return rotate(axis, angle);
 106: }
 107: 
 108: BlockFrag FLWMain(Vertex v, Rotating instance) {
 109:     mat4 spin = kineticRotation(instance.offset, instance.speed, instance.axis);
 110: 
 111:     vec4 worldPos = spin * vec4(v.pos - .5, 1.);
 112:     worldPos += vec4(instance.pos + .5, 0.);
 113: 
 114:     vec3 norm = modelToNormal(spin) * v.normal;
 115: 
 116:     FLWFinalizeWorldPos(worldPos);
 117:     FLWFinalizeNormal(norm);
 118: 
 119:     BlockFrag b;
 120:     b.diffuse = diffuse(norm);
 121:     b.texCoords = v.texCoords;
 122:     b.light = instance.light;
 123: 
 124:     #if defined(DEBUG_RAINBOW)
 125:     b.color = instance.color;
 126:     #elif defined(DEBUG_NORMAL)
 127:     b.color = vec4(norm, 1.);
 128:     #else
 129:     b.color = vec4(1.);
 130:     #endif
 131: 
 132:     return b;
 133: }
 134: attribute vec3 a_v_pos;
 135: attribute vec3 a_v_normal;
 136: attribute vec2 a_v_texCoords;
 137: 
 138: attribute vec2 a_i_light;
 139: attribute vec4 a_i_color;
 140: attribute vec3 a_i_pos;
 141: attribute float a_i_speed;
 142: attribute float a_i_offset;
 143: attribute vec3 a_i_axis;
 144: 
 145: 
 146: varying vec2 v2f_texCoords;
 147: varying vec4 v2f_color;
 148: varying float v2f_diffuse;
 149: varying vec2 v2f_light;
 150: 
 151: 
 152: void main() {
 153:     Vertex v;
 154:     v.pos = a_v_pos;
 155: v.normal = a_v_normal;
 156: v.texCoords = a_v_texCoords;
 157: 
 158: 
 159:     Rotating i;
 160:     i.light = a_i_light;
 161: i.color = a_i_color;
 162: i.pos = a_i_pos;
 163: i.speed = a_i_speed;
 164: i.offset = a_i_offset;
 165: i.axis = a_i_axis;
 166: 
 167: 
 168:     BlockFrag o = FLWMain(v, i);
 169: 
 170:     v2f_texCoords = o.texCoords;
 171: v2f_color = o.color;
 172: v2f_diffuse = o.diffuse;
 173: v2f_light = o.light;
 174: 
 175: }

[14:02:44] [main/ERROR]: Shader compilation log for flywheel:block.frag: No errors.

[14:02:44] [main/ERROR]: Source for shader 'flywheel:block.frag':
   1: #version 110
   2: #define USE_FOG
   3: #define USE_FOG_EXP2
   4: 
   5: #if defined(USE_FOG)
   6: varying float FragDistance;
   7: uniform vec4 uFogColor;
   8: #endif
   9: 
  10: #if defined(USE_FOG_LINEAR)
  11: uniform vec2 uFogRange;
  12: 
  13: float FLWFogFactor() {
  14:     return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
  15: }
  16:     #endif
  17: 
  18:     #if defined(USE_FOG_EXP2)
  19: uniform float uFogDensity;
  20: 
  21: float FLWFogFactor() {
  22:     float dist = FragDistance * uFogDensity;
  23:     return 1. / exp2(dist * dist);
  24: }
  25:     #endif
  26: // Adjust the [0,1] normalized lightmap value based on the texture matrix from LightTexture#enableLightmap
  27: vec2 shiftLight(vec2 lm) {
  28:     return lm * 0.99609375 + 0.03125;// * 255/256 + 1/32
  29: }
  30: 
  31: varying vec3 BoxCoord;
  32: varying vec2 BoxLight;
  33: uniform sampler3D uLightVolume;
  34: 
  35: uniform sampler2D uBlockAtlas;
  36: uniform sampler2D uLightMap;
  37: 
  38: vec4 FLWBlockTexture(vec2 texCoords) {
  39:     return texture2D(uBlockAtlas, texCoords);
  40: }
  41: 
  42: void FLWFinalizeColor(vec4 color) {
  43:     #if defined(USE_FOG)
  44:     float a = color.a;
  45:     float fog = clamp(FLWFogFactor(), 0., 1.);
  46: 
  47:     color = mix(uFogColor, color, fog);
  48:     color.a = a;
  49:     #endif
  50: 
  51:     gl_FragColor = color;
  52: }
  53: 
  54: vec4 FLWLight(vec2 lightCoords) {
  55:     lightCoords = max(lightCoords, texture3D(uLightVolume, BoxCoord).rg);
  56: 
  57:     return texture2D(uLightMap, shiftLight(lightCoords));
  58: }
  59: 
  60: 
  61: 
  62: struct BlockFrag {
  63:     vec2 texCoords;
  64:     vec4 color;
  65:     float diffuse;
  66:     vec2 light;
  67: };
  68: 
  69: void FLWMain(BlockFrag r) {
  70:     vec4 tex = FLWBlockTexture(r.texCoords);
  71: 
  72:     vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;
  73: 
  74: //    flw_WorldPos = ;
  75: //    flw_Normal = ;
  76: //    flw_Albedo = tex.rgb;
  77: //    flw_Alpha = tex.a;
  78: //    flw_LightMap = r.light;
  79: //    flw_Tint = r.color;
  80:     FLWFinalizeColor(color);
  81: }
  82: 
  83: varying vec2 v2f_texCoords;
  84: varying vec4 v2f_color;
  85: varying float v2f_diffuse;
  86: varying vec2 v2f_light;
  87: 
  88: 
  89: //vec3 flw_WorldPos;
  90: //vec3 flw_Normal;
  91: //vec3 flw_Albedo;
  92: //float flw_Alpha;
  93: //vec2 flw_LightMap;
  94: //vec4 flw_Tint;
  95: 
  96: void main() {
  97:     BlockFrag f;
  98:     f.texCoords = v2f_texCoords;
  99: f.color = v2f_color;
 100: f.diffuse = v2f_diffuse;
 101: f.light = v2f_light;
 102: 
 103: 
 104:     FLWMain(f);
 105: }

[14:02:44] [main/ERROR]: Shader compilation log for create:rotating.vert: No errors.

[14:02:44] [main/ERROR]: Source for shader 'create:rotating.vert':
   1: #version 110
   2: 
   3: #define PI 3.1415926538
   4: 
   5: #if defined(USE_FOG)
   6: varying float FragDistance;
   7: #endif
   8: 
   9: varying vec3 BoxCoord;
  10: 
  11: uniform vec3 uLightBoxSize;
  12: uniform vec3 uLightBoxMin;
  13: uniform mat4 uModel;
  14: 
  15: uniform float uTime;
  16: uniform mat4 uViewProjection;
  17: uniform vec3 uCameraPos;
  18: 
  19: void FLWFinalizeWorldPos(inout vec4 worldPos) {
  20:     worldPos = uModel * worldPos;
  21: 
  22:     BoxCoord = (worldPos.xyz - uLightBoxMin) / uLightBoxSize;
  23: 
  24:     #if defined(USE_FOG)
  25:     FragDistance = length(worldPos.xyz);
  26:     #endif
  27: 
  28:     gl_Position = uViewProjection * worldPos;
  29: }
  30: 
  31: void FLWFinalizeNormal(inout vec3 normal) {
  32:     mat3 m;
  33:     m[0] = uModel[0].xyz;
  34:     m[1] = uModel[1].xyz;
  35:     m[2] = uModel[2].xyz;
  36:     normal = m * normal;
  37: }
  38: 
  39: 
  40: 
  41: mat4 rotate(vec3 axis, float angle) {
  42:     float s = sin(angle);
  43:     float c = cos(angle);
  44:     float oc = 1. - c;
  45: 
  46:     vec3 sa = axis * s;
  47: 
  48:     mat4 mr = mat4(1.);
  49:     mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
  50:     mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
  51:     mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);
  52: 
  53:     return mr;
  54: }
  55: 
  56: mat4 rotation(vec3 rot) {
  57:     return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
  58: }
  59: 
  60: mat3 modelToNormal(mat4 mat) {
  61:     // Discard the edges. This won't be accurate for scaled or skewed matrices,
  62:     // but we don't have to work with those often.
  63:     mat3 m;
  64:     m[0] = mat[0].xyz;
  65:     m[1] = mat[1].xyz;
  66:     m[2] = mat[2].xyz;
  67:     return m;
  68: }
  69: 
  70: float diffuse(vec3 normal) {
  71:     vec3 n2 = normal * normal * vec3(.6, .25, .8);
  72:     return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
  73: }
  74: 
  75: 
  76: struct Rotating {
  77:     vec2 light;
  78:     vec4 color;
  79:     vec3 pos;
  80:     float speed;
  81:     float offset;
  82:     vec3 axis;
  83: };
  84: 
  85: 
  86: struct Vertex {
  87:     vec3 pos;
  88:     vec3 normal;
  89:     vec2 texCoords;
  90: };
  91: 
  92: struct BlockFrag {
  93:     vec2 texCoords;
  94:     vec4 color;
  95:     float diffuse;
  96:     vec2 light;
  97: };
  98: 
  99: mat4 kineticRotation(float offset, float speed, vec3 axis) {
 100:     float degrees = offset + uTime * speed * 3./10.;
 101:     float angle = fract(degrees / 360.) * PI * 2.;
 102: 
 103:     return rotate(axis, angle);
 104: }
 105: 
 106: BlockFrag FLWMain(Vertex v, Rotating instance) {
 107:     mat4 spin = kineticRotation(instance.offset, instance.speed, instance.axis);
 108: 
 109:     vec4 worldPos = spin * vec4(v.pos - .5, 1.);
 110:     worldPos += vec4(instance.pos + .5, 0.);
 111: 
 112:     vec3 norm = modelToNormal(spin) * v.normal;
 113: 
 114:     FLWFinalizeWorldPos(worldPos);
 115:     FLWFinalizeNormal(norm);
 116: 
 117:     BlockFrag b;
 118:     b.diffuse = diffuse(norm);
 119:     b.texCoords = v.texCoords;
 120:     b.light = instance.light;
 121: 
 122:     #if defined(DEBUG_RAINBOW)
 123:     b.color = instance.color;
 124:     #elif defined(DEBUG_NORMAL)
 125:     b.color = vec4(norm, 1.);
 126:     #else
 127:     b.color = vec4(1.);
 128:     #endif
 129: 
 130:     return b;
 131: }
 132: attribute vec3 a_v_pos;
 133: attribute vec3 a_v_normal;
 134: attribute vec2 a_v_texCoords;
 135: 
 136: attribute vec2 a_i_light;
 137: attribute vec4 a_i_color;
 138: attribute vec3 a_i_pos;
 139: attribute float a_i_speed;
 140: attribute float a_i_offset;
 141: attribute vec3 a_i_axis;
 142: 
 143: 
 144: varying vec2 v2f_texCoords;
 145: varying vec4 v2f_color;
 146: varying float v2f_diffuse;
 147: varying vec2 v2f_light;
 148: 
 149: 
 150: void main() {
 151:     Vertex v;
 152:     v.pos = a_v_pos;
 153: v.normal = a_v_normal;
 154: v.texCoords = a_v_texCoords;
 155: 
 156: 
 157:     Rotating i;
 158:     i.light = a_i_light;
 159: i.color = a_i_color;
 160: i.pos = a_i_pos;
 161: i.speed = a_i_speed;
 162: i.offset = a_i_offset;
 163: i.axis = a_i_axis;
 164: 
 165: 
 166:     BlockFrag o = FLWMain(v, i);
 167: 
 168:     v2f_texCoords = o.texCoords;
 169: v2f_color = o.color;
 170: v2f_diffuse = o.diffuse;
 171: v2f_light = o.light;
 172: 
 173: }

[14:02:44] [main/ERROR]: Shader compilation log for flywheel:block.frag: No errors.

[14:02:44] [main/ERROR]: Source for shader 'flywheel:block.frag':
   1: #version 110
   2: 
   3: #if defined(USE_FOG)
   4: varying float FragDistance;
   5: uniform vec4 uFogColor;
   6: #endif
   7: 
   8: #if defined(USE_FOG_LINEAR)
   9: uniform vec2 uFogRange;
  10: 
  11: float FLWFogFactor() {
  12:     return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
  13: }
  14:     #endif
  15: 
  16:     #if defined(USE_FOG_EXP2)
  17: uniform float uFogDensity;
  18: 
  19: float FLWFogFactor() {
  20:     float dist = FragDistance * uFogDensity;
  21:     return 1. / exp2(dist * dist);
  22: }
  23:     #endif
  24: // Adjust the [0,1] normalized lightmap value based on the texture matrix from LightTexture#enableLightmap
  25: vec2 shiftLight(vec2 lm) {
  26:     return lm * 0.99609375 + 0.03125;// * 255/256 + 1/32
  27: }
  28: 
  29: varying vec3 BoxCoord;
  30: varying vec2 BoxLight;
  31: uniform sampler3D uLightVolume;
  32: 
  33: uniform sampler2D uBlockAtlas;
  34: uniform sampler2D uLightMap;
  35: 
  36: vec4 FLWBlockTexture(vec2 texCoords) {
  37:     return texture2D(uBlockAtlas, texCoords);
  38: }
  39: 
  40: void FLWFinalizeColor(vec4 color) {
  41:     #if defined(USE_FOG)
  42:     float a = color.a;
  43:     float fog = clamp(FLWFogFactor(), 0., 1.);
  44: 
  45:     color = mix(uFogColor, color, fog);
  46:     color.a = a;
  47:     #endif
  48: 
  49:     gl_FragColor = color;
  50: }
  51: 
  52: vec4 FLWLight(vec2 lightCoords) {
  53:     lightCoords = max(lightCoords, texture3D(uLightVolume, BoxCoord).rg);
  54: 
  55:     return texture2D(uLightMap, shiftLight(lightCoords));
  56: }
  57: 
  58: 
  59: 
  60: struct BlockFrag {
  61:     vec2 texCoords;
  62:     vec4 color;
  63:     float diffuse;
  64:     vec2 light;
  65: };
  66: 
  67: void FLWMain(BlockFrag r) {
  68:     vec4 tex = FLWBlockTexture(r.texCoords);
  69: 
  70:     vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;
  71: 
  72: //    flw_WorldPos = ;
  73: //    flw_Normal = ;
  74: //    flw_Albedo = tex.rgb;
  75: //    flw_Alpha = tex.a;
  76: //    flw_LightMap = r.light;
  77: //    flw_Tint = r.color;
  78:     FLWFinalizeColor(color);
  79: }
  80: 
  81: varying vec2 v2f_texCoords;
  82: varying vec4 v2f_color;
  83: varying float v2f_diffuse;
  84: varying vec2 v2f_light;
  85: 
  86: 
  87: //vec3 flw_WorldPos;
  88: //vec3 flw_Normal;
  89: //vec3 flw_Albedo;
  90: //float flw_Alpha;
  91: //vec2 flw_LightMap;
  92: //vec4 flw_Tint;
  93: 
  94: void main() {
  95:     BlockFrag f;
  96:     f.texCoords = v2f_texCoords;
  97: f.color = v2f_color;
  98: f.diffuse = v2f_diffuse;
  99: f.light = v2f_light;
 100: 
 101: 
 102:     FLWMain(f);
 103: }

[14:02:44] [main/ERROR]: Shader compilation log for create:contraption_actor.vert: No errors.

[14:02:44] [main/ERROR]: Source for shader 'create:contraption_actor.vert':
   1: #version 110
   2: #define DEBUG_NORMAL
   3: 
   4: #define PI 3.1415926538
   5: 
   6: #if defined(USE_FOG)
   7: varying float FragDistance;
   8: #endif
   9: 
  10: varying vec3 BoxCoord;
  11: 
  12: uniform vec3 uLightBoxSize;
  13: uniform vec3 uLightBoxMin;
  14: uniform mat4 uModel;
  15: 
  16: uniform float uTime;
  17: uniform mat4 uViewProjection;
  18: uniform vec3 uCameraPos;
  19: 
  20: void FLWFinalizeWorldPos(inout vec4 worldPos) {
  21:     worldPos = uModel * worldPos;
  22: 
  23:     BoxCoord = (worldPos.xyz - uLightBoxMin) / uLightBoxSize;
  24: 
  25:     #if defined(USE_FOG)
  26:     FragDistance = length(worldPos.xyz);
  27:     #endif
  28: 
  29:     gl_Position = uViewProjection * worldPos;
  30: }
  31: 
  32: void FLWFinalizeNormal(inout vec3 normal) {
  33:     mat3 m;
  34:     m[0] = uModel[0].xyz;
  35:     m[1] = uModel[1].xyz;
  36:     m[2] = uModel[2].xyz;
  37:     normal = m * normal;
  38: }
  39: 
  40: 
  41: 
  42: mat4 rotate(vec3 axis, float angle) {
  43:     float s = sin(angle);
  44:     float c = cos(angle);
  45:     float oc = 1. - c;
  46: 
  47:     vec3 sa = axis * s;
  48: 
  49:     mat4 mr = mat4(1.);
  50:     mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
  51:     mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
  52:     mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);
  53: 
  54:     return mr;
  55: }
  56: 
  57: mat4 rotation(vec3 rot) {
  58:     return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
  59: }
  60: 
  61: mat3 modelToNormal(mat4 mat) {
  62:     // Discard the edges. This won't be accurate for scaled or skewed matrices,
  63:     // but we don't have to work with those often.
  64:     mat3 m;
  65:     m[0] = mat[0].xyz;
  66:     m[1] = mat[1].xyz;
  67:     m[2] = mat[2].xyz;
  68:     return m;
  69: }
  70: 
  71: #define PIOVER2 1.5707963268
  72: 
  73: vec4 quat(vec3 axis, float angle) {
  74:     float halfAngle = angle * PIOVER2 / 180.0;
  75:     vec2 cs = sin(vec2(PIOVER2 - halfAngle, halfAngle)); // compute sin and cos in one instruction
  76:     return vec4(axis.xyz * cs.y,  cs.x);
  77: }
  78: 
  79: vec4 quatMult(vec4 q1, vec4 q2) {
  80:     // disgustingly vectorized quaternion multiplication
  81:     vec4 a = q1.w * q2.xyzw;
  82:     vec4 b = q1.x * q2.wzxy * vec4(1., -1., 1., -1.);
  83:     vec4 c = q1.y * q2.zwxy * vec4(1., 1., -1., -1.);
  84:     vec4 d = q1.z * q2.yxwz * vec4(-1., 1., 1., -1.);
  85: 
  86:     return a + b + c + d;
  87: }
  88: 
  89: vec3 rotateVertexByQuat(vec3 v, vec4 q) {
  90:     vec3 i = q.xyz;
  91:     return v + 2.0 * cross(i, cross(i, v) + q.w * v);
  92: }
  93: 
  94: vec3 rotateAbout(vec3 v, vec3 axis, float angle) {
  95:     return rotateVertexByQuat(v, quat(axis, angle));
  96: }
  97: 
  98: float diffuse(vec3 normal) {
  99:     vec3 n2 = normal * normal * vec3(.6, .25, .8);
 100:     return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
 101: }
 102: 
 103: 
 104: struct Actor {
 105:     vec3 pos;
 106:     vec2 light;
 107:     float offset;
 108:     vec3 axis;
 109:     vec4 rotation;
 110:     vec3 rotationCenter;
 111:     float speed;
 112: };
 113: 
 114: 
 115: struct Vertex {
 116:     vec3 pos;
 117:     vec3 normal;
 118:     vec2 texCoords;
 119: };
 120: 
 121: struct BlockFrag {
 122:     vec2 texCoords;
 123:     vec4 color;
 124:     float diffuse;
 125:     vec2 light;
 126: };
 127: 
 128: BlockFrag FLWMain(Vertex v, Actor instance) {
 129:     float degrees = instance.offset + uTime * instance.speed / 20.;
 130:     //float angle = fract(degrees / 360.) * PI * 2.;
 131: 
 132:     vec4 kineticRot = quat(instance.axis, degrees);
 133:     vec3 rotated = rotateVertexByQuat(v.pos - instance.rotationCenter, kineticRot) + instance.rotationCenter;
 134: 
 135:     vec4 worldPos = vec4(rotateVertexByQuat(rotated - .5, instance.rotation) + instance.pos + .5, 1.);
 136:     vec3 norm = rotateVertexByQuat(rotateVertexByQuat(v.normal, kineticRot), instance.rotation);
 137: 
 138:     FLWFinalizeWorldPos(worldPos);
 139:     FLWFinalizeNormal(norm);
 140: 
 141:     BlockFrag b;
 142:     b.diffuse = diffuse(norm);
 143:     b.texCoords = v.texCoords;
 144:     b.light = instance.light;
 145: 
 146:     #if defined(DEBUG_NORMAL)
 147:     b.color = vec4(norm, 1.);
 148:     #else
 149:     b.color = vec4(1.);
 150:     #endif
 151: 
 152:     return b;
 153: }
 154: attribute vec3 a_v_pos;
 155: attribute vec3 a_v_normal;
 156: attribute vec2 a_v_texCoords;
 157: 
 158: attribute vec3 a_i_pos;
 159: attribute vec2 a_i_light;
 160: attribute float a_i_offset;
 161: attribute vec3 a_i_axis;
 162: attribute vec4 a_i_rotation;
 163: attribute vec3 a_i_rotationCenter;
 164: attribute float a_i_speed;
 165: 
 166: 
 167: varying vec2 v2f_texCoords;
 168: varying vec4 v2f_color;
 169: varying float v2f_diffuse;
 170: varying vec2 v2f_light;
 171: 
 172: 
 173: void main() {
 174:     Vertex v;
 175:     v.pos = a_v_pos;
 176: v.normal = a_v_normal;
 177: v.texCoords = a_v_texCoords;
 178: 
 179: 
 180:     Actor i;
 181:     i.pos = a_i_pos;
 182: i.light = a_i_light;
 183: i.offset = a_i_offset;
 184: i.axis = a_i_axis;
 185: i.rotation = a_i_rotation;
 186: i.rotationCenter = a_i_rotationCenter;
 187: i.speed = a_i_speed;
 188: 
 189: 
 190:     BlockFrag o = FLWMain(v, i);
 191: 
 192:     v2f_texCoords = o.texCoords;
 193: v2f_color = o.color;
 194: v2f_diffuse = o.diffuse;
 195: v2f_light = o.light;
 196: 
 197: }

[14:02:44] [main/ERROR]: Shader compilation log for flywheel:block.frag: No errors.

[14:02:44] [main/ERROR]: Source for shader 'flywheel:block.frag':
   1: #version 110
   2: #define DEBUG_NORMAL
   3: 
   4: #if defined(USE_FOG)
   5: varying float FragDistance;
   6: uniform vec4 uFogColor;
   7: #endif
   8: 
   9: #if defined(USE_FOG_LINEAR)
  10: uniform vec2 uFogRange;
  11: 
  12: float FLWFogFactor() {
  13:     return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
  14: }
  15:     #endif
  16: 
  17:     #if defined(USE_FOG_EXP2)
  18: uniform float uFogDensity;
  19: 
  20: float FLWFogFactor() {
  21:     float dist = FragDistance * uFogDensity;
  22:     return 1. / exp2(dist * dist);
  23: }
  24:     #endif
  25: // Adjust the [0,1] normalized lightmap value based on the texture matrix from LightTexture#enableLightmap
  26: vec2 shiftLight(vec2 lm) {
  27:     return lm * 0.99609375 + 0.03125;// * 255/256 + 1/32
  28: }
  29: 
  30: varying vec3 BoxCoord;
  31: varying vec2 BoxLight;
  32: uniform sampler3D uLightVolume;
  33: 
  34: uniform sampler2D uBlockAtlas;
  35: uniform sampler2D uLightMap;
  36: 
  37: vec4 FLWBlockTexture(vec2 texCoords) {
  38:     return texture2D(uBlockAtlas, texCoords);
  39: }
  40: 
  41: void FLWFinalizeColor(vec4 color) {
  42:     #if defined(USE_FOG)
  43:     float a = color.a;
  44:     float fog = clamp(FLWFogFactor(), 0., 1.);
  45: 
  46:     color = mix(uFogColor, color, fog);
  47:     color.a = a;
  48:     #endif
  49: 
  50:     gl_FragColor = color;
  51: }
  52: 
  53: vec4 FLWLight(vec2 lightCoords) {
  54:     lightCoords = max(lightCoords, texture3D(uLightVolume, BoxCoord).rg);
  55: 
  56:     return texture2D(uLightMap, shiftLight(lightCoords));
  57: }
  58: 
  59: 
  60: 
  61: struct BlockFrag {
  62:     vec2 texCoords;
  63:     vec4 color;
  64:     float diffuse;
  65:     vec2 light;
  66: };
  67: 
  68: void FLWMain(BlockFrag r) {
  69:     vec4 tex = FLWBlockTexture(r.texCoords);
  70: 
  71:     vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;
  72: 
  73: //    flw_WorldPos = ;
  74: //    flw_Normal = ;
  75: //    flw_Albedo = tex.rgb;
  76: //    flw_Alpha = tex.a;
  77: //    flw_LightMap = r.light;
  78: //    flw_Tint = r.color;
  79:     FLWFinalizeColor(color);
  80: }
  81: 
  82: varying vec2 v2f_texCoords;
  83: varying vec4 v2f_color;
  84: varying float v2f_diffuse;
  85: varying vec2 v2f_light;
  86: 
  87: 
  88: //vec3 flw_WorldPos;
  89: //vec3 flw_Normal;
  90: //vec3 flw_Albedo;
  91: //float flw_Alpha;
  92: //vec2 flw_LightMap;
  93: //vec4 flw_Tint;
  94: 
  95: void main() {
  96:     BlockFrag f;
  97:     f.texCoords = v2f_texCoords;
  98: f.color = v2f_color;
  99: f.diffuse = v2f_diffuse;
 100: f.light = v2f_light;
 101: 
 102: 
 103:     FLWMain(f);
 104: }

[14:02:44] [main/ERROR]: Shader compilation log for create:contraption_actor.vert: No errors.

[14:02:44] [main/ERROR]: Source for shader 'create:contraption_actor.vert':
   1: #version 110
   2: #define USE_FOG
   3: #define USE_FOG_LINEAR
   4: 
   5: #define PI 3.1415926538
   6: 
   7: #if defined(USE_FOG)
   8: varying float FragDistance;
   9: #endif
  10: 
  11: varying vec3 BoxCoord;
  12: 
  13: uniform vec3 uLightBoxSize;
  14: uniform vec3 uLightBoxMin;
  15: uniform mat4 uModel;
  16: 
  17: uniform float uTime;
  18: uniform mat4 uViewProjection;
  19: uniform vec3 uCameraPos;
  20: 
  21: void FLWFinalizeWorldPos(inout vec4 worldPos) {
  22:     worldPos = uModel * worldPos;
  23: 
  24:     BoxCoord = (worldPos.xyz - uLightBoxMin) / uLightBoxSize;
  25: 
  26:     #if defined(USE_FOG)
  27:     FragDistance = length(worldPos.xyz);
  28:     #endif
  29: 
  30:     gl_Position = uViewProjection * worldPos;
  31: }
  32: 
  33: void FLWFinalizeNormal(inout vec3 normal) {
  34:     mat3 m;
  35:     m[0] = uModel[0].xyz;
  36:     m[1] = uModel[1].xyz;
  37:     m[2] = uModel[2].xyz;
  38:     normal = m * normal;
  39: }
  40: 
  41: 
  42: 
  43: mat4 rotate(vec3 axis, float angle) {
  44:     float s = sin(angle);
  45:     float c = cos(angle);
  46:     float oc = 1. - c;
  47: 
  48:     vec3 sa = axis * s;
  49: 
  50:     mat4 mr = mat4(1.);
  51:     mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
  52:     mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
  53:     mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);
  54: 
  55:     return mr;
  56: }
  57: 
  58: mat4 rotation(vec3 rot) {
  59:     return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
  60: }
  61: 
  62: mat3 modelToNormal(mat4 mat) {
  63:     // Discard the edges. This won't be accurate for scaled or skewed matrices,
  64:     // but we don't have to work with those often.
  65:     mat3 m;
  66:     m[0] = mat[0].xyz;
  67:     m[1] = mat[1].xyz;
  68:     m[2] = mat[2].xyz;
  69:     return m;
  70: }
  71: 
  72: #define PIOVER2 1.5707963268
  73: 
  74: vec4 quat(vec3 axis, float angle) {
  75:     float halfAngle = angle * PIOVER2 / 180.0;
  76:     vec2 cs = sin(vec2(PIOVER2 - halfAngle, halfAngle)); // compute sin and cos in one instruction
  77:     return vec4(axis.xyz * cs.y,  cs.x);
  78: }
  79: 
  80: vec4 quatMult(vec4 q1, vec4 q2) {
  81:     // disgustingly vectorized quaternion multiplication
  82:     vec4 a = q1.w * q2.xyzw;
  83:     vec4 b = q1.x * q2.wzxy * vec4(1., -1., 1., -1.);
  84:     vec4 c = q1.y * q2.zwxy * vec4(1., 1., -1., -1.);
  85:     vec4 d = q1.z * q2.yxwz * vec4(-1., 1., 1., -1.);
  86: 
  87:     return a + b + c + d;
  88: }
  89: 
  90: vec3 rotateVertexByQuat(vec3 v, vec4 q) {
  91:     vec3 i = q.xyz;
  92:     return v + 2.0 * cross(i, cross(i, v) + q.w * v);
  93: }
  94: 
  95: vec3 rotateAbout(vec3 v, vec3 axis, float angle) {
  96:     return rotateVertexByQuat(v, quat(axis, angle));
  97: }
  98: 
  99: float diffuse(vec3 normal) {
 100:     vec3 n2 = normal * normal * vec3(.6, .25, .8);
 101:     return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
 102: }
 103: 
 104: 
 105: struct Actor {
 106:     vec3 pos;
 107:     vec2 light;
 108:     float offset;
 109:     vec3 axis;
 110:     vec4 rotation;
 111:     vec3 rotationCenter;
 112:     float speed;
 113: };
 114: 
 115: 
 116: struct Vertex {
 117:     vec3 pos;
 118:     vec3 normal;
 119:     vec2 texCoords;
 120: };
 121: 
 122: struct BlockFrag {
 123:     vec2 texCoords;
 124:     vec4 color;
 125:     float diffuse;
 126:     vec2 light;
 127: };
 128: 
 129: BlockFrag FLWMain(Vertex v, Actor instance) {
 130:     float degrees = instance.offset + uTime * instance.speed / 20.;
 131:     //float angle = fract(degrees / 360.) * PI * 2.;
 132: 
 133:     vec4 kineticRot = quat(instance.axis, degrees);
 134:     vec3 rotated = rotateVertexByQuat(v.pos - instance.rotationCenter, kineticRot) + instance.rotationCenter;
 135: 
 136:     vec4 worldPos = vec4(rotateVertexByQuat(rotated - .5, instance.rotation) + instance.pos + .5, 1.);
 137:     vec3 norm = rotateVertexByQuat(rotateVertexByQuat(v.normal, kineticRot), instance.rotation);
 138: 
 139:     FLWFinalizeWorldPos(worldPos);
 140:     FLWFinalizeNormal(norm);
 141: 
 142:     BlockFrag b;
 143:     b.diffuse = diffuse(norm);
 144:     b.texCoords = v.texCoords;
 145:     b.light = instance.light;
 146: 
 147:     #if defined(DEBUG_NORMAL)
 148:     b.color = vec4(norm, 1.);
 149:     #else
 150:     b.color = vec4(1.);
 151:     #endif
 152: 
 153:     return b;
 154: }
 155: attribute vec3 a_v_pos;
 156: attribute vec3 a_v_normal;
 157: attribute vec2 a_v_texCoords;
 158: 
 159: attribute vec3 a_i_pos;
 160: attribute vec2 a_i_light;
 161: attribute float a_i_offset;
 162: attribute vec3 a_i_axis;
 163: attribute vec4 a_i_rotation;
 164: attribute vec3 a_i_rotationCenter;
 165: attribute float a_i_speed;
 166: 
 167: 
 168: varying vec2 v2f_texCoords;
 169: varying vec4 v2f_color;
 170: varying float v2f_diffuse;
 171: varying vec2 v2f_light;
 172: 
 173: 
 174: void main() {
 175:     Vertex v;
 176:     v.pos = a_v_pos;
 177: v.normal = a_v_normal;
 178: v.texCoords = a_v_texCoords;
 179: 
 180: 
 181:     Actor i;
 182:     i.pos = a_i_pos;
 183: i.light = a_i_light;
 184: i.offset = a_i_offset;
 185: i.axis = a_i_axis;
 186: i.rotation = a_i_rotation;
 187: i.rotationCenter = a_i_rotationCenter;
 188: i.speed = a_i_speed;
 189: 
 190: 
 191:     BlockFrag o = FLWMain(v, i);
 192: 
 193:     v2f_texCoords = o.texCoords;
 194: v2f_color = o.color;
 195: v2f_diffuse = o.diffuse;
 196: v2f_light = o.light;
 197: 
 198: }

[14:02:44] [main/ERROR]: Shader compilation log for flywheel:block.frag: No errors.

[14:02:44] [main/ERROR]: Source for shader 'flywheel:block.frag':
   1: #version 110
   2: #define USE_FOG
   3: #define USE_FOG_LINEAR
   4: 
   5: #if defined(USE_FOG)
   6: varying float FragDistance;
   7: uniform vec4 uFogColor;
   8: #endif
   9: 
  10: #if defined(USE_FOG_LINEAR)
  11: uniform vec2 uFogRange;
  12: 
  13: float FLWFogFactor() {
  14:     return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
  15: }
  16:     #endif
  17: 
  18:     #if defined(USE_FOG_EXP2)
  19: uniform float uFogDensity;
  20: 
  21: float FLWFogFactor() {
  22:     float dist = FragDistance * uFogDensity;
  23:     return 1. / exp2(dist * dist);
  24: }
  25:     #endif
  26: // Adjust the [0,1] normalized lightmap value based on the texture matrix from LightTexture#enableLightmap
  27: vec2 shiftLight(vec2 lm) {
  28:     return lm * 0.99609375 + 0.03125;// * 255/256 + 1/32
  29: }
  30: 
  31: varying vec3 BoxCoord;
  32: varying vec2 BoxLight;
  33: uniform sampler3D uLightVolume;
  34: 
  35: uniform sampler2D uBlockAtlas;
  36: uniform sampler2D uLightMap;
  37: 
  38: vec4 FLWBlockTexture(vec2 texCoords) {
  39:     return texture2D(uBlockAtlas, texCoords);
  40: }
  41: 
  42: void FLWFinalizeColor(vec4 color) {
  43:     #if defined(USE_FOG)
  44:     float a = color.a;
  45:     float fog = clamp(FLWFogFactor(), 0., 1.);
  46: 
  47:     color = mix(uFogColor, color, fog);
  48:     color.a = a;
  49:     #endif
  50: 
  51:     gl_FragColor = color;
  52: }
  53: 
  54: vec4 FLWLight(vec2 lightCoords) {
  55:     lightCoords = max(lightCoords, texture3D(uLightVolume, BoxCoord).rg);
  56: 
  57:     return texture2D(uLightMap, shiftLight(lightCoords));
  58: }
  59: 
  60: 
  61: 
  62: struct BlockFrag {
  63:     vec2 texCoords;
  64:     vec4 color;
  65:     float diffuse;
  66:     vec2 light;
  67: };
  68: 
  69: void FLWMain(BlockFrag r) {
  70:     vec4 tex = FLWBlockTexture(r.texCoords);
  71: 
  72:     vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;
  73: 
  74: //    flw_WorldPos = ;
  75: //    flw_Normal = ;
  76: //    flw_Albedo = tex.rgb;
  77: //    flw_Alpha = tex.a;
  78: //    flw_LightMap = r.light;
  79: //    flw_Tint = r.color;
  80:     FLWFinalizeColor(color);
  81: }
  82: 
  83: varying vec2 v2f_texCoords;
  84: varying vec4 v2f_color;
  85: varying float v2f_diffuse;
  86: varying vec2 v2f_light;
  87: 
  88: 
  89: //vec3 flw_WorldPos;
  90: //vec3 flw_Normal;
  91: //vec3 flw_Albedo;
  92: //float flw_Alpha;
  93: //vec2 flw_LightMap;
  94: //vec4 flw_Tint;
  95: 
  96: void main() {
  97:     BlockFrag f;
  98:     f.texCoords = v2f_texCoords;
  99: f.color = v2f_color;
 100: f.diffuse = v2f_diffuse;
 101: f.light = v2f_light;
 102: 
 103: 
 104:     FLWMain(f);
 105: }

[14:02:44] [main/ERROR]: Shader compilation log for create:contraption_actor.vert: No errors.

[14:02:44] [main/ERROR]: Source for shader 'create:contraption_actor.vert':
   1: #version 110
   2: #define USE_FOG
   3: #define USE_FOG_EXP2
   4: 
   5: #define PI 3.1415926538
   6: 
   7: #if defined(USE_FOG)
   8: varying float FragDistance;
   9: #endif
  10: 
  11: varying vec3 BoxCoord;
  12: 
  13: uniform vec3 uLightBoxSize;
  14: uniform vec3 uLightBoxMin;
  15: uniform mat4 uModel;
  16: 
  17: uniform float uTime;
  18: uniform mat4 uViewProjection;
  19: uniform vec3 uCameraPos;
  20: 
  21: void FLWFinalizeWorldPos(inout vec4 worldPos) {
  22:     worldPos = uModel * worldPos;
  23: 
  24:     BoxCoord = (worldPos.xyz - uLightBoxMin) / uLightBoxSize;
  25: 
  26:     #if defined(USE_FOG)
  27:     FragDistance = length(worldPos.xyz);
  28:     #endif
  29: 
  30:     gl_Position = uViewProjection * worldPos;
  31: }
  32: 
  33: void FLWFinalizeNormal(inout vec3 normal) {
  34:     mat3 m;
  35:     m[0] = uModel[0].xyz;
  36:     m[1] = uModel[1].xyz;
  37:     m[2] = uModel[2].xyz;
  38:     normal = m * normal;
  39: }
  40: 
  41: 
  42: 
  43: mat4 rotate(vec3 axis, float angle) {
  44:     float s = sin(angle);
  45:     float c = cos(angle);
  46:     float oc = 1. - c;
  47: 
  48:     vec3 sa = axis * s;
  49: 
  50:     mat4 mr = mat4(1.);
  51:     mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
  52:     mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
  53:     mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);
  54: 
  55:     return mr;
  56: }
  57: 
  58: mat4 rotation(vec3 rot) {
  59:     return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
  60: }
  61: 
  62: mat3 modelToNormal(mat4 mat) {
  63:     // Discard the edges. This won't be accurate for scaled or skewed matrices,
  64:     // but we don't have to work with those often.
  65:     mat3 m;
  66:     m[0] = mat[0].xyz;
  67:     m[1] = mat[1].xyz;
  68:     m[2] = mat[2].xyz;
  69:     return m;
  70: }
  71: 
  72: #define PIOVER2 1.5707963268
  73: 
  74: vec4 quat(vec3 axis, float angle) {
  75:     float halfAngle = angle * PIOVER2 / 180.0;
  76:     vec2 cs = sin(vec2(PIOVER2 - halfAngle, halfAngle)); // compute sin and cos in one instruction
  77:     return vec4(axis.xyz * cs.y,  cs.x);
  78: }
  79: 
  80: vec4 quatMult(vec4 q1, vec4 q2) {
  81:     // disgustingly vectorized quaternion multiplication
  82:     vec4 a = q1.w * q2.xyzw;
  83:     vec4 b = q1.x * q2.wzxy * vec4(1., -1., 1., -1.);
  84:     vec4 c = q1.y * q2.zwxy * vec4(1., 1., -1., -1.);
  85:     vec4 d = q1.z * q2.yxwz * vec4(-1., 1., 1., -1.);
  86: 
  87:     return a + b + c + d;
  88: }
  89: 
  90: vec3 rotateVertexByQuat(vec3 v, vec4 q) {
  91:     vec3 i = q.xyz;
  92:     return v + 2.0 * cross(i, cross(i, v) + q.w * v);
  93: }
  94: 
  95: vec3 rotateAbout(vec3 v, vec3 axis, float angle) {
  96:     return rotateVertexByQuat(v, quat(axis, angle));
  97: }
  98: 
  99: float diffuse(vec3 normal) {
 100:     vec3 n2 = normal * normal * vec3(.6, .25, .8);
 101:     return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
 102: }
 103: 
 104: 
 105: struct Actor {
 106:     vec3 pos;
 107:     vec2 light;
 108:     float offset;
 109:     vec3 axis;
 110:     vec4 rotation;
 111:     vec3 rotationCenter;
 112:     float speed;
 113: };
 114: 
 115: 
 116: struct Vertex {
 117:     vec3 pos;
 118:     vec3 normal;
 119:     vec2 texCoords;
 120: };
 121: 
 122: struct BlockFrag {
 123:     vec2 texCoords;
 124:     vec4 color;
 125:     float diffuse;
 126:     vec2 light;
 127: };
 128: 
 129: BlockFrag FLWMain(Vertex v, Actor instance) {
 130:     float degrees = instance.offset + uTime * instance.speed / 20.;
 131:     //float angle = fract(degrees / 360.) * PI * 2.;
 132: 
 133:     vec4 kineticRot = quat(instance.axis, degrees);
 134:     vec3 rotated = rotateVertexByQuat(v.pos - instance.rotationCenter, kineticRot) + instance.rotationCenter;
 135: 
 136:     vec4 worldPos = vec4(rotateVertexByQuat(rotated - .5, instance.rotation) + instance.pos + .5, 1.);
 137:     vec3 norm = rotateVertexByQuat(rotateVertexByQuat(v.normal, kineticRot), instance.rotation);
 138: 
 139:     FLWFinalizeWorldPos(worldPos);
 140:     FLWFinalizeNormal(norm);
 141: 
 142:     BlockFrag b;
 143:     b.diffuse = diffuse(norm);
 144:     b.texCoords = v.texCoords;
 145:     b.light = instance.light;
 146: 
 147:     #if defined(DEBUG_NORMAL)
 148:     b.color = vec4(norm, 1.);
 149:     #else
 150:     b.color = vec4(1.);
 151:     #endif
 152: 
 153:     return b;
 154: }
 155: attribute vec3 a_v_pos;
 156: attribute vec3 a_v_normal;
 157: attribute vec2 a_v_texCoords;
 158: 
 159: attribute vec3 a_i_pos;
 160: attribute vec2 a_i_light;
 161: attribute float a_i_offset;
 162: attribute vec3 a_i_axis;
 163: attribute vec4 a_i_rotation;
 164: attribute vec3 a_i_rotationCenter;
 165: attribute float a_i_speed;
 166: 
 167: 
 168: varying vec2 v2f_texCoords;
 169: varying vec4 v2f_color;
 170: varying float v2f_diffuse;
 171: varying vec2 v2f_light;
 172: 
 173: 
 174: void main() {
 175:     Vertex v;
 176:     v.pos = a_v_pos;
 177: v.normal = a_v_normal;
 178: v.texCoords = a_v_texCoords;
 179: 
 180: 
 181:     Actor i;
 182:     i.pos = a_i_pos;
 183: i.light = a_i_light;
 184: i.offset = a_i_offset;
 185: i.axis = a_i_axis;
 186: i.rotation = a_i_rotation;
 187: i.rotationCenter = a_i_rotationCenter;
 188: i.speed = a_i_speed;
 189: 
 190: 
 191:     BlockFrag o = FLWMain(v, i);
 192: 
 193:     v2f_texCoords = o.texCoords;
 194: v2f_color = o.color;
 195: v2f_diffuse = o.diffuse;
 196: v2f_light = o.light;
 197: 
 198: }

[14:02:44] [main/ERROR]: Shader compilation log for flywheel:block.frag: No errors.

[14:02:44] [main/ERROR]: Source for shader 'flywheel:block.frag':
   1: #version 110
   2: #define USE_FOG
   3: #define USE_FOG_EXP2
   4: 
   5: #if defined(USE_FOG)
   6: varying float FragDistance;
   7: uniform vec4 uFogColor;
   8: #endif
   9: 
  10: #if defined(USE_FOG_LINEAR)
  11: uniform vec2 uFogRange;
  12: 
  13: float FLWFogFactor() {
  14:     return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
  15: }
  16:     #endif
  17: 
  18:     #if defined(USE_FOG_EXP2)
  19: uniform float uFogDensity;
  20: 
  21: float FLWFogFactor() {
  22:     float dist = FragDistance * uFogDensity;
  23:     return 1. / exp2(dist * dist);
  24: }
  25:     #endif
  26: // Adjust the [0,1] normalized lightmap value based on the texture matrix from LightTexture#enableLightmap
  27: vec2 shiftLight(vec2 lm) {
  28:     return lm * 0.99609375 + 0.03125;// * 255/256 + 1/32
  29: }
  30: 
  31: varying vec3 BoxCoord;
  32: varying vec2 BoxLight;
  33: uniform sampler3D uLightVolume;
  34: 
  35: uniform sampler2D uBlockAtlas;
  36: uniform sampler2D uLightMap;
  37: 
  38: vec4 FLWBlockTexture(vec2 texCoords) {
  39:     return texture2D(uBlockAtlas, texCoords);
  40: }
  41: 
  42: void FLWFinalizeColor(vec4 color) {
  43:     #if defined(USE_FOG)
  44:     float a = color.a;
  45:     float fog = clamp(FLWFogFactor(), 0., 1.);
  46: 
  47:     color = mix(uFogColor, color, fog);
  48:     color.a = a;
  49:     #endif
  50: 
  51:     gl_FragColor = color;
  52: }
  53: 
  54: vec4 FLWLight(vec2 lightCoords) {
  55:     lightCoords = max(lightCoords, texture3D(uLightVolume, BoxCoord).rg);
  56: 
  57:     return texture2D(uLightMap, shiftLight(lightCoords));
  58: }
  59: 
  60: 
  61: 
  62: struct BlockFrag {
  63:     vec2 texCoords;
  64:     vec4 color;
  65:     float diffuse;
  66:     vec2 light;
  67: };
  68: 
  69: void FLWMain(BlockFrag r) {
  70:     vec4 tex = FLWBlockTexture(r.texCoords);
  71: 
  72:     vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;
  73: 
  74: //    flw_WorldPos = ;
  75: //    flw_Normal = ;
  76: //    flw_Albedo = tex.rgb;
  77: //    flw_Alpha = tex.a;
  78: //    flw_LightMap = r.light;
  79: //    flw_Tint = r.color;
  80:     FLWFinalizeColor(color);
  81: }
  82: 
  83: varying vec2 v2f_texCoords;
  84: varying vec4 v2f_color;
  85: varying float v2f_diffuse;
  86: varying vec2 v2f_light;
  87: 
  88: 
  89: //vec3 flw_WorldPos;
  90: //vec3 flw_Normal;
  91: //vec3 flw_Albedo;
  92: //float flw_Alpha;
  93: //vec2 flw_LightMap;
  94: //vec4 flw_Tint;
  95: 
  96: void main() {
  97:     BlockFrag f;
  98:     f.texCoords = v2f_texCoords;
  99: f.color = v2f_color;
 100: f.diffuse = v2f_diffuse;
 101: f.light = v2f_light;
 102: 
 103: 
 104:     FLWMain(f);
 105: }

[14:02:45] [main/ERROR]: Shader compilation log for create:contraption_actor.vert: No errors.

[14:02:45] [main/ERROR]: Source for shader 'create:contraption_actor.vert':
   1: #version 110
   2: 
   3: #define PI 3.1415926538
   4: 
   5: #if defined(USE_FOG)
   6: varying float FragDistance;
   7: #endif
   8: 
   9: varying vec3 BoxCoord;
  10: 
  11: uniform vec3 uLightBoxSize;
  12: uniform vec3 uLightBoxMin;
  13: uniform mat4 uModel;
  14: 
  15: uniform float uTime;
  16: uniform mat4 uViewProjection;
  17: uniform vec3 uCameraPos;
  18: 
  19: void FLWFinalizeWorldPos(inout vec4 worldPos) {
  20:     worldPos = uModel * worldPos;
  21: 
  22:     BoxCoord = (worldPos.xyz - uLightBoxMin) / uLightBoxSize;
  23: 
  24:     #if defined(USE_FOG)
  25:     FragDistance = length(worldPos.xyz);
  26:     #endif
  27: 
  28:     gl_Position = uViewProjection * worldPos;
  29: }
  30: 
  31: void FLWFinalizeNormal(inout vec3 normal) {
  32:     mat3 m;
  33:     m[0] = uModel[0].xyz;
  34:     m[1] = uModel[1].xyz;
  35:     m[2] = uModel[2].xyz;
  36:     normal = m * normal;
  37: }
  38: 
  39: 
  40: 
  41: mat4 rotate(vec3 axis, float angle) {
  42:     float s = sin(angle);
  43:     float c = cos(angle);
  44:     float oc = 1. - c;
  45: 
  46:     vec3 sa = axis * s;
  47: 
  48:     mat4 mr = mat4(1.);
  49:     mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
  50:     mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
  51:     mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);
  52: 
  53:     return mr;
  54: }
  55: 
  56: mat4 rotation(vec3 rot) {
  57:     return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
  58: }
  59: 
  60: mat3 modelToNormal(mat4 mat) {
  61:     // Discard the edges. This won't be accurate for scaled or skewed matrices,
  62:     // but we don't have to work with those often.
  63:     mat3 m;
  64:     m[0] = mat[0].xyz;
  65:     m[1] = mat[1].xyz;
  66:     m[2] = mat[2].xyz;
  67:     return m;
  68: }
  69: 
  70: #define PIOVER2 1.5707963268
  71: 
  72: vec4 quat(vec3 axis, float angle) {
  73:     float halfAngle = angle * PIOVER2 / 180.0;
  74:     vec2 cs = sin(vec2(PIOVER2 - halfAngle, halfAngle)); // compute sin and cos in one instruction
  75:     return vec4(axis.xyz * cs.y,  cs.x);
  76: }
  77: 
  78: vec4 quatMult(vec4 q1, vec4 q2) {
  79:     // disgustingly vectorized quaternion multiplication
  80:     vec4 a = q1.w * q2.xyzw;
  81:     vec4 b = q1.x * q2.wzxy * vec4(1., -1., 1., -1.);
  82:     vec4 c = q1.y * q2.zwxy * vec4(1., 1., -1., -1.);
  83:     vec4 d = q1.z * q2.yxwz * vec4(-1., 1., 1., -1.);
  84: 
  85:     return a + b + c + d;
  86: }
  87: 
  88: vec3 rotateVertexByQuat(vec3 v, vec4 q) {
  89:     vec3 i = q.xyz;
  90:     return v + 2.0 * cross(i, cross(i, v) + q.w * v);
  91: }
  92: 
  93: vec3 rotateAbout(vec3 v, vec3 axis, float angle) {
  94:     return rotateVertexByQuat(v, quat(axis, angle));
  95: }
  96: 
  97: float diffuse(vec3 normal) {
  98:     vec3 n2 = normal * normal * vec3(.6, .25, .8);
  99:     return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
 100: }
 101: 
 102: 
 103: struct Actor {
 104:     vec3 pos;
 105:     vec2 light;
 106:     float offset;
 107:     vec3 axis;
 108:     vec4 rotation;
 109:     vec3 rotationCenter;
 110:     float speed;
 111: };
 112: 
 113: 
 114: struct Vertex {
 115:     vec3 pos;
 116:     vec3 normal;
 117:     vec2 texCoords;
 118: };
 119: 
 120: struct BlockFrag {
 121:     vec2 texCoords;
 122:     vec4 color;
 123:     float diffuse;
 124:     vec2 light;
 125: };
 126: 
 127: BlockFrag FLWMain(Vertex v, Actor instance) {
 128:     float degrees = instance.offset + uTime * instance.speed / 20.;
 129:     //float angle = fract(degrees / 360.) * PI * 2.;
 130: 
 131:     vec4 kineticRot = quat(instance.axis, degrees);
 132:     vec3 rotated = rotateVertexByQuat(v.pos - instance.rotationCenter, kineticRot) + instance.rotationCenter;
 133: 
 134:     vec4 worldPos = vec4(rotateVertexByQuat(rotated - .5, instance.rotation) + instance.pos + .5, 1.);
 135:     vec3 norm = rotateVertexByQuat(rotateVertexByQuat(v.normal, kineticRot), instance.rotation);
 136: 
 137:     FLWFinalizeWorldPos(worldPos);
 138:     FLWFinalizeNormal(norm);
 139: 
 140:     BlockFrag b;
 141:     b.diffuse = diffuse(norm);
 142:     b.texCoords = v.texCoords;
 143:     b.light = instance.light;
 144: 
 145:     #if defined(DEBUG_NORMAL)
 146:     b.color = vec4(norm, 1.);
 147:     #else
 148:     b.color = vec4(1.);
 149:     #endif
 150: 
 151:     return b;
 152: }
 153: attribute vec3 a_v_pos;
 154: attribute vec3 a_v_normal;
 155: attribute vec2 a_v_texCoords;
 156: 
 157: attribute vec3 a_i_pos;
 158: attribute vec2 a_i_light;
 159: attribute float a_i_offset;
 160: attribute vec3 a_i_axis;
 161: attribute vec4 a_i_rotation;
 162: attribute vec3 a_i_rotationCenter;
 163: attribute float a_i_speed;
 164: 
 165: 
 166: varying vec2 v2f_texCoords;
 167: varying vec4 v2f_color;
 168: varying float v2f_diffuse;
 169: varying vec2 v2f_light;
 170: 
 171: 
 172: void main() {
 173:     Vertex v;
 174:     v.pos = a_v_pos;
 175: v.normal = a_v_normal;
 176: v.texCoords = a_v_texCoords;
 177: 
 178: 
 179:     Actor i;
 180:     i.pos = a_i_pos;
 181: i.light = a_i_light;
 182: i.offset = a_i_offset;
 183: i.axis = a_i_axis;
 184: i.rotation = a_i_rotation;
 185: i.rotationCenter = a_i_rotationCenter;
 186: i.speed = a_i_speed;
 187: 
 188: 
 189:     BlockFrag o = FLWMain(v, i);
 190: 
 191:     v2f_texCoords = o.texCoords;
 192: v2f_color = o.color;
 193: v2f_diffuse = o.diffuse;
 194: v2f_light = o.light;
 195: 
 196: }

[14:02:45] [main/ERROR]: Shader compilation log for flywheel:block.frag: No errors.

[14:02:45] [main/ERROR]: Source for shader 'flywheel:block.frag':
   1: #version 110
   2: 
   3: #if defined(USE_FOG)
   4: varying float FragDistance;
   5: uniform vec4 uFogColor;
   6: #endif
   7: 
   8: #if defined(USE_FOG_LINEAR)
   9: uniform vec2 uFogRange;
  10: 
  11: float FLWFogFactor() {
  12:     return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
  13: }
  14:     #endif
  15: 
  16:     #if defined(USE_FOG_EXP2)
  17: uniform float uFogDensity;
  18: 
  19: float FLWFogFactor() {
  20:     float dist = FragDistance * uFogDensity;
  21:     return 1. / exp2(dist * dist);
  22: }
  23:     #endif
  24: // Adjust the [0,1] normalized lightmap value based on the texture matrix from LightTexture#enableLightmap
  25: vec2 shiftLight(vec2 lm) {
  26:     return lm * 0.99609375 + 0.03125;// * 255/256 + 1/32
  27: }
  28: 
  29: varying vec3 BoxCoord;
  30: varying vec2 BoxLight;
  31: uniform sampler3D uLightVolume;
  32: 
  33: uniform sampler2D uBlockAtlas;
  34: uniform sampler2D uLightMap;
  35: 
  36: vec4 FLWBlockTexture(vec2 texCoords) {
  37:     return texture2D(uBlockAtlas, texCoords);
  38: }
  39: 
  40: void FLWFinalizeColor(vec4 color) {
  41:     #if defined(USE_FOG)
  42:     float a = color.a;
  43:     float fog = clamp(FLWFogFactor(), 0., 1.);
  44: 
  45:     color = mix(uFogColor, color, fog);
  46:     color.a = a;
  47:     #endif
  48: 
  49:     gl_FragColor = color;
  50: }
  51: 
  52: vec4 FLWLight(vec2 lightCoords) {
  53:     lightCoords = max(lightCoords, texture3D(uLightVolume, BoxCoord).rg);
  54: 
  55:     return texture2D(uLightMap, shiftLight(lightCoords));
  56: }
  57: 
  58: 
  59: 
  60: struct BlockFrag {
  61:     vec2 texCoords;
  62:     vec4 color;
  63:     float diffuse;
  64:     vec2 light;
  65: };
  66: 
  67: void FLWMain(BlockFrag r) {
  68:     vec4 tex = FLWBlockTexture(r.texCoords);
  69: 
  70:     vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;
  71: 
  72: //    flw_WorldPos = ;
  73: //    flw_Normal = ;
  74: //    flw_Albedo = tex.rgb;
  75: //    flw_Alpha = tex.a;
  76: //    flw_LightMap = r.light;
  77: //    flw_Tint = r.color;
  78:     FLWFinalizeColor(color);
  79: }
  80: 
  81: varying vec2 v2f_texCoords;
  82: varying vec4 v2f_color;
  83: varying float v2f_diffuse;
  84: varying vec2 v2f_light;
  85: 
  86: 
  87: //vec3 flw_WorldPos;
  88: //vec3 flw_Normal;
  89: //vec3 flw_Albedo;
  90: //float flw_Alpha;
  91: //vec2 flw_LightMap;
  92: //vec4 flw_Tint;
  93: 
  94: void main() {
  95:     BlockFrag f;
  96:     f.texCoords = v2f_texCoords;
  97: f.color = v2f_color;
  98: f.diffuse = v2f_diffuse;
  99: f.light = v2f_light;
 100: 
 101: 
 102:     FLWMain(f);
 103: }

[14:02:45] [Forge Version Check/INFO]: [runelic] Found status: BETA Current: 7.0.2 Target: 7.0.2
[14:02:45] [Forge Version Check/INFO]: [cfm] Starting version check at https://mrcrayfish.com/modupdatejson?id=cfm
[14:02:45] [main/ERROR]: Shader compilation log for create:flap.vert: No errors.

[14:02:45] [main/ERROR]: Source for shader 'create:flap.vert':
   1: #version 110
   2: #define DEBUG_NORMAL
   3: 
   4: #define PI 3.1415926538
   5: 
   6: #if defined(USE_FOG)
   7: varying float FragDistance;
   8: #endif
   9: 
  10: varying vec3 BoxCoord;
  11: 
  12: uniform vec3 uLightBoxSize;
  13: uniform vec3 uLightBoxMin;
  14: uniform mat4 uModel;
  15: 
  16: uniform float uTime;
  17: uniform mat4 uViewProjection;
  18: uniform vec3 uCameraPos;
  19: 
  20: void FLWFinalizeWorldPos(inout vec4 worldPos) {
  21:     worldPos = uModel * worldPos;
  22: 
  23:     BoxCoord = (worldPos.xyz - uLightBoxMin) / uLightBoxSize;
  24: 
  25:     #if defined(USE_FOG)
  26:     FragDistance = length(worldPos.xyz);
  27:     #endif
  28: 
  29:     gl_Position = uViewProjection * worldPos;
  30: }
  31: 
  32: void FLWFinalizeNormal(inout vec3 normal) {
  33:     mat3 m;
  34:     m[0] = uModel[0].xyz;
  35:     m[1] = uModel[1].xyz;
  36:     m[2] = uModel[2].xyz;
  37:     normal = m * normal;
  38: }
  39: 
  40: 
  41: 
  42: mat4 rotate(vec3 axis, float angle) {
  43:     float s = sin(angle);
  44:     float c = cos(angle);
  45:     float oc = 1. - c;
  46: 
  47:     vec3 sa = axis * s;
  48: 
  49:     mat4 mr = mat4(1.);
  50:     mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
  51:     mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
  52:     mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);
  53: 
  54:     return mr;
  55: }
  56: 
  57: mat4 rotation(vec3 rot) {
  58:     return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
  59: }
  60: 
  61: mat3 modelToNormal(mat4 mat) {
  62:     // Discard the edges. This won't be accurate for scaled or skewed matrices,
  63:     // but we don't have to work with those often.
  64:     mat3 m;
  65:     m[0] = mat[0].xyz;
  66:     m[1] = mat[1].xyz;
  67:     m[2] = mat[2].xyz;
  68:     return m;
  69: }
  70: 
  71: #define PIOVER2 1.5707963268
  72: 
  73: vec4 quat(vec3 axis, float angle) {
  74:     float halfAngle = angle * PIOVER2 / 180.0;
  75:     vec2 cs = sin(vec2(PIOVER2 - halfAngle, halfAngle)); // compute sin and cos in one instruction
  76:     return vec4(axis.xyz * cs.y,  cs.x);
  77: }
  78: 
  79: vec4 quatMult(vec4 q1, vec4 q2) {
  80:     // disgustingly vectorized quaternion multiplication
  81:     vec4 a = q1.w * q2.xyzw;
  82:     vec4 b = q1.x * q2.wzxy * vec4(1., -1., 1., -1.);
  83:     vec4 c = q1.y * q2.zwxy * vec4(1., 1., -1., -1.);
  84:     vec4 d = q1.z * q2.yxwz * vec4(-1., 1., 1., -1.);
  85: 
  86:     return a + b + c + d;
  87: }
  88: 
  89: vec3 rotateVertexByQuat(vec3 v, vec4 q) {
  90:     vec3 i = q.xyz;
  91:     return v + 2.0 * cross(i, cross(i, v) + q.w * v);
  92: }
  93: 
  94: vec3 rotateAbout(vec3 v, vec3 axis, float angle) {
  95:     return rotateVertexByQuat(v, quat(axis, angle));
  96: }
  97: 
  98: float diffuse(vec3 normal) {
  99:     vec3 n2 = normal * normal * vec3(.6, .25, .8);
 100:     return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
 101: }
 102: 
 103: 
 104: struct Flap {
 105:     vec3 instancePos;
 106:     vec2 light;
 107:     vec3 segmentOffset;
 108:     vec3 pivot;
 109:     float horizontalAngle;
 110:     float intensity;
 111:     float flapScale;
 112:     float flapness;
 113: };
 114: 
 115: 
 116: struct Vertex {
 117:     vec3 pos;
 118:     vec3 normal;
 119:     vec2 texCoords;
 120: };
 121: 
 122: struct BlockFrag {
 123:     vec2 texCoords;
 124:     vec4 color;
 125:     float diffuse;
 126:     vec2 light;
 127: };
 128: 
 129: 
 130: float toRad(float degrees) {
 131:     return fract(degrees / 360.) * PI * 2.;
 132: }
 133: 
 134: float getFlapAngle(float flapness, float intensity, float scale) {
 135:     float absFlap = abs(flapness);
 136: 
 137:     float angle = sin((1. - absFlap) * PI * intensity) * 30. * flapness * scale;
 138: 
 139:     float halfAngle = angle * 0.5;
 140: 
 141:     float which = step(0., flapness);// 0 if negative, 1 if positive
 142:     float degrees = which * halfAngle + (1. - which) * angle;// branchless conditional multiply
 143: 
 144:     return degrees;
 145: }
 146: 
 147: BlockFrag FLWMain(Vertex v, Flap flap) {
 148:     float flapAngle = getFlapAngle(flap.flapness, flap.intensity, flap.flapScale);
 149: 
 150:     vec4 orientation = quat(vec3(0., 1., 0.), -flap.horizontalAngle);
 151:     vec4 flapRotation = quat(vec3(1., 0., 0.), flapAngle);
 152: 
 153:     vec3 rotated = rotateVertexByQuat(v.pos - flap.pivot, flapRotation) + flap.pivot + flap.segmentOffset;
 154:     rotated = rotateVertexByQuat(rotated - .5, orientation) + flap.instancePos + .5;
 155: 
 156:     vec4 worldPos = vec4(rotated, 1.);
 157:     vec3 norm = rotateVertexByQuat(rotateVertexByQuat(v.normal, flapRotation), orientation);
 158: 
 159:     FLWFinalizeWorldPos(worldPos);
 160:     FLWFinalizeNormal(norm);
 161: 
 162:     BlockFrag b;
 163:     b.diffuse = diffuse(norm);
 164:     b.texCoords = v.texCoords;
 165:     b.light = flap.light;
 166:     #if defined(DEBUG_NORMAL)
 167:     b.color = vec4(norm, 1.);
 168:     #else
 169:     b.color = vec4(1.);
 170:     #endif
 171:     return b;
 172: }
 173: attribute vec3 a_v_pos;
 174: attribute vec3 a_v_normal;
 175: attribute vec2 a_v_texCoords;
 176: 
 177: attribute vec3 a_i_instancePos;
 178: attribute vec2 a_i_light;
 179: attribute vec3 a_i_segmentOffset;
 180: attribute vec3 a_i_pivot;
 181: attribute float a_i_horizontalAngle;
 182: attribute float a_i_intensity;
 183: attribute float a_i_flapScale;
 184: attribute float a_i_flapness;
 185: 
 186: 
 187: varying vec2 v2f_texCoords;
 188: varying vec4 v2f_color;
 189: varying float v2f_diffuse;
 190: varying vec2 v2f_light;
 191: 
 192: 
 193: void main() {
 194:     Vertex v;
 195:     v.pos = a_v_pos;
 196: v.normal = a_v_normal;
 197: v.texCoords = a_v_texCoords;
 198: 
 199: 
 200:     Flap i;
 201:     i.instancePos = a_i_instancePos;
 202: i.light = a_i_light;
 203: i.segmentOffset = a_i_segmentOffset;
 204: i.pivot = a_i_pivot;
 205: i.horizontalAngle = a_i_horizontalAngle;
 206: i.intensity = a_i_intensity;
 207: i.flapScale = a_i_flapScale;
 208: i.flapness = a_i_flapness;
 209: 
 210: 
 211:     BlockFrag o = FLWMain(v, i);
 212: 
 213:     v2f_texCoords = o.texCoords;
 214: v2f_color = o.color;
 215: v2f_diffuse = o.diffuse;
 216: v2f_light = o.light;
 217: 
 218: }

[14:02:45] [main/ERROR]: Shader compilation log for flywheel:block.frag: No errors.

[14:02:45] [main/ERROR]: Source for shader 'flywheel:block.frag':
   1: #version 110
   2: #define DEBUG_NORMAL
   3: 
   4: #if defined(USE_FOG)
   5: varying float FragDistance;
   6: uniform vec4 uFogColor;
   7: #endif
   8: 
   9: #if defined(USE_FOG_LINEAR)
  10: uniform vec2 uFogRange;
  11: 
  12: float FLWFogFactor() {
  13:     return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
  14: }
  15:     #endif
  16: 
  17:     #if defined(USE_FOG_EXP2)
  18: uniform float uFogDensity;
  19: 
  20: float FLWFogFactor() {
  21:     float dist = FragDistance * uFogDensity;
  22:     return 1. / exp2(dist * dist);
  23: }
  24:     #endif
  25: // Adjust the [0,1] normalized lightmap value based on the texture matrix from LightTexture#enableLightmap
  26: vec2 shiftLight(vec2 lm) {
  27:     return lm * 0.99609375 + 0.03125;// * 255/256 + 1/32
  28: }
  29: 
  30: varying vec3 BoxCoord;
  31: varying vec2 BoxLight;
  32: uniform sampler3D uLightVolume;
  33: 
  34: uniform sampler2D uBlockAtlas;
  35: uniform sampler2D uLightMap;
  36: 
  37: vec4 FLWBlockTexture(vec2 texCoords) {
  38:     return texture2D(uBlockAtlas, texCoords);
  39: }
  40: 
  41: void FLWFinalizeColor(vec4 color) {
  42:     #if defined(USE_FOG)
  43:     float a = color.a;
  44:     float fog = clamp(FLWFogFactor(), 0., 1.);
  45: 
  46:     color = mix(uFogColor, color, fog);
  47:     color.a = a;
  48:     #endif
  49: 
  50:     gl_FragColor = color;
  51: }
  52: 
  53: vec4 FLWLight(vec2 lightCoords) {
  54:     lightCoords = max(lightCoords, texture3D(uLightVolume, BoxCoord).rg);
  55: 
  56:     return texture2D(uLightMap, shiftLight(lightCoords));
  57: }
  58: 
  59: 
  60: 
  61: struct BlockFrag {
  62:     vec2 texCoords;
  63:     vec4 color;
  64:     float diffuse;
  65:     vec2 light;
  66: };
  67: 
  68: void FLWMain(BlockFrag r) {
  69:     vec4 tex = FLWBlockTexture(r.texCoords);
  70: 
  71:     vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;
  72: 
  73: //    flw_WorldPos = ;
  74: //    flw_Normal = ;
  75: //    flw_Albedo = tex.rgb;
  76: //    flw_Alpha = tex.a;
  77: //    flw_LightMap = r.light;
  78: //    flw_Tint = r.color;
  79:     FLWFinalizeColor(color);
  80: }
  81: 
  82: varying vec2 v2f_texCoords;
  83: varying vec4 v2f_color;
  84: varying float v2f_diffuse;
  85: varying vec2 v2f_light;
  86: 
  87: 
  88: //vec3 flw_WorldPos;
  89: //vec3 flw_Normal;
  90: //vec3 flw_Albedo;
  91: //float flw_Alpha;
  92: //vec2 flw_LightMap;
  93: //vec4 flw_Tint;
  94: 
  95: void main() {
  96:     BlockFrag f;
  97:     f.texCoords = v2f_texCoords;
  98: f.color = v2f_color;
  99: f.diffuse = v2f_diffuse;
 100: f.light = v2f_light;
 101: 
 102: 
 103:     FLWMain(f);
 104: }

[14:02:45] [main/ERROR]: Shader compilation log for create:flap.vert: No errors.

[14:02:45] [main/ERROR]: Source for shader 'create:flap.vert':
   1: #version 110
   2: #define USE_FOG
   3: #define USE_FOG_LINEAR
   4: 
   5: #define PI 3.1415926538
   6: 
   7: #if defined(USE_FOG)
   8: varying float FragDistance;
   9: #endif
  10: 
  11: varying vec3 BoxCoord;
  12: 
  13: uniform vec3 uLightBoxSize;
  14: uniform vec3 uLightBoxMin;
  15: uniform mat4 uModel;
  16: 
  17: uniform float uTime;
  18: uniform mat4 uViewProjection;
  19: uniform vec3 uCameraPos;
  20: 
  21: void FLWFinalizeWorldPos(inout vec4 worldPos) {
  22:     worldPos = uModel * worldPos;
  23: 
  24:     BoxCoord = (worldPos.xyz - uLightBoxMin) / uLightBoxSize;
  25: 
  26:     #if defined(USE_FOG)
  27:     FragDistance = length(worldPos.xyz);
  28:     #endif
  29: 
  30:     gl_Position = uViewProjection * worldPos;
  31: }
  32: 
  33: void FLWFinalizeNormal(inout vec3 normal) {
  34:     mat3 m;
  35:     m[0] = uModel[0].xyz;
  36:     m[1] = uModel[1].xyz;
  37:     m[2] = uModel[2].xyz;
  38:     normal = m * normal;
  39: }
  40: 
  41: 
  42: 
  43: mat4 rotate(vec3 axis, float angle) {
  44:     float s = sin(angle);
  45:     float c = cos(angle);
  46:     float oc = 1. - c;
  47: 
  48:     vec3 sa = axis * s;
  49: 
  50:     mat4 mr = mat4(1.);
  51:     mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
  52:     mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
  53:     mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);
  54: 
  55:     return mr;
  56: }
  57: 
  58: mat4 rotation(vec3 rot) {
  59:     return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
  60: }
  61: 
  62: mat3 modelToNormal(mat4 mat) {
  63:     // Discard the edges. This won't be accurate for scaled or skewed matrices,
  64:     // but we don't have to work with those often.
  65:     mat3 m;
  66:     m[0] = mat[0].xyz;
  67:     m[1] = mat[1].xyz;
  68:     m[2] = mat[2].xyz;
  69:     return m;
  70: }
  71: 
  72: #define PIOVER2 1.5707963268
  73: 
  74: vec4 quat(vec3 axis, float angle) {
  75:     float halfAngle = angle * PIOVER2 / 180.0;
  76:     vec2 cs = sin(vec2(PIOVER2 - halfAngle, halfAngle)); // compute sin and cos in one instruction
  77:     return vec4(axis.xyz * cs.y,  cs.x);
  78: }
  79: 
  80: vec4 quatMult(vec4 q1, vec4 q2) {
  81:     // disgustingly vectorized quaternion multiplication
  82:     vec4 a = q1.w * q2.xyzw;
  83:     vec4 b = q1.x * q2.wzxy * vec4(1., -1., 1., -1.);
  84:     vec4 c = q1.y * q2.zwxy * vec4(1., 1., -1., -1.);
  85:     vec4 d = q1.z * q2.yxwz * vec4(-1., 1., 1., -1.);
  86: 
  87:     return a + b + c + d;
  88: }
  89: 
  90: vec3 rotateVertexByQuat(vec3 v, vec4 q) {
  91:     vec3 i = q.xyz;
  92:     return v + 2.0 * cross(i, cross(i, v) + q.w * v);
  93: }
  94: 
  95: vec3 rotateAbout(vec3 v, vec3 axis, float angle) {
  96:     return rotateVertexByQuat(v, quat(axis, angle));
  97: }
  98: 
  99: float diffuse(vec3 normal) {
 100:     vec3 n2 = normal * normal * vec3(.6, .25, .8);
 101:     return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
 102: }
 103: 
 104: 
 105: struct Flap {
 106:     vec3 instancePos;
 107:     vec2 light;
 108:     vec3 segmentOffset;
 109:     vec3 pivot;
 110:     float horizontalAngle;
 111:     float intensity;
 112:     float flapScale;
 113:     float flapness;
 114: };
 115: 
 116: 
 117: struct Vertex {
 118:     vec3 pos;
 119:     vec3 normal;
 120:     vec2 texCoords;
 121: };
 122: 
 123: struct BlockFrag {
 124:     vec2 texCoords;
 125:     vec4 color;
 126:     float diffuse;
 127:     vec2 light;
 128: };
 129: 
 130: 
 131: float toRad(float degrees) {
 132:     return fract(degrees / 360.) * PI * 2.;
 133: }
 134: 
 135: float getFlapAngle(float flapness, float intensity, float scale) {
 136:     float absFlap = abs(flapness);
 137: 
 138:     float angle = sin((1. - absFlap) * PI * intensity) * 30. * flapness * scale;
 139: 
 140:     float halfAngle = angle * 0.5;
 141: 
 142:     float which = step(0., flapness);// 0 if negative, 1 if positive
 143:     float degrees = which * halfAngle + (1. - which) * angle;// branchless conditional multiply
 144: 
 145:     return degrees;
 146: }
 147: 
 148: BlockFrag FLWMain(Vertex v, Flap flap) {
 149:     float flapAngle = getFlapAngle(flap.flapness, flap.intensity, flap.flapScale);
 150: 
 151:     vec4 orientation = quat(vec3(0., 1., 0.), -flap.horizontalAngle);
 152:     vec4 flapRotation = quat(vec3(1., 0., 0.), flapAngle);
 153: 
 154:     vec3 rotated = rotateVertexByQuat(v.pos - flap.pivot, flapRotation) + flap.pivot + flap.segmentOffset;
 155:     rotated = rotateVertexByQuat(rotated - .5, orientation) + flap.instancePos + .5;
 156: 
 157:     vec4 worldPos = vec4(rotated, 1.);
 158:     vec3 norm = rotateVertexByQuat(rotateVertexByQuat(v.normal, flapRotation), orientation);
 159: 
 160:     FLWFinalizeWorldPos(worldPos);
 161:     FLWFinalizeNormal(norm);
 162: 
 163:     BlockFrag b;
 164:     b.diffuse = diffuse(norm);
 165:     b.texCoords = v.texCoords;
 166:     b.light = flap.light;
 167:     #if defined(DEBUG_NORMAL)
 168:     b.color = vec4(norm, 1.);
 169:     #else
 170:     b.color = vec4(1.);
 171:     #endif
 172:     return b;
 173: }
 174: attribute vec3 a_v_pos;
 175: attribute vec3 a_v_normal;
 176: attribute vec2 a_v_texCoords;
 177: 
 178: attribute vec3 a_i_instancePos;
 179: attribute vec2 a_i_light;
 180: attribute vec3 a_i_segmentOffset;
 181: attribute vec3 a_i_pivot;
 182: attribute float a_i_horizontalAngle;
 183: attribute float a_i_intensity;
 184: attribute float a_i_flapScale;
 185: attribute float a_i_flapness;
 186: 
 187: 
 188: varying vec2 v2f_texCoords;
 189: varying vec4 v2f_color;
 190: varying float v2f_diffuse;
 191: varying vec2 v2f_light;
 192: 
 193: 
 194: void main() {
 195:     Vertex v;
 196:     v.pos = a_v_pos;
 197: v.normal = a_v_normal;
 198: v.texCoords = a_v_texCoords;
 199: 
 200: 
 201:     Flap i;
 202:     i.instancePos = a_i_instancePos;
 203: i.light = a_i_light;
 204: i.segmentOffset = a_i_segmentOffset;
 205: i.pivot = a_i_pivot;
 206: i.horizontalAngle = a_i_horizontalAngle;
 207: i.intensity = a_i_intensity;
 208: i.flapScale = a_i_flapScale;
 209: i.flapness = a_i_flapness;
 210: 
 211: 
 212:     BlockFrag o = FLWMain(v, i);
 213: 
 214:     v2f_texCoords = o.texCoords;
 215: v2f_color = o.color;
 216: v2f_diffuse = o.diffuse;
 217: v2f_light = o.light;
 218: 
 219: }

[14:02:45] [main/ERROR]: Shader compilation log for flywheel:block.frag: No errors.

[14:02:45] [main/ERROR]: Source for shader 'flywheel:block.frag':
   1: #version 110
   2: #define USE_FOG
   3: #define USE_FOG_LINEAR
   4: 
   5: #if defined(USE_FOG)
   6: varying float FragDistance;
   7: uniform vec4 uFogColor;
   8: #endif
   9: 
  10: #if defined(USE_FOG_LINEAR)
  11: uniform vec2 uFogRange;
  12: 
  13: float FLWFogFactor() {
  14:     return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
  15: }
  16:     #endif
  17: 
  18:     #if defined(USE_FOG_EXP2)
  19: uniform float uFogDensity;
  20: 
  21: float FLWFogFactor() {
  22:     float dist = FragDistance * uFogDensity;
  23:     return 1. / exp2(dist * dist);
  24: }
  25:     #endif
  26: // Adjust the [0,1] normalized lightmap value based on the texture matrix from LightTexture#enableLightmap
  27: vec2 shiftLight(vec2 lm) {
  28:     return lm * 0.99609375 + 0.03125;// * 255/256 + 1/32
  29: }
  30: 
  31: varying vec3 BoxCoord;
  32: varying vec2 BoxLight;
  33: uniform sampler3D uLightVolume;
  34: 
  35: uniform sampler2D uBlockAtlas;
  36: uniform sampler2D uLightMap;
  37: 
  38: vec4 FLWBlockTexture(vec2 texCoords) {
  39:     return texture2D(uBlockAtlas, texCoords);
  40: }
  41: 
  42: void FLWFinalizeColor(vec4 color) {
  43:     #if defined(USE_FOG)
  44:     float a = color.a;
  45:     float fog = clamp(FLWFogFactor(), 0., 1.);
  46: 
  47:     color = mix(uFogColor, color, fog);
  48:     color.a = a;
  49:     #endif
  50: 
  51:     gl_FragColor = color;
  52: }
  53: 
  54: vec4 FLWLight(vec2 lightCoords) {
  55:     lightCoords = max(lightCoords, texture3D(uLightVolume, BoxCoord).rg);
  56: 
  57:     return texture2D(uLightMap, shiftLight(lightCoords));
  58: }
  59: 
  60: 
  61: 
  62: struct BlockFrag {
  63:     vec2 texCoords;
  64:     vec4 color;
  65:     float diffuse;
  66:     vec2 light;
  67: };
  68: 
  69: void FLWMain(BlockFrag r) {
  70:     vec4 tex = FLWBlockTexture(r.texCoords);
  71: 
  72:     vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;
  73: 
  74: //    flw_WorldPos = ;
  75: //    flw_Normal = ;
  76: //    flw_Albedo = tex.rgb;
  77: //    flw_Alpha = tex.a;
  78: //    flw_LightMap = r.light;
  79: //    flw_Tint = r.color;
  80:     FLWFinalizeColor(color);
  81: }
  82: 
  83: varying vec2 v2f_texCoords;
  84: varying vec4 v2f_color;
  85: varying float v2f_diffuse;
  86: varying vec2 v2f_light;
  87: 
  88: 
  89: //vec3 flw_WorldPos;
  90: //vec3 flw_Normal;
  91: //vec3 flw_Albedo;
  92: //float flw_Alpha;
  93: //vec2 flw_LightMap;
  94: //vec4 flw_Tint;
  95: 
  96: void main() {
  97:     BlockFrag f;
  98:     f.texCoords = v2f_texCoords;
  99: f.color = v2f_color;
 100: f.diffuse = v2f_diffuse;
 101: f.light = v2f_light;
 102: 
 103: 
 104:     FLWMain(f);
 105: }

[14:02:45] [Forge Version Check/INFO]: [cfm] Found status: BETA Current: 7.0.0-pre22 Target: 7.0.0-pre22
[14:02:45] [Forge Version Check/INFO]: [morecfm] Starting version check at https://mrcrayfish.com/modupdatejson?id=morecfm
[14:02:45] [main/ERROR]: Shader compilation log for create:flap.vert: No errors.

[14:02:45] [main/ERROR]: Source for shader 'create:flap.vert':
   1: #version 110
   2: #define USE_FOG
   3: #define USE_FOG_EXP2
   4: 
   5: #define PI 3.1415926538
   6: 
   7: #if defined(USE_FOG)
   8: varying float FragDistance;
   9: #endif
  10: 
  11: varying vec3 BoxCoord;
  12: 
  13: uniform vec3 uLightBoxSize;
  14: uniform vec3 uLightBoxMin;
  15: uniform mat4 uModel;
  16: 
  17: uniform float uTime;
  18: uniform mat4 uViewProjection;
  19: uniform vec3 uCameraPos;
  20: 
  21: void FLWFinalizeWorldPos(inout vec4 worldPos) {
  22:     worldPos = uModel * worldPos;
  23: 
  24:     BoxCoord = (worldPos.xyz - uLightBoxMin) / uLightBoxSize;
  25: 
  26:     #if defined(USE_FOG)
  27:     FragDistance = length(worldPos.xyz);
  28:     #endif
  29: 
  30:     gl_Position = uViewProjection * worldPos;
  31: }
  32: 
  33: void FLWFinalizeNormal(inout vec3 normal) {
  34:     mat3 m;
  35:     m[0] = uModel[0].xyz;
  36:     m[1] = uModel[1].xyz;
  37:     m[2] = uModel[2].xyz;
  38:     normal = m * normal;
  39: }
  40: 
  41: 
  42: 
  43: mat4 rotate(vec3 axis, float angle) {
  44:     float s = sin(angle);
  45:     float c = cos(angle);
  46:     float oc = 1. - c;
  47: 
  48:     vec3 sa = axis * s;
  49: 
  50:     mat4 mr = mat4(1.);
  51:     mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
  52:     mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
  53:     mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);
  54: 
  55:     return mr;
  56: }
  57: 
  58: mat4 rotation(vec3 rot) {
  59:     return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
  60: }
  61: 
  62: mat3 modelToNormal(mat4 mat) {
  63:     // Discard the edges. This won't be accurate for scaled or skewed matrices,
  64:     // but we don't have to work with those often.
  65:     mat3 m;
  66:     m[0] = mat[0].xyz;
  67:     m[1] = mat[1].xyz;
  68:     m[2] = mat[2].xyz;
  69:     return m;
  70: }
  71: 
  72: #define PIOVER2 1.5707963268
  73: 
  74: vec4 quat(vec3 axis, float angle) {
  75:     float halfAngle = angle * PIOVER2 / 180.0;
  76:     vec2 cs = sin(vec2(PIOVER2 - halfAngle, halfAngle)); // compute sin and cos in one instruction
  77:     return vec4(axis.xyz * cs.y,  cs.x);
  78: }
  79: 
  80: vec4 quatMult(vec4 q1, vec4 q2) {
  81:     // disgustingly vectorized quaternion multiplication
  82:     vec4 a = q1.w * q2.xyzw;
  83:     vec4 b = q1.x * q2.wzxy * vec4(1., -1., 1., -1.);
  84:     vec4 c = q1.y * q2.zwxy * vec4(1., 1., -1., -1.);
  85:     vec4 d = q1.z * q2.yxwz * vec4(-1., 1., 1., -1.);
  86: 
  87:     return a + b + c + d;
  88: }
  89: 
  90: vec3 rotateVertexByQuat(vec3 v, vec4 q) {
  91:     vec3 i = q.xyz;
  92:     return v + 2.0 * cross(i, cross(i, v) + q.w * v);
  93: }
  94: 
  95: vec3 rotateAbout(vec3 v, vec3 axis, float angle) {
  96:     return rotateVertexByQuat(v, quat(axis, angle));
  97: }
  98: 
  99: float diffuse(vec3 normal) {
 100:     vec3 n2 = normal * normal * vec3(.6, .25, .8);
 101:     return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
 102: }
 103: 
 104: 
 105: struct Flap {
 106:     vec3 instancePos;
 107:     vec2 light;
 108:     vec3 segmentOffset;
 109:     vec3 pivot;
 110:     float horizontalAngle;
 111:     float intensity;
 112:     float flapScale;
 113:     float flapness;
 114: };
 115: 
 116: 
 117: struct Vertex {
 118:     vec3 pos;
 119:     vec3 normal;
 120:     vec2 texCoords;
 121: };
 122: 
 123: struct BlockFrag {
 124:     vec2 texCoords;
 125:     vec4 color;
 126:     float diffuse;
 127:     vec2 light;
 128: };
 129: 
 130: 
 131: float toRad(float degrees) {
 132:     return fract(degrees / 360.) * PI * 2.;
 133: }
 134: 
 135: float getFlapAngle(float flapness, float intensity, float scale) {
 136:     float absFlap = abs(flapness);
 137: 
 138:     float angle = sin((1. - absFlap) * PI * intensity) * 30. * flapness * scale;
 139: 
 140:     float halfAngle = angle * 0.5;
 141: 
 142:     float which = step(0., flapness);// 0 if negative, 1 if positive
 143:     float degrees = which * halfAngle + (1. - which) * angle;// branchless conditional multiply
 144: 
 145:     return degrees;
 146: }
 147: 
 148: BlockFrag FLWMain(Vertex v, Flap flap) {
 149:     float flapAngle = getFlapAngle(flap.flapness, flap.intensity, flap.flapScale);
 150: 
 151:     vec4 orientation = quat(vec3(0., 1., 0.), -flap.horizontalAngle);
 152:     vec4 flapRotation = quat(vec3(1., 0., 0.), flapAngle);
 153: 
 154:     vec3 rotated = rotateVertexByQuat(v.pos - flap.pivot, flapRotation) + flap.pivot + flap.segmentOffset;
 155:     rotated = rotateVertexByQuat(rotated - .5, orientation) + flap.instancePos + .5;
 156: 
 157:     vec4 worldPos = vec4(rotated, 1.);
 158:     vec3 norm = rotateVertexByQuat(rotateVertexByQuat(v.normal, flapRotation), orientation);
 159: 
 160:     FLWFinalizeWorldPos(worldPos);
 161:     FLWFinalizeNormal(norm);
 162: 
 163:     BlockFrag b;
 164:     b.diffuse = diffuse(norm);
 165:     b.texCoords = v.texCoords;
 166:     b.light = flap.light;
 167:     #if defined(DEBUG_NORMAL)
 168:     b.color = vec4(norm, 1.);
 169:     #else
 170:     b.color = vec4(1.);
 171:     #endif
 172:     return b;
 173: }
 174: attribute vec3 a_v_pos;
 175: attribute vec3 a_v_normal;
 176: attribute vec2 a_v_texCoords;
 177: 
 178: attribute vec3 a_i_instancePos;
 179: attribute vec2 a_i_light;
 180: attribute vec3 a_i_segmentOffset;
 181: attribute vec3 a_i_pivot;
 182: attribute float a_i_horizontalAngle;
 183: attribute float a_i_intensity;
 184: attribute float a_i_flapScale;
 185: attribute float a_i_flapness;
 186: 
 187: 
 188: varying vec2 v2f_texCoords;
 189: varying vec4 v2f_color;
 190: varying float v2f_diffuse;
 191: varying vec2 v2f_light;
 192: 
 193: 
 194: void main() {
 195:     Vertex v;
 196:     v.pos = a_v_pos;
 197: v.normal = a_v_normal;
 198: v.texCoords = a_v_texCoords;
 199: 
 200: 
 201:     Flap i;
 202:     i.instancePos = a_i_instancePos;
 203: i.light = a_i_light;
 204: i.segmentOffset = a_i_segmentOffset;
 205: i.pivot = a_i_pivot;
 206: i.horizontalAngle = a_i_horizontalAngle;
 207: i.intensity = a_i_intensity;
 208: i.flapScale = a_i_flapScale;
 209: i.flapness = a_i_flapness;
 210: 
 211: 
 212:     BlockFrag o = FLWMain(v, i);
 213: 
 214:     v2f_texCoords = o.texCoords;
 215: v2f_color = o.color;
 216: v2f_diffuse = o.diffuse;
 217: v2f_light = o.light;
 218: 
 219: }

[14:02:45] [main/ERROR]: Shader compilation log for flywheel:block.frag: No errors.

[14:02:45] [main/ERROR]: Source for shader 'flywheel:block.frag':
   1: #version 110
   2: #define USE_FOG
   3: #define USE_FOG_EXP2
   4: 
   5: #if defined(USE_FOG)
   6: varying float FragDistance;
   7: uniform vec4 uFogColor;
   8: #endif
   9: 
  10: #if defined(USE_FOG_LINEAR)
  11: uniform vec2 uFogRange;
  12: 
  13: float FLWFogFactor() {
  14:     return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
  15: }
  16:     #endif
  17: 
  18:     #if defined(USE_FOG_EXP2)
  19: uniform float uFogDensity;
  20: 
  21: float FLWFogFactor() {
  22:     float dist = FragDistance * uFogDensity;
  23:     return 1. / exp2(dist * dist);
  24: }
  25:     #endif
  26: // Adjust the [0,1] normalized lightmap value based on the texture matrix from LightTexture#enableLightmap
  27: vec2 shiftLight(vec2 lm) {
  28:     return lm * 0.99609375 + 0.03125;// * 255/256 + 1/32
  29: }
  30: 
  31: varying vec3 BoxCoord;
  32: varying vec2 BoxLight;
  33: uniform sampler3D uLightVolume;
  34: 
  35: uniform sampler2D uBlockAtlas;
  36: uniform sampler2D uLightMap;
  37: 
  38: vec4 FLWBlockTexture(vec2 texCoords) {
  39:     return texture2D(uBlockAtlas, texCoords);
  40: }
  41: 
  42: void FLWFinalizeColor(vec4 color) {
  43:     #if defined(USE_FOG)
  44:     float a = color.a;
  45:     float fog = clamp(FLWFogFactor(), 0., 1.);
  46: 
  47:     color = mix(uFogColor, color, fog);
  48:     color.a = a;
  49:     #endif
  50: 
  51:     gl_FragColor = color;
  52: }
  53: 
  54: vec4 FLWLight(vec2 lightCoords) {
  55:     lightCoords = max(lightCoords, texture3D(uLightVolume, BoxCoord).rg);
  56: 
  57:     return texture2D(uLightMap, shiftLight(lightCoords));
  58: }
  59: 
  60: 
  61: 
  62: struct BlockFrag {
  63:     vec2 texCoords;
  64:     vec4 color;
  65:     float diffuse;
  66:     vec2 light;
  67: };
  68: 
  69: void FLWMain(BlockFrag r) {
  70:     vec4 tex = FLWBlockTexture(r.texCoords);
  71: 
  72:     vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;
  73: 
  74: //    flw_WorldPos = ;
  75: //    flw_Normal = ;
  76: //    flw_Albedo = tex.rgb;
  77: //    flw_Alpha = tex.a;
  78: //    flw_LightMap = r.light;
  79: //    flw_Tint = r.color;
  80:     FLWFinalizeColor(color);
  81: }
  82: 
  83: varying vec2 v2f_texCoords;
  84: varying vec4 v2f_color;
  85: varying float v2f_diffuse;
  86: varying vec2 v2f_light;
  87: 
  88: 
  89: //vec3 flw_WorldPos;
  90: //vec3 flw_Normal;
  91: //vec3 flw_Albedo;
  92: //float flw_Alpha;
  93: //vec2 flw_LightMap;
  94: //vec4 flw_Tint;
  95: 
  96: void main() {
  97:     BlockFrag f;
  98:     f.texCoords = v2f_texCoords;
  99: f.color = v2f_color;
 100: f.diffuse = v2f_diffuse;
 101: f.light = v2f_light;
 102: 
 103: 
 104:     FLWMain(f);
 105: }

[14:02:45] [main/ERROR]: Shader compilation log for create:flap.vert: No errors.

[14:02:45] [main/ERROR]: Source for shader 'create:flap.vert':
   1: #version 110
   2: 
   3: #define PI 3.1415926538
   4: 
   5: #if defined(USE_FOG)
   6: varying float FragDistance;
   7: #endif
   8: 
   9: varying vec3 BoxCoord;
  10: 
  11: uniform vec3 uLightBoxSize;
  12: uniform vec3 uLightBoxMin;
  13: uniform mat4 uModel;
  14: 
  15: uniform float uTime;
  16: uniform mat4 uViewProjection;
  17: uniform vec3 uCameraPos;
  18: 
  19: void FLWFinalizeWorldPos(inout vec4 worldPos) {
  20:     worldPos = uModel * worldPos;
  21: 
  22:     BoxCoord = (worldPos.xyz - uLightBoxMin) / uLightBoxSize;
  23: 
  24:     #if defined(USE_FOG)
  25:     FragDistance = length(worldPos.xyz);
  26:     #endif
  27: 
  28:     gl_Position = uViewProjection * worldPos;
  29: }
  30: 
  31: void FLWFinalizeNormal(inout vec3 normal) {
  32:     mat3 m;
  33:     m[0] = uModel[0].xyz;
  34:     m[1] = uModel[1].xyz;
  35:     m[2] = uModel[2].xyz;
  36:     normal = m * normal;
  37: }
  38: 
  39: 
  40: 
  41: mat4 rotate(vec3 axis, float angle) {
  42:     float s = sin(angle);
  43:     float c = cos(angle);
  44:     float oc = 1. - c;
  45: 
  46:     vec3 sa = axis * s;
  47: 
  48:     mat4 mr = mat4(1.);
  49:     mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
  50:     mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
  51:     mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);
  52: 
  53:     return mr;
  54: }
  55: 
  56: mat4 rotation(vec3 rot) {
  57:     return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
  58: }
  59: 
  60: mat3 modelToNormal(mat4 mat) {
  61:     // Discard the edges. This won't be accurate for scaled or skewed matrices,
  62:     // but we don't have to work with those often.
  63:     mat3 m;
  64:     m[0] = mat[0].xyz;
  65:     m[1] = mat[1].xyz;
  66:     m[2] = mat[2].xyz;
  67:     return m;
  68: }
  69: 
  70: #define PIOVER2 1.5707963268
  71: 
  72: vec4 quat(vec3 axis, float angle) {
  73:     float halfAngle = angle * PIOVER2 / 180.0;
  74:     vec2 cs = sin(vec2(PIOVER2 - halfAngle, halfAngle)); // compute sin and cos in one instruction
  75:     return vec4(axis.xyz * cs.y,  cs.x);
  76: }
  77: 
  78: vec4 quatMult(vec4 q1, vec4 q2) {
  79:     // disgustingly vectorized quaternion multiplication
  80:     vec4 a = q1.w * q2.xyzw;
  81:     vec4 b = q1.x * q2.wzxy * vec4(1., -1., 1., -1.);
  82:     vec4 c = q1.y * q2.zwxy * vec4(1., 1., -1., -1.);
  83:     vec4 d = q1.z * q2.yxwz * vec4(-1., 1., 1., -1.);
  84: 
  85:     return a + b + c + d;
  86: }
  87: 
  88: vec3 rotateVertexByQuat(vec3 v, vec4 q) {
  89:     vec3 i = q.xyz;
  90:     return v + 2.0 * cross(i, cross(i, v) + q.w * v);
  91: }
  92: 
  93: vec3 rotateAbout(vec3 v, vec3 axis, float angle) {
  94:     return rotateVertexByQuat(v, quat(axis, angle));
  95: }
  96: 
  97: float diffuse(vec3 normal) {
  98:     vec3 n2 = normal * normal * vec3(.6, .25, .8);
  99:     return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
 100: }
 101: 
 102: 
 103: struct Flap {
 104:     vec3 instancePos;
 105:     vec2 light;
 106:     vec3 segmentOffset;
 107:     vec3 pivot;
 108:     float horizontalAngle;
 109:     float intensity;
 110:     float flapScale;
 111:     float flapness;
 112: };
 113: 
 114: 
 115: struct Vertex {
 116:     vec3 pos;
 117:     vec3 normal;
 118:     vec2 texCoords;
 119: };
 120: 
 121: struct BlockFrag {
 122:     vec2 texCoords;
 123:     vec4 color;
 124:     float diffuse;
 125:     vec2 light;
 126: };
 127: 
 128: 
 129: float toRad(float degrees) {
 130:     return fract(degrees / 360.) * PI * 2.;
 131: }
 132: 
 133: float getFlapAngle(float flapness, float intensity, float scale) {
 134:     float absFlap = abs(flapness);
 135: 
 136:     float angle = sin((1. - absFlap) * PI * intensity) * 30. * flapness * scale;
 137: 
 138:     float halfAngle = angle * 0.5;
 139: 
 140:     float which = step(0., flapness);// 0 if negative, 1 if positive
 141:     float degrees = which * halfAngle + (1. - which) * angle;// branchless conditional multiply
 142: 
 143:     return degrees;
 144: }
 145: 
 146: BlockFrag FLWMain(Vertex v, Flap flap) {
 147:     float flapAngle = getFlapAngle(flap.flapness, flap.intensity, flap.flapScale);
 148: 
 149:     vec4 orientation = quat(vec3(0., 1., 0.), -flap.horizontalAngle);
 150:     vec4 flapRotation = quat(vec3(1., 0., 0.), flapAngle);
 151: 
 152:     vec3 rotated = rotateVertexByQuat(v.pos - flap.pivot, flapRotation) + flap.pivot + flap.segmentOffset;
 153:     rotated = rotateVertexByQuat(rotated - .5, orientation) + flap.instancePos + .5;
 154: 
 155:     vec4 worldPos = vec4(rotated, 1.);
 156:     vec3 norm = rotateVertexByQuat(rotateVertexByQuat(v.normal, flapRotation), orientation);
 157: 
 158:     FLWFinalizeWorldPos(worldPos);
 159:     FLWFinalizeNormal(norm);
 160: 
 161:     BlockFrag b;
 162:     b.diffuse = diffuse(norm);
 163:     b.texCoords = v.texCoords;
 164:     b.light = flap.light;
 165:     #if defined(DEBUG_NORMAL)
 166:     b.color = vec4(norm, 1.);
 167:     #else
 168:     b.color = vec4(1.);
 169:     #endif
 170:     return b;
 171: }
 172: attribute vec3 a_v_pos;
 173: attribute vec3 a_v_normal;
 174: attribute vec2 a_v_texCoords;
 175: 
 176: attribute vec3 a_i_instancePos;
 177: attribute vec2 a_i_light;
 178: attribute vec3 a_i_segmentOffset;
 179: attribute vec3 a_i_pivot;
 180: attribute float a_i_horizontalAngle;
 181: attribute float a_i_intensity;
 182: attribute float a_i_flapScale;
 183: attribute float a_i_flapness;
 184: 
 185: 
 186: varying vec2 v2f_texCoords;
 187: varying vec4 v2f_color;
 188: varying float v2f_diffuse;
 189: varying vec2 v2f_light;
 190: 
 191: 
 192: void main() {
 193:     Vertex v;
 194:     v.pos = a_v_pos;
 195: v.normal = a_v_normal;
 196: v.texCoords = a_v_texCoords;
 197: 
 198: 
 199:     Flap i;
 200:     i.instancePos = a_i_instancePos;
 201: i.light = a_i_light;
 202: i.segmentOffset = a_i_segmentOffset;
 203: i.pivot = a_i_pivot;
 204: i.horizontalAngle = a_i_horizontalAngle;
 205: i.intensity = a_i_intensity;
 206: i.flapScale = a_i_flapScale;
 207: i.flapness = a_i_flapness;
 208: 
 209: 
 210:     BlockFrag o = FLWMain(v, i);
 211: 
 212:     v2f_texCoords = o.texCoords;
 213: v2f_color = o.color;
 214: v2f_diffuse = o.diffuse;
 215: v2f_light = o.light;
 216: 
 217: }

[14:02:45] [main/ERROR]: Shader compilation log for flywheel:block.frag: No errors.

[14:02:45] [main/ERROR]: Source for shader 'flywheel:block.frag':
   1: #version 110
   2: 
   3: #if defined(USE_FOG)
   4: varying float FragDistance;
   5: uniform vec4 uFogColor;
   6: #endif
   7: 
   8: #if defined(USE_FOG_LINEAR)
   9: uniform vec2 uFogRange;
  10: 
  11: float FLWFogFactor() {
  12:     return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
  13: }
  14:     #endif
  15: 
  16:     #if defined(USE_FOG_EXP2)
  17: uniform float uFogDensity;
  18: 
  19: float FLWFogFactor() {
  20:     float dist = FragDistance * uFogDensity;
  21:     return 1. / exp2(dist * dist);
  22: }
  23:     #endif
  24: // Adjust the [0,1] normalized lightmap value based on the texture matrix from LightTexture#enableLightmap
  25: vec2 shiftLight(vec2 lm) {
  26:     return lm * 0.99609375 + 0.03125;// * 255/256 + 1/32
  27: }
  28: 
  29: varying vec3 BoxCoord;
  30: varying vec2 BoxLight;
  31: uniform sampler3D uLightVolume;
  32: 
  33: uniform sampler2D uBlockAtlas;
  34: uniform sampler2D uLightMap;
  35: 
  36: vec4 FLWBlockTexture(vec2 texCoords) {
  37:     return texture2D(uBlockAtlas, texCoords);
  38: }
  39: 
  40: void FLWFinalizeColor(vec4 color) {
  41:     #if defined(USE_FOG)
  42:     float a = color.a;
  43:     float fog = clamp(FLWFogFactor(), 0., 1.);
  44: 
  45:     color = mix(uFogColor, color, fog);
  46:     color.a = a;
  47:     #endif
  48: 
  49:     gl_FragColor = color;
  50: }
  51: 
  52: vec4 FLWLight(vec2 lightCoords) {
  53:     lightCoords = max(lightCoords, texture3D(uLightVolume, BoxCoord).rg);
  54: 
  55:     return texture2D(uLightMap, shiftLight(lightCoords));
  56: }
  57: 
  58: 
  59: 
  60: struct BlockFrag {
  61:     vec2 texCoords;
  62:     vec4 color;
  63:     float diffuse;
  64:     vec2 light;
  65: };
  66: 
  67: void FLWMain(BlockFrag r) {
  68:     vec4 tex = FLWBlockTexture(r.texCoords);
  69: 
  70:     vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;
  71: 
  72: //    flw_WorldPos = ;
  73: //    flw_Normal = ;
  74: //    flw_Albedo = tex.rgb;
  75: //    flw_Alpha = tex.a;
  76: //    flw_LightMap = r.light;
  77: //    flw_Tint = r.color;
  78:     FLWFinalizeColor(color);
  79: }
  80: 
  81: varying vec2 v2f_texCoords;
  82: varying vec4 v2f_color;
  83: varying float v2f_diffuse;
  84: varying vec2 v2f_light;
  85: 
  86: 
  87: //vec3 flw_WorldPos;
  88: //vec3 flw_Normal;
  89: //vec3 flw_Albedo;
  90: //float flw_Alpha;
  91: //vec2 flw_LightMap;
  92: //vec4 flw_Tint;
  93: 
  94: void main() {
  95:     BlockFrag f;
  96:     f.texCoords = v2f_texCoords;
  97: f.color = v2f_color;
  98: f.diffuse = v2f_diffuse;
  99: f.light = v2f_light;
 100: 
 101: 
 102:     FLWMain(f);
 103: }

[14:02:45] [Forge Version Check/INFO]: [morecfm] Found status: BETA Current: 1.3.1 Target: 1.3.1
[14:02:45] [Forge Version Check/INFO]: [fallingtree] Starting version check at https://raw.githubusercontent.com/RakSrinaNa/FallingTree/1.16.5/update.json
[14:02:45] [Forge Version Check/INFO]: [fallingtree] Found status: UP_TO_DATE Current: 2.11.5 Target: null
[14:02:45] [Forge Version Check/INFO]: [codechickenlib] Starting version check at https://version-check.covers1624.net/check/?mod=CodeChickenLib&mc=1.16.5
[14:02:45] [main/ERROR]: Shader compilation log for create:belt.vert: No errors.

[14:02:45] [main/ERROR]: Source for shader 'create:belt.vert':
   1: #version 110
   2: #define DEBUG_RAINBOW
   3: 
   4: #define PI 3.1415926538
   5: 
   6: #if defined(USE_FOG)
   7: varying float FragDistance;
   8: #endif
   9: 
  10: varying vec3 BoxCoord;
  11: 
  12: uniform vec3 uLightBoxSize;
  13: uniform vec3 uLightBoxMin;
  14: uniform mat4 uModel;
  15: 
  16: uniform float uTime;
  17: uniform mat4 uViewProjection;
  18: uniform vec3 uCameraPos;
  19: 
  20: void FLWFinalizeWorldPos(inout vec4 worldPos) {
  21:     worldPos = uModel * worldPos;
  22: 
  23:     BoxCoord = (worldPos.xyz - uLightBoxMin) / uLightBoxSize;
  24: 
  25:     #if defined(USE_FOG)
  26:     FragDistance = length(worldPos.xyz);
  27:     #endif
  28: 
  29:     gl_Position = uViewProjection * worldPos;
  30: }
  31: 
  32: void FLWFinalizeNormal(inout vec3 normal) {
  33:     mat3 m;
  34:     m[0] = uModel[0].xyz;
  35:     m[1] = uModel[1].xyz;
  36:     m[2] = uModel[2].xyz;
  37:     normal = m * normal;
  38: }
  39: 
  40: 
  41: 
  42: #define PIOVER2 1.5707963268
  43: 
  44: vec4 quat(vec3 axis, float angle) {
  45:     float halfAngle = angle * PIOVER2 / 180.0;
  46:     vec2 cs = sin(vec2(PIOVER2 - halfAngle, halfAngle)); // compute sin and cos in one instruction
  47:     return vec4(axis.xyz * cs.y,  cs.x);
  48: }
  49: 
  50: vec4 quatMult(vec4 q1, vec4 q2) {
  51:     // disgustingly vectorized quaternion multiplication
  52:     vec4 a = q1.w * q2.xyzw;
  53:     vec4 b = q1.x * q2.wzxy * vec4(1., -1., 1., -1.);
  54:     vec4 c = q1.y * q2.zwxy * vec4(1., 1., -1., -1.);
  55:     vec4 d = q1.z * q2.yxwz * vec4(-1., 1., 1., -1.);
  56: 
  57:     return a + b + c + d;
  58: }
  59: 
  60: vec3 rotateVertexByQuat(vec3 v, vec4 q) {
  61:     vec3 i = q.xyz;
  62:     return v + 2.0 * cross(i, cross(i, v) + q.w * v);
  63: }
  64: 
  65: vec3 rotateAbout(vec3 v, vec3 axis, float angle) {
  66:     return rotateVertexByQuat(v, quat(axis, angle));
  67: }
  68: 
  69: mat4 rotate(vec3 axis, float angle) {
  70:     float s = sin(angle);
  71:     float c = cos(angle);
  72:     float oc = 1. - c;
  73: 
  74:     vec3 sa = axis * s;
  75: 
  76:     mat4 mr = mat4(1.);
  77:     mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
  78:     mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
  79:     mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);
  80: 
  81:     return mr;
  82: }
  83: 
  84: mat4 rotation(vec3 rot) {
  85:     return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
  86: }
  87: 
  88: mat3 modelToNormal(mat4 mat) {
  89:     // Discard the edges. This won't be accurate for scaled or skewed matrices,
  90:     // but we don't have to work with those often.
  91:     mat3 m;
  92:     m[0] = mat[0].xyz;
  93:     m[1] = mat[1].xyz;
  94:     m[2] = mat[2].xyz;
  95:     return m;
  96: }
  97: 
  98: float diffuse(vec3 normal) {
  99:     vec3 n2 = normal * normal * vec3(.6, .25, .8);
 100:     return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
 101: }
 102: 
 103: 
 104: struct Belt {
 105:     vec2 light;
 106:     vec4 color;
 107:     vec3 pos;
 108:     float speed;
 109:     float offset;
 110:     vec4 rotation;
 111:     vec2 sourceTexture;
 112:     vec4 scrollTexture;
 113:     float scrollMult;
 114: };
 115: 
 116: 
 117: struct Vertex {
 118:     vec3 pos;
 119:     vec3 normal;
 120:     vec2 texCoords;
 121: };
 122: 
 123: struct BlockFrag {
 124:     vec2 texCoords;
 125:     vec4 color;
 126:     float diffuse;
 127:     vec2 light;
 128: };
 129: 
 130: BlockFrag FLWMain(Vertex v, Belt instance) {
 131:     vec3 rotated = rotateVertexByQuat(v.pos - .5, instance.rotation) + instance.pos + .5;
 132: 
 133:     vec4 worldPos = vec4(rotated, 1.);
 134: 
 135:     vec3 norm = rotateVertexByQuat(v.normal, instance.rotation);
 136: 
 137:     FLWFinalizeWorldPos(worldPos);
 138:     FLWFinalizeNormal(norm);
 139: 
 140:     float scrollSize = instance.scrollTexture.w - instance.scrollTexture.y;
 141:     float scroll = fract(instance.speed * uTime / (31.5 * 16.) + instance.offset) * scrollSize * instance.scrollMult;
 142: 
 143:     BlockFrag b;
 144:     b.diffuse = diffuse(norm);
 145:     b.texCoords = v.texCoords - instance.sourceTexture + instance.scrollTexture.xy + vec2(0, scroll);
 146:     b.light = instance.light;
 147: 
 148:     #if defined(DEBUG_RAINBOW)
 149:     b.color = instance.color;
 150:     #elif defined(DEBUG_NORMAL)
 151:     b.color = vec4(norm, 1.);
 152:     #else
 153:     b.color = vec4(1.);
 154:     #endif
 155: 
 156:     return b;
 157: }
 158: attribute vec3 a_v_pos;
 159: attribute vec3 a_v_normal;
 160: attribute vec2 a_v_texCoords;
 161: 
 162: attribute vec2 a_i_light;
 163: attribute vec4 a_i_color;
 164: attribute vec3 a_i_pos;
 165: attribute float a_i_speed;
 166: attribute float a_i_offset;
 167: attribute vec4 a_i_rotation;
 168: attribute vec2 a_i_sourceTexture;
 169: attribute vec4 a_i_scrollTexture;
 170: attribute float a_i_scrollMult;
 171: 
 172: 
 173: varying vec2 v2f_texCoords;
 174: varying vec4 v2f_color;
 175: varying float v2f_diffuse;
 176: varying vec2 v2f_light;
 177: 
 178: 
 179: void main() {
 180:     Vertex v;
 181:     v.pos = a_v_pos;
 182: v.normal = a_v_normal;
 183: v.texCoords = a_v_texCoords;
 184: 
 185: 
 186:     Belt i;
 187:     i.light = a_i_light;
 188: i.color = a_i_color;
 189: i.pos = a_i_pos;
 190: i.speed = a_i_speed;
 191: i.offset = a_i_offset;
 192: i.rotation = a_i_rotation;
 193: i.sourceTexture = a_i_sourceTexture;
 194: i.scrollTexture = a_i_scrollTexture;
 195: i.scrollMult = a_i_scrollMult;
 196: 
 197: 
 198:     BlockFrag o = FLWMain(v, i);
 199: 
 200:     v2f_texCoords = o.texCoords;
 201: v2f_color = o.color;
 202: v2f_diffuse = o.diffuse;
 203: v2f_light = o.light;
 204: 
 205: }

[14:02:45] [main/ERROR]: Shader compilation log for flywheel:block.frag: No errors.

[14:02:45] [main/ERROR]: Source for shader 'flywheel:block.frag':
   1: #version 110
   2: #define DEBUG_RAINBOW
   3: 
   4: #if defined(USE_FOG)
   5: varying float FragDistance;
   6: uniform vec4 uFogColor;
   7: #endif
   8: 
   9: #if defined(USE_FOG_LINEAR)
  10: uniform vec2 uFogRange;
  11: 
  12: float FLWFogFactor() {
  13:     return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
  14: }
  15:     #endif
  16: 
  17:     #if defined(USE_FOG_EXP2)
  18: uniform float uFogDensity;
  19: 
  20: float FLWFogFactor() {
  21:     float dist = FragDistance * uFogDensity;
  22:     return 1. / exp2(dist * dist);
  23: }
  24:     #endif
  25: // Adjust the [0,1] normalized lightmap value based on the texture matrix from LightTexture#enableLightmap
  26: vec2 shiftLight(vec2 lm) {
  27:     return lm * 0.99609375 + 0.03125;// * 255/256 + 1/32
  28: }
  29: 
  30: varying vec3 BoxCoord;
  31: varying vec2 BoxLight;
  32: uniform sampler3D uLightVolume;
  33: 
  34: uniform sampler2D uBlockAtlas;
  35: uniform sampler2D uLightMap;
  36: 
  37: vec4 FLWBlockTexture(vec2 texCoords) {
  38:     return texture2D(uBlockAtlas, texCoords);
  39: }
  40: 
  41: void FLWFinalizeColor(vec4 color) {
  42:     #if defined(USE_FOG)
  43:     float a = color.a;
  44:     float fog = clamp(FLWFogFactor(), 0., 1.);
  45: 
  46:     color = mix(uFogColor, color, fog);
  47:     color.a = a;
  48:     #endif
  49: 
  50:     gl_FragColor = color;
  51: }
  52: 
  53: vec4 FLWLight(vec2 lightCoords) {
  54:     lightCoords = max(lightCoords, texture3D(uLightVolume, BoxCoord).rg);
  55: 
  56:     return texture2D(uLightMap, shiftLight(lightCoords));
  57: }
  58: 
  59: 
  60: 
  61: struct BlockFrag {
  62:     vec2 texCoords;
  63:     vec4 color;
  64:     float diffuse;
  65:     vec2 light;
  66: };
  67: 
  68: void FLWMain(BlockFrag r) {
  69:     vec4 tex = FLWBlockTexture(r.texCoords);
  70: 
  71:     vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;
  72: 
  73: //    flw_WorldPos = ;
  74: //    flw_Normal = ;
  75: //    flw_Albedo = tex.rgb;
  76: //    flw_Alpha = tex.a;
  77: //    flw_LightMap = r.light;
  78: //    flw_Tint = r.color;
  79:     FLWFinalizeColor(color);
  80: }
  81: 
  82: varying vec2 v2f_texCoords;
  83: varying vec4 v2f_color;
  84: varying float v2f_diffuse;
  85: varying vec2 v2f_light;
  86: 
  87: 
  88: //vec3 flw_WorldPos;
  89: //vec3 flw_Normal;
  90: //vec3 flw_Albedo;
  91: //float flw_Alpha;
  92: //vec2 flw_LightMap;
  93: //vec4 flw_Tint;
  94: 
  95: void main() {
  96:     BlockFrag f;
  97:     f.texCoords = v2f_texCoords;
  98: f.color = v2f_color;
  99: f.diffuse = v2f_diffuse;
 100: f.light = v2f_light;
 101: 
 102: 
 103:     FLWMain(f);
 104: }

[14:02:45] [main/ERROR]: Shader compilation log for create:belt.vert: No errors.

[14:02:45] [main/ERROR]: Source for shader 'create:belt.vert':
   1: #version 110
   2: #define DEBUG_NORMAL
   3: 
   4: #define PI 3.1415926538
   5: 
   6: #if defined(USE_FOG)
   7: varying float FragDistance;
   8: #endif
   9: 
  10: varying vec3 BoxCoord;
  11: 
  12: uniform vec3 uLightBoxSize;
  13: uniform vec3 uLightBoxMin;
  14: uniform mat4 uModel;
  15: 
  16: uniform float uTime;
  17: uniform mat4 uViewProjection;
  18: uniform vec3 uCameraPos;
  19: 
  20: void FLWFinalizeWorldPos(inout vec4 worldPos) {
  21:     worldPos = uModel * worldPos;
  22: 
  23:     BoxCoord = (worldPos.xyz - uLightBoxMin) / uLightBoxSize;
  24: 
  25:     #if defined(USE_FOG)
  26:     FragDistance = length(worldPos.xyz);
  27:     #endif
  28: 
  29:     gl_Position = uViewProjection * worldPos;
  30: }
  31: 
  32: void FLWFinalizeNormal(inout vec3 normal) {
  33:     mat3 m;
  34:     m[0] = uModel[0].xyz;
  35:     m[1] = uModel[1].xyz;
  36:     m[2] = uModel[2].xyz;
  37:     normal = m * normal;
  38: }
  39: 
  40: 
  41: 
  42: #define PIOVER2 1.5707963268
  43: 
  44: vec4 quat(vec3 axis, float angle) {
  45:     float halfAngle = angle * PIOVER2 / 180.0;
  46:     vec2 cs = sin(vec2(PIOVER2 - halfAngle, halfAngle)); // compute sin and cos in one instruction
  47:     return vec4(axis.xyz * cs.y,  cs.x);
  48: }
  49: 
  50: vec4 quatMult(vec4 q1, vec4 q2) {
  51:     // disgustingly vectorized quaternion multiplication
  52:     vec4 a = q1.w * q2.xyzw;
  53:     vec4 b = q1.x * q2.wzxy * vec4(1., -1., 1., -1.);
  54:     vec4 c = q1.y * q2.zwxy * vec4(1., 1., -1., -1.);
  55:     vec4 d = q1.z * q2.yxwz * vec4(-1., 1., 1., -1.);
  56: 
  57:     return a + b + c + d;
  58: }
  59: 
  60: vec3 rotateVertexByQuat(vec3 v, vec4 q) {
  61:     vec3 i = q.xyz;
  62:     return v + 2.0 * cross(i, cross(i, v) + q.w * v);
  63: }
  64: 
  65: vec3 rotateAbout(vec3 v, vec3 axis, float angle) {
  66:     return rotateVertexByQuat(v, quat(axis, angle));
  67: }
  68: 
  69: mat4 rotate(vec3 axis, float angle) {
  70:     float s = sin(angle);
  71:     float c = cos(angle);
  72:     float oc = 1. - c;
  73: 
  74:     vec3 sa = axis * s;
  75: 
  76:     mat4 mr = mat4(1.);
  77:     mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
  78:     mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
  79:     mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);
  80: 
  81:     return mr;
  82: }
  83: 
  84: mat4 rotation(vec3 rot) {
  85:     return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
  86: }
  87: 
  88: mat3 modelToNormal(mat4 mat) {
  89:     // Discard the edges. This won't be accurate for scaled or skewed matrices,
  90:     // but we don't have to work with those often.
  91:     mat3 m;
  92:     m[0] = mat[0].xyz;
  93:     m[1] = mat[1].xyz;
  94:     m[2] = mat[2].xyz;
  95:     return m;
  96: }
  97: 
  98: float diffuse(vec3 normal) {
  99:     vec3 n2 = normal * normal * vec3(.6, .25, .8);
 100:     return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
 101: }
 102: 
 103: 
 104: struct Belt {
 105:     vec2 light;
 106:     vec4 color;
 107:     vec3 pos;
 108:     float speed;
 109:     float offset;
 110:     vec4 rotation;
 111:     vec2 sourceTexture;
 112:     vec4 scrollTexture;
 113:     float scrollMult;
 114: };
 115: 
 116: 
 117: struct Vertex {
 118:     vec3 pos;
 119:     vec3 normal;
 120:     vec2 texCoords;
 121: };
 122: 
 123: struct BlockFrag {
 124:     vec2 texCoords;
 125:     vec4 color;
 126:     float diffuse;
 127:     vec2 light;
 128: };
 129: 
 130: BlockFrag FLWMain(Vertex v, Belt instance) {
 131:     vec3 rotated = rotateVertexByQuat(v.pos - .5, instance.rotation) + instance.pos + .5;
 132: 
 133:     vec4 worldPos = vec4(rotated, 1.);
 134: 
 135:     vec3 norm = rotateVertexByQuat(v.normal, instance.rotation);
 136: 
 137:     FLWFinalizeWorldPos(worldPos);
 138:     FLWFinalizeNormal(norm);
 139: 
 140:     float scrollSize = instance.scrollTexture.w - instance.scrollTexture.y;
 141:     float scroll = fract(instance.speed * uTime / (31.5 * 16.) + instance.offset) * scrollSize * instance.scrollMult;
 142: 
 143:     BlockFrag b;
 144:     b.diffuse = diffuse(norm);
 145:     b.texCoords = v.texCoords - instance.sourceTexture + instance.scrollTexture.xy + vec2(0, scroll);
 146:     b.light = instance.light;
 147: 
 148:     #if defined(DEBUG_RAINBOW)
 149:     b.color = instance.color;
 150:     #elif defined(DEBUG_NORMAL)
 151:     b.color = vec4(norm, 1.);
 152:     #else
 153:     b.color = vec4(1.);
 154:     #endif
 155: 
 156:     return b;
 157: }
 158: attribute vec3 a_v_pos;
 159: attribute vec3 a_v_normal;
 160: attribute vec2 a_v_texCoords;
 161: 
 162: attribute vec2 a_i_light;
 163: attribute vec4 a_i_color;
 164: attribute vec3 a_i_pos;
 165: attribute float a_i_speed;
 166: attribute float a_i_offset;
 167: attribute vec4 a_i_rotation;
 168: attribute vec2 a_i_sourceTexture;
 169: attribute vec4 a_i_scrollTexture;
 170: attribute float a_i_scrollMult;
 171: 
 172: 
 173: varying vec2 v2f_texCoords;
 174: varying vec4 v2f_color;
 175: varying float v2f_diffuse;
 176: varying vec2 v2f_light;
 177: 
 178: 
 179: void main() {
 180:     Vertex v;
 181:     v.pos = a_v_pos;
 182: v.normal = a_v_normal;
 183: v.texCoords = a_v_texCoords;
 184: 
 185: 
 186:     Belt i;
 187:     i.light = a_i_light;
 188: i.color = a_i_color;
 189: i.pos = a_i_pos;
 190: i.speed = a_i_speed;
 191: i.offset = a_i_offset;
 192: i.rotation = a_i_rotation;
 193: i.sourceTexture = a_i_sourceTexture;
 194: i.scrollTexture = a_i_scrollTexture;
 195: i.scrollMult = a_i_scrollMult;
 196: 
 197: 
 198:     BlockFrag o = FLWMain(v, i);
 199: 
 200:     v2f_texCoords = o.texCoords;
 201: v2f_color = o.color;
 202: v2f_diffuse = o.diffuse;
 203: v2f_light = o.light;
 204: 
 205: }

[14:02:45] [main/ERROR]: Shader compilation log for flywheel:block.frag: No errors.

[14:02:45] [main/ERROR]: Source for shader 'flywheel:block.frag':
   1: #version 110
   2: #define DEBUG_NORMAL
   3: 
   4: #if defined(USE_FOG)
   5: varying float FragDistance;
   6: uniform vec4 uFogColor;
   7: #endif
   8: 
   9: #if defined(USE_FOG_LINEAR)
  10: uniform vec2 uFogRange;
  11: 
  12: float FLWFogFactor() {
  13:     return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
  14: }
  15:     #endif
  16: 
  17:     #if defined(USE_FOG_EXP2)
  18: uniform float uFogDensity;
  19: 
  20: float FLWFogFactor() {
  21:     float dist = FragDistance * uFogDensity;
  22:     return 1. / exp2(dist * dist);
  23: }
  24:     #endif
  25: // Adjust the [0,1] normalized lightmap value based on the texture matrix from LightTexture#enableLightmap
  26: vec2 shiftLight(vec2 lm) {
  27:     return lm * 0.99609375 + 0.03125;// * 255/256 + 1/32
  28: }
  29: 
  30: varying vec3 BoxCoord;
  31: varying vec2 BoxLight;
  32: uniform sampler3D uLightVolume;
  33: 
  34: uniform sampler2D uBlockAtlas;
  35: uniform sampler2D uLightMap;
  36: 
  37: vec4 FLWBlockTexture(vec2 texCoords) {
  38:     return texture2D(uBlockAtlas, texCoords);
  39: }
  40: 
  41: void FLWFinalizeColor(vec4 color) {
  42:     #if defined(USE_FOG)
  43:     float a = color.a;
  44:     float fog = clamp(FLWFogFactor(), 0., 1.);
  45: 
  46:     color = mix(uFogColor, color, fog);
  47:     color.a = a;
  48:     #endif
  49: 
  50:     gl_FragColor = color;
  51: }
  52: 
  53: vec4 FLWLight(vec2 lightCoords) {
  54:     lightCoords = max(lightCoords, texture3D(uLightVolume, BoxCoord).rg);
  55: 
  56:     return texture2D(uLightMap, shiftLight(lightCoords));
  57: }
  58: 
  59: 
  60: 
  61: struct BlockFrag {
  62:     vec2 texCoords;
  63:     vec4 color;
  64:     float diffuse;
  65:     vec2 light;
  66: };
  67: 
  68: void FLWMain(BlockFrag r) {
  69:     vec4 tex = FLWBlockTexture(r.texCoords);
  70: 
  71:     vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;
  72: 
  73: //    flw_WorldPos = ;
  74: //    flw_Normal = ;
  75: //    flw_Albedo = tex.rgb;
  76: //    flw_Alpha = tex.a;
  77: //    flw_LightMap = r.light;
  78: //    flw_Tint = r.color;
  79:     FLWFinalizeColor(color);
  80: }
  81: 
  82: varying vec2 v2f_texCoords;
  83: varying vec4 v2f_color;
  84: varying float v2f_diffuse;
  85: varying vec2 v2f_light;
  86: 
  87: 
  88: //vec3 flw_WorldPos;
  89: //vec3 flw_Normal;
  90: //vec3 flw_Albedo;
  91: //float flw_Alpha;
  92: //vec2 flw_LightMap;
  93: //vec4 flw_Tint;
  94: 
  95: void main() {
  96:     BlockFrag f;
  97:     f.texCoords = v2f_texCoords;
  98: f.color = v2f_color;
  99: f.diffuse = v2f_diffuse;
 100: f.light = v2f_light;
 101: 
 102: 
 103:     FLWMain(f);
 104: }

[14:02:45] [main/ERROR]: Shader compilation log for create:belt.vert: No errors.

[14:02:45] [main/ERROR]: Source for shader 'create:belt.vert':
   1: #version 110
   2: #define USE_FOG
   3: #define USE_FOG_LINEAR
   4: 
   5: #define PI 3.1415926538
   6: 
   7: #if defined(USE_FOG)
   8: varying float FragDistance;
   9: #endif
  10: 
  11: varying vec3 BoxCoord;
  12: 
  13: uniform vec3 uLightBoxSize;
  14: uniform vec3 uLightBoxMin;
  15: uniform mat4 uModel;
  16: 
  17: uniform float uTime;
  18: uniform mat4 uViewProjection;
  19: uniform vec3 uCameraPos;
  20: 
  21: void FLWFinalizeWorldPos(inout vec4 worldPos) {
  22:     worldPos = uModel * worldPos;
  23: 
  24:     BoxCoord = (worldPos.xyz - uLightBoxMin) / uLightBoxSize;
  25: 
  26:     #if defined(USE_FOG)
  27:     FragDistance = length(worldPos.xyz);
  28:     #endif
  29: 
  30:     gl_Position = uViewProjection * worldPos;
  31: }
  32: 
  33: void FLWFinalizeNormal(inout vec3 normal) {
  34:     mat3 m;
  35:     m[0] = uModel[0].xyz;
  36:     m[1] = uModel[1].xyz;
  37:     m[2] = uModel[2].xyz;
  38:     normal = m * normal;
  39: }
  40: 
  41: 
  42: 
  43: #define PIOVER2 1.5707963268
  44: 
  45: vec4 quat(vec3 axis, float angle) {
  46:     float halfAngle = angle * PIOVER2 / 180.0;
  47:     vec2 cs = sin(vec2(PIOVER2 - halfAngle, halfAngle)); // compute sin and cos in one instruction
  48:     return vec4(axis.xyz * cs.y,  cs.x);
  49: }
  50: 
  51: vec4 quatMult(vec4 q1, vec4 q2) {
  52:     // disgustingly vectorized quaternion multiplication
  53:     vec4 a = q1.w * q2.xyzw;
  54:     vec4 b = q1.x * q2.wzxy * vec4(1., -1., 1., -1.);
  55:     vec4 c = q1.y * q2.zwxy * vec4(1., 1., -1., -1.);
  56:     vec4 d = q1.z * q2.yxwz * vec4(-1., 1., 1., -1.);
  57: 
  58:     return a + b + c + d;
  59: }
  60: 
  61: vec3 rotateVertexByQuat(vec3 v, vec4 q) {
  62:     vec3 i = q.xyz;
  63:     return v + 2.0 * cross(i, cross(i, v) + q.w * v);
  64: }
  65: 
  66: vec3 rotateAbout(vec3 v, vec3 axis, float angle) {
  67:     return rotateVertexByQuat(v, quat(axis, angle));
  68: }
  69: 
  70: mat4 rotate(vec3 axis, float angle) {
  71:     float s = sin(angle);
  72:     float c = cos(angle);
  73:     float oc = 1. - c;
  74: 
  75:     vec3 sa = axis * s;
  76: 
  77:     mat4 mr = mat4(1.);
  78:     mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
  79:     mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
  80:     mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);
  81: 
  82:     return mr;
  83: }
  84: 
  85: mat4 rotation(vec3 rot) {
  86:     return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
  87: }
  88: 
  89: mat3 modelToNormal(mat4 mat) {
  90:     // Discard the edges. This won't be accurate for scaled or skewed matrices,
  91:     // but we don't have to work with those often.
  92:     mat3 m;
  93:     m[0] = mat[0].xyz;
  94:     m[1] = mat[1].xyz;
  95:     m[2] = mat[2].xyz;
  96:     return m;
  97: }
  98: 
  99: float diffuse(vec3 normal) {
 100:     vec3 n2 = normal * normal * vec3(.6, .25, .8);
 101:     return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
 102: }
 103: 
 104: 
 105: struct Belt {
 106:     vec2 light;
 107:     vec4 color;
 108:     vec3 pos;
 109:     float speed;
 110:     float offset;
 111:     vec4 rotation;
 112:     vec2 sourceTexture;
 113:     vec4 scrollTexture;
 114:     float scrollMult;
 115: };
 116: 
 117: 
 118: struct Vertex {
 119:     vec3 pos;
 120:     vec3 normal;
 121:     vec2 texCoords;
 122: };
 123: 
 124: struct BlockFrag {
 125:     vec2 texCoords;
 126:     vec4 color;
 127:     float diffuse;
 128:     vec2 light;
 129: };
 130: 
 131: BlockFrag FLWMain(Vertex v, Belt instance) {
 132:     vec3 rotated = rotateVertexByQuat(v.pos - .5, instance.rotation) + instance.pos + .5;
 133: 
 134:     vec4 worldPos = vec4(rotated, 1.);
 135: 
 136:     vec3 norm = rotateVertexByQuat(v.normal, instance.rotation);
 137: 
 138:     FLWFinalizeWorldPos(worldPos);
 139:     FLWFinalizeNormal(norm);
 140: 
 141:     float scrollSize = instance.scrollTexture.w - instance.scrollTexture.y;
 142:     float scroll = fract(instance.speed * uTime / (31.5 * 16.) + instance.offset) * scrollSize * instance.scrollMult;
 143: 
 144:     BlockFrag b;
 145:     b.diffuse = diffuse(norm);
 146:     b.texCoords = v.texCoords - instance.sourceTexture + instance.scrollTexture.xy + vec2(0, scroll);
 147:     b.light = instance.light;
 148: 
 149:     #if defined(DEBUG_RAINBOW)
 150:     b.color = instance.color;
 151:     #elif defined(DEBUG_NORMAL)
 152:     b.color = vec4(norm, 1.);
 153:     #else
 154:     b.color = vec4(1.);
 155:     #endif
 156: 
 157:     return b;
 158: }
 159: attribute vec3 a_v_pos;
 160: attribute vec3 a_v_normal;
 161: attribute vec2 a_v_texCoords;
 162: 
 163: attribute vec2 a_i_light;
 164: attribute vec4 a_i_color;
 165: attribute vec3 a_i_pos;
 166: attribute float a_i_speed;
 167: attribute float a_i_offset;
 168: attribute vec4 a_i_rotation;
 169: attribute vec2 a_i_sourceTexture;
 170: attribute vec4 a_i_scrollTexture;
 171: attribute float a_i_scrollMult;
 172: 
 173: 
 174: varying vec2 v2f_texCoords;
 175: varying vec4 v2f_color;
 176: varying float v2f_diffuse;
 177: varying vec2 v2f_light;
 178: 
 179: 
 180: void main() {
 181:     Vertex v;
 182:     v.pos = a_v_pos;
 183: v.normal = a_v_normal;
 184: v.texCoords = a_v_texCoords;
 185: 
 186: 
 187:     Belt i;
 188:     i.light = a_i_light;
 189: i.color = a_i_color;
 190: i.pos = a_i_pos;
 191: i.speed = a_i_speed;
 192: i.offset = a_i_offset;
 193: i.rotation = a_i_rotation;
 194: i.sourceTexture = a_i_sourceTexture;
 195: i.scrollTexture = a_i_scrollTexture;
 196: i.scrollMult = a_i_scrollMult;
 197: 
 198: 
 199:     BlockFrag o = FLWMain(v, i);
 200: 
 201:     v2f_texCoords = o.texCoords;
 202: v2f_color = o.color;
 203: v2f_diffuse = o.diffuse;
 204: v2f_light = o.light;
 205: 
 206: }

[14:02:45] [main/ERROR]: Shader compilation log for flywheel:block.frag: No errors.

[14:02:45] [main/ERROR]: Source for shader 'flywheel:block.frag':
   1: #version 110
   2: #define USE_FOG
   3: #define USE_FOG_LINEAR
   4: 
   5: #if defined(USE_FOG)
   6: varying float FragDistance;
   7: uniform vec4 uFogColor;
   8: #endif
   9: 
  10: #if defined(USE_FOG_LINEAR)
  11: uniform vec2 uFogRange;
  12: 
  13: float FLWFogFactor() {
  14:     return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
  15: }
  16:     #endif
  17: 
  18:     #if defined(USE_FOG_EXP2)
  19: uniform float uFogDensity;
  20: 
  21: float FLWFogFactor() {
  22:     float dist = FragDistance * uFogDensity;
  23:     return 1. / exp2(dist * dist);
  24: }
  25:     #endif
  26: // Adjust the [0,1] normalized lightmap value based on the texture matrix from LightTexture#enableLightmap
  27: vec2 shiftLight(vec2 lm) {
  28:     return lm * 0.99609375 + 0.03125;// * 255/256 + 1/32
  29: }
  30: 
  31: varying vec3 BoxCoord;
  32: varying vec2 BoxLight;
  33: uniform sampler3D uLightVolume;
  34: 
  35: uniform sampler2D uBlockAtlas;
  36: uniform sampler2D uLightMap;
  37: 
  38: vec4 FLWBlockTexture(vec2 texCoords) {
  39:     return texture2D(uBlockAtlas, texCoords);
  40: }
  41: 
  42: void FLWFinalizeColor(vec4 color) {
  43:     #if defined(USE_FOG)
  44:     float a = color.a;
  45:     float fog = clamp(FLWFogFactor(), 0., 1.);
  46: 
  47:     color = mix(uFogColor, color, fog);
  48:     color.a = a;
  49:     #endif
  50: 
  51:     gl_FragColor = color;
  52: }
  53: 
  54: vec4 FLWLight(vec2 lightCoords) {
  55:     lightCoords = max(lightCoords, texture3D(uLightVolume, BoxCoord).rg);
  56: 
  57:     return texture2D(uLightMap, shiftLight(lightCoords));
  58: }
  59: 
  60: 
  61: 
  62: struct BlockFrag {
  63:     vec2 texCoords;
  64:     vec4 color;
  65:     float diffuse;
  66:     vec2 light;
  67: };
  68: 
  69: void FLWMain(BlockFrag r) {
  70:     vec4 tex = FLWBlockTexture(r.texCoords);
  71: 
  72:     vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;
  73: 
  74: //    flw_WorldPos = ;
  75: //    flw_Normal = ;
  76: //    flw_Albedo = tex.rgb;
  77: //    flw_Alpha = tex.a;
  78: //    flw_LightMap = r.light;
  79: //    flw_Tint = r.color;
  80:     FLWFinalizeColor(color);
  81: }
  82: 
  83: varying vec2 v2f_texCoords;
  84: varying vec4 v2f_color;
  85: varying float v2f_diffuse;
  86: varying vec2 v2f_light;
  87: 
  88: 
  89: //vec3 flw_WorldPos;
  90: //vec3 flw_Normal;
  91: //vec3 flw_Albedo;
  92: //float flw_Alpha;
  93: //vec2 flw_LightMap;
  94: //vec4 flw_Tint;
  95: 
  96: void main() {
  97:     BlockFrag f;
  98:     f.texCoords = v2f_texCoords;
  99: f.color = v2f_color;
 100: f.diffuse = v2f_diffuse;
 101: f.light = v2f_light;
 102: 
 103: 
 104:     FLWMain(f);
 105: }

[14:02:45] [main/ERROR]: Shader compilation log for create:belt.vert: No errors.

[14:02:45] [main/ERROR]: Source for shader 'create:belt.vert':
   1: #version 110
   2: #define USE_FOG
   3: #define USE_FOG_EXP2
   4: 
   5: #define PI 3.1415926538
   6: 
   7: #if defined(USE_FOG)
   8: varying float FragDistance;
   9: #endif
  10: 
  11: varying vec3 BoxCoord;
  12: 
  13: uniform vec3 uLightBoxSize;
  14: uniform vec3 uLightBoxMin;
  15: uniform mat4 uModel;
  16: 
  17: uniform float uTime;
  18: uniform mat4 uViewProjection;
  19: uniform vec3 uCameraPos;
  20: 
  21: void FLWFinalizeWorldPos(inout vec4 worldPos) {
  22:     worldPos = uModel * worldPos;
  23: 
  24:     BoxCoord = (worldPos.xyz - uLightBoxMin) / uLightBoxSize;
  25: 
  26:     #if defined(USE_FOG)
  27:     FragDistance = length(worldPos.xyz);
  28:     #endif
  29: 
  30:     gl_Position = uViewProjection * worldPos;
  31: }
  32: 
  33: void FLWFinalizeNormal(inout vec3 normal) {
  34:     mat3 m;
  35:     m[0] = uModel[0].xyz;
  36:     m[1] = uModel[1].xyz;
  37:     m[2] = uModel[2].xyz;
  38:     normal = m * normal;
  39: }
  40: 
  41: 
  42: 
  43: #define PIOVER2 1.5707963268
  44: 
  45: vec4 quat(vec3 axis, float angle) {
  46:     float halfAngle = angle * PIOVER2 / 180.0;
  47:     vec2 cs = sin(vec2(PIOVER2 - halfAngle, halfAngle)); // compute sin and cos in one instruction
  48:     return vec4(axis.xyz * cs.y,  cs.x);
  49: }
  50: 
  51: vec4 quatMult(vec4 q1, vec4 q2) {
  52:     // disgustingly vectorized quaternion multiplication
  53:     vec4 a = q1.w * q2.xyzw;
  54:     vec4 b = q1.x * q2.wzxy * vec4(1., -1., 1., -1.);
  55:     vec4 c = q1.y * q2.zwxy * vec4(1., 1., -1., -1.);
  56:     vec4 d = q1.z * q2.yxwz * vec4(-1., 1., 1., -1.);
  57: 
  58:     return a + b + c + d;
  59: }
  60: 
  61: vec3 rotateVertexByQuat(vec3 v, vec4 q) {
  62:     vec3 i = q.xyz;
  63:     return v + 2.0 * cross(i, cross(i, v) + q.w * v);
  64: }
  65: 
  66: vec3 rotateAbout(vec3 v, vec3 axis, float angle) {
  67:     return rotateVertexByQuat(v, quat(axis, angle));
  68: }
  69: 
  70: mat4 rotate(vec3 axis, float angle) {
  71:     float s = sin(angle);
  72:     float c = cos(angle);
  73:     float oc = 1. - c;
  74: 
  75:     vec3 sa = axis * s;
  76: 
  77:     mat4 mr = mat4(1.);
  78:     mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
  79:     mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
  80:     mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);
  81: 
  82:     return mr;
  83: }
  84: 
  85: mat4 rotation(vec3 rot) {
  86:     return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
  87: }
  88: 
  89: mat3 modelToNormal(mat4 mat) {
  90:     // Discard the edges. This won't be accurate for scaled or skewed matrices,
  91:     // but we don't have to work with those often.
  92:     mat3 m;
  93:     m[0] = mat[0].xyz;
  94:     m[1] = mat[1].xyz;
  95:     m[2] = mat[2].xyz;
  96:     return m;
  97: }
  98: 
  99: float diffuse(vec3 normal) {
 100:     vec3 n2 = normal * normal * vec3(.6, .25, .8);
 101:     return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
 102: }
 103: 
 104: 
 105: struct Belt {
 106:     vec2 light;
 107:     vec4 color;
 108:     vec3 pos;
 109:     float speed;
 110:     float offset;
 111:     vec4 rotation;
 112:     vec2 sourceTexture;
 113:     vec4 scrollTexture;
 114:     float scrollMult;
 115: };
 116: 
 117: 
 118: struct Vertex {
 119:     vec3 pos;
 120:     vec3 normal;
 121:     vec2 texCoords;
 122: };
 123: 
 124: struct BlockFrag {
 125:     vec2 texCoords;
 126:     vec4 color;
 127:     float diffuse;
 128:     vec2 light;
 129: };
 130: 
 131: BlockFrag FLWMain(Vertex v, Belt instance) {
 132:     vec3 rotated = rotateVertexByQuat(v.pos - .5, instance.rotation) + instance.pos + .5;
 133: 
 134:     vec4 worldPos = vec4(rotated, 1.);
 135: 
 136:     vec3 norm = rotateVertexByQuat(v.normal, instance.rotation);
 137: 
 138:     FLWFinalizeWorldPos(worldPos);
 139:     FLWFinalizeNormal(norm);
 140: 
 141:     float scrollSize = instance.scrollTexture.w - instance.scrollTexture.y;
 142:     float scroll = fract(instance.speed * uTime / (31.5 * 16.) + instance.offset) * scrollSize * instance.scrollMult;
 143: 
 144:     BlockFrag b;
 145:     b.diffuse = diffuse(norm);
 146:     b.texCoords = v.texCoords - instance.sourceTexture + instance.scrollTexture.xy + vec2(0, scroll);
 147:     b.light = instance.light;
 148: 
 149:     #if defined(DEBUG_RAINBOW)
 150:     b.color = instance.color;
 151:     #elif defined(DEBUG_NORMAL)
 152:     b.color = vec4(norm, 1.);
 153:     #else
 154:     b.color = vec4(1.);
 155:     #endif
 156: 
 157:     return b;
 158: }
 159: attribute vec3 a_v_pos;
 160: attribute vec3 a_v_normal;
 161: attribute vec2 a_v_texCoords;
 162: 
 163: attribute vec2 a_i_light;
 164: attribute vec4 a_i_color;
 165: attribute vec3 a_i_pos;
 166: attribute float a_i_speed;
 167: attribute float a_i_offset;
 168: attribute vec4 a_i_rotation;
 169: attribute vec2 a_i_sourceTexture;
 170: attribute vec4 a_i_scrollTexture;
 171: attribute float a_i_scrollMult;
 172: 
 173: 
 174: varying vec2 v2f_texCoords;
 175: varying vec4 v2f_color;
 176: varying float v2f_diffuse;
 177: varying vec2 v2f_light;
 178: 
 179: 
 180: void main() {
 181:     Vertex v;
 182:     v.pos = a_v_pos;
 183: v.normal = a_v_normal;
 184: v.texCoords = a_v_texCoords;
 185: 
 186: 
 187:     Belt i;
 188:     i.light = a_i_light;
 189: i.color = a_i_color;
 190: i.pos = a_i_pos;
 191: i.speed = a_i_speed;
 192: i.offset = a_i_offset;
 193: i.rotation = a_i_rotation;
 194: i.sourceTexture = a_i_sourceTexture;
 195: i.scrollTexture = a_i_scrollTexture;
 196: i.scrollMult = a_i_scrollMult;
 197: 
 198: 
 199:     BlockFrag o = FLWMain(v, i);
 200: 
 201:     v2f_texCoords = o.texCoords;
 202: v2f_color = o.color;
 203: v2f_diffuse = o.diffuse;
 204: v2f_light = o.light;
 205: 
 206: }

[14:02:45] [main/ERROR]: Shader compilation log for flywheel:block.frag: No errors.

[14:02:45] [main/ERROR]: Source for shader 'flywheel:block.frag':
   1: #version 110
   2: #define USE_FOG
   3: #define USE_FOG_EXP2
   4: 
   5: #if defined(USE_FOG)
   6: varying float FragDistance;
   7: uniform vec4 uFogColor;
   8: #endif
   9: 
  10: #if defined(USE_FOG_LINEAR)
  11: uniform vec2 uFogRange;
  12: 
  13: float FLWFogFactor() {
  14:     return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
  15: }
  16:     #endif
  17: 
  18:     #if defined(USE_FOG_EXP2)
  19: uniform float uFogDensity;
  20: 
  21: float FLWFogFactor() {
  22:     float dist = FragDistance * uFogDensity;
  23:     return 1. / exp2(dist * dist);
  24: }
  25:     #endif
  26: // Adjust the [0,1] normalized lightmap value based on the texture matrix from LightTexture#enableLightmap
  27: vec2 shiftLight(vec2 lm) {
  28:     return lm * 0.99609375 + 0.03125;// * 255/256 + 1/32
  29: }
  30: 
  31: varying vec3 BoxCoord;
  32: varying vec2 BoxLight;
  33: uniform sampler3D uLightVolume;
  34: 
  35: uniform sampler2D uBlockAtlas;
  36: uniform sampler2D uLightMap;
  37: 
  38: vec4 FLWBlockTexture(vec2 texCoords) {
  39:     return texture2D(uBlockAtlas, texCoords);
  40: }
  41: 
  42: void FLWFinalizeColor(vec4 color) {
  43:     #if defined(USE_FOG)
  44:     float a = color.a;
  45:     float fog = clamp(FLWFogFactor(), 0., 1.);
  46: 
  47:     color = mix(uFogColor, color, fog);
  48:     color.a = a;
  49:     #endif
  50: 
  51:     gl_FragColor = color;
  52: }
  53: 
  54: vec4 FLWLight(vec2 lightCoords) {
  55:     lightCoords = max(lightCoords, texture3D(uLightVolume, BoxCoord).rg);
  56: 
  57:     return texture2D(uLightMap, shiftLight(lightCoords));
  58: }
  59: 
  60: 
  61: 
  62: struct BlockFrag {
  63:     vec2 texCoords;
  64:     vec4 color;
  65:     float diffuse;
  66:     vec2 light;
  67: };
  68: 
  69: void FLWMain(BlockFrag r) {
  70:     vec4 tex = FLWBlockTexture(r.texCoords);
  71: 
  72:     vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;
  73: 
  74: //    flw_WorldPos = ;
  75: //    flw_Normal = ;
  76: //    flw_Albedo = tex.rgb;
  77: //    flw_Alpha = tex.a;
  78: //    flw_LightMap = r.light;
  79: //    flw_Tint = r.color;
  80:     FLWFinalizeColor(color);
  81: }
  82: 
  83: varying vec2 v2f_texCoords;
  84: varying vec4 v2f_color;
  85: varying float v2f_diffuse;
  86: varying vec2 v2f_light;
  87: 
  88: 
  89: //vec3 flw_WorldPos;
  90: //vec3 flw_Normal;
  91: //vec3 flw_Albedo;
  92: //float flw_Alpha;
  93: //vec2 flw_LightMap;
  94: //vec4 flw_Tint;
  95: 
  96: void main() {
  97:     BlockFrag f;
  98:     f.texCoords = v2f_texCoords;
  99: f.color = v2f_color;
 100: f.diffuse = v2f_diffuse;
 101: f.light = v2f_light;
 102: 
 103: 
 104:     FLWMain(f);
 105: }

[14:02:45] [main/ERROR]: Shader compilation log for create:belt.vert: No errors.

[14:02:45] [main/ERROR]: Source for shader 'create:belt.vert':
   1: #version 110
   2: 
   3: #define PI 3.1415926538
   4: 
   5: #if defined(USE_FOG)
   6: varying float FragDistance;
   7: #endif
   8: 
   9: varying vec3 BoxCoord;
  10: 
  11: uniform vec3 uLightBoxSize;
  12: uniform vec3 uLightBoxMin;
  13: uniform mat4 uModel;
  14: 
  15: uniform float uTime;
  16: uniform mat4 uViewProjection;
  17: uniform vec3 uCameraPos;
  18: 
  19: void FLWFinalizeWorldPos(inout vec4 worldPos) {
  20:     worldPos = uModel * worldPos;
  21: 
  22:     BoxCoord = (worldPos.xyz - uLightBoxMin) / uLightBoxSize;
  23: 
  24:     #if defined(USE_FOG)
  25:     FragDistance = length(worldPos.xyz);
  26:     #endif
  27: 
  28:     gl_Position = uViewProjection * worldPos;
  29: }
  30: 
  31: void FLWFinalizeNormal(inout vec3 normal) {
  32:     mat3 m;
  33:     m[0] = uModel[0].xyz;
  34:     m[1] = uModel[1].xyz;
  35:     m[2] = uModel[2].xyz;
  36:     normal = m * normal;
  37: }
  38: 
  39: 
  40: 
  41: #define PIOVER2 1.5707963268
  42: 
  43: vec4 quat(vec3 axis, float angle) {
  44:     float halfAngle = angle * PIOVER2 / 180.0;
  45:     vec2 cs = sin(vec2(PIOVER2 - halfAngle, halfAngle)); // compute sin and cos in one instruction
  46:     return vec4(axis.xyz * cs.y,  cs.x);
  47: }
  48: 
  49: vec4 quatMult(vec4 q1, vec4 q2) {
  50:     // disgustingly vectorized quaternion multiplication
  51:     vec4 a = q1.w * q2.xyzw;
  52:     vec4 b = q1.x * q2.wzxy * vec4(1., -1., 1., -1.);
  53:     vec4 c = q1.y * q2.zwxy * vec4(1., 1., -1., -1.);
  54:     vec4 d = q1.z * q2.yxwz * vec4(-1., 1., 1., -1.);
  55: 
  56:     return a + b + c + d;
  57: }
  58: 
  59: vec3 rotateVertexByQuat(vec3 v, vec4 q) {
  60:     vec3 i = q.xyz;
  61:     return v + 2.0 * cross(i, cross(i, v) + q.w * v);
  62: }
  63: 
  64: vec3 rotateAbout(vec3 v, vec3 axis, float angle) {
  65:     return rotateVertexByQuat(v, quat(axis, angle));
  66: }
  67: 
  68: mat4 rotate(vec3 axis, float angle) {
  69:     float s = sin(angle);
  70:     float c = cos(angle);
  71:     float oc = 1. - c;
  72: 
  73:     vec3 sa = axis * s;
  74: 
  75:     mat4 mr = mat4(1.);
  76:     mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
  77:     mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
  78:     mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);
  79: 
  80:     return mr;
  81: }
  82: 
  83: mat4 rotation(vec3 rot) {
  84:     return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
  85: }
  86: 
  87: mat3 modelToNormal(mat4 mat) {
  88:     // Discard the edges. This won't be accurate for scaled or skewed matrices,
  89:     // but we don't have to work with those often.
  90:     mat3 m;
  91:     m[0] = mat[0].xyz;
  92:     m[1] = mat[1].xyz;
  93:     m[2] = mat[2].xyz;
  94:     return m;
  95: }
  96: 
  97: float diffuse(vec3 normal) {
  98:     vec3 n2 = normal * normal * vec3(.6, .25, .8);
  99:     return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
 100: }
 101: 
 102: 
 103: struct Belt {
 104:     vec2 light;
 105:     vec4 color;
 106:     vec3 pos;
 107:     float speed;
 108:     float offset;
 109:     vec4 rotation;
 110:     vec2 sourceTexture;
 111:     vec4 scrollTexture;
 112:     float scrollMult;
 113: };
 114: 
 115: 
 116: struct Vertex {
 117:     vec3 pos;
 118:     vec3 normal;
 119:     vec2 texCoords;
 120: };
 121: 
 122: struct BlockFrag {
 123:     vec2 texCoords;
 124:     vec4 color;
 125:     float diffuse;
 126:     vec2 light;
 127: };
 128: 
 129: BlockFrag FLWMain(Vertex v, Belt instance) {
 130:     vec3 rotated = rotateVertexByQuat(v.pos - .5, instance.rotation) + instance.pos + .5;
 131: 
 132:     vec4 worldPos = vec4(rotated, 1.);
 133: 
 134:     vec3 norm = rotateVertexByQuat(v.normal, instance.rotation);
 135: 
 136:     FLWFinalizeWorldPos(worldPos);
 137:     FLWFinalizeNormal(norm);
 138: 
 139:     float scrollSize = instance.scrollTexture.w - instance.scrollTexture.y;
 140:     float scroll = fract(instance.speed * uTime / (31.5 * 16.) + instance.offset) * scrollSize * instance.scrollMult;
 141: 
 142:     BlockFrag b;
 143:     b.diffuse = diffuse(norm);
 144:     b.texCoords = v.texCoords - instance.sourceTexture + instance.scrollTexture.xy + vec2(0, scroll);
 145:     b.light = instance.light;
 146: 
 147:     #if defined(DEBUG_RAINBOW)
 148:     b.color = instance.color;
 149:     #elif defined(DEBUG_NORMAL)
 150:     b.color = vec4(norm, 1.);
 151:     #else
 152:     b.color = vec4(1.);
 153:     #endif
 154: 
 155:     return b;
 156: }
 157: attribute vec3 a_v_pos;
 158: attribute vec3 a_v_normal;
 159: attribute vec2 a_v_texCoords;
 160: 
 161: attribute vec2 a_i_light;
 162: attribute vec4 a_i_color;
 163: attribute vec3 a_i_pos;
 164: attribute float a_i_speed;
 165: attribute float a_i_offset;
 166: attribute vec4 a_i_rotation;
 167: attribute vec2 a_i_sourceTexture;
 168: attribute vec4 a_i_scrollTexture;
 169: attribute float a_i_scrollMult;
 170: 
 171: 
 172: varying vec2 v2f_texCoords;
 173: varying vec4 v2f_color;
 174: varying float v2f_diffuse;
 175: varying vec2 v2f_light;
 176: 
 177: 
 178: void main() {
 179:     Vertex v;
 180:     v.pos = a_v_pos;
 181: v.normal = a_v_normal;
 182: v.texCoords = a_v_texCoords;
 183: 
 184: 
 185:     Belt i;
 186:     i.light = a_i_light;
 187: i.color = a_i_color;
 188: i.pos = a_i_pos;
 189: i.speed = a_i_speed;
 190: i.offset = a_i_offset;
 191: i.rotation = a_i_rotation;
 192: i.sourceTexture = a_i_sourceTexture;
 193: i.scrollTexture = a_i_scrollTexture;
 194: i.scrollMult = a_i_scrollMult;
 195: 
 196: 
 197:     BlockFrag o = FLWMain(v, i);
 198: 
 199:     v2f_texCoords = o.texCoords;
 200: v2f_color = o.color;
 201: v2f_diffuse = o.diffuse;
 202: v2f_light = o.light;
 203: 
 204: }

[14:02:45] [main/ERROR]: Shader compilation log for flywheel:block.frag: No errors.

[14:02:45] [main/ERROR]: Source for shader 'flywheel:block.frag':
   1: #version 110
   2: 
   3: #if defined(USE_FOG)
   4: varying float FragDistance;
   5: uniform vec4 uFogColor;
   6: #endif
   7: 
   8: #if defined(USE_FOG_LINEAR)
   9: uniform vec2 uFogRange;
  10: 
  11: float FLWFogFactor() {
  12:     return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
  13: }
  14:     #endif
  15: 
  16:     #if defined(USE_FOG_EXP2)
  17: uniform float uFogDensity;
  18: 
  19: float FLWFogFactor() {
  20:     float dist = FragDistance * uFogDensity;
  21:     return 1. / exp2(dist * dist);
  22: }
  23:     #endif
  24: // Adjust the [0,1] normalized lightmap value based on the texture matrix from LightTexture#enableLightmap
  25: vec2 shiftLight(vec2 lm) {
  26:     return lm * 0.99609375 + 0.03125;// * 255/256 + 1/32
  27: }
  28: 
  29: varying vec3 BoxCoord;
  30: varying vec2 BoxLight;
  31: uniform sampler3D uLightVolume;
  32: 
  33: uniform sampler2D uBlockAtlas;
  34: uniform sampler2D uLightMap;
  35: 
  36: vec4 FLWBlockTexture(vec2 texCoords) {
  37:     return texture2D(uBlockAtlas, texCoords);
  38: }
  39: 
  40: void FLWFinalizeColor(vec4 color) {
  41:     #if defined(USE_FOG)
  42:     float a = color.a;
  43:     float fog = clamp(FLWFogFactor(), 0., 1.);
  44: 
  45:     color = mix(uFogColor, color, fog);
  46:     color.a = a;
  47:     #endif
  48: 
  49:     gl_FragColor = color;
  50: }
  51: 
  52: vec4 FLWLight(vec2 lightCoords) {
  53:     lightCoords = max(lightCoords, texture3D(uLightVolume, BoxCoord).rg);
  54: 
  55:     return texture2D(uLightMap, shiftLight(lightCoords));
  56: }
  57: 
  58: 
  59: 
  60: struct BlockFrag {
  61:     vec2 texCoords;
  62:     vec4 color;
  63:     float diffuse;
  64:     vec2 light;
  65: };
  66: 
  67: void FLWMain(BlockFrag r) {
  68:     vec4 tex = FLWBlockTexture(r.texCoords);
  69: 
  70:     vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;
  71: 
  72: //    flw_WorldPos = ;
  73: //    flw_Normal = ;
  74: //    flw_Albedo = tex.rgb;
  75: //    flw_Alpha = tex.a;
  76: //    flw_LightMap = r.light;
  77: //    flw_Tint = r.color;
  78:     FLWFinalizeColor(color);
  79: }
  80: 
  81: varying vec2 v2f_texCoords;
  82: varying vec4 v2f_color;
  83: varying float v2f_diffuse;
  84: varying vec2 v2f_light;
  85: 
  86: 
  87: //vec3 flw_WorldPos;
  88: //vec3 flw_Normal;
  89: //vec3 flw_Albedo;
  90: //float flw_Alpha;
  91: //vec2 flw_LightMap;
  92: //vec4 flw_Tint;
  93: 
  94: void main() {
  95:     BlockFrag f;
  96:     f.texCoords = v2f_texCoords;
  97: f.color = v2f_color;
  98: f.diffuse = v2f_diffuse;
  99: f.light = v2f_light;
 100: 
 101: 
 102:     FLWMain(f);
 103: }

[14:02:45] [main/ERROR]: Shader compilation log for flywheel:oriented.vert: No errors.

[14:02:45] [main/ERROR]: Source for shader 'flywheel:oriented.vert':
   1: #version 110
   2: #define DEBUG_NORMAL
   3: 
   4: #if defined(USE_FOG)
   5: varying float FragDistance;
   6: #endif
   7: 
   8: varying vec3 BoxCoord;
   9: 
  10: uniform vec3 uLightBoxSize;
  11: uniform vec3 uLightBoxMin;
  12: uniform mat4 uModel;
  13: 
  14: uniform float uTime;
  15: uniform mat4 uViewProjection;
  16: uniform vec3 uCameraPos;
  17: 
  18: void FLWFinalizeWorldPos(inout vec4 worldPos) {
  19:     worldPos = uModel * worldPos;
  20: 
  21:     BoxCoord = (worldPos.xyz - uLightBoxMin) / uLightBoxSize;
  22: 
  23:     #if defined(USE_FOG)
  24:     FragDistance = length(worldPos.xyz);
  25:     #endif
  26: 
  27:     gl_Position = uViewProjection * worldPos;
  28: }
  29: 
  30: void FLWFinalizeNormal(inout vec3 normal) {
  31:     mat3 m;
  32:     m[0] = uModel[0].xyz;
  33:     m[1] = uModel[1].xyz;
  34:     m[2] = uModel[2].xyz;
  35:     normal = m * normal;
  36: }
  37: 
  38: 
  39: 
  40: mat4 rotate(vec3 axis, float angle) {
  41:     float s = sin(angle);
  42:     float c = cos(angle);
  43:     float oc = 1. - c;
  44: 
  45:     vec3 sa = axis * s;
  46: 
  47:     mat4 mr = mat4(1.);
  48:     mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
  49:     mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
  50:     mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);
  51: 
  52:     return mr;
  53: }
  54: 
  55: mat4 rotation(vec3 rot) {
  56:     return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
  57: }
  58: 
  59: mat3 modelToNormal(mat4 mat) {
  60:     // Discard the edges. This won't be accurate for scaled or skewed matrices,
  61:     // but we don't have to work with those often.
  62:     mat3 m;
  63:     m[0] = mat[0].xyz;
  64:     m[1] = mat[1].xyz;
  65:     m[2] = mat[2].xyz;
  66:     return m;
  67: }
  68: 
  69: #define PIOVER2 1.5707963268
  70: 
  71: vec4 quat(vec3 axis, float angle) {
  72:     float halfAngle = angle * PIOVER2 / 180.0;
  73:     vec2 cs = sin(vec2(PIOVER2 - halfAngle, halfAngle)); // compute sin and cos in one instruction
  74:     return vec4(axis.xyz * cs.y,  cs.x);
  75: }
  76: 
  77: vec4 quatMult(vec4 q1, vec4 q2) {
  78:     // disgustingly vectorized quaternion multiplication
  79:     vec4 a = q1.w * q2.xyzw;
  80:     vec4 b = q1.x * q2.wzxy * vec4(1., -1., 1., -1.);
  81:     vec4 c = q1.y * q2.zwxy * vec4(1., 1., -1., -1.);
  82:     vec4 d = q1.z * q2.yxwz * vec4(-1., 1., 1., -1.);
  83: 
  84:     return a + b + c + d;
  85: }
  86: 
  87: vec3 rotateVertexByQuat(vec3 v, vec4 q) {
  88:     vec3 i = q.xyz;
  89:     return v + 2.0 * cross(i, cross(i, v) + q.w * v);
  90: }
  91: 
  92: vec3 rotateAbout(vec3 v, vec3 axis, float angle) {
  93:     return rotateVertexByQuat(v, quat(axis, angle));
  94: }
  95: 
  96: float diffuse(vec3 normal) {
  97:     vec3 n2 = normal * normal * vec3(.6, .25, .8);
  98:     return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
  99: }
 100: 
 101: 
 102: struct Oriented {
 103:     vec2 light;
 104:     vec4 color;
 105:     vec3 pos;
 106:     vec3 pivot;
 107:     vec4 rotation;
 108: };
 109: 
 110: 
 111: struct Vertex {
 112:     vec3 pos;
 113:     vec3 normal;
 114:     vec2 texCoords;
 115: };
 116: 
 117: struct BlockFrag {
 118:     vec2 texCoords;
 119:     vec4 color;
 120:     float diffuse;
 121:     vec2 light;
 122: };
 123: 
 124: BlockFrag FLWMain(Vertex v, Oriented o) {
 125:     vec4 worldPos = vec4(rotateVertexByQuat(v.pos - o.pivot, o.rotation) + o.pivot + o.pos, 1.);
 126: 
 127:     vec3 norm = rotateVertexByQuat(v.normal, o.rotation);
 128: 
 129:     FLWFinalizeWorldPos(worldPos);
 130:     FLWFinalizeNormal(norm);
 131: 
 132:     BlockFrag b;
 133:     b.diffuse = diffuse(norm);
 134:     b.texCoords = v.texCoords;
 135:     b.light = o.light;
 136:     #if defined(DEBUG_NORMAL)
 137:     b.color = vec4(norm, 1.);
 138:     #else
 139:     b.color = o.color;
 140:     #endif
 141:     return b;
 142: }
 143: attribute vec3 a_v_pos;
 144: attribute vec3 a_v_normal;
 145: attribute vec2 a_v_texCoords;
 146: 
 147: attribute vec2 a_i_light;
 148: attribute vec4 a_i_color;
 149: attribute vec3 a_i_pos;
 150: attribute vec3 a_i_pivot;
 151: attribute vec4 a_i_rotation;
 152: 
 153: 
 154: varying vec2 v2f_texCoords;
 155: varying vec4 v2f_color;
 156: varying float v2f_diffuse;
 157: varying vec2 v2f_light;
 158: 
 159: 
 160: void main() {
 161:     Vertex v;
 162:     v.pos = a_v_pos;
 163: v.normal = a_v_normal;
 164: v.texCoords = a_v_texCoords;
 165: 
 166: 
 167:     Oriented i;
 168:     i.light = a_i_light;
 169: i.color = a_i_color;
 170: i.pos = a_i_pos;
 171: i.pivot = a_i_pivot;
 172: i.rotation = a_i_rotation;
 173: 
 174: 
 175:     BlockFrag o = FLWMain(v, i);
 176: 
 177:     v2f_texCoords = o.texCoords;
 178: v2f_color = o.color;
 179: v2f_diffuse = o.diffuse;
 180: v2f_light = o.light;
 181: 
 182: }

[14:02:45] [main/ERROR]: Shader compilation log for flywheel:block.frag: No errors.

[14:02:45] [main/ERROR]: Source for shader 'flywheel:block.frag':
   1: #version 110
   2: #define DEBUG_NORMAL
   3: 
   4: #if defined(USE_FOG)
   5: varying float FragDistance;
   6: uniform vec4 uFogColor;
   7: #endif
   8: 
   9: #if defined(USE_FOG_LINEAR)
  10: uniform vec2 uFogRange;
  11: 
  12: float FLWFogFactor() {
  13:     return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
  14: }
  15:     #endif
  16: 
  17:     #if defined(USE_FOG_EXP2)
  18: uniform float uFogDensity;
  19: 
  20: float FLWFogFactor() {
  21:     float dist = FragDistance * uFogDensity;
  22:     return 1. / exp2(dist * dist);
  23: }
  24:     #endif
  25: // Adjust the [0,1] normalized lightmap value based on the texture matrix from LightTexture#enableLightmap
  26: vec2 shiftLight(vec2 lm) {
  27:     return lm * 0.99609375 + 0.03125;// * 255/256 + 1/32
  28: }
  29: 
  30: varying vec3 BoxCoord;
  31: varying vec2 BoxLight;
  32: uniform sampler3D uLightVolume;
  33: 
  34: uniform sampler2D uBlockAtlas;
  35: uniform sampler2D uLightMap;
  36: 
  37: vec4 FLWBlockTexture(vec2 texCoords) {
  38:     return texture2D(uBlockAtlas, texCoords);
  39: }
  40: 
  41: void FLWFinalizeColor(vec4 color) {
  42:     #if defined(USE_FOG)
  43:     float a = color.a;
  44:     float fog = clamp(FLWFogFactor(), 0., 1.);
  45: 
  46:     color = mix(uFogColor, color, fog);
  47:     color.a = a;
  48:     #endif
  49: 
  50:     gl_FragColor = color;
  51: }
  52: 
  53: vec4 FLWLight(vec2 lightCoords) {
  54:     lightCoords = max(lightCoords, texture3D(uLightVolume, BoxCoord).rg);
  55: 
  56:     return texture2D(uLightMap, shiftLight(lightCoords));
  57: }
  58: 
  59: 
  60: 
  61: struct BlockFrag {
  62:     vec2 texCoords;
  63:     vec4 color;
  64:     float diffuse;
  65:     vec2 light;
  66: };
  67: 
  68: void FLWMain(BlockFrag r) {
  69:     vec4 tex = FLWBlockTexture(r.texCoords);
  70: 
  71:     vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;
  72: 
  73: //    flw_WorldPos = ;
  74: //    flw_Normal = ;
  75: //    flw_Albedo = tex.rgb;
  76: //    flw_Alpha = tex.a;
  77: //    flw_LightMap = r.light;
  78: //    flw_Tint = r.color;
  79:     FLWFinalizeColor(color);
  80: }
  81: 
  82: varying vec2 v2f_texCoords;
  83: varying vec4 v2f_color;
  84: varying float v2f_diffuse;
  85: varying vec2 v2f_light;
  86: 
  87: 
  88: //vec3 flw_WorldPos;
  89: //vec3 flw_Normal;
  90: //vec3 flw_Albedo;
  91: //float flw_Alpha;
  92: //vec2 flw_LightMap;
  93: //vec4 flw_Tint;
  94: 
  95: void main() {
  96:     BlockFrag f;
  97:     f.texCoords = v2f_texCoords;
  98: f.color = v2f_color;
  99: f.diffuse = v2f_diffuse;
 100: f.light = v2f_light;
 101: 
 102: 
 103:     FLWMain(f);
 104: }

[14:02:45] [main/ERROR]: Shader compilation log for flywheel:oriented.vert: No errors.

[14:02:45] [main/ERROR]: Source for shader 'flywheel:oriented.vert':
   1: #version 110
   2: #define USE_FOG
   3: #define USE_FOG_LINEAR
   4: 
   5: #if defined(USE_FOG)
   6: varying float FragDistance;
   7: #endif
   8: 
   9: varying vec3 BoxCoord;
  10: 
  11: uniform vec3 uLightBoxSize;
  12: uniform vec3 uLightBoxMin;
  13: uniform mat4 uModel;
  14: 
  15: uniform float uTime;
  16: uniform mat4 uViewProjection;
  17: uniform vec3 uCameraPos;
  18: 
  19: void FLWFinalizeWorldPos(inout vec4 worldPos) {
  20:     worldPos = uModel * worldPos;
  21: 
  22:     BoxCoord = (worldPos.xyz - uLightBoxMin) / uLightBoxSize;
  23: 
  24:     #if defined(USE_FOG)
  25:     FragDistance = length(worldPos.xyz);
  26:     #endif
  27: 
  28:     gl_Position = uViewProjection * worldPos;
  29: }
  30: 
  31: void FLWFinalizeNormal(inout vec3 normal) {
  32:     mat3 m;
  33:     m[0] = uModel[0].xyz;
  34:     m[1] = uModel[1].xyz;
  35:     m[2] = uModel[2].xyz;
  36:     normal = m * normal;
  37: }
  38: 
  39: 
  40: 
  41: mat4 rotate(vec3 axis, float angle) {
  42:     float s = sin(angle);
  43:     float c = cos(angle);
  44:     float oc = 1. - c;
  45: 
  46:     vec3 sa = axis * s;
  47: 
  48:     mat4 mr = mat4(1.);
  49:     mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
  50:     mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
  51:     mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);
  52: 
  53:     return mr;
  54: }
  55: 
  56: mat4 rotation(vec3 rot) {
  57:     return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
  58: }
  59: 
  60: mat3 modelToNormal(mat4 mat) {
  61:     // Discard the edges. This won't be accurate for scaled or skewed matrices,
  62:     // but we don't have to work with those often.
  63:     mat3 m;
  64:     m[0] = mat[0].xyz;
  65:     m[1] = mat[1].xyz;
  66:     m[2] = mat[2].xyz;
  67:     return m;
  68: }
  69: 
  70: #define PIOVER2 1.5707963268
  71: 
  72: vec4 quat(vec3 axis, float angle) {
  73:     float halfAngle = angle * PIOVER2 / 180.0;
  74:     vec2 cs = sin(vec2(PIOVER2 - halfAngle, halfAngle)); // compute sin and cos in one instruction
  75:     return vec4(axis.xyz * cs.y,  cs.x);
  76: }
  77: 
  78: vec4 quatMult(vec4 q1, vec4 q2) {
  79:     // disgustingly vectorized quaternion multiplication
  80:     vec4 a = q1.w * q2.xyzw;
  81:     vec4 b = q1.x * q2.wzxy * vec4(1., -1., 1., -1.);
  82:     vec4 c = q1.y * q2.zwxy * vec4(1., 1., -1., -1.);
  83:     vec4 d = q1.z * q2.yxwz * vec4(-1., 1., 1., -1.);
  84: 
  85:     return a + b + c + d;
  86: }
  87: 
  88: vec3 rotateVertexByQuat(vec3 v, vec4 q) {
  89:     vec3 i = q.xyz;
  90:     return v + 2.0 * cross(i, cross(i, v) + q.w * v);
  91: }
  92: 
  93: vec3 rotateAbout(vec3 v, vec3 axis, float angle) {
  94:     return rotateVertexByQuat(v, quat(axis, angle));
  95: }
  96: 
  97: float diffuse(vec3 normal) {
  98:     vec3 n2 = normal * normal * vec3(.6, .25, .8);
  99:     return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
 100: }
 101: 
 102: 
 103: struct Oriented {
 104:     vec2 light;
 105:     vec4 color;
 106:     vec3 pos;
 107:     vec3 pivot;
 108:     vec4 rotation;
 109: };
 110: 
 111: 
 112: struct Vertex {
 113:     vec3 pos;
 114:     vec3 normal;
 115:     vec2 texCoords;
 116: };
 117: 
 118: struct BlockFrag {
 119:     vec2 texCoords;
 120:     vec4 color;
 121:     float diffuse;
 122:     vec2 light;
 123: };
 124: 
 125: BlockFrag FLWMain(Vertex v, Oriented o) {
 126:     vec4 worldPos = vec4(rotateVertexByQuat(v.pos - o.pivot, o.rotation) + o.pivot + o.pos, 1.);
 127: 
 128:     vec3 norm = rotateVertexByQuat(v.normal, o.rotation);
 129: 
 130:     FLWFinalizeWorldPos(worldPos);
 131:     FLWFinalizeNormal(norm);
 132: 
 133:     BlockFrag b;
 134:     b.diffuse = diffuse(norm);
 135:     b.texCoords = v.texCoords;
 136:     b.light = o.light;
 137:     #if defined(DEBUG_NORMAL)
 138:     b.color = vec4(norm, 1.);
 139:     #else
 140:     b.color = o.color;
 141:     #endif
 142:     return b;
 143: }
 144: attribute vec3 a_v_pos;
 145: attribute vec3 a_v_normal;
 146: attribute vec2 a_v_texCoords;
 147: 
 148: attribute vec2 a_i_light;
 149: attribute vec4 a_i_color;
 150: attribute vec3 a_i_pos;
 151: attribute vec3 a_i_pivot;
 152: attribute vec4 a_i_rotation;
 153: 
 154: 
 155: varying vec2 v2f_texCoords;
 156: varying vec4 v2f_color;
 157: varying float v2f_diffuse;
 158: varying vec2 v2f_light;
 159: 
 160: 
 161: void main() {
 162:     Vertex v;
 163:     v.pos = a_v_pos;
 164: v.normal = a_v_normal;
 165: v.texCoords = a_v_texCoords;
 166: 
 167: 
 168:     Oriented i;
 169:     i.light = a_i_light;
 170: i.color = a_i_color;
 171: i.pos = a_i_pos;
 172: i.pivot = a_i_pivot;
 173: i.rotation = a_i_rotation;
 174: 
 175: 
 176:     BlockFrag o = FLWMain(v, i);
 177: 
 178:     v2f_texCoords = o.texCoords;
 179: v2f_color = o.color;
 180: v2f_diffuse = o.diffuse;
 181: v2f_light = o.light;
 182: 
 183: }

[14:02:45] [main/ERROR]: Shader compilation log for flywheel:block.frag: No errors.

[14:02:45] [main/ERROR]: Source for shader 'flywheel:block.frag':
   1: #version 110
   2: #define USE_FOG
   3: #define USE_FOG_LINEAR
   4: 
   5: #if defined(USE_FOG)
   6: varying float FragDistance;
   7: uniform vec4 uFogColor;
   8: #endif
   9: 
  10: #if defined(USE_FOG_LINEAR)
  11: uniform vec2 uFogRange;
  12: 
  13: float FLWFogFactor() {
  14:     return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
  15: }
  16:     #endif
  17: 
  18:     #if defined(USE_FOG_EXP2)
  19: uniform float uFogDensity;
  20: 
  21: float FLWFogFactor() {
  22:     float dist = FragDistance * uFogDensity;
  23:     return 1. / exp2(dist * dist);
  24: }
  25:     #endif
  26: // Adjust the [0,1] normalized lightmap value based on the texture matrix from LightTexture#enableLightmap
  27: vec2 shiftLight(vec2 lm) {
  28:     return lm * 0.99609375 + 0.03125;// * 255/256 + 1/32
  29: }
  30: 
  31: varying vec3 BoxCoord;
  32: varying vec2 BoxLight;
  33: uniform sampler3D uLightVolume;
  34: 
  35: uniform sampler2D uBlockAtlas;
  36: uniform sampler2D uLightMap;
  37: 
  38: vec4 FLWBlockTexture(vec2 texCoords) {
  39:     return texture2D(uBlockAtlas, texCoords);
  40: }
  41: 
  42: void FLWFinalizeColor(vec4 color) {
  43:     #if defined(USE_FOG)
  44:     float a = color.a;
  45:     float fog = clamp(FLWFogFactor(), 0., 1.);
  46: 
  47:     color = mix(uFogColor, color, fog);
  48:     color.a = a;
  49:     #endif
  50: 
  51:     gl_FragColor = color;
  52: }
  53: 
  54: vec4 FLWLight(vec2 lightCoords) {
  55:     lightCoords = max(lightCoords, texture3D(uLightVolume, BoxCoord).rg);
  56: 
  57:     return texture2D(uLightMap, shiftLight(lightCoords));
  58: }
  59: 
  60: 
  61: 
  62: struct BlockFrag {
  63:     vec2 texCoords;
  64:     vec4 color;
  65:     float diffuse;
  66:     vec2 light;
  67: };
  68: 
  69: void FLWMain(BlockFrag r) {
  70:     vec4 tex = FLWBlockTexture(r.texCoords);
  71: 
  72:     vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;
  73: 
  74: //    flw_WorldPos = ;
  75: //    flw_Normal = ;
  76: //    flw_Albedo = tex.rgb;
  77: //    flw_Alpha = tex.a;
  78: //    flw_LightMap = r.light;
  79: //    flw_Tint = r.color;
  80:     FLWFinalizeColor(color);
  81: }
  82: 
  83: varying vec2 v2f_texCoords;
  84: varying vec4 v2f_color;
  85: varying float v2f_diffuse;
  86: varying vec2 v2f_light;
  87: 
  88: 
  89: //vec3 flw_WorldPos;
  90: //vec3 flw_Normal;
  91: //vec3 flw_Albedo;
  92: //float flw_Alpha;
  93: //vec2 flw_LightMap;
  94: //vec4 flw_Tint;
  95: 
  96: void main() {
  97:     BlockFrag f;
  98:     f.texCoords = v2f_texCoords;
  99: f.color = v2f_color;
 100: f.diffuse = v2f_diffuse;
 101: f.light = v2f_light;
 102: 
 103: 
 104:     FLWMain(f);
 105: }

[14:02:45] [main/ERROR]: Shader compilation log for flywheel:oriented.vert: No errors.

[14:02:45] [main/ERROR]: Source for shader 'flywheel:oriented.vert':
   1: #version 110
   2: #define USE_FOG
   3: #define USE_FOG_EXP2
   4: 
   5: #if defined(USE_FOG)
   6: varying float FragDistance;
   7: #endif
   8: 
   9: varying vec3 BoxCoord;
  10: 
  11: uniform vec3 uLightBoxSize;
  12: uniform vec3 uLightBoxMin;
  13: uniform mat4 uModel;
  14: 
  15: uniform float uTime;
  16: uniform mat4 uViewProjection;
  17: uniform vec3 uCameraPos;
  18: 
  19: void FLWFinalizeWorldPos(inout vec4 worldPos) {
  20:     worldPos = uModel * worldPos;
  21: 
  22:     BoxCoord = (worldPos.xyz - uLightBoxMin) / uLightBoxSize;
  23: 
  24:     #if defined(USE_FOG)
  25:     FragDistance = length(worldPos.xyz);
  26:     #endif
  27: 
  28:     gl_Position = uViewProjection * worldPos;
  29: }
  30: 
  31: void FLWFinalizeNormal(inout vec3 normal) {
  32:     mat3 m;
  33:     m[0] = uModel[0].xyz;
  34:     m[1] = uModel[1].xyz;
  35:     m[2] = uModel[2].xyz;
  36:     normal = m * normal;
  37: }
  38: 
  39: 
  40: 
  41: mat4 rotate(vec3 axis, float angle) {
  42:     float s = sin(angle);
  43:     float c = cos(angle);
  44:     float oc = 1. - c;
  45: 
  46:     vec3 sa = axis * s;
  47: 
  48:     mat4 mr = mat4(1.);
  49:     mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
  50:     mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
  51:     mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);
  52: 
  53:     return mr;
  54: }
  55: 
  56: mat4 rotation(vec3 rot) {
  57:     return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
  58: }
  59: 
  60: mat3 modelToNormal(mat4 mat) {
  61:     // Discard the edges. This won't be accurate for scaled or skewed matrices,
  62:     // but we don't have to work with those often.
  63:     mat3 m;
  64:     m[0] = mat[0].xyz;
  65:     m[1] = mat[1].xyz;
  66:     m[2] = mat[2].xyz;
  67:     return m;
  68: }
  69: 
  70: #define PIOVER2 1.5707963268
  71: 
  72: vec4 quat(vec3 axis, float angle) {
  73:     float halfAngle = angle * PIOVER2 / 180.0;
  74:     vec2 cs = sin(vec2(PIOVER2 - halfAngle, halfAngle)); // compute sin and cos in one instruction
  75:     return vec4(axis.xyz * cs.y,  cs.x);
  76: }
  77: 
  78: vec4 quatMult(vec4 q1, vec4 q2) {
  79:     // disgustingly vectorized quaternion multiplication
  80:     vec4 a = q1.w * q2.xyzw;
  81:     vec4 b = q1.x * q2.wzxy * vec4(1., -1., 1., -1.);
  82:     vec4 c = q1.y * q2.zwxy * vec4(1., 1., -1., -1.);
  83:     vec4 d = q1.z * q2.yxwz * vec4(-1., 1., 1., -1.);
  84: 
  85:     return a + b + c + d;
  86: }
  87: 
  88: vec3 rotateVertexByQuat(vec3 v, vec4 q) {
  89:     vec3 i = q.xyz;
  90:     return v + 2.0 * cross(i, cross(i, v) + q.w * v);
  91: }
  92: 
  93: vec3 rotateAbout(vec3 v, vec3 axis, float angle) {
  94:     return rotateVertexByQuat(v, quat(axis, angle));
  95: }
  96: 
  97: float diffuse(vec3 normal) {
  98:     vec3 n2 = normal * normal * vec3(.6, .25, .8);
  99:     return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
 100: }
 101: 
 102: 
 103: struct Oriented {
 104:     vec2 light;
 105:     vec4 color;
 106:     vec3 pos;
 107:     vec3 pivot;
 108:     vec4 rotation;
 109: };
 110: 
 111: 
 112: struct Vertex {
 113:     vec3 pos;
 114:     vec3 normal;
 115:     vec2 texCoords;
 116: };
 117: 
 118: struct BlockFrag {
 119:     vec2 texCoords;
 120:     vec4 color;
 121:     float diffuse;
 122:     vec2 light;
 123: };
 124: 
 125: BlockFrag FLWMain(Vertex v, Oriented o) {
 126:     vec4 worldPos = vec4(rotateVertexByQuat(v.pos - o.pivot, o.rotation) + o.pivot + o.pos, 1.);
 127: 
 128:     vec3 norm = rotateVertexByQuat(v.normal, o.rotation);
 129: 
 130:     FLWFinalizeWorldPos(worldPos);
 131:     FLWFinalizeNormal(norm);
 132: 
 133:     BlockFrag b;
 134:     b.diffuse = diffuse(norm);
 135:     b.texCoords = v.texCoords;
 136:     b.light = o.light;
 137:     #if defined(DEBUG_NORMAL)
 138:     b.color = vec4(norm, 1.);
 139:     #else
 140:     b.color = o.color;
 141:     #endif
 142:     return b;
 143: }
 144: attribute vec3 a_v_pos;
 145: attribute vec3 a_v_normal;
 146: attribute vec2 a_v_texCoords;
 147: 
 148: attribute vec2 a_i_light;
 149: attribute vec4 a_i_color;
 150: attribute vec3 a_i_pos;
 151: attribute vec3 a_i_pivot;
 152: attribute vec4 a_i_rotation;
 153: 
 154: 
 155: varying vec2 v2f_texCoords;
 156: varying vec4 v2f_color;
 157: varying float v2f_diffuse;
 158: varying vec2 v2f_light;
 159: 
 160: 
 161: void main() {
 162:     Vertex v;
 163:     v.pos = a_v_pos;
 164: v.normal = a_v_normal;
 165: v.texCoords = a_v_texCoords;
 166: 
 167: 
 168:     Oriented i;
 169:     i.light = a_i_light;
 170: i.color = a_i_color;
 171: i.pos = a_i_pos;
 172: i.pivot = a_i_pivot;
 173: i.rotation = a_i_rotation;
 174: 
 175: 
 176:     BlockFrag o = FLWMain(v, i);
 177: 
 178:     v2f_texCoords = o.texCoords;
 179: v2f_color = o.color;
 180: v2f_diffuse = o.diffuse;
 181: v2f_light = o.light;
 182: 
 183: }

[14:02:45] [main/ERROR]: Shader compilation log for flywheel:block.frag: No errors.

[14:02:45] [main/ERROR]: Source for shader 'flywheel:block.frag':
   1: #version 110
   2: #define USE_FOG
   3: #define USE_FOG_EXP2
   4: 
   5: #if defined(USE_FOG)
   6: varying float FragDistance;
   7: uniform vec4 uFogColor;
   8: #endif
   9: 
  10: #if defined(USE_FOG_LINEAR)
  11: uniform vec2 uFogRange;
  12: 
  13: float FLWFogFactor() {
  14:     return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
  15: }
  16:     #endif
  17: 
  18:     #if defined(USE_FOG_EXP2)
  19: uniform float uFogDensity;
  20: 
  21: float FLWFogFactor() {
  22:     float dist = FragDistance * uFogDensity;
  23:     return 1. / exp2(dist * dist);
  24: }
  25:     #endif
  26: // Adjust the [0,1] normalized lightmap value based on the texture matrix from LightTexture#enableLightmap
  27: vec2 shiftLight(vec2 lm) {
  28:     return lm * 0.99609375 + 0.03125;// * 255/256 + 1/32
  29: }
  30: 
  31: varying vec3 BoxCoord;
  32: varying vec2 BoxLight;
  33: uniform sampler3D uLightVolume;
  34: 
  35: uniform sampler2D uBlockAtlas;
  36: uniform sampler2D uLightMap;
  37: 
  38: vec4 FLWBlockTexture(vec2 texCoords) {
  39:     return texture2D(uBlockAtlas, texCoords);
  40: }
  41: 
  42: void FLWFinalizeColor(vec4 color) {
  43:     #if defined(USE_FOG)
  44:     float a = color.a;
  45:     float fog = clamp(FLWFogFactor(), 0., 1.);
  46: 
  47:     color = mix(uFogColor, color, fog);
  48:     color.a = a;
  49:     #endif
  50: 
  51:     gl_FragColor = color;
  52: }
  53: 
  54: vec4 FLWLight(vec2 lightCoords) {
  55:     lightCoords = max(lightCoords, texture3D(uLightVolume, BoxCoord).rg);
  56: 
  57:     return texture2D(uLightMap, shiftLight(lightCoords));
  58: }
  59: 
  60: 
  61: 
  62: struct BlockFrag {
  63:     vec2 texCoords;
  64:     vec4 color;
  65:     float diffuse;
  66:     vec2 light;
  67: };
  68: 
  69: void FLWMain(BlockFrag r) {
  70:     vec4 tex = FLWBlockTexture(r.texCoords);
  71: 
  72:     vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;
  73: 
  74: //    flw_WorldPos = ;
  75: //    flw_Normal = ;
  76: //    flw_Albedo = tex.rgb;
  77: //    flw_Alpha = tex.a;
  78: //    flw_LightMap = r.light;
  79: //    flw_Tint = r.color;
  80:     FLWFinalizeColor(color);
  81: }
  82: 
  83: varying vec2 v2f_texCoords;
  84: varying vec4 v2f_color;
  85: varying float v2f_diffuse;
  86: varying vec2 v2f_light;
  87: 
  88: 
  89: //vec3 flw_WorldPos;
  90: //vec3 flw_Normal;
  91: //vec3 flw_Albedo;
  92: //float flw_Alpha;
  93: //vec2 flw_LightMap;
  94: //vec4 flw_Tint;
  95: 
  96: void main() {
  97:     BlockFrag f;
  98:     f.texCoords = v2f_texCoords;
  99: f.color = v2f_color;
 100: f.diffuse = v2f_diffuse;
 101: f.light = v2f_light;
 102: 
 103: 
 104:     FLWMain(f);
 105: }

[14:02:45] [main/ERROR]: Shader compilation log for flywheel:oriented.vert: No errors.

[14:02:45] [main/ERROR]: Source for shader 'flywheel:oriented.vert':
   1: #version 110
   2: 
   3: #if defined(USE_FOG)
   4: varying float FragDistance;
   5: #endif
   6: 
   7: varying vec3 BoxCoord;
   8: 
   9: uniform vec3 uLightBoxSize;
  10: uniform vec3 uLightBoxMin;
  11: uniform mat4 uModel;
  12: 
  13: uniform float uTime;
  14: uniform mat4 uViewProjection;
  15: uniform vec3 uCameraPos;
  16: 
  17: void FLWFinalizeWorldPos(inout vec4 worldPos) {
  18:     worldPos = uModel * worldPos;
  19: 
  20:     BoxCoord = (worldPos.xyz - uLightBoxMin) / uLightBoxSize;
  21: 
  22:     #if defined(USE_FOG)
  23:     FragDistance = length(worldPos.xyz);
  24:     #endif
  25: 
  26:     gl_Position = uViewProjection * worldPos;
  27: }
  28: 
  29: void FLWFinalizeNormal(inout vec3 normal) {
  30:     mat3 m;
  31:     m[0] = uModel[0].xyz;
  32:     m[1] = uModel[1].xyz;
  33:     m[2] = uModel[2].xyz;
  34:     normal = m * normal;
  35: }
  36: 
  37: 
  38: 
  39: mat4 rotate(vec3 axis, float angle) {
  40:     float s = sin(angle);
  41:     float c = cos(angle);
  42:     float oc = 1. - c;
  43: 
  44:     vec3 sa = axis * s;
  45: 
  46:     mat4 mr = mat4(1.);
  47:     mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
  48:     mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
  49:     mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);
  50: 
  51:     return mr;
  52: }
  53: 
  54: mat4 rotation(vec3 rot) {
  55:     return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
  56: }
  57: 
  58: mat3 modelToNormal(mat4 mat) {
  59:     // Discard the edges. This won't be accurate for scaled or skewed matrices,
  60:     // but we don't have to work with those often.
  61:     mat3 m;
  62:     m[0] = mat[0].xyz;
  63:     m[1] = mat[1].xyz;
  64:     m[2] = mat[2].xyz;
  65:     return m;
  66: }
  67: 
  68: #define PIOVER2 1.5707963268
  69: 
  70: vec4 quat(vec3 axis, float angle) {
  71:     float halfAngle = angle * PIOVER2 / 180.0;
  72:     vec2 cs = sin(vec2(PIOVER2 - halfAngle, halfAngle)); // compute sin and cos in one instruction
  73:     return vec4(axis.xyz * cs.y,  cs.x);
  74: }
  75: 
  76: vec4 quatMult(vec4 q1, vec4 q2) {
  77:     // disgustingly vectorized quaternion multiplication
  78:     vec4 a = q1.w * q2.xyzw;
  79:     vec4 b = q1.x * q2.wzxy * vec4(1., -1., 1., -1.);
  80:     vec4 c = q1.y * q2.zwxy * vec4(1., 1., -1., -1.);
  81:     vec4 d = q1.z * q2.yxwz * vec4(-1., 1., 1., -1.);
  82: 
  83:     return a + b + c + d;
  84: }
  85: 
  86: vec3 rotateVertexByQuat(vec3 v, vec4 q) {
  87:     vec3 i = q.xyz;
  88:     return v + 2.0 * cross(i, cross(i, v) + q.w * v);
  89: }
  90: 
  91: vec3 rotateAbout(vec3 v, vec3 axis, float angle) {
  92:     return rotateVertexByQuat(v, quat(axis, angle));
  93: }
  94: 
  95: float diffuse(vec3 normal) {
  96:     vec3 n2 = normal * normal * vec3(.6, .25, .8);
  97:     return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
  98: }
  99: 
 100: 
 101: struct Oriented {
 102:     vec2 light;
 103:     vec4 color;
 104:     vec3 pos;
 105:     vec3 pivot;
 106:     vec4 rotation;
 107: };
 108: 
 109: 
 110: struct Vertex {
 111:     vec3 pos;
 112:     vec3 normal;
 113:     vec2 texCoords;
 114: };
 115: 
 116: struct BlockFrag {
 117:     vec2 texCoords;
 118:     vec4 color;
 119:     float diffuse;
 120:     vec2 light;
 121: };
 122: 
 123: BlockFrag FLWMain(Vertex v, Oriented o) {
 124:     vec4 worldPos = vec4(rotateVertexByQuat(v.pos - o.pivot, o.rotation) + o.pivot + o.pos, 1.);
 125: 
 126:     vec3 norm = rotateVertexByQuat(v.normal, o.rotation);
 127: 
 128:     FLWFinalizeWorldPos(worldPos);
 129:     FLWFinalizeNormal(norm);
 130: 
 131:     BlockFrag b;
 132:     b.diffuse = diffuse(norm);
 133:     b.texCoords = v.texCoords;
 134:     b.light = o.light;
 135:     #if defined(DEBUG_NORMAL)
 136:     b.color = vec4(norm, 1.);
 137:     #else
 138:     b.color = o.color;
 139:     #endif
 140:     return b;
 141: }
 142: attribute vec3 a_v_pos;
 143: attribute vec3 a_v_normal;
 144: attribute vec2 a_v_texCoords;
 145: 
 146: attribute vec2 a_i_light;
 147: attribute vec4 a_i_color;
 148: attribute vec3 a_i_pos;
 149: attribute vec3 a_i_pivot;
 150: attribute vec4 a_i_rotation;
 151: 
 152: 
 153: varying vec2 v2f_texCoords;
 154: varying vec4 v2f_color;
 155: varying float v2f_diffuse;
 156: varying vec2 v2f_light;
 157: 
 158: 
 159: void main() {
 160:     Vertex v;
 161:     v.pos = a_v_pos;
 162: v.normal = a_v_normal;
 163: v.texCoords = a_v_texCoords;
 164: 
 165: 
 166:     Oriented i;
 167:     i.light = a_i_light;
 168: i.color = a_i_color;
 169: i.pos = a_i_pos;
 170: i.pivot = a_i_pivot;
 171: i.rotation = a_i_rotation;
 172: 
 173: 
 174:     BlockFrag o = FLWMain(v, i);
 175: 
 176:     v2f_texCoords = o.texCoords;
 177: v2f_color = o.color;
 178: v2f_diffuse = o.diffuse;
 179: v2f_light = o.light;
 180: 
 181: }

[14:02:45] [main/ERROR]: Shader compilation log for flywheel:block.frag: No errors.

[14:02:45] [main/ERROR]: Source for shader 'flywheel:block.frag':
   1: #version 110
   2: 
   3: #if defined(USE_FOG)
   4: varying float FragDistance;
   5: uniform vec4 uFogColor;
   6: #endif
   7: 
   8: #if defined(USE_FOG_LINEAR)
   9: uniform vec2 uFogRange;
  10: 
  11: float FLWFogFactor() {
  12:     return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
  13: }
  14:     #endif
  15: 
  16:     #if defined(USE_FOG_EXP2)
  17: uniform float uFogDensity;
  18: 
  19: float FLWFogFactor() {
  20:     float dist = FragDistance * uFogDensity;
  21:     return 1. / exp2(dist * dist);
  22: }
  23:     #endif
  24: // Adjust the [0,1] normalized lightmap value based on the texture matrix from LightTexture#enableLightmap
  25: vec2 shiftLight(vec2 lm) {
  26:     return lm * 0.99609375 + 0.03125;// * 255/256 + 1/32
  27: }
  28: 
  29: varying vec3 BoxCoord;
  30: varying vec2 BoxLight;
  31: uniform sampler3D uLightVolume;
  32: 
  33: uniform sampler2D uBlockAtlas;
  34: uniform sampler2D uLightMap;
  35: 
  36: vec4 FLWBlockTexture(vec2 texCoords) {
  37:     return texture2D(uBlockAtlas, texCoords);
  38: }
  39: 
  40: void FLWFinalizeColor(vec4 color) {
  41:     #if defined(USE_FOG)
  42:     float a = color.a;
  43:     float fog = clamp(FLWFogFactor(), 0., 1.);
  44: 
  45:     color = mix(uFogColor, color, fog);
  46:     color.a = a;
  47:     #endif
  48: 
  49:     gl_FragColor = color;
  50: }
  51: 
  52: vec4 FLWLight(vec2 lightCoords) {
  53:     lightCoords = max(lightCoords, texture3D(uLightVolume, BoxCoord).rg);
  54: 
  55:     return texture2D(uLightMap, shiftLight(lightCoords));
  56: }
  57: 
  58: 
  59: 
  60: struct BlockFrag {
  61:     vec2 texCoords;
  62:     vec4 color;
  63:     float diffuse;
  64:     vec2 light;
  65: };
  66: 
  67: void FLWMain(BlockFrag r) {
  68:     vec4 tex = FLWBlockTexture(r.texCoords);
  69: 
  70:     vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;
  71: 
  72: //    flw_WorldPos = ;
  73: //    flw_Normal = ;
  74: //    flw_Albedo = tex.rgb;
  75: //    flw_Alpha = tex.a;
  76: //    flw_LightMap = r.light;
  77: //    flw_Tint = r.color;
  78:     FLWFinalizeColor(color);
  79: }
  80: 
  81: varying vec2 v2f_texCoords;
  82: varying vec4 v2f_color;
  83: varying float v2f_diffuse;
  84: varying vec2 v2f_light;
  85: 
  86: 
  87: //vec3 flw_WorldPos;
  88: //vec3 flw_Normal;
  89: //vec3 flw_Albedo;
  90: //float flw_Alpha;
  91: //vec2 flw_LightMap;
  92: //vec4 flw_Tint;
  93: 
  94: void main() {
  95:     BlockFrag f;
  96:     f.texCoords = v2f_texCoords;
  97: f.color = v2f_color;
  98: f.diffuse = v2f_diffuse;
  99: f.light = v2f_light;
 100: 
 101: 
 102:     FLWMain(f);
 103: }

[14:02:46] [main/ERROR]: Shader compilation log for flywheel:model.vert: No errors.

[14:02:46] [main/ERROR]: Source for shader 'flywheel:model.vert':
   1: #version 110
   2: #define DEBUG_NORMAL
   3: 
   4: #if defined(USE_FOG)
   5: varying float FragDistance;
   6: #endif
   7: 
   8: varying vec3 BoxCoord;
   9: 
  10: uniform vec3 uLightBoxSize;
  11: uniform vec3 uLightBoxMin;
  12: uniform mat4 uModel;
  13: 
  14: uniform float uTime;
  15: uniform mat4 uViewProjection;
  16: uniform vec3 uCameraPos;
  17: 
  18: void FLWFinalizeWorldPos(inout vec4 worldPos) {
  19:     worldPos = uModel * worldPos;
  20: 
  21:     BoxCoord = (worldPos.xyz - uLightBoxMin) / uLightBoxSize;
  22: 
  23:     #if defined(USE_FOG)
  24:     FragDistance = length(worldPos.xyz);
  25:     #endif
  26: 
  27:     gl_Position = uViewProjection * worldPos;
  28: }
  29: 
  30: void FLWFinalizeNormal(inout vec3 normal) {
  31:     mat3 m;
  32:     m[0] = uModel[0].xyz;
  33:     m[1] = uModel[1].xyz;
  34:     m[2] = uModel[2].xyz;
  35:     normal = m * normal;
  36: }
  37: 
  38: 
  39: 
  40: float diffuse(vec3 normal) {
  41:     vec3 n2 = normal * normal * vec3(.6, .25, .8);
  42:     return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
  43: }
  44: 
  45: 
  46: struct Vertex {
  47:     vec3 pos;
  48:     vec3 normal;
  49:     vec2 texCoords;
  50: };
  51: 
  52: struct BlockFrag {
  53:     vec2 texCoords;
  54:     vec4 color;
  55:     float diffuse;
  56:     vec2 light;
  57: };
  58: 
  59: 
  60: struct Instance {
  61:     vec2 light;
  62:     vec4 color;
  63:     mat4 transform;
  64:     mat3 normalMat;
  65: };
  66: 
  67: BlockFrag FLWMain(Vertex v, Instance i) {
  68:     vec4 worldPos = i.transform * vec4(v.pos, 1.);
  69: 
  70:     vec3 norm = i.normalMat * v.normal;
  71: 
  72:     FLWFinalizeWorldPos(worldPos);
  73:     FLWFinalizeNormal(norm);
  74: 
  75:     norm = normalize(norm);
  76: 
  77:     BlockFrag b;
  78:     b.diffuse = diffuse(norm);
  79:     b.texCoords = v.texCoords;
  80:     b.light = i.light;
  81:     #if defined(DEBUG_NORMAL)
  82:     b.color = vec4(norm, 1.);
  83:     #else
  84:     b.color = i.color;
  85:     #endif
  86:     return b;
  87: }
  88: attribute vec3 a_v_pos;
  89: attribute vec3 a_v_normal;
  90: attribute vec2 a_v_texCoords;
  91: 
  92: attribute vec2 a_i_light;
  93: attribute vec4 a_i_color;
  94: attribute mat4 a_i_transform;
  95: attribute mat3 a_i_normalMat;
  96: 
  97: 
  98: varying vec2 v2f_texCoords;
  99: varying vec4 v2f_color;
 100: varying float v2f_diffuse;
 101: varying vec2 v2f_light;
 102: 
 103: 
 104: void main() {
 105:     Vertex v;
 106:     v.pos = a_v_pos;
 107: v.normal = a_v_normal;
 108: v.texCoords = a_v_texCoords;
 109: 
 110: 
 111:     Instance i;
 112:     i.light = a_i_light;
 113: i.color = a_i_color;
 114: i.transform = a_i_transform;
 115: i.normalMat = a_i_normalMat;
 116: 
 117: 
 118:     BlockFrag o = FLWMain(v, i);
 119: 
 120:     v2f_texCoords = o.texCoords;
 121: v2f_color = o.color;
 122: v2f_diffuse = o.diffuse;
 123: v2f_light = o.light;
 124: 
 125: }

[14:02:46] [main/ERROR]: Shader compilation log for flywheel:block.frag: No errors.

[14:02:46] [main/ERROR]: Source for shader 'flywheel:block.frag':
   1: #version 110
   2: #define DEBUG_NORMAL
   3: 
   4: #if defined(USE_FOG)
   5: varying float FragDistance;
   6: uniform vec4 uFogColor;
   7: #endif
   8: 
   9: #if defined(USE_FOG_LINEAR)
  10: uniform vec2 uFogRange;
  11: 
  12: float FLWFogFactor() {
  13:     return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
  14: }
  15:     #endif
  16: 
  17:     #if defined(USE_FOG_EXP2)
  18: uniform float uFogDensity;
  19: 
  20: float FLWFogFactor() {
  21:     float dist = FragDistance * uFogDensity;
  22:     return 1. / exp2(dist * dist);
  23: }
  24:     #endif
  25: // Adjust the [0,1] normalized lightmap value based on the texture matrix from LightTexture#enableLightmap
  26: vec2 shiftLight(vec2 lm) {
  27:     return lm * 0.99609375 + 0.03125;// * 255/256 + 1/32
  28: }
  29: 
  30: varying vec3 BoxCoord;
  31: varying vec2 BoxLight;
  32: uniform sampler3D uLightVolume;
  33: 
  34: uniform sampler2D uBlockAtlas;
  35: uniform sampler2D uLightMap;
  36: 
  37: vec4 FLWBlockTexture(vec2 texCoords) {
  38:     return texture2D(uBlockAtlas, texCoords);
  39: }
  40: 
  41: void FLWFinalizeColor(vec4 color) {
  42:     #if defined(USE_FOG)
  43:     float a = color.a;
  44:     float fog = clamp(FLWFogFactor(), 0., 1.);
  45: 
  46:     color = mix(uFogColor, color, fog);
  47:     color.a = a;
  48:     #endif
  49: 
  50:     gl_FragColor = color;
  51: }
  52: 
  53: vec4 FLWLight(vec2 lightCoords) {
  54:     lightCoords = max(lightCoords, texture3D(uLightVolume, BoxCoord).rg);
  55: 
  56:     return texture2D(uLightMap, shiftLight(lightCoords));
  57: }
  58: 
  59: 
  60: 
  61: struct BlockFrag {
  62:     vec2 texCoords;
  63:     vec4 color;
  64:     float diffuse;
  65:     vec2 light;
  66: };
  67: 
  68: void FLWMain(BlockFrag r) {
  69:     vec4 tex = FLWBlockTexture(r.texCoords);
  70: 
  71:     vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;
  72: 
  73: //    flw_WorldPos = ;
  74: //    flw_Normal = ;
  75: //    flw_Albedo = tex.rgb;
  76: //    flw_Alpha = tex.a;
  77: //    flw_LightMap = r.light;
  78: //    flw_Tint = r.color;
  79:     FLWFinalizeColor(color);
  80: }
  81: 
  82: varying vec2 v2f_texCoords;
  83: varying vec4 v2f_color;
  84: varying float v2f_diffuse;
  85: varying vec2 v2f_light;
  86: 
  87: 
  88: //vec3 flw_WorldPos;
  89: //vec3 flw_Normal;
  90: //vec3 flw_Albedo;
  91: //float flw_Alpha;
  92: //vec2 flw_LightMap;
  93: //vec4 flw_Tint;
  94: 
  95: void main() {
  96:     BlockFrag f;
  97:     f.texCoords = v2f_texCoords;
  98: f.color = v2f_color;
  99: f.diffuse = v2f_diffuse;
 100: f.light = v2f_light;
 101: 
 102: 
 103:     FLWMain(f);
 104: }

[14:02:46] [main/ERROR]: Shader compilation log for flywheel:model.vert: No errors.

[14:02:46] [main/ERROR]: Source for shader 'flywheel:model.vert':
   1: #version 110
   2: #define USE_FOG
   3: #define USE_FOG_LINEAR
   4: 
   5: #if defined(USE_FOG)
   6: varying float FragDistance;
   7: #endif
   8: 
   9: varying vec3 BoxCoord;
  10: 
  11: uniform vec3 uLightBoxSize;
  12: uniform vec3 uLightBoxMin;
  13: uniform mat4 uModel;
  14: 
  15: uniform float uTime;
  16: uniform mat4 uViewProjection;
  17: uniform vec3 uCameraPos;
  18: 
  19: void FLWFinalizeWorldPos(inout vec4 worldPos) {
  20:     worldPos = uModel * worldPos;
  21: 
  22:     BoxCoord = (worldPos.xyz - uLightBoxMin) / uLightBoxSize;
  23: 
  24:     #if defined(USE_FOG)
  25:     FragDistance = length(worldPos.xyz);
  26:     #endif
  27: 
  28:     gl_Position = uViewProjection * worldPos;
  29: }
  30: 
  31: void FLWFinalizeNormal(inout vec3 normal) {
  32:     mat3 m;
  33:     m[0] = uModel[0].xyz;
  34:     m[1] = uModel[1].xyz;
  35:     m[2] = uModel[2].xyz;
  36:     normal = m * normal;
  37: }
  38: 
  39: 
  40: 
  41: float diffuse(vec3 normal) {
  42:     vec3 n2 = normal * normal * vec3(.6, .25, .8);
  43:     return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
  44: }
  45: 
  46: 
  47: struct Vertex {
  48:     vec3 pos;
  49:     vec3 normal;
  50:     vec2 texCoords;
  51: };
  52: 
  53: struct BlockFrag {
  54:     vec2 texCoords;
  55:     vec4 color;
  56:     float diffuse;
  57:     vec2 light;
  58: };
  59: 
  60: 
  61: struct Instance {
  62:     vec2 light;
  63:     vec4 color;
  64:     mat4 transform;
  65:     mat3 normalMat;
  66: };
  67: 
  68: BlockFrag FLWMain(Vertex v, Instance i) {
  69:     vec4 worldPos = i.transform * vec4(v.pos, 1.);
  70: 
  71:     vec3 norm = i.normalMat * v.normal;
  72: 
  73:     FLWFinalizeWorldPos(worldPos);
  74:     FLWFinalizeNormal(norm);
  75: 
  76:     norm = normalize(norm);
  77: 
  78:     BlockFrag b;
  79:     b.diffuse = diffuse(norm);
  80:     b.texCoords = v.texCoords;
  81:     b.light = i.light;
  82:     #if defined(DEBUG_NORMAL)
  83:     b.color = vec4(norm, 1.);
  84:     #else
  85:     b.color = i.color;
  86:     #endif
  87:     return b;
  88: }
  89: attribute vec3 a_v_pos;
  90: attribute vec3 a_v_normal;
  91: attribute vec2 a_v_texCoords;
  92: 
  93: attribute vec2 a_i_light;
  94: attribute vec4 a_i_color;
  95: attribute mat4 a_i_transform;
  96: attribute mat3 a_i_normalMat;
  97: 
  98: 
  99: varying vec2 v2f_texCoords;
 100: varying vec4 v2f_color;
 101: varying float v2f_diffuse;
 102: varying vec2 v2f_light;
 103: 
 104: 
 105: void main() {
 106:     Vertex v;
 107:     v.pos = a_v_pos;
 108: v.normal = a_v_normal;
 109: v.texCoords = a_v_texCoords;
 110: 
 111: 
 112:     Instance i;
 113:     i.light = a_i_light;
 114: i.color = a_i_color;
 115: i.transform = a_i_transform;
 116: i.normalMat = a_i_normalMat;
 117: 
 118: 
 119:     BlockFrag o = FLWMain(v, i);
 120: 
 121:     v2f_texCoords = o.texCoords;
 122: v2f_color = o.color;
 123: v2f_diffuse = o.diffuse;
 124: v2f_light = o.light;
 125: 
 126: }

[14:02:46] [main/ERROR]: Shader compilation log for flywheel:block.frag: No errors.

[14:02:46] [main/ERROR]: Source for shader 'flywheel:block.frag':
   1: #version 110
   2: #define USE_FOG
   3: #define USE_FOG_LINEAR
   4: 
   5: #if defined(USE_FOG)
   6: varying float FragDistance;
   7: uniform vec4 uFogColor;
   8: #endif
   9: 
  10: #if defined(USE_FOG_LINEAR)
  11: uniform vec2 uFogRange;
  12: 
  13: float FLWFogFactor() {
  14:     return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
  15: }
  16:     #endif
  17: 
  18:     #if defined(USE_FOG_EXP2)
  19: uniform float uFogDensity;
  20: 
  21: float FLWFogFactor() {
  22:     float dist = FragDistance * uFogDensity;
  23:     return 1. / exp2(dist * dist);
  24: }
  25:     #endif
  26: // Adjust the [0,1] normalized lightmap value based on the texture matrix from LightTexture#enableLightmap
  27: vec2 shiftLight(vec2 lm) {
  28:     return lm * 0.99609375 + 0.03125;// * 255/256 + 1/32
  29: }
  30: 
  31: varying vec3 BoxCoord;
  32: varying vec2 BoxLight;
  33: uniform sampler3D uLightVolume;
  34: 
  35: uniform sampler2D uBlockAtlas;
  36: uniform sampler2D uLightMap;
  37: 
  38: vec4 FLWBlockTexture(vec2 texCoords) {
  39:     return texture2D(uBlockAtlas, texCoords);
  40: }
  41: 
  42: void FLWFinalizeColor(vec4 color) {
  43:     #if defined(USE_FOG)
  44:     float a = color.a;
  45:     float fog = clamp(FLWFogFactor(), 0., 1.);
  46: 
  47:     color = mix(uFogColor, color, fog);
  48:     color.a = a;
  49:     #endif
  50: 
  51:     gl_FragColor = color;
  52: }
  53: 
  54: vec4 FLWLight(vec2 lightCoords) {
  55:     lightCoords = max(lightCoords, texture3D(uLightVolume, BoxCoord).rg);
  56: 
  57:     return texture2D(uLightMap, shiftLight(lightCoords));
  58: }
  59: 
  60: 
  61: 
  62: struct BlockFrag {
  63:     vec2 texCoords;
  64:     vec4 color;
  65:     float diffuse;
  66:     vec2 light;
  67: };
  68: 
  69: void FLWMain(BlockFrag r) {
  70:     vec4 tex = FLWBlockTexture(r.texCoords);
  71: 
  72:     vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;
  73: 
  74: //    flw_WorldPos = ;
  75: //    flw_Normal = ;
  76: //    flw_Albedo = tex.rgb;
  77: //    flw_Alpha = tex.a;
  78: //    flw_LightMap = r.light;
  79: //    flw_Tint = r.color;
  80:     FLWFinalizeColor(color);
  81: }
  82: 
  83: varying vec2 v2f_texCoords;
  84: varying vec4 v2f_color;
  85: varying float v2f_diffuse;
  86: varying vec2 v2f_light;
  87: 
  88: 
  89: //vec3 flw_WorldPos;
  90: //vec3 flw_Normal;
  91: //vec3 flw_Albedo;
  92: //float flw_Alpha;
  93: //vec2 flw_LightMap;
  94: //vec4 flw_Tint;
  95: 
  96: void main() {
  97:     BlockFrag f;
  98:     f.texCoords = v2f_texCoords;
  99: f.color = v2f_color;
 100: f.diffuse = v2f_diffuse;
 101: f.light = v2f_light;
 102: 
 103: 
 104:     FLWMain(f);
 105: }

[14:02:46] [main/ERROR]: Shader compilation log for flywheel:model.vert: No errors.

[14:02:46] [main/ERROR]: Source for shader 'flywheel:model.vert':
   1: #version 110
   2: #define USE_FOG
   3: #define USE_FOG_EXP2
   4: 
   5: #if defined(USE_FOG)
   6: varying float FragDistance;
   7: #endif
   8: 
   9: varying vec3 BoxCoord;
  10: 
  11: uniform vec3 uLightBoxSize;
  12: uniform vec3 uLightBoxMin;
  13: uniform mat4 uModel;
  14: 
  15: uniform float uTime;
  16: uniform mat4 uViewProjection;
  17: uniform vec3 uCameraPos;
  18: 
  19: void FLWFinalizeWorldPos(inout vec4 worldPos) {
  20:     worldPos = uModel * worldPos;
  21: 
  22:     BoxCoord = (worldPos.xyz - uLightBoxMin) / uLightBoxSize;
  23: 
  24:     #if defined(USE_FOG)
  25:     FragDistance = length(worldPos.xyz);
  26:     #endif
  27: 
  28:     gl_Position = uViewProjection * worldPos;
  29: }
  30: 
  31: void FLWFinalizeNormal(inout vec3 normal) {
  32:     mat3 m;
  33:     m[0] = uModel[0].xyz;
  34:     m[1] = uModel[1].xyz;
  35:     m[2] = uModel[2].xyz;
  36:     normal = m * normal;
  37: }
  38: 
  39: 
  40: 
  41: float diffuse(vec3 normal) {
  42:     vec3 n2 = normal * normal * vec3(.6, .25, .8);
  43:     return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
  44: }
  45: 
  46: 
  47: struct Vertex {
  48:     vec3 pos;
  49:     vec3 normal;
  50:     vec2 texCoords;
  51: };
  52: 
  53: struct BlockFrag {
  54:     vec2 texCoords;
  55:     vec4 color;
  56:     float diffuse;
  57:     vec2 light;
  58: };
  59: 
  60: 
  61: struct Instance {
  62:     vec2 light;
  63:     vec4 color;
  64:     mat4 transform;
  65:     mat3 normalMat;
  66: };
  67: 
  68: BlockFrag FLWMain(Vertex v, Instance i) {
  69:     vec4 worldPos = i.transform * vec4(v.pos, 1.);
  70: 
  71:     vec3 norm = i.normalMat * v.normal;
  72: 
  73:     FLWFinalizeWorldPos(worldPos);
  74:     FLWFinalizeNormal(norm);
  75: 
  76:     norm = normalize(norm);
  77: 
  78:     BlockFrag b;
  79:     b.diffuse = diffuse(norm);
  80:     b.texCoords = v.texCoords;
  81:     b.light = i.light;
  82:     #if defined(DEBUG_NORMAL)
  83:     b.color = vec4(norm, 1.);
  84:     #else
  85:     b.color = i.color;
  86:     #endif
  87:     return b;
  88: }
  89: attribute vec3 a_v_pos;
  90: attribute vec3 a_v_normal;
  91: attribute vec2 a_v_texCoords;
  92: 
  93: attribute vec2 a_i_light;
  94: attribute vec4 a_i_color;
  95: attribute mat4 a_i_transform;
  96: attribute mat3 a_i_normalMat;
  97: 
  98: 
  99: varying vec2 v2f_texCoords;
 100: varying vec4 v2f_color;
 101: varying float v2f_diffuse;
 102: varying vec2 v2f_light;
 103: 
 104: 
 105: void main() {
 106:     Vertex v;
 107:     v.pos = a_v_pos;
 108: v.normal = a_v_normal;
 109: v.texCoords = a_v_texCoords;
 110: 
 111: 
 112:     Instance i;
 113:     i.light = a_i_light;
 114: i.color = a_i_color;
 115: i.transform = a_i_transform;
 116: i.normalMat = a_i_normalMat;
 117: 
 118: 
 119:     BlockFrag o = FLWMain(v, i);
 120: 
 121:     v2f_texCoords = o.texCoords;
 122: v2f_color = o.color;
 123: v2f_diffuse = o.diffuse;
 124: v2f_light = o.light;
 125: 
 126: }

[14:02:46] [main/ERROR]: Shader compilation log for flywheel:block.frag: No errors.

[14:02:46] [main/ERROR]: Source for shader 'flywheel:block.frag':
   1: #version 110
   2: #define USE_FOG
   3: #define USE_FOG_EXP2
   4: 
   5: #if defined(USE_FOG)
   6: varying float FragDistance;
   7: uniform vec4 uFogColor;
   8: #endif
   9: 
  10: #if defined(USE_FOG_LINEAR)
  11: uniform vec2 uFogRange;
  12: 
  13: float FLWFogFactor() {
  14:     return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
  15: }
  16:     #endif
  17: 
  18:     #if defined(USE_FOG_EXP2)
  19: uniform float uFogDensity;
  20: 
  21: float FLWFogFactor() {
  22:     float dist = FragDistance * uFogDensity;
  23:     return 1. / exp2(dist * dist);
  24: }
  25:     #endif
  26: // Adjust the [0,1] normalized lightmap value based on the texture matrix from LightTexture#enableLightmap
  27: vec2 shiftLight(vec2 lm) {
  28:     return lm * 0.99609375 + 0.03125;// * 255/256 + 1/32
  29: }
  30: 
  31: varying vec3 BoxCoord;
  32: varying vec2 BoxLight;
  33: uniform sampler3D uLightVolume;
  34: 
  35: uniform sampler2D uBlockAtlas;
  36: uniform sampler2D uLightMap;
  37: 
  38: vec4 FLWBlockTexture(vec2 texCoords) {
  39:     return texture2D(uBlockAtlas, texCoords);
  40: }
  41: 
  42: void FLWFinalizeColor(vec4 color) {
  43:     #if defined(USE_FOG)
  44:     float a = color.a;
  45:     float fog = clamp(FLWFogFactor(), 0., 1.);
  46: 
  47:     color = mix(uFogColor, color, fog);
  48:     color.a = a;
  49:     #endif
  50: 
  51:     gl_FragColor = color;
  52: }
  53: 
  54: vec4 FLWLight(vec2 lightCoords) {
  55:     lightCoords = max(lightCoords, texture3D(uLightVolume, BoxCoord).rg);
  56: 
  57:     return texture2D(uLightMap, shiftLight(lightCoords));
  58: }
  59: 
  60: 
  61: 
  62: struct BlockFrag {
  63:     vec2 texCoords;
  64:     vec4 color;
  65:     float diffuse;
  66:     vec2 light;
  67: };
  68: 
  69: void FLWMain(BlockFrag r) {
  70:     vec4 tex = FLWBlockTexture(r.texCoords);
  71: 
  72:     vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;
  73: 
  74: //    flw_WorldPos = ;
  75: //    flw_Normal = ;
  76: //    flw_Albedo = tex.rgb;
  77: //    flw_Alpha = tex.a;
  78: //    flw_LightMap = r.light;
  79: //    flw_Tint = r.color;
  80:     FLWFinalizeColor(color);
  81: }
  82: 
  83: varying vec2 v2f_texCoords;
  84: varying vec4 v2f_color;
  85: varying float v2f_diffuse;
  86: varying vec2 v2f_light;
  87: 
  88: 
  89: //vec3 flw_WorldPos;
  90: //vec3 flw_Normal;
  91: //vec3 flw_Albedo;
  92: //float flw_Alpha;
  93: //vec2 flw_LightMap;
  94: //vec4 flw_Tint;
  95: 
  96: void main() {
  97:     BlockFrag f;
  98:     f.texCoords = v2f_texCoords;
  99: f.color = v2f_color;
 100: f.diffuse = v2f_diffuse;
 101: f.light = v2f_light;
 102: 
 103: 
 104:     FLWMain(f);
 105: }

[14:02:46] [main/ERROR]: Shader compilation log for flywheel:model.vert: No errors.

[14:02:46] [main/ERROR]: Source for shader 'flywheel:model.vert':
   1: #version 110
   2: 
   3: #if defined(USE_FOG)
   4: varying float FragDistance;
   5: #endif
   6: 
   7: varying vec3 BoxCoord;
   8: 
   9: uniform vec3 uLightBoxSize;
  10: uniform vec3 uLightBoxMin;
  11: uniform mat4 uModel;
  12: 
  13: uniform float uTime;
  14: uniform mat4 uViewProjection;
  15: uniform vec3 uCameraPos;
  16: 
  17: void FLWFinalizeWorldPos(inout vec4 worldPos) {
  18:     worldPos = uModel * worldPos;
  19: 
  20:     BoxCoord = (worldPos.xyz - uLightBoxMin) / uLightBoxSize;
  21: 
  22:     #if defined(USE_FOG)
  23:     FragDistance = length(worldPos.xyz);
  24:     #endif
  25: 
  26:     gl_Position = uViewProjection * worldPos;
  27: }
  28: 
  29: void FLWFinalizeNormal(inout vec3 normal) {
  30:     mat3 m;
  31:     m[0] = uModel[0].xyz;
  32:     m[1] = uModel[1].xyz;
  33:     m[2] = uModel[2].xyz;
  34:     normal = m * normal;
  35: }
  36: 
  37: 
  38: 
  39: float diffuse(vec3 normal) {
  40:     vec3 n2 = normal * normal * vec3(.6, .25, .8);
  41:     return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
  42: }
  43: 
  44: 
  45: struct Vertex {
  46:     vec3 pos;
  47:     vec3 normal;
  48:     vec2 texCoords;
  49: };
  50: 
  51: struct BlockFrag {
  52:     vec2 texCoords;
  53:     vec4 color;
  54:     float diffuse;
  55:     vec2 light;
  56: };
  57: 
  58: 
  59: struct Instance {
  60:     vec2 light;
  61:     vec4 color;
  62:     mat4 transform;
  63:     mat3 normalMat;
  64: };
  65: 
  66: BlockFrag FLWMain(Vertex v, Instance i) {
  67:     vec4 worldPos = i.transform * vec4(v.pos, 1.);
  68: 
  69:     vec3 norm = i.normalMat * v.normal;
  70: 
  71:     FLWFinalizeWorldPos(worldPos);
  72:     FLWFinalizeNormal(norm);
  73: 
  74:     norm = normalize(norm);
  75: 
  76:     BlockFrag b;
  77:     b.diffuse = diffuse(norm);
  78:     b.texCoords = v.texCoords;
  79:     b.light = i.light;
  80:     #if defined(DEBUG_NORMAL)
  81:     b.color = vec4(norm, 1.);
  82:     #else
  83:     b.color = i.color;
  84:     #endif
  85:     return b;
  86: }
  87: attribute vec3 a_v_pos;
  88: attribute vec3 a_v_normal;
  89: attribute vec2 a_v_texCoords;
  90: 
  91: attribute vec2 a_i_light;
  92: attribute vec4 a_i_color;
  93: attribute mat4 a_i_transform;
  94: attribute mat3 a_i_normalMat;
  95: 
  96: 
  97: varying vec2 v2f_texCoords;
  98: varying vec4 v2f_color;
  99: varying float v2f_diffuse;
 100: varying vec2 v2f_light;
 101: 
 102: 
 103: void main() {
 104:     Vertex v;
 105:     v.pos = a_v_pos;
 106: v.normal = a_v_normal;
 107: v.texCoords = a_v_texCoords;
 108: 
 109: 
 110:     Instance i;
 111:     i.light = a_i_light;
 112: i.color = a_i_color;
 113: i.transform = a_i_transform;
 114: i.normalMat = a_i_normalMat;
 115: 
 116: 
 117:     BlockFrag o = FLWMain(v, i);
 118: 
 119:     v2f_texCoords = o.texCoords;
 120: v2f_color = o.color;
 121: v2f_diffuse = o.diffuse;
 122: v2f_light = o.light;
 123: 
 124: }

[14:02:46] [main/ERROR]: Shader compilation log for flywheel:block.frag: No errors.

[14:02:46] [main/ERROR]: Source for shader 'flywheel:block.frag':
   1: #version 110
   2: 
   3: #if defined(USE_FOG)
   4: varying float FragDistance;
   5: uniform vec4 uFogColor;
   6: #endif
   7: 
   8: #if defined(USE_FOG_LINEAR)
   9: uniform vec2 uFogRange;
  10: 
  11: float FLWFogFactor() {
  12:     return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
  13: }
  14:     #endif
  15: 
  16:     #if defined(USE_FOG_EXP2)
  17: uniform float uFogDensity;
  18: 
  19: float FLWFogFactor() {
  20:     float dist = FragDistance * uFogDensity;
  21:     return 1. / exp2(dist * dist);
  22: }
  23:     #endif
  24: // Adjust the [0,1] normalized lightmap value based on the texture matrix from LightTexture#enableLightmap
  25: vec2 shiftLight(vec2 lm) {
  26:     return lm * 0.99609375 + 0.03125;// * 255/256 + 1/32
  27: }
  28: 
  29: varying vec3 BoxCoord;
  30: varying vec2 BoxLight;
  31: uniform sampler3D uLightVolume;
  32: 
  33: uniform sampler2D uBlockAtlas;
  34: uniform sampler2D uLightMap;
  35: 
  36: vec4 FLWBlockTexture(vec2 texCoords) {
  37:     return texture2D(uBlockAtlas, texCoords);
  38: }
  39: 
  40: void FLWFinalizeColor(vec4 color) {
  41:     #if defined(USE_FOG)
  42:     float a = color.a;
  43:     float fog = clamp(FLWFogFactor(), 0., 1.);
  44: 
  45:     color = mix(uFogColor, color, fog);
  46:     color.a = a;
  47:     #endif
  48: 
  49:     gl_FragColor = color;
  50: }
  51: 
  52: vec4 FLWLight(vec2 lightCoords) {
  53:     lightCoords = max(lightCoords, texture3D(uLightVolume, BoxCoord).rg);
  54: 
  55:     return texture2D(uLightMap, shiftLight(lightCoords));
  56: }
  57: 
  58: 
  59: 
  60: struct BlockFrag {
  61:     vec2 texCoords;
  62:     vec4 color;
  63:     float diffuse;
  64:     vec2 light;
  65: };
  66: 
  67: void FLWMain(BlockFrag r) {
  68:     vec4 tex = FLWBlockTexture(r.texCoords);
  69: 
  70:     vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;
  71: 
  72: //    flw_WorldPos = ;
  73: //    flw_Normal = ;
  74: //    flw_Albedo = tex.rgb;
  75: //    flw_Alpha = tex.a;
  76: //    flw_LightMap = r.light;
  77: //    flw_Tint = r.color;
  78:     FLWFinalizeColor(color);
  79: }
  80: 
  81: varying vec2 v2f_texCoords;
  82: varying vec4 v2f_color;
  83: varying float v2f_diffuse;
  84: varying vec2 v2f_light;
  85: 
  86: 
  87: //vec3 flw_WorldPos;
  88: //vec3 flw_Normal;
  89: //vec3 flw_Albedo;
  90: //float flw_Alpha;
  91: //vec2 flw_LightMap;
  92: //vec4 flw_Tint;
  93: 
  94: void main() {
  95:     BlockFrag f;
  96:     f.texCoords = v2f_texCoords;
  97: f.color = v2f_color;
  98: f.diffuse = v2f_diffuse;
  99: f.light = v2f_light;
 100: 
 101: 
 102:     FLWMain(f);
 103: }

[14:02:46] [main/INFO]: Loading context 'create:context/contraption'
[14:02:46] [main/ERROR]: Shader compilation log for create:contraption_structure.vert: No errors.

[14:02:46] [main/ERROR]: Source for shader 'create:contraption_structure.vert':
   1: #version 110
   2: #define DEBUG_NORMAL
   3: 
   4: #define PI 3.1415926538
   5: 
   6: #if defined(USE_FOG)
   7: varying float FragDistance;
   8: #endif
   9: 
  10: varying vec3 BoxCoord;
  11: 
  12: uniform vec3 uLightBoxSize;
  13: uniform vec3 uLightBoxMin;
  14: uniform mat4 uModel;
  15: 
  16: uniform float uTime;
  17: uniform mat4 uViewProjection;
  18: uniform vec3 uCameraPos;
  19: 
  20: void FLWFinalizeWorldPos(inout vec4 worldPos) {
  21:     worldPos = uModel * worldPos;
  22: 
  23:     BoxCoord = (worldPos.xyz - uLightBoxMin) / uLightBoxSize;
  24: 
  25:     #if defined(USE_FOG)
  26:     FragDistance = length(worldPos.xyz);
  27:     #endif
  28: 
  29:     gl_Position = uViewProjection * worldPos;
  30: }
  31: 
  32: void FLWFinalizeNormal(inout vec3 normal) {
  33:     mat3 m;
  34:     m[0] = uModel[0].xyz;
  35:     m[1] = uModel[1].xyz;
  36:     m[2] = uModel[2].xyz;
  37:     normal = m * normal;
  38: }
  39: 
  40: 
  41: 
  42: mat4 rotate(vec3 axis, float angle) {
  43:     float s = sin(angle);
  44:     float c = cos(angle);
  45:     float oc = 1. - c;
  46: 
  47:     vec3 sa = axis * s;
  48: 
  49:     mat4 mr = mat4(1.);
  50:     mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
  51:     mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
  52:     mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);
  53: 
  54:     return mr;
  55: }
  56: 
  57: mat4 rotation(vec3 rot) {
  58:     return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
  59: }
  60: 
  61: mat3 modelToNormal(mat4 mat) {
  62:     // Discard the edges. This won't be accurate for scaled or skewed matrices,
  63:     // but we don't have to work with those often.
  64:     mat3 m;
  65:     m[0] = mat[0].xyz;
  66:     m[1] = mat[1].xyz;
  67:     m[2] = mat[2].xyz;
  68:     return m;
  69: }
  70: 
  71: float diffuse(vec3 normal) {
  72:     vec3 n2 = normal * normal * vec3(.6, .25, .8);
  73:     return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
  74: }
  75: 
  76: 
  77: struct Vertex {
  78:     vec3 pos;
  79:     vec3 normal;
  80:     vec2 texCoords;
  81:     vec4 color;
  82:     vec2 modelLight;
  83: };
  84: 
  85: 
  86: struct BlockFrag {
  87:     vec2 texCoords;
  88:     vec4 color;
  89:     float diffuse;
  90:     vec2 light;
  91: };
  92: 
  93: BlockFrag FLWMain(Vertex v) {
  94:     vec4 worldPos = vec4(v.pos, 1.);
  95:     vec3 norm = v.normal;
  96: 
  97:     FLWFinalizeWorldPos(worldPos);
  98:     FLWFinalizeNormal(norm);
  99: 
 100:     BlockFrag b;
 101:     b.diffuse = diffuse(norm);
 102:     b.texCoords = v.texCoords;
 103:     b.light = v.modelLight;
 104: 
 105:     #if defined(DEBUG_NORMAL)
 106:     b.color = vec4(norm, 1.);
 107:     #else
 108:     b.color = vec4(v.color.rgb / diffuse(v.normal), v.color.a);
 109:     #endif
 110: 
 111:     return b;
 112: }
 113: attribute vec3 a_v_pos;
 114: attribute vec3 a_v_normal;
 115: attribute vec2 a_v_texCoords;
 116: attribute vec4 a_v_color;
 117: attribute vec2 a_v_modelLight;
 118: 
 119: 
 120: varying vec2 v2f_texCoords;
 121: varying vec4 v2f_color;
 122: varying float v2f_diffuse;
 123: varying vec2 v2f_light;
 124: 
 125: 
 126: void main() {
 127:     Vertex v;
 128:     v.pos = a_v_pos;
 129: v.normal = a_v_normal;
 130: v.texCoords = a_v_texCoords;
 131: v.color = a_v_color;
 132: v.modelLight = a_v_modelLight;
 133: 
 134: 
 135:     BlockFrag o = FLWMain(v);
 136: 
 137:     v2f_texCoords = o.texCoords;
 138: v2f_color = o.color;
 139: v2f_diffuse = o.diffuse;
 140: v2f_light = o.light;
 141: 
 142: }

[14:02:46] [main/ERROR]: Shader compilation log for flywheel:block.frag: No errors.

[14:02:46] [main/ERROR]: Source for shader 'flywheel:block.frag':
   1: #version 110
   2: #define DEBUG_NORMAL
   3: 
   4: #if defined(USE_FOG)
   5: varying float FragDistance;
   6: uniform vec4 uFogColor;
   7: #endif
   8: 
   9: #if defined(USE_FOG_LINEAR)
  10: uniform vec2 uFogRange;
  11: 
  12: float FLWFogFactor() {
  13:     return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
  14: }
  15:     #endif
  16: 
  17:     #if defined(USE_FOG_EXP2)
  18: uniform float uFogDensity;
  19: 
  20: float FLWFogFactor() {
  21:     float dist = FragDistance * uFogDensity;
  22:     return 1. / exp2(dist * dist);
  23: }
  24:     #endif
  25: // Adjust the [0,1] normalized lightmap value based on the texture matrix from LightTexture#enableLightmap
  26: vec2 shiftLight(vec2 lm) {
  27:     return lm * 0.99609375 + 0.03125;// * 255/256 + 1/32
  28: }
  29: 
  30: varying vec3 BoxCoord;
  31: varying vec2 BoxLight;
  32: uniform sampler3D uLightVolume;
  33: 
  34: uniform sampler2D uBlockAtlas;
  35: uniform sampler2D uLightMap;
  36: 
  37: vec4 FLWBlockTexture(vec2 texCoords) {
  38:     return texture2D(uBlockAtlas, texCoords);
  39: }
  40: 
  41: void FLWFinalizeColor(vec4 color) {
  42:     #if defined(USE_FOG)
  43:     float a = color.a;
  44:     float fog = clamp(FLWFogFactor(), 0., 1.);
  45: 
  46:     color = mix(uFogColor, color, fog);
  47:     color.a = a;
  48:     #endif
  49: 
  50:     gl_FragColor = color;
  51: }
  52: 
  53: vec4 FLWLight(vec2 lightCoords) {
  54:     lightCoords = max(lightCoords, texture3D(uLightVolume, BoxCoord).rg);
  55: 
  56:     return texture2D(uLightMap, shiftLight(lightCoords));
  57: }
  58: 
  59: 
  60: 
  61: struct BlockFrag {
  62:     vec2 texCoords;
  63:     vec4 color;
  64:     float diffuse;
  65:     vec2 light;
  66: };
  67: 
  68: void FLWMain(BlockFrag r) {
  69:     vec4 tex = FLWBlockTexture(r.texCoords);
  70: 
  71:     vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;
  72: 
  73: //    flw_WorldPos = ;
  74: //    flw_Normal = ;
  75: //    flw_Albedo = tex.rgb;
  76: //    flw_Alpha = tex.a;
  77: //    flw_LightMap = r.light;
  78: //    flw_Tint = r.color;
  79:     FLWFinalizeColor(color);
  80: }
  81: 
  82: varying vec2 v2f_texCoords;
  83: varying vec4 v2f_color;
  84: varying float v2f_diffuse;
  85: varying vec2 v2f_light;
  86: 
  87: 
  88: void main() {
  89:     BlockFrag f;
  90:     f.texCoords = v2f_texCoords;
  91: f.color = v2f_color;
  92: f.diffuse = v2f_diffuse;
  93: f.light = v2f_light;
  94: 
  95: 
  96:     FLWMain(f);
  97: }

[14:02:46] [main/ERROR]: Shader compilation log for create:contraption_structure.vert: No errors.

[14:02:46] [main/ERROR]: Source for shader 'create:contraption_structure.vert':
   1: #version 110
   2: #define USE_FOG
   3: #define USE_FOG_LINEAR
   4: 
   5: #define PI 3.1415926538
   6: 
   7: #if defined(USE_FOG)
   8: varying float FragDistance;
   9: #endif
  10: 
  11: varying vec3 BoxCoord;
  12: 
  13: uniform vec3 uLightBoxSize;
  14: uniform vec3 uLightBoxMin;
  15: uniform mat4 uModel;
  16: 
  17: uniform float uTime;
  18: uniform mat4 uViewProjection;
  19: uniform vec3 uCameraPos;
  20: 
  21: void FLWFinalizeWorldPos(inout vec4 worldPos) {
  22:     worldPos = uModel * worldPos;
  23: 
  24:     BoxCoord = (worldPos.xyz - uLightBoxMin) / uLightBoxSize;
  25: 
  26:     #if defined(USE_FOG)
  27:     FragDistance = length(worldPos.xyz);
  28:     #endif
  29: 
  30:     gl_Position = uViewProjection * worldPos;
  31: }
  32: 
  33: void FLWFinalizeNormal(inout vec3 normal) {
  34:     mat3 m;
  35:     m[0] = uModel[0].xyz;
  36:     m[1] = uModel[1].xyz;
  37:     m[2] = uModel[2].xyz;
  38:     normal = m * normal;
  39: }
  40: 
  41: 
  42: 
  43: mat4 rotate(vec3 axis, float angle) {
  44:     float s = sin(angle);
  45:     float c = cos(angle);
  46:     float oc = 1. - c;
  47: 
  48:     vec3 sa = axis * s;
  49: 
  50:     mat4 mr = mat4(1.);
  51:     mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
  52:     mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
  53:     mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);
  54: 
  55:     return mr;
  56: }
  57: 
  58: mat4 rotation(vec3 rot) {
  59:     return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
  60: }
  61: 
  62: mat3 modelToNormal(mat4 mat) {
  63:     // Discard the edges. This won't be accurate for scaled or skewed matrices,
  64:     // but we don't have to work with those often.
  65:     mat3 m;
  66:     m[0] = mat[0].xyz;
  67:     m[1] = mat[1].xyz;
  68:     m[2] = mat[2].xyz;
  69:     return m;
  70: }
  71: 
  72: float diffuse(vec3 normal) {
  73:     vec3 n2 = normal * normal * vec3(.6, .25, .8);
  74:     return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
  75: }
  76: 
  77: 
  78: struct Vertex {
  79:     vec3 pos;
  80:     vec3 normal;
  81:     vec2 texCoords;
  82:     vec4 color;
  83:     vec2 modelLight;
  84: };
  85: 
  86: 
  87: struct BlockFrag {
  88:     vec2 texCoords;
  89:     vec4 color;
  90:     float diffuse;
  91:     vec2 light;
  92: };
  93: 
  94: BlockFrag FLWMain(Vertex v) {
  95:     vec4 worldPos = vec4(v.pos, 1.);
  96:     vec3 norm = v.normal;
  97: 
  98:     FLWFinalizeWorldPos(worldPos);
  99:     FLWFinalizeNormal(norm);
 100: 
 101:     BlockFrag b;
 102:     b.diffuse = diffuse(norm);
 103:     b.texCoords = v.texCoords;
 104:     b.light = v.modelLight;
 105: 
 106:     #if defined(DEBUG_NORMAL)
 107:     b.color = vec4(norm, 1.);
 108:     #else
 109:     b.color = vec4(v.color.rgb / diffuse(v.normal), v.color.a);
 110:     #endif
 111: 
 112:     return b;
 113: }
 114: attribute vec3 a_v_pos;
 115: attribute vec3 a_v_normal;
 116: attribute vec2 a_v_texCoords;
 117: attribute vec4 a_v_color;
 118: attribute vec2 a_v_modelLight;
 119: 
 120: 
 121: varying vec2 v2f_texCoords;
 122: varying vec4 v2f_color;
 123: varying float v2f_diffuse;
 124: varying vec2 v2f_light;
 125: 
 126: 
 127: void main() {
 128:     Vertex v;
 129:     v.pos = a_v_pos;
 130: v.normal = a_v_normal;
 131: v.texCoords = a_v_texCoords;
 132: v.color = a_v_color;
 133: v.modelLight = a_v_modelLight;
 134: 
 135: 
 136:     BlockFrag o = FLWMain(v);
 137: 
 138:     v2f_texCoords = o.texCoords;
 139: v2f_color = o.color;
 140: v2f_diffuse = o.diffuse;
 141: v2f_light = o.light;
 142: 
 143: }

[14:02:46] [main/ERROR]: Shader compilation log for flywheel:block.frag: No errors.

[14:02:46] [main/ERROR]: Source for shader 'flywheel:block.frag':
   1: #version 110
   2: #define USE_FOG
   3: #define USE_FOG_LINEAR
   4: 
   5: #if defined(USE_FOG)
   6: varying float FragDistance;
   7: uniform vec4 uFogColor;
   8: #endif
   9: 
  10: #if defined(USE_FOG_LINEAR)
  11: uniform vec2 uFogRange;
  12: 
  13: float FLWFogFactor() {
  14:     return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
  15: }
  16:     #endif
  17: 
  18:     #if defined(USE_FOG_EXP2)
  19: uniform float uFogDensity;
  20: 
  21: float FLWFogFactor() {
  22:     float dist = FragDistance * uFogDensity;
  23:     return 1. / exp2(dist * dist);
  24: }
  25:     #endif
  26: // Adjust the [0,1] normalized lightmap value based on the texture matrix from LightTexture#enableLightmap
  27: vec2 shiftLight(vec2 lm) {
  28:     return lm * 0.99609375 + 0.03125;// * 255/256 + 1/32
  29: }
  30: 
  31: varying vec3 BoxCoord;
  32: varying vec2 BoxLight;
  33: uniform sampler3D uLightVolume;
  34: 
  35: uniform sampler2D uBlockAtlas;
  36: uniform sampler2D uLightMap;
  37: 
  38: vec4 FLWBlockTexture(vec2 texCoords) {
  39:     return texture2D(uBlockAtlas, texCoords);
  40: }
  41: 
  42: void FLWFinalizeColor(vec4 color) {
  43:     #if defined(USE_FOG)
  44:     float a = color.a;
  45:     float fog = clamp(FLWFogFactor(), 0., 1.);
  46: 
  47:     color = mix(uFogColor, color, fog);
  48:     color.a = a;
  49:     #endif
  50: 
  51:     gl_FragColor = color;
  52: }
  53: 
  54: vec4 FLWLight(vec2 lightCoords) {
  55:     lightCoords = max(lightCoords, texture3D(uLightVolume, BoxCoord).rg);
  56: 
  57:     return texture2D(uLightMap, shiftLight(lightCoords));
  58: }
  59: 
  60: 
  61: 
  62: struct BlockFrag {
  63:     vec2 texCoords;
  64:     vec4 color;
  65:     float diffuse;
  66:     vec2 light;
  67: };
  68: 
  69: void FLWMain(BlockFrag r) {
  70:     vec4 tex = FLWBlockTexture(r.texCoords);
  71: 
  72:     vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;
  73: 
  74: //    flw_WorldPos = ;
  75: //    flw_Normal = ;
  76: //    flw_Albedo = tex.rgb;
  77: //    flw_Alpha = tex.a;
  78: //    flw_LightMap = r.light;
  79: //    flw_Tint = r.color;
  80:     FLWFinalizeColor(color);
  81: }
  82: 
  83: varying vec2 v2f_texCoords;
  84: varying vec4 v2f_color;
  85: varying float v2f_diffuse;
  86: varying vec2 v2f_light;
  87: 
  88: 
  89: void main() {
  90:     BlockFrag f;
  91:     f.texCoords = v2f_texCoords;
  92: f.color = v2f_color;
  93: f.diffuse = v2f_diffuse;
  94: f.light = v2f_light;
  95: 
  96: 
  97:     FLWMain(f);
  98: }

[14:02:46] [main/ERROR]: Shader compilation log for create:contraption_structure.vert: No errors.

[14:02:46] [main/ERROR]: Source for shader 'create:contraption_structure.vert':
   1: #version 110
   2: #define USE_FOG
   3: #define USE_FOG_EXP2
   4: 
   5: #define PI 3.1415926538
   6: 
   7: #if defined(USE_FOG)
   8: varying float FragDistance;
   9: #endif
  10: 
  11: varying vec3 BoxCoord;
  12: 
  13: uniform vec3 uLightBoxSize;
  14: uniform vec3 uLightBoxMin;
  15: uniform mat4 uModel;
  16: 
  17: uniform float uTime;
  18: uniform mat4 uViewProjection;
  19: uniform vec3 uCameraPos;
  20: 
  21: void FLWFinalizeWorldPos(inout vec4 worldPos) {
  22:     worldPos = uModel * worldPos;
  23: 
  24:     BoxCoord = (worldPos.xyz - uLightBoxMin) / uLightBoxSize;
  25: 
  26:     #if defined(USE_FOG)
  27:     FragDistance = length(worldPos.xyz);
  28:     #endif
  29: 
  30:     gl_Position = uViewProjection * worldPos;
  31: }
  32: 
  33: void FLWFinalizeNormal(inout vec3 normal) {
  34:     mat3 m;
  35:     m[0] = uModel[0].xyz;
  36:     m[1] = uModel[1].xyz;
  37:     m[2] = uModel[2].xyz;
  38:     normal = m * normal;
  39: }
  40: 
  41: 
  42: 
  43: mat4 rotate(vec3 axis, float angle) {
  44:     float s = sin(angle);
  45:     float c = cos(angle);
  46:     float oc = 1. - c;
  47: 
  48:     vec3 sa = axis * s;
  49: 
  50:     mat4 mr = mat4(1.);
  51:     mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
  52:     mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
  53:     mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);
  54: 
  55:     return mr;
  56: }
  57: 
  58: mat4 rotation(vec3 rot) {
  59:     return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
  60: }
  61: 
  62: mat3 modelToNormal(mat4 mat) {
  63:     // Discard the edges. This won't be accurate for scaled or skewed matrices,
  64:     // but we don't have to work with those often.
  65:     mat3 m;
  66:     m[0] = mat[0].xyz;
  67:     m[1] = mat[1].xyz;
  68:     m[2] = mat[2].xyz;
  69:     return m;
  70: }
  71: 
  72: float diffuse(vec3 normal) {
  73:     vec3 n2 = normal * normal * vec3(.6, .25, .8);
  74:     return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
  75: }
  76: 
  77: 
  78: struct Vertex {
  79:     vec3 pos;
  80:     vec3 normal;
  81:     vec2 texCoords;
  82:     vec4 color;
  83:     vec2 modelLight;
  84: };
  85: 
  86: 
  87: struct BlockFrag {
  88:     vec2 texCoords;
  89:     vec4 color;
  90:     float diffuse;
  91:     vec2 light;
  92: };
  93: 
  94: BlockFrag FLWMain(Vertex v) {
  95:     vec4 worldPos = vec4(v.pos, 1.);
  96:     vec3 norm = v.normal;
  97: 
  98:     FLWFinalizeWorldPos(worldPos);
  99:     FLWFinalizeNormal(norm);
 100: 
 101:     BlockFrag b;
 102:     b.diffuse = diffuse(norm);
 103:     b.texCoords = v.texCoords;
 104:     b.light = v.modelLight;
 105: 
 106:     #if defined(DEBUG_NORMAL)
 107:     b.color = vec4(norm, 1.);
 108:     #else
 109:     b.color = vec4(v.color.rgb / diffuse(v.normal), v.color.a);
 110:     #endif
 111: 
 112:     return b;
 113: }
 114: attribute vec3 a_v_pos;
 115: attribute vec3 a_v_normal;
 116: attribute vec2 a_v_texCoords;
 117: attribute vec4 a_v_color;
 118: attribute vec2 a_v_modelLight;
 119: 
 120: 
 121: varying vec2 v2f_texCoords;
 122: varying vec4 v2f_color;
 123: varying float v2f_diffuse;
 124: varying vec2 v2f_light;
 125: 
 126: 
 127: void main() {
 128:     Vertex v;
 129:     v.pos = a_v_pos;
 130: v.normal = a_v_normal;
 131: v.texCoords = a_v_texCoords;
 132: v.color = a_v_color;
 133: v.modelLight = a_v_modelLight;
 134: 
 135: 
 136:     BlockFrag o = FLWMain(v);
 137: 
 138:     v2f_texCoords = o.texCoords;
 139: v2f_color = o.color;
 140: v2f_diffuse = o.diffuse;
 141: v2f_light = o.light;
 142: 
 143: }

[14:02:46] [main/ERROR]: Shader compilation log for flywheel:block.frag: No errors.

[14:02:46] [main/ERROR]: Source for shader 'flywheel:block.frag':
   1: #version 110
   2: #define USE_FOG
   3: #define USE_FOG_EXP2
   4: 
   5: #if defined(USE_FOG)
   6: varying float FragDistance;
   7: uniform vec4 uFogColor;
   8: #endif
   9: 
  10: #if defined(USE_FOG_LINEAR)
  11: uniform vec2 uFogRange;
  12: 
  13: float FLWFogFactor() {
  14:     return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
  15: }
  16:     #endif
  17: 
  18:     #if defined(USE_FOG_EXP2)
  19: uniform float uFogDensity;
  20: 
  21: float FLWFogFactor() {
  22:     float dist = FragDistance * uFogDensity;
  23:     return 1. / exp2(dist * dist);
  24: }
  25:     #endif
  26: // Adjust the [0,1] normalized lightmap value based on the texture matrix from LightTexture#enableLightmap
  27: vec2 shiftLight(vec2 lm) {
  28:     return lm * 0.99609375 + 0.03125;// * 255/256 + 1/32
  29: }
  30: 
  31: varying vec3 BoxCoord;
  32: varying vec2 BoxLight;
  33: uniform sampler3D uLightVolume;
  34: 
  35: uniform sampler2D uBlockAtlas;
  36: uniform sampler2D uLightMap;
  37: 
  38: vec4 FLWBlockTexture(vec2 texCoords) {
  39:     return texture2D(uBlockAtlas, texCoords);
  40: }
  41: 
  42: void FLWFinalizeColor(vec4 color) {
  43:     #if defined(USE_FOG)
  44:     float a = color.a;
  45:     float fog = clamp(FLWFogFactor(), 0., 1.);
  46: 
  47:     color = mix(uFogColor, color, fog);
  48:     color.a = a;
  49:     #endif
  50: 
  51:     gl_FragColor = color;
  52: }
  53: 
  54: vec4 FLWLight(vec2 lightCoords) {
  55:     lightCoords = max(lightCoords, texture3D(uLightVolume, BoxCoord).rg);
  56: 
  57:     return texture2D(uLightMap, shiftLight(lightCoords));
  58: }
  59: 
  60: 
  61: 
  62: struct BlockFrag {
  63:     vec2 texCoords;
  64:     vec4 color;
  65:     float diffuse;
  66:     vec2 light;
  67: };
  68: 
  69: void FLWMain(BlockFrag r) {
  70:     vec4 tex = FLWBlockTexture(r.texCoords);
  71: 
  72:     vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;
  73: 
  74: //    flw_WorldPos = ;
  75: //    flw_Normal = ;
  76: //    flw_Albedo = tex.rgb;
  77: //    flw_Alpha = tex.a;
  78: //    flw_LightMap = r.light;
  79: //    flw_Tint = r.color;
  80:     FLWFinalizeColor(color);
  81: }
  82: 
  83: varying vec2 v2f_texCoords;
  84: varying vec4 v2f_color;
  85: varying float v2f_diffuse;
  86: varying vec2 v2f_light;
  87: 
  88: 
  89: void main() {
  90:     BlockFrag f;
  91:     f.texCoords = v2f_texCoords;
  92: f.color = v2f_color;
  93: f.diffuse = v2f_diffuse;
  94: f.light = v2f_light;
  95: 
  96: 
  97:     FLWMain(f);
  98: }

[14:02:46] [main/ERROR]: Shader compilation log for create:contraption_structure.vert: No errors.

[14:02:46] [main/ERROR]: Source for shader 'create:contraption_structure.vert':
   1: #version 110
   2: 
   3: #define PI 3.1415926538
   4: 
   5: #if defined(USE_FOG)
   6: varying float FragDistance;
   7: #endif
   8: 
   9: varying vec3 BoxCoord;
  10: 
  11: uniform vec3 uLightBoxSize;
  12: uniform vec3 uLightBoxMin;
  13: uniform mat4 uModel;
  14: 
  15: uniform float uTime;
  16: uniform mat4 uViewProjection;
  17: uniform vec3 uCameraPos;
  18: 
  19: void FLWFinalizeWorldPos(inout vec4 worldPos) {
  20:     worldPos = uModel * worldPos;
  21: 
  22:     BoxCoord = (worldPos.xyz - uLightBoxMin) / uLightBoxSize;
  23: 
  24:     #if defined(USE_FOG)
  25:     FragDistance = length(worldPos.xyz);
  26:     #endif
  27: 
  28:     gl_Position = uViewProjection * worldPos;
  29: }
  30: 
  31: void FLWFinalizeNormal(inout vec3 normal) {
  32:     mat3 m;
  33:     m[0] = uModel[0].xyz;
  34:     m[1] = uModel[1].xyz;
  35:     m[2] = uModel[2].xyz;
  36:     normal = m * normal;
  37: }
  38: 
  39: 
  40: 
  41: mat4 rotate(vec3 axis, float angle) {
  42:     float s = sin(angle);
  43:     float c = cos(angle);
  44:     float oc = 1. - c;
  45: 
  46:     vec3 sa = axis * s;
  47: 
  48:     mat4 mr = mat4(1.);
  49:     mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
  50:     mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
  51:     mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);
  52: 
  53:     return mr;
  54: }
  55: 
  56: mat4 rotation(vec3 rot) {
  57:     return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
  58: }
  59: 
  60: mat3 modelToNormal(mat4 mat) {
  61:     // Discard the edges. This won't be accurate for scaled or skewed matrices,
  62:     // but we don't have to work with those often.
  63:     mat3 m;
  64:     m[0] = mat[0].xyz;
  65:     m[1] = mat[1].xyz;
  66:     m[2] = mat[2].xyz;
  67:     return m;
  68: }
  69: 
  70: float diffuse(vec3 normal) {
  71:     vec3 n2 = normal * normal * vec3(.6, .25, .8);
  72:     return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
  73: }
  74: 
  75: 
  76: struct Vertex {
  77:     vec3 pos;
  78:     vec3 normal;
  79:     vec2 texCoords;
  80:     vec4 color;
  81:     vec2 modelLight;
  82: };
  83: 
  84: 
  85: struct BlockFrag {
  86:     vec2 texCoords;
  87:     vec4 color;
  88:     float diffuse;
  89:     vec2 light;
  90: };
  91: 
  92: BlockFrag FLWMain(Vertex v) {
  93:     vec4 worldPos = vec4(v.pos, 1.);
  94:     vec3 norm = v.normal;
  95: 
  96:     FLWFinalizeWorldPos(worldPos);
  97:     FLWFinalizeNormal(norm);
  98: 
  99:     BlockFrag b;
 100:     b.diffuse = diffuse(norm);
 101:     b.texCoords = v.texCoords;
 102:     b.light = v.modelLight;
 103: 
 104:     #if defined(DEBUG_NORMAL)
 105:     b.color = vec4(norm, 1.);
 106:     #else
 107:     b.color = vec4(v.color.rgb / diffuse(v.normal), v.color.a);
 108:     #endif
 109: 
 110:     return b;
 111: }
 112: attribute vec3 a_v_pos;
 113: attribute vec3 a_v_normal;
 114: attribute vec2 a_v_texCoords;
 115: attribute vec4 a_v_color;
 116: attribute vec2 a_v_modelLight;
 117: 
 118: 
 119: varying vec2 v2f_texCoords;
 120: varying vec4 v2f_color;
 121: varying float v2f_diffuse;
 122: varying vec2 v2f_light;
 123: 
 124: 
 125: void main() {
 126:     Vertex v;
 127:     v.pos = a_v_pos;
 128: v.normal = a_v_normal;
 129: v.texCoords = a_v_texCoords;
 130: v.color = a_v_color;
 131: v.modelLight = a_v_modelLight;
 132: 
 133: 
 134:     BlockFrag o = FLWMain(v);
 135: 
 136:     v2f_texCoords = o.texCoords;
 137: v2f_color = o.color;
 138: v2f_diffuse = o.diffuse;
 139: v2f_light = o.light;
 140: 
 141: }

[14:02:46] [main/ERROR]: Shader compilation log for flywheel:block.frag: No errors.

[14:02:46] [main/ERROR]: Source for shader 'flywheel:block.frag':
   1: #version 110
   2: 
   3: #if defined(USE_FOG)
   4: varying float FragDistance;
   5: uniform vec4 uFogColor;
   6: #endif
   7: 
   8: #if defined(USE_FOG_LINEAR)
   9: uniform vec2 uFogRange;
  10: 
  11: float FLWFogFactor() {
  12:     return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
  13: }
  14:     #endif
  15: 
  16:     #if defined(USE_FOG_EXP2)
  17: uniform float uFogDensity;
  18: 
  19: float FLWFogFactor() {
  20:     float dist = FragDistance * uFogDensity;
  21:     return 1. / exp2(dist * dist);
  22: }
  23:     #endif
  24: // Adjust the [0,1] normalized lightmap value based on the texture matrix from LightTexture#enableLightmap
  25: vec2 shiftLight(vec2 lm) {
  26:     return lm * 0.99609375 + 0.03125;// * 255/256 + 1/32
  27: }
  28: 
  29: varying vec3 BoxCoord;
  30: varying vec2 BoxLight;
  31: uniform sampler3D uLightVolume;
  32: 
  33: uniform sampler2D uBlockAtlas;
  34: uniform sampler2D uLightMap;
  35: 
  36: vec4 FLWBlockTexture(vec2 texCoords) {
  37:     return texture2D(uBlockAtlas, texCoords);
  38: }
  39: 
  40: void FLWFinalizeColor(vec4 color) {
  41:     #if defined(USE_FOG)
  42:     float a = color.a;
  43:     float fog = clamp(FLWFogFactor(), 0., 1.);
  44: 
  45:     color = mix(uFogColor, color, fog);
  46:     color.a = a;
  47:     #endif
  48: 
  49:     gl_FragColor = color;
  50: }
  51: 
  52: vec4 FLWLight(vec2 lightCoords) {
  53:     lightCoords = max(lightCoords, texture3D(uLightVolume, BoxCoord).rg);
  54: 
  55:     return texture2D(uLightMap, shiftLight(lightCoords));
  56: }
  57: 
  58: 
  59: 
  60: struct BlockFrag {
  61:     vec2 texCoords;
  62:     vec4 color;
  63:     float diffuse;
  64:     vec2 light;
  65: };
  66: 
  67: void FLWMain(BlockFrag r) {
  68:     vec4 tex = FLWBlockTexture(r.texCoords);
  69: 
  70:     vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;
  71: 
  72: //    flw_WorldPos = ;
  73: //    flw_Normal = ;
  74: //    flw_Albedo = tex.rgb;
  75: //    flw_Alpha = tex.a;
  76: //    flw_LightMap = r.light;
  77: //    flw_Tint = r.color;
  78:     FLWFinalizeColor(color);
  79: }
  80: 
  81: varying vec2 v2f_texCoords;
  82: varying vec4 v2f_color;
  83: varying float v2f_diffuse;
  84: varying vec2 v2f_light;
  85: 
  86: 
  87: void main() {
  88:     BlockFrag f;
  89:     f.texCoords = v2f_texCoords;
  90: f.color = v2f_color;
  91: f.diffuse = v2f_diffuse;
  92: f.light = v2f_light;
  93: 
  94: 
  95:     FLWMain(f);
  96: }

[14:02:46] [main/INFO]: Loading context 'flywheel:context/crumbling'
[14:02:46] [main/ERROR]: Shader compilation log for create:rotating.vert: No errors.

[14:02:46] [main/ERROR]: Source for shader 'create:rotating.vert':
   1: #version 110
   2: #define DEBUG_RAINBOW
   3: 
   4: #define PI 3.1415926538
   5: 
   6: uniform float uTime;
   7: uniform mat4 uViewProjection;
   8: uniform vec3 uCameraPos;
   9: 
  10: #if defined(USE_FOG)
  11: varying float FragDistance;
  12: #endif
  13: 
  14: void FLWFinalizeWorldPos(inout vec4 worldPos) {
  15:     #if defined(USE_FOG)
  16:     FragDistance = length(worldPos.xyz - uCameraPos);
  17:     #endif
  18: 
  19:     gl_Position = uViewProjection * worldPos;
  20: }
  21: 
  22: void FLWFinalizeNormal(inout vec3 normal) {
  23:     // noop
  24: }
  25: 
  26: 
  27: mat4 rotate(vec3 axis, float angle) {
  28:     float s = sin(angle);
  29:     float c = cos(angle);
  30:     float oc = 1. - c;
  31: 
  32:     vec3 sa = axis * s;
  33: 
  34:     mat4 mr = mat4(1.);
  35:     mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
  36:     mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
  37:     mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);
  38: 
  39:     return mr;
  40: }
  41: 
  42: mat4 rotation(vec3 rot) {
  43:     return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
  44: }
  45: 
  46: mat3 modelToNormal(mat4 mat) {
  47:     // Discard the edges. This won't be accurate for scaled or skewed matrices,
  48:     // but we don't have to work with those often.
  49:     mat3 m;
  50:     m[0] = mat[0].xyz;
  51:     m[1] = mat[1].xyz;
  52:     m[2] = mat[2].xyz;
  53:     return m;
  54: }
  55: 
  56: float diffuse(vec3 normal) {
  57:     vec3 n2 = normal * normal * vec3(.6, .25, .8);
  58:     return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
  59: }
  60: 
  61: 
  62: struct Rotating {
  63:     vec2 light;
  64:     vec4 color;
  65:     vec3 pos;
  66:     float speed;
  67:     float offset;
  68:     vec3 axis;
  69: };
  70: 
  71: 
  72: struct Vertex {
  73:     vec3 pos;
  74:     vec3 normal;
  75:     vec2 texCoords;
  76: };
  77: 
  78: struct BlockFrag {
  79:     vec2 texCoords;
  80:     vec4 color;
  81:     float diffuse;
  82:     vec2 light;
  83: };
  84: 
  85: mat4 kineticRotation(float offset, float speed, vec3 axis) {
  86:     float degrees = offset + uTime * speed * 3./10.;
  87:     float angle = fract(degrees / 360.) * PI * 2.;
  88: 
  89:     return rotate(axis, angle);
  90: }
  91: 
  92: BlockFrag FLWMain(Vertex v, Rotating instance) {
  93:     mat4 spin = kineticRotation(instance.offset, instance.speed, instance.axis);
  94: 
  95:     vec4 worldPos = spin * vec4(v.pos - .5, 1.);
  96:     worldPos += vec4(instance.pos + .5, 0.);
  97: 
  98:     vec3 norm = modelToNormal(spin) * v.normal;
  99: 
 100:     FLWFinalizeWorldPos(worldPos);
 101:     FLWFinalizeNormal(norm);
 102: 
 103:     BlockFrag b;
 104:     b.diffuse = diffuse(norm);
 105:     b.texCoords = v.texCoords;
 106:     b.light = instance.light;
 107: 
 108:     #if defined(DEBUG_RAINBOW)
 109:     b.color = instance.color;
 110:     #elif defined(DEBUG_NORMAL)
 111:     b.color = vec4(norm, 1.);
 112:     #else
 113:     b.color = vec4(1.);
 114:     #endif
 115: 
 116:     return b;
 117: }
 118: attribute vec3 a_v_pos;
 119: attribute vec3 a_v_normal;
 120: attribute vec2 a_v_texCoords;
 121: 
 122: attribute vec2 a_i_light;
 123: attribute vec4 a_i_color;
 124: attribute vec3 a_i_pos;
 125: attribute float a_i_speed;
 126: attribute float a_i_offset;
 127: attribute vec3 a_i_axis;
 128: 
 129: 
 130: varying vec2 v2f_texCoords;
 131: varying vec4 v2f_color;
 132: varying float v2f_diffuse;
 133: varying vec2 v2f_light;
 134: 
 135: 
 136: void main() {
 137:     Vertex v;
 138:     v.pos = a_v_pos;
 139: v.normal = a_v_normal;
 140: v.texCoords = a_v_texCoords;
 141: 
 142: 
 143:     Rotating i;
 144:     i.light = a_i_light;
 145: i.color = a_i_color;
 146: i.pos = a_i_pos;
 147: i.speed = a_i_speed;
 148: i.offset = a_i_offset;
 149: i.axis = a_i_axis;
 150: 
 151: 
 152:     BlockFrag o = FLWMain(v, i);
 153: 
 154:     v2f_texCoords = o.texCoords;
 155: v2f_color = o.color;
 156: v2f_diffuse = o.diffuse;
 157: v2f_light = o.light;
 158: 
 159: }

[14:02:46] [main/ERROR]: Shader compilation log for flywheel:block.frag: No errors.

[14:02:46] [main/ERROR]: Source for shader 'flywheel:block.frag':
   1: #version 110
   2: #define DEBUG_RAINBOW
   3: 
   4: #if defined(USE_FOG)
   5: varying float FragDistance;
   6: uniform vec4 uFogColor;
   7: #endif
   8: 
   9: #if defined(USE_FOG_LINEAR)
  10: uniform vec2 uFogRange;
  11: 
  12: float FLWFogFactor() {
  13:     return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
  14: }
  15:     #endif
  16: 
  17:     #if defined(USE_FOG_EXP2)
  18: uniform float uFogDensity;
  19: 
  20: float FLWFogFactor() {
  21:     float dist = FragDistance * uFogDensity;
  22:     return 1. / exp2(dist * dist);
  23: }
  24:     #endif
  25: 
  26: uniform vec2 uTextureScale;
  27: uniform sampler2D uBlockAtlas;
  28: uniform sampler2D uLightMap;
  29: uniform sampler2D uCrumbling;
  30: 
  31: vec4 FLWBlockTexture(vec2 texCoords) {
  32:     vec4 cr = texture2D(uCrumbling, texCoords * uTextureScale);
  33:     float diffuseAlpha = texture2D(uBlockAtlas, texCoords).a;
  34:     cr.a = cr.a * diffuseAlpha;
  35:     return cr;
  36: }
  37: 
  38: void FLWFinalizeColor(vec4 color) {
  39:     #if defined(USE_FOG)
  40:     float a = color.a;
  41:     float fog = clamp(FLWFogFactor(), 0., 1.);
  42: 
  43:     color = mix(uFogColor, color, fog);
  44:     color.a = a;
  45:     #endif
  46: 
  47:     gl_FragColor = color;
  48: }
  49: 
  50: vec4 FLWLight(vec2 lightCoords) {
  51:     return vec4(1.);
  52: }
  53: 
  54: 
  55: 
  56: struct BlockFrag {
  57:     vec2 texCoords;
  58:     vec4 color;
  59:     float diffuse;
  60:     vec2 light;
  61: };
  62: 
  63: void FLWMain(BlockFrag r) {
  64:     vec4 tex = FLWBlockTexture(r.texCoords);
  65: 
  66:     vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;
  67: 
  68: //    flw_WorldPos = ;
  69: //    flw_Normal = ;
  70: //    flw_Albedo = tex.rgb;
  71: //    flw_Alpha = tex.a;
  72: //    flw_LightMap = r.light;
  73: //    flw_Tint = r.color;
  74:     FLWFinalizeColor(color);
  75: }
  76: 
  77: varying vec2 v2f_texCoords;
  78: varying vec4 v2f_color;
  79: varying float v2f_diffuse;
  80: varying vec2 v2f_light;
  81: 
  82: 
  83: //vec3 flw_WorldPos;
  84: //vec3 flw_Normal;
  85: //vec3 flw_Albedo;
  86: //float flw_Alpha;
  87: //vec2 flw_LightMap;
  88: //vec4 flw_Tint;
  89: 
  90: void main() {
  91:     BlockFrag f;
  92:     f.texCoords = v2f_texCoords;
  93: f.color = v2f_color;
  94: f.diffuse = v2f_diffuse;
  95: f.light = v2f_light;
  96: 
  97: 
  98:     FLWMain(f);
  99: }

[14:02:46] [main/ERROR]: Shader compilation log for create:rotating.vert: No errors.

[14:02:46] [main/ERROR]: Source for shader 'create:rotating.vert':
   1: #version 110
   2: #define DEBUG_NORMAL
   3: 
   4: #define PI 3.1415926538
   5: 
   6: uniform float uTime;
   7: uniform mat4 uViewProjection;
   8: uniform vec3 uCameraPos;
   9: 
  10: #if defined(USE_FOG)
  11: varying float FragDistance;
  12: #endif
  13: 
  14: void FLWFinalizeWorldPos(inout vec4 worldPos) {
  15:     #if defined(USE_FOG)
  16:     FragDistance = length(worldPos.xyz - uCameraPos);
  17:     #endif
  18: 
  19:     gl_Position = uViewProjection * worldPos;
  20: }
  21: 
  22: void FLWFinalizeNormal(inout vec3 normal) {
  23:     // noop
  24: }
  25: 
  26: 
  27: mat4 rotate(vec3 axis, float angle) {
  28:     float s = sin(angle);
  29:     float c = cos(angle);
  30:     float oc = 1. - c;
  31: 
  32:     vec3 sa = axis * s;
  33: 
  34:     mat4 mr = mat4(1.);
  35:     mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
  36:     mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
  37:     mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);
  38: 
  39:     return mr;
  40: }
  41: 
  42: mat4 rotation(vec3 rot) {
  43:     return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
  44: }
  45: 
  46: mat3 modelToNormal(mat4 mat) {
  47:     // Discard the edges. This won't be accurate for scaled or skewed matrices,
  48:     // but we don't have to work with those often.
  49:     mat3 m;
  50:     m[0] = mat[0].xyz;
  51:     m[1] = mat[1].xyz;
  52:     m[2] = mat[2].xyz;
  53:     return m;
  54: }
  55: 
  56: float diffuse(vec3 normal) {
  57:     vec3 n2 = normal * normal * vec3(.6, .25, .8);
  58:     return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
  59: }
  60: 
  61: 
  62: struct Rotating {
  63:     vec2 light;
  64:     vec4 color;
  65:     vec3 pos;
  66:     float speed;
  67:     float offset;
  68:     vec3 axis;
  69: };
  70: 
  71: 
  72: struct Vertex {
  73:     vec3 pos;
  74:     vec3 normal;
  75:     vec2 texCoords;
  76: };
  77: 
  78: struct BlockFrag {
  79:     vec2 texCoords;
  80:     vec4 color;
  81:     float diffuse;
  82:     vec2 light;
  83: };
  84: 
  85: mat4 kineticRotation(float offset, float speed, vec3 axis) {
  86:     float degrees = offset + uTime * speed * 3./10.;
  87:     float angle = fract(degrees / 360.) * PI * 2.;
  88: 
  89:     return rotate(axis, angle);
  90: }
  91: 
  92: BlockFrag FLWMain(Vertex v, Rotating instance) {
  93:     mat4 spin = kineticRotation(instance.offset, instance.speed, instance.axis);
  94: 
  95:     vec4 worldPos = spin * vec4(v.pos - .5, 1.);
  96:     worldPos += vec4(instance.pos + .5, 0.);
  97: 
  98:     vec3 norm = modelToNormal(spin) * v.normal;
  99: 
 100:     FLWFinalizeWorldPos(worldPos);
 101:     FLWFinalizeNormal(norm);
 102: 
 103:     BlockFrag b;
 104:     b.diffuse = diffuse(norm);
 105:     b.texCoords = v.texCoords;
 106:     b.light = instance.light;
 107: 
 108:     #if defined(DEBUG_RAINBOW)
 109:     b.color = instance.color;
 110:     #elif defined(DEBUG_NORMAL)
 111:     b.color = vec4(norm, 1.);
 112:     #else
 113:     b.color = vec4(1.);
 114:     #endif
 115: 
 116:     return b;
 117: }
 118: attribute vec3 a_v_pos;
 119: attribute vec3 a_v_normal;
 120: attribute vec2 a_v_texCoords;
 121: 
 122: attribute vec2 a_i_light;
 123: attribute vec4 a_i_color;
 124: attribute vec3 a_i_pos;
 125: attribute float a_i_speed;
 126: attribute float a_i_offset;
 127: attribute vec3 a_i_axis;
 128: 
 129: 
 130: varying vec2 v2f_texCoords;
 131: varying vec4 v2f_color;
 132: varying float v2f_diffuse;
 133: varying vec2 v2f_light;
 134: 
 135: 
 136: void main() {
 137:     Vertex v;
 138:     v.pos = a_v_pos;
 139: v.normal = a_v_normal;
 140: v.texCoords = a_v_texCoords;
 141: 
 142: 
 143:     Rotating i;
 144:     i.light = a_i_light;
 145: i.color = a_i_color;
 146: i.pos = a_i_pos;
 147: i.speed = a_i_speed;
 148: i.offset = a_i_offset;
 149: i.axis = a_i_axis;
 150: 
 151: 
 152:     BlockFrag o = FLWMain(v, i);
 153: 
 154:     v2f_texCoords = o.texCoords;
 155: v2f_color = o.color;
 156: v2f_diffuse = o.diffuse;
 157: v2f_light = o.light;
 158: 
 159: }

[14:02:46] [main/ERROR]: Shader compilation log for flywheel:block.frag: No errors.

[14:02:46] [main/ERROR]: Source for shader 'flywheel:block.frag':
   1: #version 110
   2: #define DEBUG_NORMAL
   3: 
   4: #if defined(USE_FOG)
   5: varying float FragDistance;
   6: uniform vec4 uFogColor;
   7: #endif
   8: 
   9: #if defined(USE_FOG_LINEAR)
  10: uniform vec2 uFogRange;
  11: 
  12: float FLWFogFactor() {
  13:     return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
  14: }
  15:     #endif
  16: 
  17:     #if defined(USE_FOG_EXP2)
  18: uniform float uFogDensity;
  19: 
  20: float FLWFogFactor() {
  21:     float dist = FragDistance * uFogDensity;
  22:     return 1. / exp2(dist * dist);
  23: }
  24:     #endif
  25: 
  26: uniform vec2 uTextureScale;
  27: uniform sampler2D uBlockAtlas;
  28: uniform sampler2D uLightMap;
  29: uniform sampler2D uCrumbling;
  30: 
  31: vec4 FLWBlockTexture(vec2 texCoords) {
  32:     vec4 cr = texture2D(uCrumbling, texCoords * uTextureScale);
  33:     float diffuseAlpha = texture2D(uBlockAtlas, texCoords).a;
  34:     cr.a = cr.a * diffuseAlpha;
  35:     return cr;
  36: }
  37: 
  38: void FLWFinalizeColor(vec4 color) {
  39:     #if defined(USE_FOG)
  40:     float a = color.a;
  41:     float fog = clamp(FLWFogFactor(), 0., 1.);
  42: 
  43:     color = mix(uFogColor, color, fog);
  44:     color.a = a;
  45:     #endif
  46: 
  47:     gl_FragColor = color;
  48: }
  49: 
  50: vec4 FLWLight(vec2 lightCoords) {
  51:     return vec4(1.);
  52: }
  53: 
  54: 
  55: 
  56: struct BlockFrag {
  57:     vec2 texCoords;
  58:     vec4 color;
  59:     float diffuse;
  60:     vec2 light;
  61: };
  62: 
  63: void FLWMain(BlockFrag r) {
  64:     vec4 tex = FLWBlockTexture(r.texCoords);
  65: 
  66:     vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;
  67: 
  68: //    flw_WorldPos = ;
  69: //    flw_Normal = ;
  70: //    flw_Albedo = tex.rgb;
  71: //    flw_Alpha = tex.a;
  72: //    flw_LightMap = r.light;
  73: //    flw_Tint = r.color;
  74:     FLWFinalizeColor(color);
  75: }
  76: 
  77: varying vec2 v2f_texCoords;
  78: varying vec4 v2f_color;
  79: varying float v2f_diffuse;
  80: varying vec2 v2f_light;
  81: 
  82: 
  83: //vec3 flw_WorldPos;
  84: //vec3 flw_Normal;
  85: //vec3 flw_Albedo;
  86: //float flw_Alpha;
  87: //vec2 flw_LightMap;
  88: //vec4 flw_Tint;
  89: 
  90: void main() {
  91:     BlockFrag f;
  92:     f.texCoords = v2f_texCoords;
  93: f.color = v2f_color;
  94: f.diffuse = v2f_diffuse;
  95: f.light = v2f_light;
  96: 
  97: 
  98:     FLWMain(f);
  99: }

[14:02:46] [main/ERROR]: Shader compilation log for create:rotating.vert: No errors.

[14:02:46] [main/ERROR]: Source for shader 'create:rotating.vert':
   1: #version 110
   2: #define USE_FOG
   3: #define USE_FOG_LINEAR
   4: 
   5: #define PI 3.1415926538
   6: 
   7: uniform float uTime;
   8: uniform mat4 uViewProjection;
   9: uniform vec3 uCameraPos;
  10: 
  11: #if defined(USE_FOG)
  12: varying float FragDistance;
  13: #endif
  14: 
  15: void FLWFinalizeWorldPos(inout vec4 worldPos) {
  16:     #if defined(USE_FOG)
  17:     FragDistance = length(worldPos.xyz - uCameraPos);
  18:     #endif
  19: 
  20:     gl_Position = uViewProjection * worldPos;
  21: }
  22: 
  23: void FLWFinalizeNormal(inout vec3 normal) {
  24:     // noop
  25: }
  26: 
  27: 
  28: mat4 rotate(vec3 axis, float angle) {
  29:     float s = sin(angle);
  30:     float c = cos(angle);
  31:     float oc = 1. - c;
  32: 
  33:     vec3 sa = axis * s;
  34: 
  35:     mat4 mr = mat4(1.);
  36:     mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
  37:     mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
  38:     mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);
  39: 
  40:     return mr;
  41: }
  42: 
  43: mat4 rotation(vec3 rot) {
  44:     return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
  45: }
  46: 
  47: mat3 modelToNormal(mat4 mat) {
  48:     // Discard the edges. This won't be accurate for scaled or skewed matrices,
  49:     // but we don't have to work with those often.
  50:     mat3 m;
  51:     m[0] = mat[0].xyz;
  52:     m[1] = mat[1].xyz;
  53:     m[2] = mat[2].xyz;
  54:     return m;
  55: }
  56: 
  57: float diffuse(vec3 normal) {
  58:     vec3 n2 = normal * normal * vec3(.6, .25, .8);
  59:     return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
  60: }
  61: 
  62: 
  63: struct Rotating {
  64:     vec2 light;
  65:     vec4 color;
  66:     vec3 pos;
  67:     float speed;
  68:     float offset;
  69:     vec3 axis;
  70: };
  71: 
  72: 
  73: struct Vertex {
  74:     vec3 pos;
  75:     vec3 normal;
  76:     vec2 texCoords;
  77: };
  78: 
  79: struct BlockFrag {
  80:     vec2 texCoords;
  81:     vec4 color;
  82:     float diffuse;
  83:     vec2 light;
  84: };
  85: 
  86: mat4 kineticRotation(float offset, float speed, vec3 axis) {
  87:     float degrees = offset + uTime * speed * 3./10.;
  88:     float angle = fract(degrees / 360.) * PI * 2.;
  89: 
  90:     return rotate(axis, angle);
  91: }
  92: 
  93: BlockFrag FLWMain(Vertex v, Rotating instance) {
  94:     mat4 spin = kineticRotation(instance.offset, instance.speed, instance.axis);
  95: 
  96:     vec4 worldPos = spin * vec4(v.pos - .5, 1.);
  97:     worldPos += vec4(instance.pos + .5, 0.);
  98: 
  99:     vec3 norm = modelToNormal(spin) * v.normal;
 100: 
 101:     FLWFinalizeWorldPos(worldPos);
 102:     FLWFinalizeNormal(norm);
 103: 
 104:     BlockFrag b;
 105:     b.diffuse = diffuse(norm);
 106:     b.texCoords = v.texCoords;
 107:     b.light = instance.light;
 108: 
 109:     #if defined(DEBUG_RAINBOW)
 110:     b.color = instance.color;
 111:     #elif defined(DEBUG_NORMAL)
 112:     b.color = vec4(norm, 1.);
 113:     #else
 114:     b.color = vec4(1.);
 115:     #endif
 116: 
 117:     return b;
 118: }
 119: attribute vec3 a_v_pos;
 120: attribute vec3 a_v_normal;
 121: attribute vec2 a_v_texCoords;
 122: 
 123: attribute vec2 a_i_light;
 124: attribute vec4 a_i_color;
 125: attribute vec3 a_i_pos;
 126: attribute float a_i_speed;
 127: attribute float a_i_offset;
 128: attribute vec3 a_i_axis;
 129: 
 130: 
 131: varying vec2 v2f_texCoords;
 132: varying vec4 v2f_color;
 133: varying float v2f_diffuse;
 134: varying vec2 v2f_light;
 135: 
 136: 
 137: void main() {
 138:     Vertex v;
 139:     v.pos = a_v_pos;
 140: v.normal = a_v_normal;
 141: v.texCoords = a_v_texCoords;
 142: 
 143: 
 144:     Rotating i;
 145:     i.light = a_i_light;
 146: i.color = a_i_color;
 147: i.pos = a_i_pos;
 148: i.speed = a_i_speed;
 149: i.offset = a_i_offset;
 150: i.axis = a_i_axis;
 151: 
 152: 
 153:     BlockFrag o = FLWMain(v, i);
 154: 
 155:     v2f_texCoords = o.texCoords;
 156: v2f_color = o.color;
 157: v2f_diffuse = o.diffuse;
 158: v2f_light = o.light;
 159: 
 160: }

[14:02:46] [main/ERROR]: Shader compilation log for flywheel:block.frag: No errors.

[14:02:46] [main/ERROR]: Source for shader 'flywheel:block.frag':
   1: #version 110
   2: #define USE_FOG
   3: #define USE_FOG_LINEAR
   4: 
   5: #if defined(USE_FOG)
   6: varying float FragDistance;
   7: uniform vec4 uFogColor;
   8: #endif
   9: 
  10: #if defined(USE_FOG_LINEAR)
  11: uniform vec2 uFogRange;
  12: 
  13: float FLWFogFactor() {
  14:     return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
  15: }
  16:     #endif
  17: 
  18:     #if defined(USE_FOG_EXP2)
  19: uniform float uFogDensity;
  20: 
  21: float FLWFogFactor() {
  22:     float dist = FragDistance * uFogDensity;
  23:     return 1. / exp2(dist * dist);
  24: }
  25:     #endif
  26: 
  27: uniform vec2 uTextureScale;
  28: uniform sampler2D uBlockAtlas;
  29: uniform sampler2D uLightMap;
  30: uniform sampler2D uCrumbling;
  31: 
  32: vec4 FLWBlockTexture(vec2 texCoords) {
  33:     vec4 cr = texture2D(uCrumbling, texCoords * uTextureScale);
  34:     float diffuseAlpha = texture2D(uBlockAtlas, texCoords).a;
  35:     cr.a = cr.a * diffuseAlpha;
  36:     return cr;
  37: }
  38: 
  39: void FLWFinalizeColor(vec4 color) {
  40:     #if defined(USE_FOG)
  41:     float a = color.a;
  42:     float fog = clamp(FLWFogFactor(), 0., 1.);
  43: 
  44:     color = mix(uFogColor, color, fog);
  45:     color.a = a;
  46:     #endif
  47: 
  48:     gl_FragColor = color;
  49: }
  50: 
  51: vec4 FLWLight(vec2 lightCoords) {
  52:     return vec4(1.);
  53: }
  54: 
  55: 
  56: 
  57: struct BlockFrag {
  58:     vec2 texCoords;
  59:     vec4 color;
  60:     float diffuse;
  61:     vec2 light;
  62: };
  63: 
  64: void FLWMain(BlockFrag r) {
  65:     vec4 tex = FLWBlockTexture(r.texCoords);
  66: 
  67:     vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;
  68: 
  69: //    flw_WorldPos = ;
  70: //    flw_Normal = ;
  71: //    flw_Albedo = tex.rgb;
  72: //    flw_Alpha = tex.a;
  73: //    flw_LightMap = r.light;
  74: //    flw_Tint = r.color;
  75:     FLWFinalizeColor(color);
  76: }
  77: 
  78: varying vec2 v2f_texCoords;
  79: varying vec4 v2f_color;
  80: varying float v2f_diffuse;
  81: varying vec2 v2f_light;
  82: 
  83: 
  84: //vec3 flw_WorldPos;
  85: //vec3 flw_Normal;
  86: //vec3 flw_Albedo;
  87: //float flw_Alpha;
  88: //vec2 flw_LightMap;
  89: //vec4 flw_Tint;
  90: 
  91: void main() {
  92:     BlockFrag f;
  93:     f.texCoords = v2f_texCoords;
  94: f.color = v2f_color;
  95: f.diffuse = v2f_diffuse;
  96: f.light = v2f_light;
  97: 
  98: 
  99:     FLWMain(f);
 100: }

[14:02:46] [main/ERROR]: Shader compilation log for create:rotating.vert: No errors.

[14:02:46] [main/ERROR]: Source for shader 'create:rotating.vert':
   1: #version 110
   2: #define USE_FOG
   3: #define USE_FOG_EXP2
   4: 
   5: #define PI 3.1415926538
   6: 
   7: uniform float uTime;
   8: uniform mat4 uViewProjection;
   9: uniform vec3 uCameraPos;
  10: 
  11: #if defined(USE_FOG)
  12: varying float FragDistance;
  13: #endif
  14: 
  15: void FLWFinalizeWorldPos(inout vec4 worldPos) {
  16:     #if defined(USE_FOG)
  17:     FragDistance = length(worldPos.xyz - uCameraPos);
  18:     #endif
  19: 
  20:     gl_Position = uViewProjection * worldPos;
  21: }
  22: 
  23: void FLWFinalizeNormal(inout vec3 normal) {
  24:     // noop
  25: }
  26: 
  27: 
  28: mat4 rotate(vec3 axis, float angle) {
  29:     float s = sin(angle);
  30:     float c = cos(angle);
  31:     float oc = 1. - c;
  32: 
  33:     vec3 sa = axis * s;
  34: 
  35:     mat4 mr = mat4(1.);
  36:     mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
  37:     mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
  38:     mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);
  39: 
  40:     return mr;
  41: }
  42: 
  43: mat4 rotation(vec3 rot) {
  44:     return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
  45: }
  46: 
  47: mat3 modelToNormal(mat4 mat) {
  48:     // Discard the edges. This won't be accurate for scaled or skewed matrices,
  49:     // but we don't have to work with those often.
  50:     mat3 m;
  51:     m[0] = mat[0].xyz;
  52:     m[1] = mat[1].xyz;
  53:     m[2] = mat[2].xyz;
  54:     return m;
  55: }
  56: 
  57: float diffuse(vec3 normal) {
  58:     vec3 n2 = normal * normal * vec3(.6, .25, .8);
  59:     return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
  60: }
  61: 
  62: 
  63: struct Rotating {
  64:     vec2 light;
  65:     vec4 color;
  66:     vec3 pos;
  67:     float speed;
  68:     float offset;
  69:     vec3 axis;
  70: };
  71: 
  72: 
  73: struct Vertex {
  74:     vec3 pos;
  75:     vec3 normal;
  76:     vec2 texCoords;
  77: };
  78: 
  79: struct BlockFrag {
  80:     vec2 texCoords;
  81:     vec4 color;
  82:     float diffuse;
  83:     vec2 light;
  84: };
  85: 
  86: mat4 kineticRotation(float offset, float speed, vec3 axis) {
  87:     float degrees = offset + uTime * speed * 3./10.;
  88:     float angle = fract(degrees / 360.) * PI * 2.;
  89: 
  90:     return rotate(axis, angle);
  91: }
  92: 
  93: BlockFrag FLWMain(Vertex v, Rotating instance) {
  94:     mat4 spin = kineticRotation(instance.offset, instance.speed, instance.axis);
  95: 
  96:     vec4 worldPos = spin * vec4(v.pos - .5, 1.);
  97:     worldPos += vec4(instance.pos + .5, 0.);
  98: 
  99:     vec3 norm = modelToNormal(spin) * v.normal;
 100: 
 101:     FLWFinalizeWorldPos(worldPos);
 102:     FLWFinalizeNormal(norm);
 103: 
 104:     BlockFrag b;
 105:     b.diffuse = diffuse(norm);
 106:     b.texCoords = v.texCoords;
 107:     b.light = instance.light;
 108: 
 109:     #if defined(DEBUG_RAINBOW)
 110:     b.color = instance.color;
 111:     #elif defined(DEBUG_NORMAL)
 112:     b.color = vec4(norm, 1.);
 113:     #else
 114:     b.color = vec4(1.);
 115:     #endif
 116: 
 117:     return b;
 118: }
 119: attribute vec3 a_v_pos;
 120: attribute vec3 a_v_normal;
 121: attribute vec2 a_v_texCoords;
 122: 
 123: attribute vec2 a_i_light;
 124: attribute vec4 a_i_color;
 125: attribute vec3 a_i_pos;
 126: attribute float a_i_speed;
 127: attribute float a_i_offset;
 128: attribute vec3 a_i_axis;
 129: 
 130: 
 131: varying vec2 v2f_texCoords;
 132: varying vec4 v2f_color;
 133: varying float v2f_diffuse;
 134: varying vec2 v2f_light;
 135: 
 136: 
 137: void main() {
 138:     Vertex v;
 139:     v.pos = a_v_pos;
 140: v.normal = a_v_normal;
 141: v.texCoords = a_v_texCoords;
 142: 
 143: 
 144:     Rotating i;
 145:     i.light = a_i_light;
 146: i.color = a_i_color;
 147: i.pos = a_i_pos;
 148: i.speed = a_i_speed;
 149: i.offset = a_i_offset;
 150: i.axis = a_i_axis;
 151: 
 152: 
 153:     BlockFrag o = FLWMain(v, i);
 154: 
 155:     v2f_texCoords = o.texCoords;
 156: v2f_color = o.color;
 157: v2f_diffuse = o.diffuse;
 158: v2f_light = o.light;
 159: 
 160: }

[14:02:46] [main/ERROR]: Shader compilation log for flywheel:block.frag: No errors.

[14:02:46] [main/ERROR]: Source for shader 'flywheel:block.frag':
   1: #version 110
   2: #define USE_FOG
   3: #define USE_FOG_EXP2
   4: 
   5: #if defined(USE_FOG)
   6: varying float FragDistance;
   7: uniform vec4 uFogColor;
   8: #endif
   9: 
  10: #if defined(USE_FOG_LINEAR)
  11: uniform vec2 uFogRange;
  12: 
  13: float FLWFogFactor() {
  14:     return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
  15: }
  16:     #endif
  17: 
  18:     #if defined(USE_FOG_EXP2)
  19: uniform float uFogDensity;
  20: 
  21: float FLWFogFactor() {
  22:     float dist = FragDistance * uFogDensity;
  23:     return 1. / exp2(dist * dist);
  24: }
  25:     #endif
  26: 
  27: uniform vec2 uTextureScale;
  28: uniform sampler2D uBlockAtlas;
  29: uniform sampler2D uLightMap;
  30: uniform sampler2D uCrumbling;
  31: 
  32: vec4 FLWBlockTexture(vec2 texCoords) {
  33:     vec4 cr = texture2D(uCrumbling, texCoords * uTextureScale);
  34:     float diffuseAlpha = texture2D(uBlockAtlas, texCoords).a;
  35:     cr.a = cr.a * diffuseAlpha;
  36:     return cr;
  37: }
  38: 
  39: void FLWFinalizeColor(vec4 color) {
  40:     #if defined(USE_FOG)
  41:     float a = color.a;
  42:     float fog = clamp(FLWFogFactor(), 0., 1.);
  43: 
  44:     color = mix(uFogColor, color, fog);
  45:     color.a = a;
  46:     #endif
  47: 
  48:     gl_FragColor = color;
  49: }
  50: 
  51: vec4 FLWLight(vec2 lightCoords) {
  52:     return vec4(1.);
  53: }
  54: 
  55: 
  56: 
  57: struct BlockFrag {
  58:     vec2 texCoords;
  59:     vec4 color;
  60:     float diffuse;
  61:     vec2 light;
  62: };
  63: 
  64: void FLWMain(BlockFrag r) {
  65:     vec4 tex = FLWBlockTexture(r.texCoords);
  66: 
  67:     vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;
  68: 
  69: //    flw_WorldPos = ;
  70: //    flw_Normal = ;
  71: //    flw_Albedo = tex.rgb;
  72: //    flw_Alpha = tex.a;
  73: //    flw_LightMap = r.light;
  74: //    flw_Tint = r.color;
  75:     FLWFinalizeColor(color);
  76: }
  77: 
  78: varying vec2 v2f_texCoords;
  79: varying vec4 v2f_color;
  80: varying float v2f_diffuse;
  81: varying vec2 v2f_light;
  82: 
  83: 
  84: //vec3 flw_WorldPos;
  85: //vec3 flw_Normal;
  86: //vec3 flw_Albedo;
  87: //float flw_Alpha;
  88: //vec2 flw_LightMap;
  89: //vec4 flw_Tint;
  90: 
  91: void main() {
  92:     BlockFrag f;
  93:     f.texCoords = v2f_texCoords;
  94: f.color = v2f_color;
  95: f.diffuse = v2f_diffuse;
  96: f.light = v2f_light;
  97: 
  98: 
  99:     FLWMain(f);
 100: }

[14:02:46] [main/ERROR]: Shader compilation log for create:rotating.vert: No errors.

[14:02:46] [main/ERROR]: Source for shader 'create:rotating.vert':
   1: #version 110
   2: 
   3: #define PI 3.1415926538
   4: 
   5: uniform float uTime;
   6: uniform mat4 uViewProjection;
   7: uniform vec3 uCameraPos;
   8: 
   9: #if defined(USE_FOG)
  10: varying float FragDistance;
  11: #endif
  12: 
  13: void FLWFinalizeWorldPos(inout vec4 worldPos) {
  14:     #if defined(USE_FOG)
  15:     FragDistance = length(worldPos.xyz - uCameraPos);
  16:     #endif
  17: 
  18:     gl_Position = uViewProjection * worldPos;
  19: }
  20: 
  21: void FLWFinalizeNormal(inout vec3 normal) {
  22:     // noop
  23: }
  24: 
  25: 
  26: mat4 rotate(vec3 axis, float angle) {
  27:     float s = sin(angle);
  28:     float c = cos(angle);
  29:     float oc = 1. - c;
  30: 
  31:     vec3 sa = axis * s;
  32: 
  33:     mat4 mr = mat4(1.);
  34:     mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
  35:     mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
  36:     mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);
  37: 
  38:     return mr;
  39: }
  40: 
  41: mat4 rotation(vec3 rot) {
  42:     return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
  43: }
  44: 
  45: mat3 modelToNormal(mat4 mat) {
  46:     // Discard the edges. This won't be accurate for scaled or skewed matrices,
  47:     // but we don't have to work with those often.
  48:     mat3 m;
  49:     m[0] = mat[0].xyz;
  50:     m[1] = mat[1].xyz;
  51:     m[2] = mat[2].xyz;
  52:     return m;
  53: }
  54: 
  55: float diffuse(vec3 normal) {
  56:     vec3 n2 = normal * normal * vec3(.6, .25, .8);
  57:     return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
  58: }
  59: 
  60: 
  61: struct Rotating {
  62:     vec2 light;
  63:     vec4 color;
  64:     vec3 pos;
  65:     float speed;
  66:     float offset;
  67:     vec3 axis;
  68: };
  69: 
  70: 
  71: struct Vertex {
  72:     vec3 pos;
  73:     vec3 normal;
  74:     vec2 texCoords;
  75: };
  76: 
  77: struct BlockFrag {
  78:     vec2 texCoords;
  79:     vec4 color;
  80:     float diffuse;
  81:     vec2 light;
  82: };
  83: 
  84: mat4 kineticRotation(float offset, float speed, vec3 axis) {
  85:     float degrees = offset + uTime * speed * 3./10.;
  86:     float angle = fract(degrees / 360.) * PI * 2.;
  87: 
  88:     return rotate(axis, angle);
  89: }
  90: 
  91: BlockFrag FLWMain(Vertex v, Rotating instance) {
  92:     mat4 spin = kineticRotation(instance.offset, instance.speed, instance.axis);
  93: 
  94:     vec4 worldPos = spin * vec4(v.pos - .5, 1.);
  95:     worldPos += vec4(instance.pos + .5, 0.);
  96: 
  97:     vec3 norm = modelToNormal(spin) * v.normal;
  98: 
  99:     FLWFinalizeWorldPos(worldPos);
 100:     FLWFinalizeNormal(norm);
 101: 
 102:     BlockFrag b;
 103:     b.diffuse = diffuse(norm);
 104:     b.texCoords = v.texCoords;
 105:     b.light = instance.light;
 106: 
 107:     #if defined(DEBUG_RAINBOW)
 108:     b.color = instance.color;
 109:     #elif defined(DEBUG_NORMAL)
 110:     b.color = vec4(norm, 1.);
 111:     #else
 112:     b.color = vec4(1.);
 113:     #endif
 114: 
 115:     return b;
 116: }
 117: attribute vec3 a_v_pos;
 118: attribute vec3 a_v_normal;
 119: attribute vec2 a_v_texCoords;
 120: 
 121: attribute vec2 a_i_light;
 122: attribute vec4 a_i_color;
 123: attribute vec3 a_i_pos;
 124: attribute float a_i_speed;
 125: attribute float a_i_offset;
 126: attribute vec3 a_i_axis;
 127: 
 128: 
 129: varying vec2 v2f_texCoords;
 130: varying vec4 v2f_color;
 131: varying float v2f_diffuse;
 132: varying vec2 v2f_light;
 133: 
 134: 
 135: void main() {
 136:     Vertex v;
 137:     v.pos = a_v_pos;
 138: v.normal = a_v_normal;
 139: v.texCoords = a_v_texCoords;
 140: 
 141: 
 142:     Rotating i;
 143:     i.light = a_i_light;
 144: i.color = a_i_color;
 145: i.pos = a_i_pos;
 146: i.speed = a_i_speed;
 147: i.offset = a_i_offset;
 148: i.axis = a_i_axis;
 149: 
 150: 
 151:     BlockFrag o = FLWMain(v, i);
 152: 
 153:     v2f_texCoords = o.texCoords;
 154: v2f_color = o.color;
 155: v2f_diffuse = o.diffuse;
 156: v2f_light = o.light;
 157: 
 158: }

[14:02:46] [main/ERROR]: Shader compilation log for flywheel:block.frag: No errors.

[14:02:46] [main/ERROR]: Source for shader 'flywheel:block.frag':
   1: #version 110
   2: 
   3: #if defined(USE_FOG)
   4: varying float FragDistance;
   5: uniform vec4 uFogColor;
   6: #endif
   7: 
   8: #if defined(USE_FOG_LINEAR)
   9: uniform vec2 uFogRange;
  10: 
  11: float FLWFogFactor() {
  12:     return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
  13: }
  14:     #endif
  15: 
  16:     #if defined(USE_FOG_EXP2)
  17: uniform float uFogDensity;
  18: 
  19: float FLWFogFactor() {
  20:     float dist = FragDistance * uFogDensity;
  21:     return 1. / exp2(dist * dist);
  22: }
  23:     #endif
  24: 
  25: uniform vec2 uTextureScale;
  26: uniform sampler2D uBlockAtlas;
  27: uniform sampler2D uLightMap;
  28: uniform sampler2D uCrumbling;
  29: 
  30: vec4 FLWBlockTexture(vec2 texCoords) {
  31:     vec4 cr = texture2D(uCrumbling, texCoords * uTextureScale);
  32:     float diffuseAlpha = texture2D(uBlockAtlas, texCoords).a;
  33:     cr.a = cr.a * diffuseAlpha;
  34:     return cr;
  35: }
  36: 
  37: void FLWFinalizeColor(vec4 color) {
  38:     #if defined(USE_FOG)
  39:     float a = color.a;
  40:     float fog = clamp(FLWFogFactor(), 0., 1.);
  41: 
  42:     color = mix(uFogColor, color, fog);
  43:     color.a = a;
  44:     #endif
  45: 
  46:     gl_FragColor = color;
  47: }
  48: 
  49: vec4 FLWLight(vec2 lightCoords) {
  50:     return vec4(1.);
  51: }
  52: 
  53: 
  54: 
  55: struct BlockFrag {
  56:     vec2 texCoords;
  57:     vec4 color;
  58:     float diffuse;
  59:     vec2 light;
  60: };
  61: 
  62: void FLWMain(BlockFrag r) {
  63:     vec4 tex = FLWBlockTexture(r.texCoords);
  64: 
  65:     vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;
  66: 
  67: //    flw_WorldPos = ;
  68: //    flw_Normal = ;
  69: //    flw_Albedo = tex.rgb;
  70: //    flw_Alpha = tex.a;
  71: //    flw_LightMap = r.light;
  72: //    flw_Tint = r.color;
  73:     FLWFinalizeColor(color);
  74: }
  75: 
  76: varying vec2 v2f_texCoords;
  77: varying vec4 v2f_color;
  78: varying float v2f_diffuse;
  79: varying vec2 v2f_light;
  80: 
  81: 
  82: //vec3 flw_WorldPos;
  83: //vec3 flw_Normal;
  84: //vec3 flw_Albedo;
  85: //float flw_Alpha;
  86: //vec2 flw_LightMap;
  87: //vec4 flw_Tint;
  88: 
  89: void main() {
  90:     BlockFrag f;
  91:     f.texCoords = v2f_texCoords;
  92: f.color = v2f_color;
  93: f.diffuse = v2f_diffuse;
  94: f.light = v2f_light;
  95: 
  96: 
  97:     FLWMain(f);
  98: }

[14:02:46] [main/ERROR]: Shader compilation log for create:contraption_actor.vert: No errors.

[14:02:46] [main/ERROR]: Source for shader 'create:contraption_actor.vert':
   1: #version 110
   2: #define DEBUG_NORMAL
   3: 
   4: #define PI 3.1415926538
   5: 
   6: uniform float uTime;
   7: uniform mat4 uViewProjection;
   8: uniform vec3 uCameraPos;
   9: 
  10: #if defined(USE_FOG)
  11: varying float FragDistance;
  12: #endif
  13: 
  14: void FLWFinalizeWorldPos(inout vec4 worldPos) {
  15:     #if defined(USE_FOG)
  16:     FragDistance = length(worldPos.xyz - uCameraPos);
  17:     #endif
  18: 
  19:     gl_Position = uViewProjection * worldPos;
  20: }
  21: 
  22: void FLWFinalizeNormal(inout vec3 normal) {
  23:     // noop
  24: }
  25: 
  26: 
  27: mat4 rotate(vec3 axis, float angle) {
  28:     float s = sin(angle);
  29:     float c = cos(angle);
  30:     float oc = 1. - c;
  31: 
  32:     vec3 sa = axis * s;
  33: 
  34:     mat4 mr = mat4(1.);
  35:     mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
  36:     mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
  37:     mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);
  38: 
  39:     return mr;
  40: }
  41: 
  42: mat4 rotation(vec3 rot) {
  43:     return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
  44: }
  45: 
  46: mat3 modelToNormal(mat4 mat) {
  47:     // Discard the edges. This won't be accurate for scaled or skewed matrices,
  48:     // but we don't have to work with those often.
  49:     mat3 m;
  50:     m[0] = mat[0].xyz;
  51:     m[1] = mat[1].xyz;
  52:     m[2] = mat[2].xyz;
  53:     return m;
  54: }
  55: 
  56: #define PIOVER2 1.5707963268
  57: 
  58: vec4 quat(vec3 axis, float angle) {
  59:     float halfAngle = angle * PIOVER2 / 180.0;
  60:     vec2 cs = sin(vec2(PIOVER2 - halfAngle, halfAngle)); // compute sin and cos in one instruction
  61:     return vec4(axis.xyz * cs.y,  cs.x);
  62: }
  63: 
  64: vec4 quatMult(vec4 q1, vec4 q2) {
  65:     // disgustingly vectorized quaternion multiplication
  66:     vec4 a = q1.w * q2.xyzw;
  67:     vec4 b = q1.x * q2.wzxy * vec4(1., -1., 1., -1.);
  68:     vec4 c = q1.y * q2.zwxy * vec4(1., 1., -1., -1.);
  69:     vec4 d = q1.z * q2.yxwz * vec4(-1., 1., 1., -1.);
  70: 
  71:     return a + b + c + d;
  72: }
  73: 
  74: vec3 rotateVertexByQuat(vec3 v, vec4 q) {
  75:     vec3 i = q.xyz;
  76:     return v + 2.0 * cross(i, cross(i, v) + q.w * v);
  77: }
  78: 
  79: vec3 rotateAbout(vec3 v, vec3 axis, float angle) {
  80:     return rotateVertexByQuat(v, quat(axis, angle));
  81: }
  82: 
  83: float diffuse(vec3 normal) {
  84:     vec3 n2 = normal * normal * vec3(.6, .25, .8);
  85:     return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
  86: }
  87: 
  88: 
  89: struct Actor {
  90:     vec3 pos;
  91:     vec2 light;
  92:     float offset;
  93:     vec3 axis;
  94:     vec4 rotation;
  95:     vec3 rotationCenter;
  96:     float speed;
  97: };
  98: 
  99: 
 100: struct Vertex {
 101:     vec3 pos;
 102:     vec3 normal;
 103:     vec2 texCoords;
 104: };
 105: 
 106: struct BlockFrag {
 107:     vec2 texCoords;
 108:     vec4 color;
 109:     float diffuse;
 110:     vec2 light;
 111: };
 112: 
 113: BlockFrag FLWMain(Vertex v, Actor instance) {
 114:     float degrees = instance.offset + uTime * instance.speed / 20.;
 115:     //float angle = fract(degrees / 360.) * PI * 2.;
 116: 
 117:     vec4 kineticRot = quat(instance.axis, degrees);
 118:     vec3 rotated = rotateVertexByQuat(v.pos - instance.rotationCenter, kineticRot) + instance.rotationCenter;
 119: 
 120:     vec4 worldPos = vec4(rotateVertexByQuat(rotated - .5, instance.rotation) + instance.pos + .5, 1.);
 121:     vec3 norm = rotateVertexByQuat(rotateVertexByQuat(v.normal, kineticRot), instance.rotation);
 122: 
 123:     FLWFinalizeWorldPos(worldPos);
 124:     FLWFinalizeNormal(norm);
 125: 
 126:     BlockFrag b;
 127:     b.diffuse = diffuse(norm);
 128:     b.texCoords = v.texCoords;
 129:     b.light = instance.light;
 130: 
 131:     #if defined(DEBUG_NORMAL)
 132:     b.color = vec4(norm, 1.);
 133:     #else
 134:     b.color = vec4(1.);
 135:     #endif
 136: 
 137:     return b;
 138: }
 139: attribute vec3 a_v_pos;
 140: attribute vec3 a_v_normal;
 141: attribute vec2 a_v_texCoords;
 142: 
 143: attribute vec3 a_i_pos;
 144: attribute vec2 a_i_light;
 145: attribute float a_i_offset;
 146: attribute vec3 a_i_axis;
 147: attribute vec4 a_i_rotation;
 148: attribute vec3 a_i_rotationCenter;
 149: attribute float a_i_speed;
 150: 
 151: 
 152: varying vec2 v2f_texCoords;
 153: varying vec4 v2f_color;
 154: varying float v2f_diffuse;
 155: varying vec2 v2f_light;
 156: 
 157: 
 158: void main() {
 159:     Vertex v;
 160:     v.pos = a_v_pos;
 161: v.normal = a_v_normal;
 162: v.texCoords = a_v_texCoords;
 163: 
 164: 
 165:     Actor i;
 166:     i.pos = a_i_pos;
 167: i.light = a_i_light;
 168: i.offset = a_i_offset;
 169: i.axis = a_i_axis;
 170: i.rotation = a_i_rotation;
 171: i.rotationCenter = a_i_rotationCenter;
 172: i.speed = a_i_speed;
 173: 
 174: 
 175:     BlockFrag o = FLWMain(v, i);
 176: 
 177:     v2f_texCoords = o.texCoords;
 178: v2f_color = o.color;
 179: v2f_diffuse = o.diffuse;
 180: v2f_light = o.light;
 181: 
 182: }

[14:02:46] [main/ERROR]: Shader compilation log for flywheel:block.frag: No errors.

[14:02:46] [main/ERROR]: Source for shader 'flywheel:block.frag':
   1: #version 110
   2: #define DEBUG_NORMAL
   3: 
   4: #if defined(USE_FOG)
   5: varying float FragDistance;
   6: uniform vec4 uFogColor;
   7: #endif
   8: 
   9: #if defined(USE_FOG_LINEAR)
  10: uniform vec2 uFogRange;
  11: 
  12: float FLWFogFactor() {
  13:     return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
  14: }
  15:     #endif
  16: 
  17:     #if defined(USE_FOG_EXP2)
  18: uniform float uFogDensity;
  19: 
  20: float FLWFogFactor() {
  21:     float dist = FragDistance * uFogDensity;
  22:     return 1. / exp2(dist * dist);
  23: }
  24:     #endif
  25: 
  26: uniform vec2 uTextureScale;
  27: uniform sampler2D uBlockAtlas;
  28: uniform sampler2D uLightMap;
  29: uniform sampler2D uCrumbling;
  30: 
  31: vec4 FLWBlockTexture(vec2 texCoords) {
  32:     vec4 cr = texture2D(uCrumbling, texCoords * uTextureScale);
  33:     float diffuseAlpha = texture2D(uBlockAtlas, texCoords).a;
  34:     cr.a = cr.a * diffuseAlpha;
  35:     return cr;
  36: }
  37: 
  38: void FLWFinalizeColor(vec4 color) {
  39:     #if defined(USE_FOG)
  40:     float a = color.a;
  41:     float fog = clamp(FLWFogFactor(), 0., 1.);
  42: 
  43:     color = mix(uFogColor, color, fog);
  44:     color.a = a;
  45:     #endif
  46: 
  47:     gl_FragColor = color;
  48: }
  49: 
  50: vec4 FLWLight(vec2 lightCoords) {
  51:     return vec4(1.);
  52: }
  53: 
  54: 
  55: 
  56: struct BlockFrag {
  57:     vec2 texCoords;
  58:     vec4 color;
  59:     float diffuse;
  60:     vec2 light;
  61: };
  62: 
  63: void FLWMain(BlockFrag r) {
  64:     vec4 tex = FLWBlockTexture(r.texCoords);
  65: 
  66:     vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;
  67: 
  68: //    flw_WorldPos = ;
  69: //    flw_Normal = ;
  70: //    flw_Albedo = tex.rgb;
  71: //    flw_Alpha = tex.a;
  72: //    flw_LightMap = r.light;
  73: //    flw_Tint = r.color;
  74:     FLWFinalizeColor(color);
  75: }
  76: 
  77: varying vec2 v2f_texCoords;
  78: varying vec4 v2f_color;
  79: varying float v2f_diffuse;
  80: varying vec2 v2f_light;
  81: 
  82: 
  83: //vec3 flw_WorldPos;
  84: //vec3 flw_Normal;
  85: //vec3 flw_Albedo;
  86: //float flw_Alpha;
  87: //vec2 flw_LightMap;
  88: //vec4 flw_Tint;
  89: 
  90: void main() {
  91:     BlockFrag f;
  92:     f.texCoords = v2f_texCoords;
  93: f.color = v2f_color;
  94: f.diffuse = v2f_diffuse;
  95: f.light = v2f_light;
  96: 
  97: 
  98:     FLWMain(f);
  99: }

[14:02:46] [main/ERROR]: Shader compilation log for create:contraption_actor.vert: No errors.

[14:02:46] [main/ERROR]: Source for shader 'create:contraption_actor.vert':
   1: #version 110
   2: #define USE_FOG
   3: #define USE_FOG_LINEAR
   4: 
   5: #define PI 3.1415926538
   6: 
   7: uniform float uTime;
   8: uniform mat4 uViewProjection;
   9: uniform vec3 uCameraPos;
  10: 
  11: #if defined(USE_FOG)
  12: varying float FragDistance;
  13: #endif
  14: 
  15: void FLWFinalizeWorldPos(inout vec4 worldPos) {
  16:     #if defined(USE_FOG)
  17:     FragDistance = length(worldPos.xyz - uCameraPos);
  18:     #endif
  19: 
  20:     gl_Position = uViewProjection * worldPos;
  21: }
  22: 
  23: void FLWFinalizeNormal(inout vec3 normal) {
  24:     // noop
  25: }
  26: 
  27: 
  28: mat4 rotate(vec3 axis, float angle) {
  29:     float s = sin(angle);
  30:     float c = cos(angle);
  31:     float oc = 1. - c;
  32: 
  33:     vec3 sa = axis * s;
  34: 
  35:     mat4 mr = mat4(1.);
  36:     mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
  37:     mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
  38:     mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);
  39: 
  40:     return mr;
  41: }
  42: 
  43: mat4 rotation(vec3 rot) {
  44:     return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
  45: }
  46: 
  47: mat3 modelToNormal(mat4 mat) {
  48:     // Discard the edges. This won't be accurate for scaled or skewed matrices,
  49:     // but we don't have to work with those often.
  50:     mat3 m;
  51:     m[0] = mat[0].xyz;
  52:     m[1] = mat[1].xyz;
  53:     m[2] = mat[2].xyz;
  54:     return m;
  55: }
  56: 
  57: #define PIOVER2 1.5707963268
  58: 
  59: vec4 quat(vec3 axis, float angle) {
  60:     float halfAngle = angle * PIOVER2 / 180.0;
  61:     vec2 cs = sin(vec2(PIOVER2 - halfAngle, halfAngle)); // compute sin and cos in one instruction
  62:     return vec4(axis.xyz * cs.y,  cs.x);
  63: }
  64: 
  65: vec4 quatMult(vec4 q1, vec4 q2) {
  66:     // disgustingly vectorized quaternion multiplication
  67:     vec4 a = q1.w * q2.xyzw;
  68:     vec4 b = q1.x * q2.wzxy * vec4(1., -1., 1., -1.);
  69:     vec4 c = q1.y * q2.zwxy * vec4(1., 1., -1., -1.);
  70:     vec4 d = q1.z * q2.yxwz * vec4(-1., 1., 1., -1.);
  71: 
  72:     return a + b + c + d;
  73: }
  74: 
  75: vec3 rotateVertexByQuat(vec3 v, vec4 q) {
  76:     vec3 i = q.xyz;
  77:     return v + 2.0 * cross(i, cross(i, v) + q.w * v);
  78: }
  79: 
  80: vec3 rotateAbout(vec3 v, vec3 axis, float angle) {
  81:     return rotateVertexByQuat(v, quat(axis, angle));
  82: }
  83: 
  84: float diffuse(vec3 normal) {
  85:     vec3 n2 = normal * normal * vec3(.6, .25, .8);
  86:     return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
  87: }
  88: 
  89: 
  90: struct Actor {
  91:     vec3 pos;
  92:     vec2 light;
  93:     float offset;
  94:     vec3 axis;
  95:     vec4 rotation;
  96:     vec3 rotationCenter;
  97:     float speed;
  98: };
  99: 
 100: 
 101: struct Vertex {
 102:     vec3 pos;
 103:     vec3 normal;
 104:     vec2 texCoords;
 105: };
 106: 
 107: struct BlockFrag {
 108:     vec2 texCoords;
 109:     vec4 color;
 110:     float diffuse;
 111:     vec2 light;
 112: };
 113: 
 114: BlockFrag FLWMain(Vertex v, Actor instance) {
 115:     float degrees = instance.offset + uTime * instance.speed / 20.;
 116:     //float angle = fract(degrees / 360.) * PI * 2.;
 117: 
 118:     vec4 kineticRot = quat(instance.axis, degrees);
 119:     vec3 rotated = rotateVertexByQuat(v.pos - instance.rotationCenter, kineticRot) + instance.rotationCenter;
 120: 
 121:     vec4 worldPos = vec4(rotateVertexByQuat(rotated - .5, instance.rotation) + instance.pos + .5, 1.);
 122:     vec3 norm = rotateVertexByQuat(rotateVertexByQuat(v.normal, kineticRot), instance.rotation);
 123: 
 124:     FLWFinalizeWorldPos(worldPos);
 125:     FLWFinalizeNormal(norm);
 126: 
 127:     BlockFrag b;
 128:     b.diffuse = diffuse(norm);
 129:     b.texCoords = v.texCoords;
 130:     b.light = instance.light;
 131: 
 132:     #if defined(DEBUG_NORMAL)
 133:     b.color = vec4(norm, 1.);
 134:     #else
 135:     b.color = vec4(1.);
 136:     #endif
 137: 
 138:     return b;
 139: }
 140: attribute vec3 a_v_pos;
 141: attribute vec3 a_v_normal;
 142: attribute vec2 a_v_texCoords;
 143: 
 144: attribute vec3 a_i_pos;
 145: attribute vec2 a_i_light;
 146: attribute float a_i_offset;
 147: attribute vec3 a_i_axis;
 148: attribute vec4 a_i_rotation;
 149: attribute vec3 a_i_rotationCenter;
 150: attribute float a_i_speed;
 151: 
 152: 
 153: varying vec2 v2f_texCoords;
 154: varying vec4 v2f_color;
 155: varying float v2f_diffuse;
 156: varying vec2 v2f_light;
 157: 
 158: 
 159: void main() {
 160:     Vertex v;
 161:     v.pos = a_v_pos;
 162: v.normal = a_v_normal;
 163: v.texCoords = a_v_texCoords;
 164: 
 165: 
 166:     Actor i;
 167:     i.pos = a_i_pos;
 168: i.light = a_i_light;
 169: i.offset = a_i_offset;
 170: i.axis = a_i_axis;
 171: i.rotation = a_i_rotation;
 172: i.rotationCenter = a_i_rotationCenter;
 173: i.speed = a_i_speed;
 174: 
 175: 
 176:     BlockFrag o = FLWMain(v, i);
 177: 
 178:     v2f_texCoords = o.texCoords;
 179: v2f_color = o.color;
 180: v2f_diffuse = o.diffuse;
 181: v2f_light = o.light;
 182: 
 183: }

[14:02:46] [main/ERROR]: Shader compilation log for flywheel:block.frag: No errors.

[14:02:46] [main/ERROR]: Source for shader 'flywheel:block.frag':
   1: #version 110
   2: #define USE_FOG
   3: #define USE_FOG_LINEAR
   4: 
   5: #if defined(USE_FOG)
   6: varying float FragDistance;
   7: uniform vec4 uFogColor;
   8: #endif
   9: 
  10: #if defined(USE_FOG_LINEAR)
  11: uniform vec2 uFogRange;
  12: 
  13: float FLWFogFactor() {
  14:     return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
  15: }
  16:     #endif
  17: 
  18:     #if defined(USE_FOG_EXP2)
  19: uniform float uFogDensity;
  20: 
  21: float FLWFogFactor() {
  22:     float dist = FragDistance * uFogDensity;
  23:     return 1. / exp2(dist * dist);
  24: }
  25:     #endif
  26: 
  27: uniform vec2 uTextureScale;
  28: uniform sampler2D uBlockAtlas;
  29: uniform sampler2D uLightMap;
  30: uniform sampler2D uCrumbling;
  31: 
  32: vec4 FLWBlockTexture(vec2 texCoords) {
  33:     vec4 cr = texture2D(uCrumbling, texCoords * uTextureScale);
  34:     float diffuseAlpha = texture2D(uBlockAtlas, texCoords).a;
  35:     cr.a = cr.a * diffuseAlpha;
  36:     return cr;
  37: }
  38: 
  39: void FLWFinalizeColor(vec4 color) {
  40:     #if defined(USE_FOG)
  41:     float a = color.a;
  42:     float fog = clamp(FLWFogFactor(), 0., 1.);
  43: 
  44:     color = mix(uFogColor, color, fog);
  45:     color.a = a;
  46:     #endif
  47: 
  48:     gl_FragColor = color;
  49: }
  50: 
  51: vec4 FLWLight(vec2 lightCoords) {
  52:     return vec4(1.);
  53: }
  54: 
  55: 
  56: 
  57: struct BlockFrag {
  58:     vec2 texCoords;
  59:     vec4 color;
  60:     float diffuse;
  61:     vec2 light;
  62: };
  63: 
  64: void FLWMain(BlockFrag r) {
  65:     vec4 tex = FLWBlockTexture(r.texCoords);
  66: 
  67:     vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;
  68: 
  69: //    flw_WorldPos = ;
  70: //    flw_Normal = ;
  71: //    flw_Albedo = tex.rgb;
  72: //    flw_Alpha = tex.a;
  73: //    flw_LightMap = r.light;
  74: //    flw_Tint = r.color;
  75:     FLWFinalizeColor(color);
  76: }
  77: 
  78: varying vec2 v2f_texCoords;
  79: varying vec4 v2f_color;
  80: varying float v2f_diffuse;
  81: varying vec2 v2f_light;
  82: 
  83: 
  84: //vec3 flw_WorldPos;
  85: //vec3 flw_Normal;
  86: //vec3 flw_Albedo;
  87: //float flw_Alpha;
  88: //vec2 flw_LightMap;
  89: //vec4 flw_Tint;
  90: 
  91: void main() {
  92:     BlockFrag f;
  93:     f.texCoords = v2f_texCoords;
  94: f.color = v2f_color;
  95: f.diffuse = v2f_diffuse;
  96: f.light = v2f_light;
  97: 
  98: 
  99:     FLWMain(f);
 100: }

[14:02:46] [main/ERROR]: Shader compilation log for create:contraption_actor.vert: No errors.

[14:02:46] [main/ERROR]: Source for shader 'create:contraption_actor.vert':
   1: #version 110
   2: #define USE_FOG
   3: #define USE_FOG_EXP2
   4: 
   5: #define PI 3.1415926538
   6: 
   7: uniform float uTime;
   8: uniform mat4 uViewProjection;
   9: uniform vec3 uCameraPos;
  10: 
  11: #if defined(USE_FOG)
  12: varying float FragDistance;
  13: #endif
  14: 
  15: void FLWFinalizeWorldPos(inout vec4 worldPos) {
  16:     #if defined(USE_FOG)
  17:     FragDistance = length(worldPos.xyz - uCameraPos);
  18:     #endif
  19: 
  20:     gl_Position = uViewProjection * worldPos;
  21: }
  22: 
  23: void FLWFinalizeNormal(inout vec3 normal) {
  24:     // noop
  25: }
  26: 
  27: 
  28: mat4 rotate(vec3 axis, float angle) {
  29:     float s = sin(angle);
  30:     float c = cos(angle);
  31:     float oc = 1. - c;
  32: 
  33:     vec3 sa = axis * s;
  34: 
  35:     mat4 mr = mat4(1.);
  36:     mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
  37:     mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
  38:     mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);
  39: 
  40:     return mr;
  41: }
  42: 
  43: mat4 rotation(vec3 rot) {
  44:     return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
  45: }
  46: 
  47: mat3 modelToNormal(mat4 mat) {
  48:     // Discard the edges. This won't be accurate for scaled or skewed matrices,
  49:     // but we don't have to work with those often.
  50:     mat3 m;
  51:     m[0] = mat[0].xyz;
  52:     m[1] = mat[1].xyz;
  53:     m[2] = mat[2].xyz;
  54:     return m;
  55: }
  56: 
  57: #define PIOVER2 1.5707963268
  58: 
  59: vec4 quat(vec3 axis, float angle) {
  60:     float halfAngle = angle * PIOVER2 / 180.0;
  61:     vec2 cs = sin(vec2(PIOVER2 - halfAngle, halfAngle)); // compute sin and cos in one instruction
  62:     return vec4(axis.xyz * cs.y,  cs.x);
  63: }
  64: 
  65: vec4 quatMult(vec4 q1, vec4 q2) {
  66:     // disgustingly vectorized quaternion multiplication
  67:     vec4 a = q1.w * q2.xyzw;
  68:     vec4 b = q1.x * q2.wzxy * vec4(1., -1., 1., -1.);
  69:     vec4 c = q1.y * q2.zwxy * vec4(1., 1., -1., -1.);
  70:     vec4 d = q1.z * q2.yxwz * vec4(-1., 1., 1., -1.);
  71: 
  72:     return a + b + c + d;
  73: }
  74: 
  75: vec3 rotateVertexByQuat(vec3 v, vec4 q) {
  76:     vec3 i = q.xyz;
  77:     return v + 2.0 * cross(i, cross(i, v) + q.w * v);
  78: }
  79: 
  80: vec3 rotateAbout(vec3 v, vec3 axis, float angle) {
  81:     return rotateVertexByQuat(v, quat(axis, angle));
  82: }
  83: 
  84: float diffuse(vec3 normal) {
  85:     vec3 n2 = normal * normal * vec3(.6, .25, .8);
  86:     return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
  87: }
  88: 
  89: 
  90: struct Actor {
  91:     vec3 pos;
  92:     vec2 light;
  93:     float offset;
  94:     vec3 axis;
  95:     vec4 rotation;
  96:     vec3 rotationCenter;
  97:     float speed;
  98: };
  99: 
 100: 
 101: struct Vertex {
 102:     vec3 pos;
 103:     vec3 normal;
 104:     vec2 texCoords;
 105: };
 106: 
 107: struct BlockFrag {
 108:     vec2 texCoords;
 109:     vec4 color;
 110:     float diffuse;
 111:     vec2 light;
 112: };
 113: 
 114: BlockFrag FLWMain(Vertex v, Actor instance) {
 115:     float degrees = instance.offset + uTime * instance.speed / 20.;
 116:     //float angle = fract(degrees / 360.) * PI * 2.;
 117: 
 118:     vec4 kineticRot = quat(instance.axis, degrees);
 119:     vec3 rotated = rotateVertexByQuat(v.pos - instance.rotationCenter, kineticRot) + instance.rotationCenter;
 120: 
 121:     vec4 worldPos = vec4(rotateVertexByQuat(rotated - .5, instance.rotation) + instance.pos + .5, 1.);
 122:     vec3 norm = rotateVertexByQuat(rotateVertexByQuat(v.normal, kineticRot), instance.rotation);
 123: 
 124:     FLWFinalizeWorldPos(worldPos);
 125:     FLWFinalizeNormal(norm);
 126: 
 127:     BlockFrag b;
 128:     b.diffuse = diffuse(norm);
 129:     b.texCoords = v.texCoords;
 130:     b.light = instance.light;
 131: 
 132:     #if defined(DEBUG_NORMAL)
 133:     b.color = vec4(norm, 1.);
 134:     #else
 135:     b.color = vec4(1.);
 136:     #endif
 137: 
 138:     return b;
 139: }
 140: attribute vec3 a_v_pos;
 141: attribute vec3 a_v_normal;
 142: attribute vec2 a_v_texCoords;
 143: 
 144: attribute vec3 a_i_pos;
 145: attribute vec2 a_i_light;
 146: attribute float a_i_offset;
 147: attribute vec3 a_i_axis;
 148: attribute vec4 a_i_rotation;
 149: attribute vec3 a_i_rotationCenter;
 150: attribute float a_i_speed;
 151: 
 152: 
 153: varying vec2 v2f_texCoords;
 154: varying vec4 v2f_color;
 155: varying float v2f_diffuse;
 156: varying vec2 v2f_light;
 157: 
 158: 
 159: void main() {
 160:     Vertex v;
 161:     v.pos = a_v_pos;
 162: v.normal = a_v_normal;
 163: v.texCoords = a_v_texCoords;
 164: 
 165: 
 166:     Actor i;
 167:     i.pos = a_i_pos;
 168: i.light = a_i_light;
 169: i.offset = a_i_offset;
 170: i.axis = a_i_axis;
 171: i.rotation = a_i_rotation;
 172: i.rotationCenter = a_i_rotationCenter;
 173: i.speed = a_i_speed;
 174: 
 175: 
 176:     BlockFrag o = FLWMain(v, i);
 177: 
 178:     v2f_texCoords = o.texCoords;
 179: v2f_color = o.color;
 180: v2f_diffuse = o.diffuse;
 181: v2f_light = o.light;
 182: 
 183: }

[14:02:46] [main/ERROR]: Shader compilation log for flywheel:block.frag: No errors.

[14:02:46] [main/ERROR]: Source for shader 'flywheel:block.frag':
   1: #version 110
   2: #define USE_FOG
   3: #define USE_FOG_EXP2
   4: 
   5: #if defined(USE_FOG)
   6: varying float FragDistance;
   7: uniform vec4 uFogColor;
   8: #endif
   9: 
  10: #if defined(USE_FOG_LINEAR)
  11: uniform vec2 uFogRange;
  12: 
  13: float FLWFogFactor() {
  14:     return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
  15: }
  16:     #endif
  17: 
  18:     #if defined(USE_FOG_EXP2)
  19: uniform float uFogDensity;
  20: 
  21: float FLWFogFactor() {
  22:     float dist = FragDistance * uFogDensity;
  23:     return 1. / exp2(dist * dist);
  24: }
  25:     #endif
  26: 
  27: uniform vec2 uTextureScale;
  28: uniform sampler2D uBlockAtlas;
  29: uniform sampler2D uLightMap;
  30: uniform sampler2D uCrumbling;
  31: 
  32: vec4 FLWBlockTexture(vec2 texCoords) {
  33:     vec4 cr = texture2D(uCrumbling, texCoords * uTextureScale);
  34:     float diffuseAlpha = texture2D(uBlockAtlas, texCoords).a;
  35:     cr.a = cr.a * diffuseAlpha;
  36:     return cr;
  37: }
  38: 
  39: void FLWFinalizeColor(vec4 color) {
  40:     #if defined(USE_FOG)
  41:     float a = color.a;
  42:     float fog = clamp(FLWFogFactor(), 0., 1.);
  43: 
  44:     color = mix(uFogColor, color, fog);
  45:     color.a = a;
  46:     #endif
  47: 
  48:     gl_FragColor = color;
  49: }
  50: 
  51: vec4 FLWLight(vec2 lightCoords) {
  52:     return vec4(1.);
  53: }
  54: 
  55: 
  56: 
  57: struct BlockFrag {
  58:     vec2 texCoords;
  59:     vec4 color;
  60:     float diffuse;
  61:     vec2 light;
  62: };
  63: 
  64: void FLWMain(BlockFrag r) {
  65:     vec4 tex = FLWBlockTexture(r.texCoords);
  66: 
  67:     vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;
  68: 
  69: //    flw_WorldPos = ;
  70: //    flw_Normal = ;
  71: //    flw_Albedo = tex.rgb;
  72: //    flw_Alpha = tex.a;
  73: //    flw_LightMap = r.light;
  74: //    flw_Tint = r.color;
  75:     FLWFinalizeColor(color);
  76: }
  77: 
  78: varying vec2 v2f_texCoords;
  79: varying vec4 v2f_color;
  80: varying float v2f_diffuse;
  81: varying vec2 v2f_light;
  82: 
  83: 
  84: //vec3 flw_WorldPos;
  85: //vec3 flw_Normal;
  86: //vec3 flw_Albedo;
  87: //float flw_Alpha;
  88: //vec2 flw_LightMap;
  89: //vec4 flw_Tint;
  90: 
  91: void main() {
  92:     BlockFrag f;
  93:     f.texCoords = v2f_texCoords;
  94: f.color = v2f_color;
  95: f.diffuse = v2f_diffuse;
  96: f.light = v2f_light;
  97: 
  98: 
  99:     FLWMain(f);
 100: }

[14:02:46] [main/ERROR]: Shader compilation log for create:contraption_actor.vert: No errors.

[14:02:46] [main/ERROR]: Source for shader 'create:contraption_actor.vert':
   1: #version 110
   2: 
   3: #define PI 3.1415926538
   4: 
   5: uniform float uTime;
   6: uniform mat4 uViewProjection;
   7: uniform vec3 uCameraPos;
   8: 
   9: #if defined(USE_FOG)
  10: varying float FragDistance;
  11: #endif
  12: 
  13: void FLWFinalizeWorldPos(inout vec4 worldPos) {
  14:     #if defined(USE_FOG)
  15:     FragDistance = length(worldPos.xyz - uCameraPos);
  16:     #endif
  17: 
  18:     gl_Position = uViewProjection * worldPos;
  19: }
  20: 
  21: void FLWFinalizeNormal(inout vec3 normal) {
  22:     // noop
  23: }
  24: 
  25: 
  26: mat4 rotate(vec3 axis, float angle) {
  27:     float s = sin(angle);
  28:     float c = cos(angle);
  29:     float oc = 1. - c;
  30: 
  31:     vec3 sa = axis * s;
  32: 
  33:     mat4 mr = mat4(1.);
  34:     mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
  35:     mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
  36:     mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);
  37: 
  38:     return mr;
  39: }
  40: 
  41: mat4 rotation(vec3 rot) {
  42:     return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
  43: }
  44: 
  45: mat3 modelToNormal(mat4 mat) {
  46:     // Discard the edges. This won't be accurate for scaled or skewed matrices,
  47:     // but we don't have to work with those often.
  48:     mat3 m;
  49:     m[0] = mat[0].xyz;
  50:     m[1] = mat[1].xyz;
  51:     m[2] = mat[2].xyz;
  52:     return m;
  53: }
  54: 
  55: #define PIOVER2 1.5707963268
  56: 
  57: vec4 quat(vec3 axis, float angle) {
  58:     float halfAngle = angle * PIOVER2 / 180.0;
  59:     vec2 cs = sin(vec2(PIOVER2 - halfAngle, halfAngle)); // compute sin and cos in one instruction
  60:     return vec4(axis.xyz * cs.y,  cs.x);
  61: }
  62: 
  63: vec4 quatMult(vec4 q1, vec4 q2) {
  64:     // disgustingly vectorized quaternion multiplication
  65:     vec4 a = q1.w * q2.xyzw;
  66:     vec4 b = q1.x * q2.wzxy * vec4(1., -1., 1., -1.);
  67:     vec4 c = q1.y * q2.zwxy * vec4(1., 1., -1., -1.);
  68:     vec4 d = q1.z * q2.yxwz * vec4(-1., 1., 1., -1.);
  69: 
  70:     return a + b + c + d;
  71: }
  72: 
  73: vec3 rotateVertexByQuat(vec3 v, vec4 q) {
  74:     vec3 i = q.xyz;
  75:     return v + 2.0 * cross(i, cross(i, v) + q.w * v);
  76: }
  77: 
  78: vec3 rotateAbout(vec3 v, vec3 axis, float angle) {
  79:     return rotateVertexByQuat(v, quat(axis, angle));
  80: }
  81: 
  82: float diffuse(vec3 normal) {
  83:     vec3 n2 = normal * normal * vec3(.6, .25, .8);
  84:     return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
  85: }
  86: 
  87: 
  88: struct Actor {
  89:     vec3 pos;
  90:     vec2 light;
  91:     float offset;
  92:     vec3 axis;
  93:     vec4 rotation;
  94:     vec3 rotationCenter;
  95:     float speed;
  96: };
  97: 
  98: 
  99: struct Vertex {
 100:     vec3 pos;
 101:     vec3 normal;
 102:     vec2 texCoords;
 103: };
 104: 
 105: struct BlockFrag {
 106:     vec2 texCoords;
 107:     vec4 color;
 108:     float diffuse;
 109:     vec2 light;
 110: };
 111: 
 112: BlockFrag FLWMain(Vertex v, Actor instance) {
 113:     float degrees = instance.offset + uTime * instance.speed / 20.;
 114:     //float angle = fract(degrees / 360.) * PI * 2.;
 115: 
 116:     vec4 kineticRot = quat(instance.axis, degrees);
 117:     vec3 rotated = rotateVertexByQuat(v.pos - instance.rotationCenter, kineticRot) + instance.rotationCenter;
 118: 
 119:     vec4 worldPos = vec4(rotateVertexByQuat(rotated - .5, instance.rotation) + instance.pos + .5, 1.);
 120:     vec3 norm = rotateVertexByQuat(rotateVertexByQuat(v.normal, kineticRot), instance.rotation);
 121: 
 122:     FLWFinalizeWorldPos(worldPos);
 123:     FLWFinalizeNormal(norm);
 124: 
 125:     BlockFrag b;
 126:     b.diffuse = diffuse(norm);
 127:     b.texCoords = v.texCoords;
 128:     b.light = instance.light;
 129: 
 130:     #if defined(DEBUG_NORMAL)
 131:     b.color = vec4(norm, 1.);
 132:     #else
 133:     b.color = vec4(1.);
 134:     #endif
 135: 
 136:     return b;
 137: }
 138: attribute vec3 a_v_pos;
 139: attribute vec3 a_v_normal;
 140: attribute vec2 a_v_texCoords;
 141: 
 142: attribute vec3 a_i_pos;
 143: attribute vec2 a_i_light;
 144: attribute float a_i_offset;
 145: attribute vec3 a_i_axis;
 146: attribute vec4 a_i_rotation;
 147: attribute vec3 a_i_rotationCenter;
 148: attribute float a_i_speed;
 149: 
 150: 
 151: varying vec2 v2f_texCoords;
 152: varying vec4 v2f_color;
 153: varying float v2f_diffuse;
 154: varying vec2 v2f_light;
 155: 
 156: 
 157: void main() {
 158:     Vertex v;
 159:     v.pos = a_v_pos;
 160: v.normal = a_v_normal;
 161: v.texCoords = a_v_texCoords;
 162: 
 163: 
 164:     Actor i;
 165:     i.pos = a_i_pos;
 166: i.light = a_i_light;
 167: i.offset = a_i_offset;
 168: i.axis = a_i_axis;
 169: i.rotation = a_i_rotation;
 170: i.rotationCenter = a_i_rotationCenter;
 171: i.speed = a_i_speed;
 172: 
 173: 
 174:     BlockFrag o = FLWMain(v, i);
 175: 
 176:     v2f_texCoords = o.texCoords;
 177: v2f_color = o.color;
 178: v2f_diffuse = o.diffuse;
 179: v2f_light = o.light;
 180: 
 181: }

[14:02:46] [main/ERROR]: Shader compilation log for flywheel:block.frag: No errors.

[14:02:46] [main/ERROR]: Source for shader 'flywheel:block.frag':
   1: #version 110
   2: 
   3: #if defined(USE_FOG)
   4: varying float FragDistance;
   5: uniform vec4 uFogColor;
   6: #endif
   7: 
   8: #if defined(USE_FOG_LINEAR)
   9: uniform vec2 uFogRange;
  10: 
  11: float FLWFogFactor() {
  12:     return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
  13: }
  14:     #endif
  15: 
  16:     #if defined(USE_FOG_EXP2)
  17: uniform float uFogDensity;
  18: 
  19: float FLWFogFactor() {
  20:     float dist = FragDistance * uFogDensity;
  21:     return 1. / exp2(dist * dist);
  22: }
  23:     #endif
  24: 
  25: uniform vec2 uTextureScale;
  26: uniform sampler2D uBlockAtlas;
  27: uniform sampler2D uLightMap;
  28: uniform sampler2D uCrumbling;
  29: 
  30: vec4 FLWBlockTexture(vec2 texCoords) {
  31:     vec4 cr = texture2D(uCrumbling, texCoords * uTextureScale);
  32:     float diffuseAlpha = texture2D(uBlockAtlas, texCoords).a;
  33:     cr.a = cr.a * diffuseAlpha;
  34:     return cr;
  35: }
  36: 
  37: void FLWFinalizeColor(vec4 color) {
  38:     #if defined(USE_FOG)
  39:     float a = color.a;
  40:     float fog = clamp(FLWFogFactor(), 0., 1.);
  41: 
  42:     color = mix(uFogColor, color, fog);
  43:     color.a = a;
  44:     #endif
  45: 
  46:     gl_FragColor = color;
  47: }
  48: 
  49: vec4 FLWLight(vec2 lightCoords) {
  50:     return vec4(1.);
  51: }
  52: 
  53: 
  54: 
  55: struct BlockFrag {
  56:     vec2 texCoords;
  57:     vec4 color;
  58:     float diffuse;
  59:     vec2 light;
  60: };
  61: 
  62: void FLWMain(BlockFrag r) {
  63:     vec4 tex = FLWBlockTexture(r.texCoords);
  64: 
  65:     vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;
  66: 
  67: //    flw_WorldPos = ;
  68: //    flw_Normal = ;
  69: //    flw_Albedo = tex.rgb;
  70: //    flw_Alpha = tex.a;
  71: //    flw_LightMap = r.light;
  72: //    flw_Tint = r.color;
  73:     FLWFinalizeColor(color);
  74: }
  75: 
  76: varying vec2 v2f_texCoords;
  77: varying vec4 v2f_color;
  78: varying float v2f_diffuse;
  79: varying vec2 v2f_light;
  80: 
  81: 
  82: //vec3 flw_WorldPos;
  83: //vec3 flw_Normal;
  84: //vec3 flw_Albedo;
  85: //float flw_Alpha;
  86: //vec2 flw_LightMap;
  87: //vec4 flw_Tint;
  88: 
  89: void main() {
  90:     BlockFrag f;
  91:     f.texCoords = v2f_texCoords;
  92: f.color = v2f_color;
  93: f.diffuse = v2f_diffuse;
  94: f.light = v2f_light;
  95: 
  96: 
  97:     FLWMain(f);
  98: }

[14:02:46] [main/ERROR]: Shader compilation log for create:flap.vert: No errors.

[14:02:46] [main/ERROR]: Source for shader 'create:flap.vert':
   1: #version 110
   2: #define DEBUG_NORMAL
   3: 
   4: #define PI 3.1415926538
   5: 
   6: uniform float uTime;
   7: uniform mat4 uViewProjection;
   8: uniform vec3 uCameraPos;
   9: 
  10: #if defined(USE_FOG)
  11: varying float FragDistance;
  12: #endif
  13: 
  14: void FLWFinalizeWorldPos(inout vec4 worldPos) {
  15:     #if defined(USE_FOG)
  16:     FragDistance = length(worldPos.xyz - uCameraPos);
  17:     #endif
  18: 
  19:     gl_Position = uViewProjection * worldPos;
  20: }
  21: 
  22: void FLWFinalizeNormal(inout vec3 normal) {
  23:     // noop
  24: }
  25: 
  26: 
  27: mat4 rotate(vec3 axis, float angle) {
  28:     float s = sin(angle);
  29:     float c = cos(angle);
  30:     float oc = 1. - c;
  31: 
  32:     vec3 sa = axis * s;
  33: 
  34:     mat4 mr = mat4(1.);
  35:     mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
  36:     mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
  37:     mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);
  38: 
  39:     return mr;
  40: }
  41: 
  42: mat4 rotation(vec3 rot) {
  43:     return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
  44: }
  45: 
  46: mat3 modelToNormal(mat4 mat) {
  47:     // Discard the edges. This won't be accurate for scaled or skewed matrices,
  48:     // but we don't have to work with those often.
  49:     mat3 m;
  50:     m[0] = mat[0].xyz;
  51:     m[1] = mat[1].xyz;
  52:     m[2] = mat[2].xyz;
  53:     return m;
  54: }
  55: 
  56: #define PIOVER2 1.5707963268
  57: 
  58: vec4 quat(vec3 axis, float angle) {
  59:     float halfAngle = angle * PIOVER2 / 180.0;
  60:     vec2 cs = sin(vec2(PIOVER2 - halfAngle, halfAngle)); // compute sin and cos in one instruction
  61:     return vec4(axis.xyz * cs.y,  cs.x);
  62: }
  63: 
  64: vec4 quatMult(vec4 q1, vec4 q2) {
  65:     // disgustingly vectorized quaternion multiplication
  66:     vec4 a = q1.w * q2.xyzw;
  67:     vec4 b = q1.x * q2.wzxy * vec4(1., -1., 1., -1.);
  68:     vec4 c = q1.y * q2.zwxy * vec4(1., 1., -1., -1.);
  69:     vec4 d = q1.z * q2.yxwz * vec4(-1., 1., 1., -1.);
  70: 
  71:     return a + b + c + d;
  72: }
  73: 
  74: vec3 rotateVertexByQuat(vec3 v, vec4 q) {
  75:     vec3 i = q.xyz;
  76:     return v + 2.0 * cross(i, cross(i, v) + q.w * v);
  77: }
  78: 
  79: vec3 rotateAbout(vec3 v, vec3 axis, float angle) {
  80:     return rotateVertexByQuat(v, quat(axis, angle));
  81: }
  82: 
  83: float diffuse(vec3 normal) {
  84:     vec3 n2 = normal * normal * vec3(.6, .25, .8);
  85:     return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
  86: }
  87: 
  88: 
  89: struct Flap {
  90:     vec3 instancePos;
  91:     vec2 light;
  92:     vec3 segmentOffset;
  93:     vec3 pivot;
  94:     float horizontalAngle;
  95:     float intensity;
  96:     float flapScale;
  97:     float flapness;
  98: };
  99: 
 100: 
 101: struct Vertex {
 102:     vec3 pos;
 103:     vec3 normal;
 104:     vec2 texCoords;
 105: };
 106: 
 107: struct BlockFrag {
 108:     vec2 texCoords;
 109:     vec4 color;
 110:     float diffuse;
 111:     vec2 light;
 112: };
 113: 
 114: 
 115: float toRad(float degrees) {
 116:     return fract(degrees / 360.) * PI * 2.;
 117: }
 118: 
 119: float getFlapAngle(float flapness, float intensity, float scale) {
 120:     float absFlap = abs(flapness);
 121: 
 122:     float angle = sin((1. - absFlap) * PI * intensity) * 30. * flapness * scale;
 123: 
 124:     float halfAngle = angle * 0.5;
 125: 
 126:     float which = step(0., flapness);// 0 if negative, 1 if positive
 127:     float degrees = which * halfAngle + (1. - which) * angle;// branchless conditional multiply
 128: 
 129:     return degrees;
 130: }
 131: 
 132: BlockFrag FLWMain(Vertex v, Flap flap) {
 133:     float flapAngle = getFlapAngle(flap.flapness, flap.intensity, flap.flapScale);
 134: 
 135:     vec4 orientation = quat(vec3(0., 1., 0.), -flap.horizontalAngle);
 136:     vec4 flapRotation = quat(vec3(1., 0., 0.), flapAngle);
 137: 
 138:     vec3 rotated = rotateVertexByQuat(v.pos - flap.pivot, flapRotation) + flap.pivot + flap.segmentOffset;
 139:     rotated = rotateVertexByQuat(rotated - .5, orientation) + flap.instancePos + .5;
 140: 
 141:     vec4 worldPos = vec4(rotated, 1.);
 142:     vec3 norm = rotateVertexByQuat(rotateVertexByQuat(v.normal, flapRotation), orientation);
 143: 
 144:     FLWFinalizeWorldPos(worldPos);
 145:     FLWFinalizeNormal(norm);
 146: 
 147:     BlockFrag b;
 148:     b.diffuse = diffuse(norm);
 149:     b.texCoords = v.texCoords;
 150:     b.light = flap.light;
 151:     #if defined(DEBUG_NORMAL)
 152:     b.color = vec4(norm, 1.);
 153:     #else
 154:     b.color = vec4(1.);
 155:     #endif
 156:     return b;
 157: }
 158: attribute vec3 a_v_pos;
 159: attribute vec3 a_v_normal;
 160: attribute vec2 a_v_texCoords;
 161: 
 162: attribute vec3 a_i_instancePos;
 163: attribute vec2 a_i_light;
 164: attribute vec3 a_i_segmentOffset;
 165: attribute vec3 a_i_pivot;
 166: attribute float a_i_horizontalAngle;
 167: attribute float a_i_intensity;
 168: attribute float a_i_flapScale;
 169: attribute float a_i_flapness;
 170: 
 171: 
 172: varying vec2 v2f_texCoords;
 173: varying vec4 v2f_color;
 174: varying float v2f_diffuse;
 175: varying vec2 v2f_light;
 176: 
 177: 
 178: void main() {
 179:     Vertex v;
 180:     v.pos = a_v_pos;
 181: v.normal = a_v_normal;
 182: v.texCoords = a_v_texCoords;
 183: 
 184: 
 185:     Flap i;
 186:     i.instancePos = a_i_instancePos;
 187: i.light = a_i_light;
 188: i.segmentOffset = a_i_segmentOffset;
 189: i.pivot = a_i_pivot;
 190: i.horizontalAngle = a_i_horizontalAngle;
 191: i.intensity = a_i_intensity;
 192: i.flapScale = a_i_flapScale;
 193: i.flapness = a_i_flapness;
 194: 
 195: 
 196:     BlockFrag o = FLWMain(v, i);
 197: 
 198:     v2f_texCoords = o.texCoords;
 199: v2f_color = o.color;
 200: v2f_diffuse = o.diffuse;
 201: v2f_light = o.light;
 202: 
 203: }

[14:02:46] [main/ERROR]: Shader compilation log for flywheel:block.frag: No errors.

[14:02:46] [main/ERROR]: Source for shader 'flywheel:block.frag':
   1: #version 110
   2: #define DEBUG_NORMAL
   3: 
   4: #if defined(USE_FOG)
   5: varying float FragDistance;
   6: uniform vec4 uFogColor;
   7: #endif
   8: 
   9: #if defined(USE_FOG_LINEAR)
  10: uniform vec2 uFogRange;
  11: 
  12: float FLWFogFactor() {
  13:     return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
  14: }
  15:     #endif
  16: 
  17:     #if defined(USE_FOG_EXP2)
  18: uniform float uFogDensity;
  19: 
  20: float FLWFogFactor() {
  21:     float dist = FragDistance * uFogDensity;
  22:     return 1. / exp2(dist * dist);
  23: }
  24:     #endif
  25: 
  26: uniform vec2 uTextureScale;
  27: uniform sampler2D uBlockAtlas;
  28: uniform sampler2D uLightMap;
  29: uniform sampler2D uCrumbling;
  30: 
  31: vec4 FLWBlockTexture(vec2 texCoords) {
  32:     vec4 cr = texture2D(uCrumbling, texCoords * uTextureScale);
  33:     float diffuseAlpha = texture2D(uBlockAtlas, texCoords).a;
  34:     cr.a = cr.a * diffuseAlpha;
  35:     return cr;
  36: }
  37: 
  38: void FLWFinalizeColor(vec4 color) {
  39:     #if defined(USE_FOG)
  40:     float a = color.a;
  41:     float fog = clamp(FLWFogFactor(), 0., 1.);
  42: 
  43:     color = mix(uFogColor, color, fog);
  44:     color.a = a;
  45:     #endif
  46: 
  47:     gl_FragColor = color;
  48: }
  49: 
  50: vec4 FLWLight(vec2 lightCoords) {
  51:     return vec4(1.);
  52: }
  53: 
  54: 
  55: 
  56: struct BlockFrag {
  57:     vec2 texCoords;
  58:     vec4 color;
  59:     float diffuse;
  60:     vec2 light;
  61: };
  62: 
  63: void FLWMain(BlockFrag r) {
  64:     vec4 tex = FLWBlockTexture(r.texCoords);
  65: 
  66:     vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;
  67: 
  68: //    flw_WorldPos = ;
  69: //    flw_Normal = ;
  70: //    flw_Albedo = tex.rgb;
  71: //    flw_Alpha = tex.a;
  72: //    flw_LightMap = r.light;
  73: //    flw_Tint = r.color;
  74:     FLWFinalizeColor(color);
  75: }
  76: 
  77: varying vec2 v2f_texCoords;
  78: varying vec4 v2f_color;
  79: varying float v2f_diffuse;
  80: varying vec2 v2f_light;
  81: 
  82: 
  83: //vec3 flw_WorldPos;
  84: //vec3 flw_Normal;
  85: //vec3 flw_Albedo;
  86: //float flw_Alpha;
  87: //vec2 flw_LightMap;
  88: //vec4 flw_Tint;
  89: 
  90: void main() {
  91:     BlockFrag f;
  92:     f.texCoords = v2f_texCoords;
  93: f.color = v2f_color;
  94: f.diffuse = v2f_diffuse;
  95: f.light = v2f_light;
  96: 
  97: 
  98:     FLWMain(f);
  99: }

[14:02:46] [main/ERROR]: Shader compilation log for create:flap.vert: No errors.

[14:02:46] [main/ERROR]: Source for shader 'create:flap.vert':
   1: #version 110
   2: #define USE_FOG
   3: #define USE_FOG_LINEAR
   4: 
   5: #define PI 3.1415926538
   6: 
   7: uniform float uTime;
   8: uniform mat4 uViewProjection;
   9: uniform vec3 uCameraPos;
  10: 
  11: #if defined(USE_FOG)
  12: varying float FragDistance;
  13: #endif
  14: 
  15: void FLWFinalizeWorldPos(inout vec4 worldPos) {
  16:     #if defined(USE_FOG)
  17:     FragDistance = length(worldPos.xyz - uCameraPos);
  18:     #endif
  19: 
  20:     gl_Position = uViewProjection * worldPos;
  21: }
  22: 
  23: void FLWFinalizeNormal(inout vec3 normal) {
  24:     // noop
  25: }
  26: 
  27: 
  28: mat4 rotate(vec3 axis, float angle) {
  29:     float s = sin(angle);
  30:     float c = cos(angle);
  31:     float oc = 1. - c;
  32: 
  33:     vec3 sa = axis * s;
  34: 
  35:     mat4 mr = mat4(1.);
  36:     mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
  37:     mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
  38:     mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);
  39: 
  40:     return mr;
  41: }
  42: 
  43: mat4 rotation(vec3 rot) {
  44:     return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
  45: }
  46: 
  47: mat3 modelToNormal(mat4 mat) {
  48:     // Discard the edges. This won't be accurate for scaled or skewed matrices,
  49:     // but we don't have to work with those often.
  50:     mat3 m;
  51:     m[0] = mat[0].xyz;
  52:     m[1] = mat[1].xyz;
  53:     m[2] = mat[2].xyz;
  54:     return m;
  55: }
  56: 
  57: #define PIOVER2 1.5707963268
  58: 
  59: vec4 quat(vec3 axis, float angle) {
  60:     float halfAngle = angle * PIOVER2 / 180.0;
  61:     vec2 cs = sin(vec2(PIOVER2 - halfAngle, halfAngle)); // compute sin and cos in one instruction
  62:     return vec4(axis.xyz * cs.y,  cs.x);
  63: }
  64: 
  65: vec4 quatMult(vec4 q1, vec4 q2) {
  66:     // disgustingly vectorized quaternion multiplication
  67:     vec4 a = q1.w * q2.xyzw;
  68:     vec4 b = q1.x * q2.wzxy * vec4(1., -1., 1., -1.);
  69:     vec4 c = q1.y * q2.zwxy * vec4(1., 1., -1., -1.);
  70:     vec4 d = q1.z * q2.yxwz * vec4(-1., 1., 1., -1.);
  71: 
  72:     return a + b + c + d;
  73: }
  74: 
  75: vec3 rotateVertexByQuat(vec3 v, vec4 q) {
  76:     vec3 i = q.xyz;
  77:     return v + 2.0 * cross(i, cross(i, v) + q.w * v);
  78: }
  79: 
  80: vec3 rotateAbout(vec3 v, vec3 axis, float angle) {
  81:     return rotateVertexByQuat(v, quat(axis, angle));
  82: }
  83: 
  84: float diffuse(vec3 normal) {
  85:     vec3 n2 = normal * normal * vec3(.6, .25, .8);
  86:     return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
  87: }
  88: 
  89: 
  90: struct Flap {
  91:     vec3 instancePos;
  92:     vec2 light;
  93:     vec3 segmentOffset;
  94:     vec3 pivot;
  95:     float horizontalAngle;
  96:     float intensity;
  97:     float flapScale;
  98:     float flapness;
  99: };
 100: 
 101: 
 102: struct Vertex {
 103:     vec3 pos;
 104:     vec3 normal;
 105:     vec2 texCoords;
 106: };
 107: 
 108: struct BlockFrag {
 109:     vec2 texCoords;
 110:     vec4 color;
 111:     float diffuse;
 112:     vec2 light;
 113: };
 114: 
 115: 
 116: float toRad(float degrees) {
 117:     return fract(degrees / 360.) * PI * 2.;
 118: }
 119: 
 120: float getFlapAngle(float flapness, float intensity, float scale) {
 121:     float absFlap = abs(flapness);
 122: 
 123:     float angle = sin((1. - absFlap) * PI * intensity) * 30. * flapness * scale;
 124: 
 125:     float halfAngle = angle * 0.5;
 126: 
 127:     float which = step(0., flapness);// 0 if negative, 1 if positive
 128:     float degrees = which * halfAngle + (1. - which) * angle;// branchless conditional multiply
 129: 
 130:     return degrees;
 131: }
 132: 
 133: BlockFrag FLWMain(Vertex v, Flap flap) {
 134:     float flapAngle = getFlapAngle(flap.flapness, flap.intensity, flap.flapScale);
 135: 
 136:     vec4 orientation = quat(vec3(0., 1., 0.), -flap.horizontalAngle);
 137:     vec4 flapRotation = quat(vec3(1., 0., 0.), flapAngle);
 138: 
 139:     vec3 rotated = rotateVertexByQuat(v.pos - flap.pivot, flapRotation) + flap.pivot + flap.segmentOffset;
 140:     rotated = rotateVertexByQuat(rotated - .5, orientation) + flap.instancePos + .5;
 141: 
 142:     vec4 worldPos = vec4(rotated, 1.);
 143:     vec3 norm = rotateVertexByQuat(rotateVertexByQuat(v.normal, flapRotation), orientation);
 144: 
 145:     FLWFinalizeWorldPos(worldPos);
 146:     FLWFinalizeNormal(norm);
 147: 
 148:     BlockFrag b;
 149:     b.diffuse = diffuse(norm);
 150:     b.texCoords = v.texCoords;
 151:     b.light = flap.light;
 152:     #if defined(DEBUG_NORMAL)
 153:     b.color = vec4(norm, 1.);
 154:     #else
 155:     b.color = vec4(1.);
 156:     #endif
 157:     return b;
 158: }
 159: attribute vec3 a_v_pos;
 160: attribute vec3 a_v_normal;
 161: attribute vec2 a_v_texCoords;
 162: 
 163: attribute vec3 a_i_instancePos;
 164: attribute vec2 a_i_light;
 165: attribute vec3 a_i_segmentOffset;
 166: attribute vec3 a_i_pivot;
 167: attribute float a_i_horizontalAngle;
 168: attribute float a_i_intensity;
 169: attribute float a_i_flapScale;
 170: attribute float a_i_flapness;
 171: 
 172: 
 173: varying vec2 v2f_texCoords;
 174: varying vec4 v2f_color;
 175: varying float v2f_diffuse;
 176: varying vec2 v2f_light;
 177: 
 178: 
 179: void main() {
 180:     Vertex v;
 181:     v.pos = a_v_pos;
 182: v.normal = a_v_normal;
 183: v.texCoords = a_v_texCoords;
 184: 
 185: 
 186:     Flap i;
 187:     i.instancePos = a_i_instancePos;
 188: i.light = a_i_light;
 189: i.segmentOffset = a_i_segmentOffset;
 190: i.pivot = a_i_pivot;
 191: i.horizontalAngle = a_i_horizontalAngle;
 192: i.intensity = a_i_intensity;
 193: i.flapScale = a_i_flapScale;
 194: i.flapness = a_i_flapness;
 195: 
 196: 
 197:     BlockFrag o = FLWMain(v, i);
 198: 
 199:     v2f_texCoords = o.texCoords;
 200: v2f_color = o.color;
 201: v2f_diffuse = o.diffuse;
 202: v2f_light = o.light;
 203: 
 204: }

[14:02:46] [main/ERROR]: Shader compilation log for flywheel:block.frag: No errors.

[14:02:46] [main/ERROR]: Source for shader 'flywheel:block.frag':
   1: #version 110
   2: #define USE_FOG
   3: #define USE_FOG_LINEAR
   4: 
   5: #if defined(USE_FOG)
   6: varying float FragDistance;
   7: uniform vec4 uFogColor;
   8: #endif
   9: 
  10: #if defined(USE_FOG_LINEAR)
  11: uniform vec2 uFogRange;
  12: 
  13: float FLWFogFactor() {
  14:     return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
  15: }
  16:     #endif
  17: 
  18:     #if defined(USE_FOG_EXP2)
  19: uniform float uFogDensity;
  20: 
  21: float FLWFogFactor() {
  22:     float dist = FragDistance * uFogDensity;
  23:     return 1. / exp2(dist * dist);
  24: }
  25:     #endif
  26: 
  27: uniform vec2 uTextureScale;
  28: uniform sampler2D uBlockAtlas;
  29: uniform sampler2D uLightMap;
  30: uniform sampler2D uCrumbling;
  31: 
  32: vec4 FLWBlockTexture(vec2 texCoords) {
  33:     vec4 cr = texture2D(uCrumbling, texCoords * uTextureScale);
  34:     float diffuseAlpha = texture2D(uBlockAtlas, texCoords).a;
  35:     cr.a = cr.a * diffuseAlpha;
  36:     return cr;
  37: }
  38: 
  39: void FLWFinalizeColor(vec4 color) {
  40:     #if defined(USE_FOG)
  41:     float a = color.a;
  42:     float fog = clamp(FLWFogFactor(), 0., 1.);
  43: 
  44:     color = mix(uFogColor, color, fog);
  45:     color.a = a;
  46:     #endif
  47: 
  48:     gl_FragColor = color;
  49: }
  50: 
  51: vec4 FLWLight(vec2 lightCoords) {
  52:     return vec4(1.);
  53: }
  54: 
  55: 
  56: 
  57: struct BlockFrag {
  58:     vec2 texCoords;
  59:     vec4 color;
  60:     float diffuse;
  61:     vec2 light;
  62: };
  63: 
  64: void FLWMain(BlockFrag r) {
  65:     vec4 tex = FLWBlockTexture(r.texCoords);
  66: 
  67:     vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;
  68: 
  69: //    flw_WorldPos = ;
  70: //    flw_Normal = ;
  71: //    flw_Albedo = tex.rgb;
  72: //    flw_Alpha = tex.a;
  73: //    flw_LightMap = r.light;
  74: //    flw_Tint = r.color;
  75:     FLWFinalizeColor(color);
  76: }
  77: 
  78: varying vec2 v2f_texCoords;
  79: varying vec4 v2f_color;
  80: varying float v2f_diffuse;
  81: varying vec2 v2f_light;
  82: 
  83: 
  84: //vec3 flw_WorldPos;
  85: //vec3 flw_Normal;
  86: //vec3 flw_Albedo;
  87: //float flw_Alpha;
  88: //vec2 flw_LightMap;
  89: //vec4 flw_Tint;
  90: 
  91: void main() {
  92:     BlockFrag f;
  93:     f.texCoords = v2f_texCoords;
  94: f.color = v2f_color;
  95: f.diffuse = v2f_diffuse;
  96: f.light = v2f_light;
  97: 
  98: 
  99:     FLWMain(f);
 100: }

[14:02:47] [Forge Version Check/INFO]: [codechickenlib] Found status: UP_TO_DATE Current: 4.0.7.445 Target: null
[14:02:47] [Forge Version Check/INFO]: [enderstorage] Starting version check at https://version-check.covers1624.net/check/?mod=EnderStorage&mc=1.16.5
[14:02:47] [main/ERROR]: Shader compilation log for create:flap.vert: No errors.

[14:02:47] [main/ERROR]: Source for shader 'create:flap.vert':
   1: #version 110
   2: #define USE_FOG
   3: #define USE_FOG_EXP2
   4: 
   5: #define PI 3.1415926538
   6: 
   7: uniform float uTime;
   8: uniform mat4 uViewProjection;
   9: uniform vec3 uCameraPos;
  10: 
  11: #if defined(USE_FOG)
  12: varying float FragDistance;
  13: #endif
  14: 
  15: void FLWFinalizeWorldPos(inout vec4 worldPos) {
  16:     #if defined(USE_FOG)
  17:     FragDistance = length(worldPos.xyz - uCameraPos);
  18:     #endif
  19: 
  20:     gl_Position = uViewProjection * worldPos;
  21: }
  22: 
  23: void FLWFinalizeNormal(inout vec3 normal) {
  24:     // noop
  25: }
  26: 
  27: 
  28: mat4 rotate(vec3 axis, float angle) {
  29:     float s = sin(angle);
  30:     float c = cos(angle);
  31:     float oc = 1. - c;
  32: 
  33:     vec3 sa = axis * s;
  34: 
  35:     mat4 mr = mat4(1.);
  36:     mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
  37:     mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
  38:     mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);
  39: 
  40:     return mr;
  41: }
  42: 
  43: mat4 rotation(vec3 rot) {
  44:     return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
  45: }
  46: 
  47: mat3 modelToNormal(mat4 mat) {
  48:     // Discard the edges. This won't be accurate for scaled or skewed matrices,
  49:     // but we don't have to work with those often.
  50:     mat3 m;
  51:     m[0] = mat[0].xyz;
  52:     m[1] = mat[1].xyz;
  53:     m[2] = mat[2].xyz;
  54:     return m;
  55: }
  56: 
  57: #define PIOVER2 1.5707963268
  58: 
  59: vec4 quat(vec3 axis, float angle) {
  60:     float halfAngle = angle * PIOVER2 / 180.0;
  61:     vec2 cs = sin(vec2(PIOVER2 - halfAngle, halfAngle)); // compute sin and cos in one instruction
  62:     return vec4(axis.xyz * cs.y,  cs.x);
  63: }
  64: 
  65: vec4 quatMult(vec4 q1, vec4 q2) {
  66:     // disgustingly vectorized quaternion multiplication
  67:     vec4 a = q1.w * q2.xyzw;
  68:     vec4 b = q1.x * q2.wzxy * vec4(1., -1., 1., -1.);
  69:     vec4 c = q1.y * q2.zwxy * vec4(1., 1., -1., -1.);
  70:     vec4 d = q1.z * q2.yxwz * vec4(-1., 1., 1., -1.);
  71: 
  72:     return a + b + c + d;
  73: }
  74: 
  75: vec3 rotateVertexByQuat(vec3 v, vec4 q) {
  76:     vec3 i = q.xyz;
  77:     return v + 2.0 * cross(i, cross(i, v) + q.w * v);
  78: }
  79: 
  80: vec3 rotateAbout(vec3 v, vec3 axis, float angle) {
  81:     return rotateVertexByQuat(v, quat(axis, angle));
  82: }
  83: 
  84: float diffuse(vec3 normal) {
  85:     vec3 n2 = normal * normal * vec3(.6, .25, .8);
  86:     return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
  87: }
  88: 
  89: 
  90: struct Flap {
  91:     vec3 instancePos;
  92:     vec2 light;
  93:     vec3 segmentOffset;
  94:     vec3 pivot;
  95:     float horizontalAngle;
  96:     float intensity;
  97:     float flapScale;
  98:     float flapness;
  99: };
 100: 
 101: 
 102: struct Vertex {
 103:     vec3 pos;
 104:     vec3 normal;
 105:     vec2 texCoords;
 106: };
 107: 
 108: struct BlockFrag {
 109:     vec2 texCoords;
 110:     vec4 color;
 111:     float diffuse;
 112:     vec2 light;
 113: };
 114: 
 115: 
 116: float toRad(float degrees) {
 117:     return fract(degrees / 360.) * PI * 2.;
 118: }
 119: 
 120: float getFlapAngle(float flapness, float intensity, float scale) {
 121:     float absFlap = abs(flapness);
 122: 
 123:     float angle = sin((1. - absFlap) * PI * intensity) * 30. * flapness * scale;
 124: 
 125:     float halfAngle = angle * 0.5;
 126: 
 127:     float which = step(0., flapness);// 0 if negative, 1 if positive
 128:     float degrees = which * halfAngle + (1. - which) * angle;// branchless conditional multiply
 129: 
 130:     return degrees;
 131: }
 132: 
 133: BlockFrag FLWMain(Vertex v, Flap flap) {
 134:     float flapAngle = getFlapAngle(flap.flapness, flap.intensity, flap.flapScale);
 135: 
 136:     vec4 orientation = quat(vec3(0., 1., 0.), -flap.horizontalAngle);
 137:     vec4 flapRotation = quat(vec3(1., 0., 0.), flapAngle);
 138: 
 139:     vec3 rotated = rotateVertexByQuat(v.pos - flap.pivot, flapRotation) + flap.pivot + flap.segmentOffset;
 140:     rotated = rotateVertexByQuat(rotated - .5, orientation) + flap.instancePos + .5;
 141: 
 142:     vec4 worldPos = vec4(rotated, 1.);
 143:     vec3 norm = rotateVertexByQuat(rotateVertexByQuat(v.normal, flapRotation), orientation);
 144: 
 145:     FLWFinalizeWorldPos(worldPos);
 146:     FLWFinalizeNormal(norm);
 147: 
 148:     BlockFrag b;
 149:     b.diffuse = diffuse(norm);
 150:     b.texCoords = v.texCoords;
 151:     b.light = flap.light;
 152:     #if defined(DEBUG_NORMAL)
 153:     b.color = vec4(norm, 1.);
 154:     #else
 155:     b.color = vec4(1.);
 156:     #endif
 157:     return b;
 158: }
 159: attribute vec3 a_v_pos;
 160: attribute vec3 a_v_normal;
 161: attribute vec2 a_v_texCoords;
 162: 
 163: attribute vec3 a_i_instancePos;
 164: attribute vec2 a_i_light;
 165: attribute vec3 a_i_segmentOffset;
 166: attribute vec3 a_i_pivot;
 167: attribute float a_i_horizontalAngle;
 168: attribute float a_i_intensity;
 169: attribute float a_i_flapScale;
 170: attribute float a_i_flapness;
 171: 
 172: 
 173: varying vec2 v2f_texCoords;
 174: varying vec4 v2f_color;
 175: varying float v2f_diffuse;
 176: varying vec2 v2f_light;
 177: 
 178: 
 179: void main() {
 180:     Vertex v;
 181:     v.pos = a_v_pos;
 182: v.normal = a_v_normal;
 183: v.texCoords = a_v_texCoords;
 184: 
 185: 
 186:     Flap i;
 187:     i.instancePos = a_i_instancePos;
 188: i.light = a_i_light;
 189: i.segmentOffset = a_i_segmentOffset;
 190: i.pivot = a_i_pivot;
 191: i.horizontalAngle = a_i_horizontalAngle;
 192: i.intensity = a_i_intensity;
 193: i.flapScale = a_i_flapScale;
 194: i.flapness = a_i_flapness;
 195: 
 196: 
 197:     BlockFrag o = FLWMain(v, i);
 198: 
 199:     v2f_texCoords = o.texCoords;
 200: v2f_color = o.color;
 201: v2f_diffuse = o.diffuse;
 202: v2f_light = o.light;
 203: 
 204: }

[14:02:47] [main/ERROR]: Shader compilation log for flywheel:block.frag: No errors.

[14:02:47] [main/ERROR]: Source for shader 'flywheel:block.frag':
   1: #version 110
   2: #define USE_FOG
   3: #define USE_FOG_EXP2
   4: 
   5: #if defined(USE_FOG)
   6: varying float FragDistance;
   7: uniform vec4 uFogColor;
   8: #endif
   9: 
  10: #if defined(USE_FOG_LINEAR)
  11: uniform vec2 uFogRange;
  12: 
  13: float FLWFogFactor() {
  14:     return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
  15: }
  16:     #endif
  17: 
  18:     #if defined(USE_FOG_EXP2)
  19: uniform float uFogDensity;
  20: 
  21: float FLWFogFactor() {
  22:     float dist = FragDistance * uFogDensity;
  23:     return 1. / exp2(dist * dist);
  24: }
  25:     #endif
  26: 
  27: uniform vec2 uTextureScale;
  28: uniform sampler2D uBlockAtlas;
  29: uniform sampler2D uLightMap;
  30: uniform sampler2D uCrumbling;
  31: 
  32: vec4 FLWBlockTexture(vec2 texCoords) {
  33:     vec4 cr = texture2D(uCrumbling, texCoords * uTextureScale);
  34:     float diffuseAlpha = texture2D(uBlockAtlas, texCoords).a;
  35:     cr.a = cr.a * diffuseAlpha;
  36:     return cr;
  37: }
  38: 
  39: void FLWFinalizeColor(vec4 color) {
  40:     #if defined(USE_FOG)
  41:     float a = color.a;
  42:     float fog = clamp(FLWFogFactor(), 0., 1.);
  43: 
  44:     color = mix(uFogColor, color, fog);
  45:     color.a = a;
  46:     #endif
  47: 
  48:     gl_FragColor = color;
  49: }
  50: 
  51: vec4 FLWLight(vec2 lightCoords) {
  52:     return vec4(1.);
  53: }
  54: 
  55: 
  56: 
  57: struct BlockFrag {
  58:     vec2 texCoords;
  59:     vec4 color;
  60:     float diffuse;
  61:     vec2 light;
  62: };
  63: 
  64: void FLWMain(BlockFrag r) {
  65:     vec4 tex = FLWBlockTexture(r.texCoords);
  66: 
  67:     vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;
  68: 
  69: //    flw_WorldPos = ;
  70: //    flw_Normal = ;
  71: //    flw_Albedo = tex.rgb;
  72: //    flw_Alpha = tex.a;
  73: //    flw_LightMap = r.light;
  74: //    flw_Tint = r.color;
  75:     FLWFinalizeColor(color);
  76: }
  77: 
  78: varying vec2 v2f_texCoords;
  79: varying vec4 v2f_color;
  80: varying float v2f_diffuse;
  81: varying vec2 v2f_light;
  82: 
  83: 
  84: //vec3 flw_WorldPos;
  85: //vec3 flw_Normal;
  86: //vec3 flw_Albedo;
  87: //float flw_Alpha;
  88: //vec2 flw_LightMap;
  89: //vec4 flw_Tint;
  90: 
  91: void main() {
  92:     BlockFrag f;
  93:     f.texCoords = v2f_texCoords;
  94: f.color = v2f_color;
  95: f.diffuse = v2f_diffuse;
  96: f.light = v2f_light;
  97: 
  98: 
  99:     FLWMain(f);
 100: }

[14:02:47] [main/ERROR]: Shader compilation log for create:flap.vert: No errors.

[14:02:47] [main/ERROR]: Source for shader 'create:flap.vert':
   1: #version 110
   2: 
   3: #define PI 3.1415926538
   4: 
   5: uniform float uTime;
   6: uniform mat4 uViewProjection;
   7: uniform vec3 uCameraPos;
   8: 
   9: #if defined(USE_FOG)
  10: varying float FragDistance;
  11: #endif
  12: 
  13: void FLWFinalizeWorldPos(inout vec4 worldPos) {
  14:     #if defined(USE_FOG)
  15:     FragDistance = length(worldPos.xyz - uCameraPos);
  16:     #endif
  17: 
  18:     gl_Position = uViewProjection * worldPos;
  19: }
  20: 
  21: void FLWFinalizeNormal(inout vec3 normal) {
  22:     // noop
  23: }
  24: 
  25: 
  26: mat4 rotate(vec3 axis, float angle) {
  27:     float s = sin(angle);
  28:     float c = cos(angle);
  29:     float oc = 1. - c;
  30: 
  31:     vec3 sa = axis * s;
  32: 
  33:     mat4 mr = mat4(1.);
  34:     mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
  35:     mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
  36:     mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);
  37: 
  38:     return mr;
  39: }
  40: 
  41: mat4 rotation(vec3 rot) {
  42:     return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
  43: }
  44: 
  45: mat3 modelToNormal(mat4 mat) {
  46:     // Discard the edges. This won't be accurate for scaled or skewed matrices,
  47:     // but we don't have to work with those often.
  48:     mat3 m;
  49:     m[0] = mat[0].xyz;
  50:     m[1] = mat[1].xyz;
  51:     m[2] = mat[2].xyz;
  52:     return m;
  53: }
  54: 
  55: #define PIOVER2 1.5707963268
  56: 
  57: vec4 quat(vec3 axis, float angle) {
  58:     float halfAngle = angle * PIOVER2 / 180.0;
  59:     vec2 cs = sin(vec2(PIOVER2 - halfAngle, halfAngle)); // compute sin and cos in one instruction
  60:     return vec4(axis.xyz * cs.y,  cs.x);
  61: }
  62: 
  63: vec4 quatMult(vec4 q1, vec4 q2) {
  64:     // disgustingly vectorized quaternion multiplication
  65:     vec4 a = q1.w * q2.xyzw;
  66:     vec4 b = q1.x * q2.wzxy * vec4(1., -1., 1., -1.);
  67:     vec4 c = q1.y * q2.zwxy * vec4(1., 1., -1., -1.);
  68:     vec4 d = q1.z * q2.yxwz * vec4(-1., 1., 1., -1.);
  69: 
  70:     return a + b + c + d;
  71: }
  72: 
  73: vec3 rotateVertexByQuat(vec3 v, vec4 q) {
  74:     vec3 i = q.xyz;
  75:     return v + 2.0 * cross(i, cross(i, v) + q.w * v);
  76: }
  77: 
  78: vec3 rotateAbout(vec3 v, vec3 axis, float angle) {
  79:     return rotateVertexByQuat(v, quat(axis, angle));
  80: }
  81: 
  82: float diffuse(vec3 normal) {
  83:     vec3 n2 = normal * normal * vec3(.6, .25, .8);
  84:     return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
  85: }
  86: 
  87: 
  88: struct Flap {
  89:     vec3 instancePos;
  90:     vec2 light;
  91:     vec3 segmentOffset;
  92:     vec3 pivot;
  93:     float horizontalAngle;
  94:     float intensity;
  95:     float flapScale;
  96:     float flapness;
  97: };
  98: 
  99: 
 100: struct Vertex {
 101:     vec3 pos;
 102:     vec3 normal;
 103:     vec2 texCoords;
 104: };
 105: 
 106: struct BlockFrag {
 107:     vec2 texCoords;
 108:     vec4 color;
 109:     float diffuse;
 110:     vec2 light;
 111: };
 112: 
 113: 
 114: float toRad(float degrees) {
 115:     return fract(degrees / 360.) * PI * 2.;
 116: }
 117: 
 118: float getFlapAngle(float flapness, float intensity, float scale) {
 119:     float absFlap = abs(flapness);
 120: 
 121:     float angle = sin((1. - absFlap) * PI * intensity) * 30. * flapness * scale;
 122: 
 123:     float halfAngle = angle * 0.5;
 124: 
 125:     float which = step(0., flapness);// 0 if negative, 1 if positive
 126:     float degrees = which * halfAngle + (1. - which) * angle;// branchless conditional multiply
 127: 
 128:     return degrees;
 129: }
 130: 
 131: BlockFrag FLWMain(Vertex v, Flap flap) {
 132:     float flapAngle = getFlapAngle(flap.flapness, flap.intensity, flap.flapScale);
 133: 
 134:     vec4 orientation = quat(vec3(0., 1., 0.), -flap.horizontalAngle);
 135:     vec4 flapRotation = quat(vec3(1., 0., 0.), flapAngle);
 136: 
 137:     vec3 rotated = rotateVertexByQuat(v.pos - flap.pivot, flapRotation) + flap.pivot + flap.segmentOffset;
 138:     rotated = rotateVertexByQuat(rotated - .5, orientation) + flap.instancePos + .5;
 139: 
 140:     vec4 worldPos = vec4(rotated, 1.);
 141:     vec3 norm = rotateVertexByQuat(rotateVertexByQuat(v.normal, flapRotation), orientation);
 142: 
 143:     FLWFinalizeWorldPos(worldPos);
 144:     FLWFinalizeNormal(norm);
 145: 
 146:     BlockFrag b;
 147:     b.diffuse = diffuse(norm);
 148:     b.texCoords = v.texCoords;
 149:     b.light = flap.light;
 150:     #if defined(DEBUG_NORMAL)
 151:     b.color = vec4(norm, 1.);
 152:     #else
 153:     b.color = vec4(1.);
 154:     #endif
 155:     return b;
 156: }
 157: attribute vec3 a_v_pos;
 158: attribute vec3 a_v_normal;
 159: attribute vec2 a_v_texCoords;
 160: 
 161: attribute vec3 a_i_instancePos;
 162: attribute vec2 a_i_light;
 163: attribute vec3 a_i_segmentOffset;
 164: attribute vec3 a_i_pivot;
 165: attribute float a_i_horizontalAngle;
 166: attribute float a_i_intensity;
 167: attribute float a_i_flapScale;
 168: attribute float a_i_flapness;
 169: 
 170: 
 171: varying vec2 v2f_texCoords;
 172: varying vec4 v2f_color;
 173: varying float v2f_diffuse;
 174: varying vec2 v2f_light;
 175: 
 176: 
 177: void main() {
 178:     Vertex v;
 179:     v.pos = a_v_pos;
 180: v.normal = a_v_normal;
 181: v.texCoords = a_v_texCoords;
 182: 
 183: 
 184:     Flap i;
 185:     i.instancePos = a_i_instancePos;
 186: i.light = a_i_light;
 187: i.segmentOffset = a_i_segmentOffset;
 188: i.pivot = a_i_pivot;
 189: i.horizontalAngle = a_i_horizontalAngle;
 190: i.intensity = a_i_intensity;
 191: i.flapScale = a_i_flapScale;
 192: i.flapness = a_i_flapness;
 193: 
 194: 
 195:     BlockFrag o = FLWMain(v, i);
 196: 
 197:     v2f_texCoords = o.texCoords;
 198: v2f_color = o.color;
 199: v2f_diffuse = o.diffuse;
 200: v2f_light = o.light;
 201: 
 202: }

[14:02:47] [main/ERROR]: Shader compilation log for flywheel:block.frag: No errors.

[14:02:47] [main/ERROR]: Source for shader 'flywheel:block.frag':
   1: #version 110
   2: 
   3: #if defined(USE_FOG)
   4: varying float FragDistance;
   5: uniform vec4 uFogColor;
   6: #endif
   7: 
   8: #if defined(USE_FOG_LINEAR)
   9: uniform vec2 uFogRange;
  10: 
  11: float FLWFogFactor() {
  12:     return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
  13: }
  14:     #endif
  15: 
  16:     #if defined(USE_FOG_EXP2)
  17: uniform float uFogDensity;
  18: 
  19: float FLWFogFactor() {
  20:     float dist = FragDistance * uFogDensity;
  21:     return 1. / exp2(dist * dist);
  22: }
  23:     #endif
  24: 
  25: uniform vec2 uTextureScale;
  26: uniform sampler2D uBlockAtlas;
  27: uniform sampler2D uLightMap;
  28: uniform sampler2D uCrumbling;
  29: 
  30: vec4 FLWBlockTexture(vec2 texCoords) {
  31:     vec4 cr = texture2D(uCrumbling, texCoords * uTextureScale);
  32:     float diffuseAlpha = texture2D(uBlockAtlas, texCoords).a;
  33:     cr.a = cr.a * diffuseAlpha;
  34:     return cr;
  35: }
  36: 
  37: void FLWFinalizeColor(vec4 color) {
  38:     #if defined(USE_FOG)
  39:     float a = color.a;
  40:     float fog = clamp(FLWFogFactor(), 0., 1.);
  41: 
  42:     color = mix(uFogColor, color, fog);
  43:     color.a = a;
  44:     #endif
  45: 
  46:     gl_FragColor = color;
  47: }
  48: 
  49: vec4 FLWLight(vec2 lightCoords) {
  50:     return vec4(1.);
  51: }
  52: 
  53: 
  54: 
  55: struct BlockFrag {
  56:     vec2 texCoords;
  57:     vec4 color;
  58:     float diffuse;
  59:     vec2 light;
  60: };
  61: 
  62: void FLWMain(BlockFrag r) {
  63:     vec4 tex = FLWBlockTexture(r.texCoords);
  64: 
  65:     vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;
  66: 
  67: //    flw_WorldPos = ;
  68: //    flw_Normal = ;
  69: //    flw_Albedo = tex.rgb;
  70: //    flw_Alpha = tex.a;
  71: //    flw_LightMap = r.light;
  72: //    flw_Tint = r.color;
  73:     FLWFinalizeColor(color);
  74: }
  75: 
  76: varying vec2 v2f_texCoords;
  77: varying vec4 v2f_color;
  78: varying float v2f_diffuse;
  79: varying vec2 v2f_light;
  80: 
  81: 
  82: //vec3 flw_WorldPos;
  83: //vec3 flw_Normal;
  84: //vec3 flw_Albedo;
  85: //float flw_Alpha;
  86: //vec2 flw_LightMap;
  87: //vec4 flw_Tint;
  88: 
  89: void main() {
  90:     BlockFrag f;
  91:     f.texCoords = v2f_texCoords;
  92: f.color = v2f_color;
  93: f.diffuse = v2f_diffuse;
  94: f.light = v2f_light;
  95: 
  96: 
  97:     FLWMain(f);
  98: }

[14:02:47] [main/ERROR]: Shader compilation log for create:belt.vert: No errors.

[14:02:47] [main/ERROR]: Source for shader 'create:belt.vert':
   1: #version 110
   2: #define DEBUG_RAINBOW
   3: 
   4: #define PI 3.1415926538
   5: 
   6: uniform float uTime;
   7: uniform mat4 uViewProjection;
   8: uniform vec3 uCameraPos;
   9: 
  10: #if defined(USE_FOG)
  11: varying float FragDistance;
  12: #endif
  13: 
  14: void FLWFinalizeWorldPos(inout vec4 worldPos) {
  15:     #if defined(USE_FOG)
  16:     FragDistance = length(worldPos.xyz - uCameraPos);
  17:     #endif
  18: 
  19:     gl_Position = uViewProjection * worldPos;
  20: }
  21: 
  22: void FLWFinalizeNormal(inout vec3 normal) {
  23:     // noop
  24: }
  25: 
  26: 
  27: #define PIOVER2 1.5707963268
  28: 
  29: vec4 quat(vec3 axis, float angle) {
  30:     float halfAngle = angle * PIOVER2 / 180.0;
  31:     vec2 cs = sin(vec2(PIOVER2 - halfAngle, halfAngle)); // compute sin and cos in one instruction
  32:     return vec4(axis.xyz * cs.y,  cs.x);
  33: }
  34: 
  35: vec4 quatMult(vec4 q1, vec4 q2) {
  36:     // disgustingly vectorized quaternion multiplication
  37:     vec4 a = q1.w * q2.xyzw;
  38:     vec4 b = q1.x * q2.wzxy * vec4(1., -1., 1., -1.);
  39:     vec4 c = q1.y * q2.zwxy * vec4(1., 1., -1., -1.);
  40:     vec4 d = q1.z * q2.yxwz * vec4(-1., 1., 1., -1.);
  41: 
  42:     return a + b + c + d;
  43: }
  44: 
  45: vec3 rotateVertexByQuat(vec3 v, vec4 q) {
  46:     vec3 i = q.xyz;
  47:     return v + 2.0 * cross(i, cross(i, v) + q.w * v);
  48: }
  49: 
  50: vec3 rotateAbout(vec3 v, vec3 axis, float angle) {
  51:     return rotateVertexByQuat(v, quat(axis, angle));
  52: }
  53: 
  54: mat4 rotate(vec3 axis, float angle) {
  55:     float s = sin(angle);
  56:     float c = cos(angle);
  57:     float oc = 1. - c;
  58: 
  59:     vec3 sa = axis * s;
  60: 
  61:     mat4 mr = mat4(1.);
  62:     mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
  63:     mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
  64:     mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);
  65: 
  66:     return mr;
  67: }
  68: 
  69: mat4 rotation(vec3 rot) {
  70:     return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
  71: }
  72: 
  73: mat3 modelToNormal(mat4 mat) {
  74:     // Discard the edges. This won't be accurate for scaled or skewed matrices,
  75:     // but we don't have to work with those often.
  76:     mat3 m;
  77:     m[0] = mat[0].xyz;
  78:     m[1] = mat[1].xyz;
  79:     m[2] = mat[2].xyz;
  80:     return m;
  81: }
  82: 
  83: float diffuse(vec3 normal) {
  84:     vec3 n2 = normal * normal * vec3(.6, .25, .8);
  85:     return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
  86: }
  87: 
  88: 
  89: struct Belt {
  90:     vec2 light;
  91:     vec4 color;
  92:     vec3 pos;
  93:     float speed;
  94:     float offset;
  95:     vec4 rotation;
  96:     vec2 sourceTexture;
  97:     vec4 scrollTexture;
  98:     float scrollMult;
  99: };
 100: 
 101: 
 102: struct Vertex {
 103:     vec3 pos;
 104:     vec3 normal;
 105:     vec2 texCoords;
 106: };
 107: 
 108: struct BlockFrag {
 109:     vec2 texCoords;
 110:     vec4 color;
 111:     float diffuse;
 112:     vec2 light;
 113: };
 114: 
 115: BlockFrag FLWMain(Vertex v, Belt instance) {
 116:     vec3 rotated = rotateVertexByQuat(v.pos - .5, instance.rotation) + instance.pos + .5;
 117: 
 118:     vec4 worldPos = vec4(rotated, 1.);
 119: 
 120:     vec3 norm = rotateVertexByQuat(v.normal, instance.rotation);
 121: 
 122:     FLWFinalizeWorldPos(worldPos);
 123:     FLWFinalizeNormal(norm);
 124: 
 125:     float scrollSize = instance.scrollTexture.w - instance.scrollTexture.y;
 126:     float scroll = fract(instance.speed * uTime / (31.5 * 16.) + instance.offset) * scrollSize * instance.scrollMult;
 127: 
 128:     BlockFrag b;
 129:     b.diffuse = diffuse(norm);
 130:     b.texCoords = v.texCoords - instance.sourceTexture + instance.scrollTexture.xy + vec2(0, scroll);
 131:     b.light = instance.light;
 132: 
 133:     #if defined(DEBUG_RAINBOW)
 134:     b.color = instance.color;
 135:     #elif defined(DEBUG_NORMAL)
 136:     b.color = vec4(norm, 1.);
 137:     #else
 138:     b.color = vec4(1.);
 139:     #endif
 140: 
 141:     return b;
 142: }
 143: attribute vec3 a_v_pos;
 144: attribute vec3 a_v_normal;
 145: attribute vec2 a_v_texCoords;
 146: 
 147: attribute vec2 a_i_light;
 148: attribute vec4 a_i_color;
 149: attribute vec3 a_i_pos;
 150: attribute float a_i_speed;
 151: attribute float a_i_offset;
 152: attribute vec4 a_i_rotation;
 153: attribute vec2 a_i_sourceTexture;
 154: attribute vec4 a_i_scrollTexture;
 155: attribute float a_i_scrollMult;
 156: 
 157: 
 158: varying vec2 v2f_texCoords;
 159: varying vec4 v2f_color;
 160: varying float v2f_diffuse;
 161: varying vec2 v2f_light;
 162: 
 163: 
 164: void main() {
 165:     Vertex v;
 166:     v.pos = a_v_pos;
 167: v.normal = a_v_normal;
 168: v.texCoords = a_v_texCoords;
 169: 
 170: 
 171:     Belt i;
 172:     i.light = a_i_light;
 173: i.color = a_i_color;
 174: i.pos = a_i_pos;
 175: i.speed = a_i_speed;
 176: i.offset = a_i_offset;
 177: i.rotation = a_i_rotation;
 178: i.sourceTexture = a_i_sourceTexture;
 179: i.scrollTexture = a_i_scrollTexture;
 180: i.scrollMult = a_i_scrollMult;
 181: 
 182: 
 183:     BlockFrag o = FLWMain(v, i);
 184: 
 185:     v2f_texCoords = o.texCoords;
 186: v2f_color = o.color;
 187: v2f_diffuse = o.diffuse;
 188: v2f_light = o.light;
 189: 
 190: }

[14:02:47] [main/ERROR]: Shader compilation log for flywheel:block.frag: No errors.

[14:02:47] [main/ERROR]: Source for shader 'flywheel:block.frag':
   1: #version 110
   2: #define DEBUG_RAINBOW
   3: 
   4: #if defined(USE_FOG)
   5: varying float FragDistance;
   6: uniform vec4 uFogColor;
   7: #endif
   8: 
   9: #if defined(USE_FOG_LINEAR)
  10: uniform vec2 uFogRange;
  11: 
  12: float FLWFogFactor() {
  13:     return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
  14: }
  15:     #endif
  16: 
  17:     #if defined(USE_FOG_EXP2)
  18: uniform float uFogDensity;
  19: 
  20: float FLWFogFactor() {
  21:     float dist = FragDistance * uFogDensity;
  22:     return 1. / exp2(dist * dist);
  23: }
  24:     #endif
  25: 
  26: uniform vec2 uTextureScale;
  27: uniform sampler2D uBlockAtlas;
  28: uniform sampler2D uLightMap;
  29: uniform sampler2D uCrumbling;
  30: 
  31: vec4 FLWBlockTexture(vec2 texCoords) {
  32:     vec4 cr = texture2D(uCrumbling, texCoords * uTextureScale);
  33:     float diffuseAlpha = texture2D(uBlockAtlas, texCoords).a;
  34:     cr.a = cr.a * diffuseAlpha;
  35:     return cr;
  36: }
  37: 
  38: void FLWFinalizeColor(vec4 color) {
  39:     #if defined(USE_FOG)
  40:     float a = color.a;
  41:     float fog = clamp(FLWFogFactor(), 0., 1.);
  42: 
  43:     color = mix(uFogColor, color, fog);
  44:     color.a = a;
  45:     #endif
  46: 
  47:     gl_FragColor = color;
  48: }
  49: 
  50: vec4 FLWLight(vec2 lightCoords) {
  51:     return vec4(1.);
  52: }
  53: 
  54: 
  55: 
  56: struct BlockFrag {
  57:     vec2 texCoords;
  58:     vec4 color;
  59:     float diffuse;
  60:     vec2 light;
  61: };
  62: 
  63: void FLWMain(BlockFrag r) {
  64:     vec4 tex = FLWBlockTexture(r.texCoords);
  65: 
  66:     vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;
  67: 
  68: //    flw_WorldPos = ;
  69: //    flw_Normal = ;
  70: //    flw_Albedo = tex.rgb;
  71: //    flw_Alpha = tex.a;
  72: //    flw_LightMap = r.light;
  73: //    flw_Tint = r.color;
  74:     FLWFinalizeColor(color);
  75: }
  76: 
  77: varying vec2 v2f_texCoords;
  78: varying vec4 v2f_color;
  79: varying float v2f_diffuse;
  80: varying vec2 v2f_light;
  81: 
  82: 
  83: //vec3 flw_WorldPos;
  84: //vec3 flw_Normal;
  85: //vec3 flw_Albedo;
  86: //float flw_Alpha;
  87: //vec2 flw_LightMap;
  88: //vec4 flw_Tint;
  89: 
  90: void main() {
  91:     BlockFrag f;
  92:     f.texCoords = v2f_texCoords;
  93: f.color = v2f_color;
  94: f.diffuse = v2f_diffuse;
  95: f.light = v2f_light;
  96: 
  97: 
  98:     FLWMain(f);
  99: }

[14:02:47] [main/ERROR]: Shader compilation log for create:belt.vert: No errors.

[14:02:47] [main/ERROR]: Source for shader 'create:belt.vert':
   1: #version 110
   2: #define DEBUG_NORMAL
   3: 
   4: #define PI 3.1415926538
   5: 
   6: uniform float uTime;
   7: uniform mat4 uViewProjection;
   8: uniform vec3 uCameraPos;
   9: 
  10: #if defined(USE_FOG)
  11: varying float FragDistance;
  12: #endif
  13: 
  14: void FLWFinalizeWorldPos(inout vec4 worldPos) {
  15:     #if defined(USE_FOG)
  16:     FragDistance = length(worldPos.xyz - uCameraPos);
  17:     #endif
  18: 
  19:     gl_Position = uViewProjection * worldPos;
  20: }
  21: 
  22: void FLWFinalizeNormal(inout vec3 normal) {
  23:     // noop
  24: }
  25: 
  26: 
  27: #define PIOVER2 1.5707963268
  28: 
  29: vec4 quat(vec3 axis, float angle) {
  30:     float halfAngle = angle * PIOVER2 / 180.0;
  31:     vec2 cs = sin(vec2(PIOVER2 - halfAngle, halfAngle)); // compute sin and cos in one instruction
  32:     return vec4(axis.xyz * cs.y,  cs.x);
  33: }
  34: 
  35: vec4 quatMult(vec4 q1, vec4 q2) {
  36:     // disgustingly vectorized quaternion multiplication
  37:     vec4 a = q1.w * q2.xyzw;
  38:     vec4 b = q1.x * q2.wzxy * vec4(1., -1., 1., -1.);
  39:     vec4 c = q1.y * q2.zwxy * vec4(1., 1., -1., -1.);
  40:     vec4 d = q1.z * q2.yxwz * vec4(-1., 1., 1., -1.);
  41: 
  42:     return a + b + c + d;
  43: }
  44: 
  45: vec3 rotateVertexByQuat(vec3 v, vec4 q) {
  46:     vec3 i = q.xyz;
  47:     return v + 2.0 * cross(i, cross(i, v) + q.w * v);
  48: }
  49: 
  50: vec3 rotateAbout(vec3 v, vec3 axis, float angle) {
  51:     return rotateVertexByQuat(v, quat(axis, angle));
  52: }
  53: 
  54: mat4 rotate(vec3 axis, float angle) {
  55:     float s = sin(angle);
  56:     float c = cos(angle);
  57:     float oc = 1. - c;
  58: 
  59:     vec3 sa = axis * s;
  60: 
  61:     mat4 mr = mat4(1.);
  62:     mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
  63:     mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
  64:     mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);
  65: 
  66:     return mr;
  67: }
  68: 
  69: mat4 rotation(vec3 rot) {
  70:     return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
  71: }
  72: 
  73: mat3 modelToNormal(mat4 mat) {
  74:     // Discard the edges. This won't be accurate for scaled or skewed matrices,
  75:     // but we don't have to work with those often.
  76:     mat3 m;
  77:     m[0] = mat[0].xyz;
  78:     m[1] = mat[1].xyz;
  79:     m[2] = mat[2].xyz;
  80:     return m;
  81: }
  82: 
  83: float diffuse(vec3 normal) {
  84:     vec3 n2 = normal * normal * vec3(.6, .25, .8);
  85:     return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
  86: }
  87: 
  88: 
  89: struct Belt {
  90:     vec2 light;
  91:     vec4 color;
  92:     vec3 pos;
  93:     float speed;
  94:     float offset;
  95:     vec4 rotation;
  96:     vec2 sourceTexture;
  97:     vec4 scrollTexture;
  98:     float scrollMult;
  99: };
 100: 
 101: 
 102: struct Vertex {
 103:     vec3 pos;
 104:     vec3 normal;
 105:     vec2 texCoords;
 106: };
 107: 
 108: struct BlockFrag {
 109:     vec2 texCoords;
 110:     vec4 color;
 111:     float diffuse;
 112:     vec2 light;
 113: };
 114: 
 115: BlockFrag FLWMain(Vertex v, Belt instance) {
 116:     vec3 rotated = rotateVertexByQuat(v.pos - .5, instance.rotation) + instance.pos + .5;
 117: 
 118:     vec4 worldPos = vec4(rotated, 1.);
 119: 
 120:     vec3 norm = rotateVertexByQuat(v.normal, instance.rotation);
 121: 
 122:     FLWFinalizeWorldPos(worldPos);
 123:     FLWFinalizeNormal(norm);
 124: 
 125:     float scrollSize = instance.scrollTexture.w - instance.scrollTexture.y;
 126:     float scroll = fract(instance.speed * uTime / (31.5 * 16.) + instance.offset) * scrollSize * instance.scrollMult;
 127: 
 128:     BlockFrag b;
 129:     b.diffuse = diffuse(norm);
 130:     b.texCoords = v.texCoords - instance.sourceTexture + instance.scrollTexture.xy + vec2(0, scroll);
 131:     b.light = instance.light;
 132: 
 133:     #if defined(DEBUG_RAINBOW)
 134:     b.color = instance.color;
 135:     #elif defined(DEBUG_NORMAL)
 136:     b.color = vec4(norm, 1.);
 137:     #else
 138:     b.color = vec4(1.);
 139:     #endif
 140: 
 141:     return b;
 142: }
 143: attribute vec3 a_v_pos;
 144: attribute vec3 a_v_normal;
 145: attribute vec2 a_v_texCoords;
 146: 
 147: attribute vec2 a_i_light;
 148: attribute vec4 a_i_color;
 149: attribute vec3 a_i_pos;
 150: attribute float a_i_speed;
 151: attribute float a_i_offset;
 152: attribute vec4 a_i_rotation;
 153: attribute vec2 a_i_sourceTexture;
 154: attribute vec4 a_i_scrollTexture;
 155: attribute float a_i_scrollMult;
 156: 
 157: 
 158: varying vec2 v2f_texCoords;
 159: varying vec4 v2f_color;
 160: varying float v2f_diffuse;
 161: varying vec2 v2f_light;
 162: 
 163: 
 164: void main() {
 165:     Vertex v;
 166:     v.pos = a_v_pos;
 167: v.normal = a_v_normal;
 168: v.texCoords = a_v_texCoords;
 169: 
 170: 
 171:     Belt i;
 172:     i.light = a_i_light;
 173: i.color = a_i_color;
 174: i.pos = a_i_pos;
 175: i.speed = a_i_speed;
 176: i.offset = a_i_offset;
 177: i.rotation = a_i_rotation;
 178: i.sourceTexture = a_i_sourceTexture;
 179: i.scrollTexture = a_i_scrollTexture;
 180: i.scrollMult = a_i_scrollMult;
 181: 
 182: 
 183:     BlockFrag o = FLWMain(v, i);
 184: 
 185:     v2f_texCoords = o.texCoords;
 186: v2f_color = o.color;
 187: v2f_diffuse = o.diffuse;
 188: v2f_light = o.light;
 189: 
 190: }

[14:02:47] [main/ERROR]: Shader compilation log for flywheel:block.frag: No errors.

[14:02:47] [main/ERROR]: Source for shader 'flywheel:block.frag':
   1: #version 110
   2: #define DEBUG_NORMAL
   3: 
   4: #if defined(USE_FOG)
   5: varying float FragDistance;
   6: uniform vec4 uFogColor;
   7: #endif
   8: 
   9: #if defined(USE_FOG_LINEAR)
  10: uniform vec2 uFogRange;
  11: 
  12: float FLWFogFactor() {
  13:     return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
  14: }
  15:     #endif
  16: 
  17:     #if defined(USE_FOG_EXP2)
  18: uniform float uFogDensity;
  19: 
  20: float FLWFogFactor() {
  21:     float dist = FragDistance * uFogDensity;
  22:     return 1. / exp2(dist * dist);
  23: }
  24:     #endif
  25: 
  26: uniform vec2 uTextureScale;
  27: uniform sampler2D uBlockAtlas;
  28: uniform sampler2D uLightMap;
  29: uniform sampler2D uCrumbling;
  30: 
  31: vec4 FLWBlockTexture(vec2 texCoords) {
  32:     vec4 cr = texture2D(uCrumbling, texCoords * uTextureScale);
  33:     float diffuseAlpha = texture2D(uBlockAtlas, texCoords).a;
  34:     cr.a = cr.a * diffuseAlpha;
  35:     return cr;
  36: }
  37: 
  38: void FLWFinalizeColor(vec4 color) {
  39:     #if defined(USE_FOG)
  40:     float a = color.a;
  41:     float fog = clamp(FLWFogFactor(), 0., 1.);
  42: 
  43:     color = mix(uFogColor, color, fog);
  44:     color.a = a;
  45:     #endif
  46: 
  47:     gl_FragColor = color;
  48: }
  49: 
  50: vec4 FLWLight(vec2 lightCoords) {
  51:     return vec4(1.);
  52: }
  53: 
  54: 
  55: 
  56: struct BlockFrag {
  57:     vec2 texCoords;
  58:     vec4 color;
  59:     float diffuse;
  60:     vec2 light;
  61: };
  62: 
  63: void FLWMain(BlockFrag r) {
  64:     vec4 tex = FLWBlockTexture(r.texCoords);
  65: 
  66:     vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;
  67: 
  68: //    flw_WorldPos = ;
  69: //    flw_Normal = ;
  70: //    flw_Albedo = tex.rgb;
  71: //    flw_Alpha = tex.a;
  72: //    flw_LightMap = r.light;
  73: //    flw_Tint = r.color;
  74:     FLWFinalizeColor(color);
  75: }
  76: 
  77: varying vec2 v2f_texCoords;
  78: varying vec4 v2f_color;
  79: varying float v2f_diffuse;
  80: varying vec2 v2f_light;
  81: 
  82: 
  83: //vec3 flw_WorldPos;
  84: //vec3 flw_Normal;
  85: //vec3 flw_Albedo;
  86: //float flw_Alpha;
  87: //vec2 flw_LightMap;
  88: //vec4 flw_Tint;
  89: 
  90: void main() {
  91:     BlockFrag f;
  92:     f.texCoords = v2f_texCoords;
  93: f.color = v2f_color;
  94: f.diffuse = v2f_diffuse;
  95: f.light = v2f_light;
  96: 
  97: 
  98:     FLWMain(f);
  99: }

[14:02:47] [Forge Version Check/INFO]: [enderstorage] Found status: UP_TO_DATE Current: 2.8.0.168 Target: null
[14:02:47] [main/ERROR]: Shader compilation log for create:belt.vert: No errors.

[14:02:47] [main/ERROR]: Source for shader 'create:belt.vert':
   1: #version 110
   2: #define USE_FOG
   3: #define USE_FOG_LINEAR
   4: 
   5: #define PI 3.1415926538
   6: 
   7: uniform float uTime;
   8: uniform mat4 uViewProjection;
   9: uniform vec3 uCameraPos;
  10: 
  11: #if defined(USE_FOG)
  12: varying float FragDistance;
  13: #endif
  14: 
  15: void FLWFinalizeWorldPos(inout vec4 worldPos) {
  16:     #if defined(USE_FOG)
  17:     FragDistance = length(worldPos.xyz - uCameraPos);
  18:     #endif
  19: 
  20:     gl_Position = uViewProjection * worldPos;
  21: }
  22: 
  23: void FLWFinalizeNormal(inout vec3 normal) {
  24:     // noop
  25: }
  26: 
  27: 
  28: #define PIOVER2 1.5707963268
  29: 
  30: vec4 quat(vec3 axis, float angle) {
  31:     float halfAngle = angle * PIOVER2 / 180.0;
  32:     vec2 cs = sin(vec2(PIOVER2 - halfAngle, halfAngle)); // compute sin and cos in one instruction
  33:     return vec4(axis.xyz * cs.y,  cs.x);
  34: }
  35: 
  36: vec4 quatMult(vec4 q1, vec4 q2) {
  37:     // disgustingly vectorized quaternion multiplication
  38:     vec4 a = q1.w * q2.xyzw;
  39:     vec4 b = q1.x * q2.wzxy * vec4(1., -1., 1., -1.);
  40:     vec4 c = q1.y * q2.zwxy * vec4(1., 1., -1., -1.);
  41:     vec4 d = q1.z * q2.yxwz * vec4(-1., 1., 1., -1.);
  42: 
  43:     return a + b + c + d;
  44: }
  45: 
  46: vec3 rotateVertexByQuat(vec3 v, vec4 q) {
  47:     vec3 i = q.xyz;
  48:     return v + 2.0 * cross(i, cross(i, v) + q.w * v);
  49: }
  50: 
  51: vec3 rotateAbout(vec3 v, vec3 axis, float angle) {
  52:     return rotateVertexByQuat(v, quat(axis, angle));
  53: }
  54: 
  55: mat4 rotate(vec3 axis, float angle) {
  56:     float s = sin(angle);
  57:     float c = cos(angle);
  58:     float oc = 1. - c;
  59: 
  60:     vec3 sa = axis * s;
  61: 
  62:     mat4 mr = mat4(1.);
  63:     mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
  64:     mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
  65:     mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);
  66: 
  67:     return mr;
  68: }
  69: 
  70: mat4 rotation(vec3 rot) {
  71:     return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
  72: }
  73: 
  74: mat3 modelToNormal(mat4 mat) {
  75:     // Discard the edges. This won't be accurate for scaled or skewed matrices,
  76:     // but we don't have to work with those often.
  77:     mat3 m;
  78:     m[0] = mat[0].xyz;
  79:     m[1] = mat[1].xyz;
  80:     m[2] = mat[2].xyz;
  81:     return m;
  82: }
  83: 
  84: float diffuse(vec3 normal) {
  85:     vec3 n2 = normal * normal * vec3(.6, .25, .8);
  86:     return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
  87: }
  88: 
  89: 
  90: struct Belt {
  91:     vec2 light;
  92:     vec4 color;
  93:     vec3 pos;
  94:     float speed;
  95:     float offset;
  96:     vec4 rotation;
  97:     vec2 sourceTexture;
  98:     vec4 scrollTexture;
  99:     float scrollMult;
 100: };
 101: 
 102: 
 103: struct Vertex {
 104:     vec3 pos;
 105:     vec3 normal;
 106:     vec2 texCoords;
 107: };
 108: 
 109: struct BlockFrag {
 110:     vec2 texCoords;
 111:     vec4 color;
 112:     float diffuse;
 113:     vec2 light;
 114: };
 115: 
 116: BlockFrag FLWMain(Vertex v, Belt instance) {
 117:     vec3 rotated = rotateVertexByQuat(v.pos - .5, instance.rotation) + instance.pos + .5;
 118: 
 119:     vec4 worldPos = vec4(rotated, 1.);
 120: 
 121:     vec3 norm = rotateVertexByQuat(v.normal, instance.rotation);
 122: 
 123:     FLWFinalizeWorldPos(worldPos);
 124:     FLWFinalizeNormal(norm);
 125: 
 126:     float scrollSize = instance.scrollTexture.w - instance.scrollTexture.y;
 127:     float scroll = fract(instance.speed * uTime / (31.5 * 16.) + instance.offset) * scrollSize * instance.scrollMult;
 128: 
 129:     BlockFrag b;
 130:     b.diffuse = diffuse(norm);
 131:     b.texCoords = v.texCoords - instance.sourceTexture + instance.scrollTexture.xy + vec2(0, scroll);
 132:     b.light = instance.light;
 133: 
 134:     #if defined(DEBUG_RAINBOW)
 135:     b.color = instance.color;
 136:     #elif defined(DEBUG_NORMAL)
 137:     b.color = vec4(norm, 1.);
 138:     #else
 139:     b.color = vec4(1.);
 140:     #endif
 141: 
 142:     return b;
 143: }
 144: attribute vec3 a_v_pos;
 145: attribute vec3 a_v_normal;
 146: attribute vec2 a_v_texCoords;
 147: 
 148: attribute vec2 a_i_light;
 149: attribute vec4 a_i_color;
 150: attribute vec3 a_i_pos;
 151: attribute float a_i_speed;
 152: attribute float a_i_offset;
 153: attribute vec4 a_i_rotation;
 154: attribute vec2 a_i_sourceTexture;
 155: attribute vec4 a_i_scrollTexture;
 156: attribute float a_i_scrollMult;
 157: 
 158: 
 159: varying vec2 v2f_texCoords;
 160: varying vec4 v2f_color;
 161: varying float v2f_diffuse;
 162: varying vec2 v2f_light;
 163: 
 164: 
 165: void main() {
 166:     Vertex v;
 167:     v.pos = a_v_pos;
 168: v.normal = a_v_normal;
 169: v.texCoords = a_v_texCoords;
 170: 
 171: 
 172:     Belt i;
 173:     i.light = a_i_light;
 174: i.color = a_i_color;
 175: i.pos = a_i_pos;
 176: i.speed = a_i_speed;
 177: i.offset = a_i_offset;
 178: i.rotation = a_i_rotation;
 179: i.sourceTexture = a_i_sourceTexture;
 180: i.scrollTexture = a_i_scrollTexture;
 181: i.scrollMult = a_i_scrollMult;
 182: 
 183: 
 184:     BlockFrag o = FLWMain(v, i);
 185: 
 186:     v2f_texCoords = o.texCoords;
 187: v2f_color = o.color;
 188: v2f_diffuse = o.diffuse;
 189: v2f_light = o.light;
 190: 
 191: }

[14:02:47] [main/ERROR]: Shader compilation log for flywheel:block.frag: No errors.

[14:02:47] [main/ERROR]: Source for shader 'flywheel:block.frag':
   1: #version 110
   2: #define USE_FOG
   3: #define USE_FOG_LINEAR
   4: 
   5: #if defined(USE_FOG)
   6: varying float FragDistance;
   7: uniform vec4 uFogColor;
   8: #endif
   9: 
  10: #if defined(USE_FOG_LINEAR)
  11: uniform vec2 uFogRange;
  12: 
  13: float FLWFogFactor() {
  14:     return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
  15: }
  16:     #endif
  17: 
  18:     #if defined(USE_FOG_EXP2)
  19: uniform float uFogDensity;
  20: 
  21: float FLWFogFactor() {
  22:     float dist = FragDistance * uFogDensity;
  23:     return 1. / exp2(dist * dist);
  24: }
  25:     #endif
  26: 
  27: uniform vec2 uTextureScale;
  28: uniform sampler2D uBlockAtlas;
  29: uniform sampler2D uLightMap;
  30: uniform sampler2D uCrumbling;
  31: 
  32: vec4 FLWBlockTexture(vec2 texCoords) {
  33:     vec4 cr = texture2D(uCrumbling, texCoords * uTextureScale);
  34:     float diffuseAlpha = texture2D(uBlockAtlas, texCoords).a;
  35:     cr.a = cr.a * diffuseAlpha;
  36:     return cr;
  37: }
  38: 
  39: void FLWFinalizeColor(vec4 color) {
  40:     #if defined(USE_FOG)
  41:     float a = color.a;
  42:     float fog = clamp(FLWFogFactor(), 0., 1.);
  43: 
  44:     color = mix(uFogColor, color, fog);
  45:     color.a = a;
  46:     #endif
  47: 
  48:     gl_FragColor = color;
  49: }
  50: 
  51: vec4 FLWLight(vec2 lightCoords) {
  52:     return vec4(1.);
  53: }
  54: 
  55: 
  56: 
  57: struct BlockFrag {
  58:     vec2 texCoords;
  59:     vec4 color;
  60:     float diffuse;
  61:     vec2 light;
  62: };
  63: 
  64: void FLWMain(BlockFrag r) {
  65:     vec4 tex = FLWBlockTexture(r.texCoords);
  66: 
  67:     vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;
  68: 
  69: //    flw_WorldPos = ;
  70: //    flw_Normal = ;
  71: //    flw_Albedo = tex.rgb;
  72: //    flw_Alpha = tex.a;
  73: //    flw_LightMap = r.light;
  74: //    flw_Tint = r.color;
  75:     FLWFinalizeColor(color);
  76: }
  77: 
  78: varying vec2 v2f_texCoords;
  79: varying vec4 v2f_color;
  80: varying float v2f_diffuse;
  81: varying vec2 v2f_light;
  82: 
  83: 
  84: //vec3 flw_WorldPos;
  85: //vec3 flw_Normal;
  86: //vec3 flw_Albedo;
  87: //float flw_Alpha;
  88: //vec2 flw_LightMap;
  89: //vec4 flw_Tint;
  90: 
  91: void main() {
  92:     BlockFrag f;
  93:     f.texCoords = v2f_texCoords;
  94: f.color = v2f_color;
  95: f.diffuse = v2f_diffuse;
  96: f.light = v2f_light;
  97: 
  98: 
  99:     FLWMain(f);
 100: }

[14:02:47] [main/ERROR]: Shader compilation log for create:belt.vert: No errors.

[14:02:47] [main/ERROR]: Source for shader 'create:belt.vert':
   1: #version 110
   2: #define USE_FOG
   3: #define USE_FOG_EXP2
   4: 
   5: #define PI 3.1415926538
   6: 
   7: uniform float uTime;
   8: uniform mat4 uViewProjection;
   9: uniform vec3 uCameraPos;
  10: 
  11: #if defined(USE_FOG)
  12: varying float FragDistance;
  13: #endif
  14: 
  15: void FLWFinalizeWorldPos(inout vec4 worldPos) {
  16:     #if defined(USE_FOG)
  17:     FragDistance = length(worldPos.xyz - uCameraPos);
  18:     #endif
  19: 
  20:     gl_Position = uViewProjection * worldPos;
  21: }
  22: 
  23: void FLWFinalizeNormal(inout vec3 normal) {
  24:     // noop
  25: }
  26: 
  27: 
  28: #define PIOVER2 1.5707963268
  29: 
  30: vec4 quat(vec3 axis, float angle) {
  31:     float halfAngle = angle * PIOVER2 / 180.0;
  32:     vec2 cs = sin(vec2(PIOVER2 - halfAngle, halfAngle)); // compute sin and cos in one instruction
  33:     return vec4(axis.xyz * cs.y,  cs.x);
  34: }
  35: 
  36: vec4 quatMult(vec4 q1, vec4 q2) {
  37:     // disgustingly vectorized quaternion multiplication
  38:     vec4 a = q1.w * q2.xyzw;
  39:     vec4 b = q1.x * q2.wzxy * vec4(1., -1., 1., -1.);
  40:     vec4 c = q1.y * q2.zwxy * vec4(1., 1., -1., -1.);
  41:     vec4 d = q1.z * q2.yxwz * vec4(-1., 1., 1., -1.);
  42: 
  43:     return a + b + c + d;
  44: }
  45: 
  46: vec3 rotateVertexByQuat(vec3 v, vec4 q) {
  47:     vec3 i = q.xyz;
  48:     return v + 2.0 * cross(i, cross(i, v) + q.w * v);
  49: }
  50: 
  51: vec3 rotateAbout(vec3 v, vec3 axis, float angle) {
  52:     return rotateVertexByQuat(v, quat(axis, angle));
  53: }
  54: 
  55: mat4 rotate(vec3 axis, float angle) {
  56:     float s = sin(angle);
  57:     float c = cos(angle);
  58:     float oc = 1. - c;
  59: 
  60:     vec3 sa = axis * s;
  61: 
  62:     mat4 mr = mat4(1.);
  63:     mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
  64:     mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
  65:     mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);
  66: 
  67:     return mr;
  68: }
  69: 
  70: mat4 rotation(vec3 rot) {
  71:     return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
  72: }
  73: 
  74: mat3 modelToNormal(mat4 mat) {
  75:     // Discard the edges. This won't be accurate for scaled or skewed matrices,
  76:     // but we don't have to work with those often.
  77:     mat3 m;
  78:     m[0] = mat[0].xyz;
  79:     m[1] = mat[1].xyz;
  80:     m[2] = mat[2].xyz;
  81:     return m;
  82: }
  83: 
  84: float diffuse(vec3 normal) {
  85:     vec3 n2 = normal * normal * vec3(.6, .25, .8);
  86:     return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
  87: }
  88: 
  89: 
  90: struct Belt {
  91:     vec2 light;
  92:     vec4 color;
  93:     vec3 pos;
  94:     float speed;
  95:     float offset;
  96:     vec4 rotation;
  97:     vec2 sourceTexture;
  98:     vec4 scrollTexture;
  99:     float scrollMult;
 100: };
 101: 
 102: 
 103: struct Vertex {
 104:     vec3 pos;
 105:     vec3 normal;
 106:     vec2 texCoords;
 107: };
 108: 
 109: struct BlockFrag {
 110:     vec2 texCoords;
 111:     vec4 color;
 112:     float diffuse;
 113:     vec2 light;
 114: };
 115: 
 116: BlockFrag FLWMain(Vertex v, Belt instance) {
 117:     vec3 rotated = rotateVertexByQuat(v.pos - .5, instance.rotation) + instance.pos + .5;
 118: 
 119:     vec4 worldPos = vec4(rotated, 1.);
 120: 
 121:     vec3 norm = rotateVertexByQuat(v.normal, instance.rotation);
 122: 
 123:     FLWFinalizeWorldPos(worldPos);
 124:     FLWFinalizeNormal(norm);
 125: 
 126:     float scrollSize = instance.scrollTexture.w - instance.scrollTexture.y;
 127:     float scroll = fract(instance.speed * uTime / (31.5 * 16.) + instance.offset) * scrollSize * instance.scrollMult;
 128: 
 129:     BlockFrag b;
 130:     b.diffuse = diffuse(norm);
 131:     b.texCoords = v.texCoords - instance.sourceTexture + instance.scrollTexture.xy + vec2(0, scroll);
 132:     b.light = instance.light;
 133: 
 134:     #if defined(DEBUG_RAINBOW)
 135:     b.color = instance.color;
 136:     #elif defined(DEBUG_NORMAL)
 137:     b.color = vec4(norm, 1.);
 138:     #else
 139:     b.color = vec4(1.);
 140:     #endif
 141: 
 142:     return b;
 143: }
 144: attribute vec3 a_v_pos;
 145: attribute vec3 a_v_normal;
 146: attribute vec2 a_v_texCoords;
 147: 
 148: attribute vec2 a_i_light;
 149: attribute vec4 a_i_color;
 150: attribute vec3 a_i_pos;
 151: attribute float a_i_speed;
 152: attribute float a_i_offset;
 153: attribute vec4 a_i_rotation;
 154: attribute vec2 a_i_sourceTexture;
 155: attribute vec4 a_i_scrollTexture;
 156: attribute float a_i_scrollMult;
 157: 
 158: 
 159: varying vec2 v2f_texCoords;
 160: varying vec4 v2f_color;
 161: varying float v2f_diffuse;
 162: varying vec2 v2f_light;
 163: 
 164: 
 165: void main() {
 166:     Vertex v;
 167:     v.pos = a_v_pos;
 168: v.normal = a_v_normal;
 169: v.texCoords = a_v_texCoords;
 170: 
 171: 
 172:     Belt i;
 173:     i.light = a_i_light;
 174: i.color = a_i_color;
 175: i.pos = a_i_pos;
 176: i.speed = a_i_speed;
 177: i.offset = a_i_offset;
 178: i.rotation = a_i_rotation;
 179: i.sourceTexture = a_i_sourceTexture;
 180: i.scrollTexture = a_i_scrollTexture;
 181: i.scrollMult = a_i_scrollMult;
 182: 
 183: 
 184:     BlockFrag o = FLWMain(v, i);
 185: 
 186:     v2f_texCoords = o.texCoords;
 187: v2f_color = o.color;
 188: v2f_diffuse = o.diffuse;
 189: v2f_light = o.light;
 190: 
 191: }

[14:02:47] [main/ERROR]: Shader compilation log for flywheel:block.frag: No errors.

[14:02:47] [main/ERROR]: Source for shader 'flywheel:block.frag':
   1: #version 110
   2: #define USE_FOG
   3: #define USE_FOG_EXP2
   4: 
   5: #if defined(USE_FOG)
   6: varying float FragDistance;
   7: uniform vec4 uFogColor;
   8: #endif
   9: 
  10: #if defined(USE_FOG_LINEAR)
  11: uniform vec2 uFogRange;
  12: 
  13: float FLWFogFactor() {
  14:     return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
  15: }
  16:     #endif
  17: 
  18:     #if defined(USE_FOG_EXP2)
  19: uniform float uFogDensity;
  20: 
  21: float FLWFogFactor() {
  22:     float dist = FragDistance * uFogDensity;
  23:     return 1. / exp2(dist * dist);
  24: }
  25:     #endif
  26: 
  27: uniform vec2 uTextureScale;
  28: uniform sampler2D uBlockAtlas;
  29: uniform sampler2D uLightMap;
  30: uniform sampler2D uCrumbling;
  31: 
  32: vec4 FLWBlockTexture(vec2 texCoords) {
  33:     vec4 cr = texture2D(uCrumbling, texCoords * uTextureScale);
  34:     float diffuseAlpha = texture2D(uBlockAtlas, texCoords).a;
  35:     cr.a = cr.a * diffuseAlpha;
  36:     return cr;
  37: }
  38: 
  39: void FLWFinalizeColor(vec4 color) {
  40:     #if defined(USE_FOG)
  41:     float a = color.a;
  42:     float fog = clamp(FLWFogFactor(), 0., 1.);
  43: 
  44:     color = mix(uFogColor, color, fog);
  45:     color.a = a;
  46:     #endif
  47: 
  48:     gl_FragColor = color;
  49: }
  50: 
  51: vec4 FLWLight(vec2 lightCoords) {
  52:     return vec4(1.);
  53: }
  54: 
  55: 
  56: 
  57: struct BlockFrag {
  58:     vec2 texCoords;
  59:     vec4 color;
  60:     float diffuse;
  61:     vec2 light;
  62: };
  63: 
  64: void FLWMain(BlockFrag r) {
  65:     vec4 tex = FLWBlockTexture(r.texCoords);
  66: 
  67:     vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;
  68: 
  69: //    flw_WorldPos = ;
  70: //    flw_Normal = ;
  71: //    flw_Albedo = tex.rgb;
  72: //    flw_Alpha = tex.a;
  73: //    flw_LightMap = r.light;
  74: //    flw_Tint = r.color;
  75:     FLWFinalizeColor(color);
  76: }
  77: 
  78: varying vec2 v2f_texCoords;
  79: varying vec4 v2f_color;
  80: varying float v2f_diffuse;
  81: varying vec2 v2f_light;
  82: 
  83: 
  84: //vec3 flw_WorldPos;
  85: //vec3 flw_Normal;
  86: //vec3 flw_Albedo;
  87: //float flw_Alpha;
  88: //vec2 flw_LightMap;
  89: //vec4 flw_Tint;
  90: 
  91: void main() {
  92:     BlockFrag f;
  93:     f.texCoords = v2f_texCoords;
  94: f.color = v2f_color;
  95: f.diffuse = v2f_diffuse;
  96: f.light = v2f_light;
  97: 
  98: 
  99:     FLWMain(f);
 100: }

[14:02:47] [main/ERROR]: Shader compilation log for create:belt.vert: No errors.

[14:02:47] [main/ERROR]: Source for shader 'create:belt.vert':
   1: #version 110
   2: 
   3: #define PI 3.1415926538
   4: 
   5: uniform float uTime;
   6: uniform mat4 uViewProjection;
   7: uniform vec3 uCameraPos;
   8: 
   9: #if defined(USE_FOG)
  10: varying float FragDistance;
  11: #endif
  12: 
  13: void FLWFinalizeWorldPos(inout vec4 worldPos) {
  14:     #if defined(USE_FOG)
  15:     FragDistance = length(worldPos.xyz - uCameraPos);
  16:     #endif
  17: 
  18:     gl_Position = uViewProjection * worldPos;
  19: }
  20: 
  21: void FLWFinalizeNormal(inout vec3 normal) {
  22:     // noop
  23: }
  24: 
  25: 
  26: #define PIOVER2 1.5707963268
  27: 
  28: vec4 quat(vec3 axis, float angle) {
  29:     float halfAngle = angle * PIOVER2 / 180.0;
  30:     vec2 cs = sin(vec2(PIOVER2 - halfAngle, halfAngle)); // compute sin and cos in one instruction
  31:     return vec4(axis.xyz * cs.y,  cs.x);
  32: }
  33: 
  34: vec4 quatMult(vec4 q1, vec4 q2) {
  35:     // disgustingly vectorized quaternion multiplication
  36:     vec4 a = q1.w * q2.xyzw;
  37:     vec4 b = q1.x * q2.wzxy * vec4(1., -1., 1., -1.);
  38:     vec4 c = q1.y * q2.zwxy * vec4(1., 1., -1., -1.);
  39:     vec4 d = q1.z * q2.yxwz * vec4(-1., 1., 1., -1.);
  40: 
  41:     return a + b + c + d;
  42: }
  43: 
  44: vec3 rotateVertexByQuat(vec3 v, vec4 q) {
  45:     vec3 i = q.xyz;
  46:     return v + 2.0 * cross(i, cross(i, v) + q.w * v);
  47: }
  48: 
  49: vec3 rotateAbout(vec3 v, vec3 axis, float angle) {
  50:     return rotateVertexByQuat(v, quat(axis, angle));
  51: }
  52: 
  53: mat4 rotate(vec3 axis, float angle) {
  54:     float s = sin(angle);
  55:     float c = cos(angle);
  56:     float oc = 1. - c;
  57: 
  58:     vec3 sa = axis * s;
  59: 
  60:     mat4 mr = mat4(1.);
  61:     mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
  62:     mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
  63:     mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);
  64: 
  65:     return mr;
  66: }
  67: 
  68: mat4 rotation(vec3 rot) {
  69:     return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
  70: }
  71: 
  72: mat3 modelToNormal(mat4 mat) {
  73:     // Discard the edges. This won't be accurate for scaled or skewed matrices,
  74:     // but we don't have to work with those often.
  75:     mat3 m;
  76:     m[0] = mat[0].xyz;
  77:     m[1] = mat[1].xyz;
  78:     m[2] = mat[2].xyz;
  79:     return m;
  80: }
  81: 
  82: float diffuse(vec3 normal) {
  83:     vec3 n2 = normal * normal * vec3(.6, .25, .8);
  84:     return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
  85: }
  86: 
  87: 
  88: struct Belt {
  89:     vec2 light;
  90:     vec4 color;
  91:     vec3 pos;
  92:     float speed;
  93:     float offset;
  94:     vec4 rotation;
  95:     vec2 sourceTexture;
  96:     vec4 scrollTexture;
  97:     float scrollMult;
  98: };
  99: 
 100: 
 101: struct Vertex {
 102:     vec3 pos;
 103:     vec3 normal;
 104:     vec2 texCoords;
 105: };
 106: 
 107: struct BlockFrag {
 108:     vec2 texCoords;
 109:     vec4 color;
 110:     float diffuse;
 111:     vec2 light;
 112: };
 113: 
 114: BlockFrag FLWMain(Vertex v, Belt instance) {
 115:     vec3 rotated = rotateVertexByQuat(v.pos - .5, instance.rotation) + instance.pos + .5;
 116: 
 117:     vec4 worldPos = vec4(rotated, 1.);
 118: 
 119:     vec3 norm = rotateVertexByQuat(v.normal, instance.rotation);
 120: 
 121:     FLWFinalizeWorldPos(worldPos);
 122:     FLWFinalizeNormal(norm);
 123: 
 124:     float scrollSize = instance.scrollTexture.w - instance.scrollTexture.y;
 125:     float scroll = fract(instance.speed * uTime / (31.5 * 16.) + instance.offset) * scrollSize * instance.scrollMult;
 126: 
 127:     BlockFrag b;
 128:     b.diffuse = diffuse(norm);
 129:     b.texCoords = v.texCoords - instance.sourceTexture + instance.scrollTexture.xy + vec2(0, scroll);
 130:     b.light = instance.light;
 131: 
 132:     #if defined(DEBUG_RAINBOW)
 133:     b.color = instance.color;
 134:     #elif defined(DEBUG_NORMAL)
 135:     b.color = vec4(norm, 1.);
 136:     #else
 137:     b.color = vec4(1.);
 138:     #endif
 139: 
 140:     return b;
 141: }
 142: attribute vec3 a_v_pos;
 143: attribute vec3 a_v_normal;
 144: attribute vec2 a_v_texCoords;
 145: 
 146: attribute vec2 a_i_light;
 147: attribute vec4 a_i_color;
 148: attribute vec3 a_i_pos;
 149: attribute float a_i_speed;
 150: attribute float a_i_offset;
 151: attribute vec4 a_i_rotation;
 152: attribute vec2 a_i_sourceTexture;
 153: attribute vec4 a_i_scrollTexture;
 154: attribute float a_i_scrollMult;
 155: 
 156: 
 157: varying vec2 v2f_texCoords;
 158: varying vec4 v2f_color;
 159: varying float v2f_diffuse;
 160: varying vec2 v2f_light;
 161: 
 162: 
 163: void main() {
 164:     Vertex v;
 165:     v.pos = a_v_pos;
 166: v.normal = a_v_normal;
 167: v.texCoords = a_v_texCoords;
 168: 
 169: 
 170:     Belt i;
 171:     i.light = a_i_light;
 172: i.color = a_i_color;
 173: i.pos = a_i_pos;
 174: i.speed = a_i_speed;
 175: i.offset = a_i_offset;
 176: i.rotation = a_i_rotation;
 177: i.sourceTexture = a_i_sourceTexture;
 178: i.scrollTexture = a_i_scrollTexture;
 179: i.scrollMult = a_i_scrollMult;
 180: 
 181: 
 182:     BlockFrag o = FLWMain(v, i);
 183: 
 184:     v2f_texCoords = o.texCoords;
 185: v2f_color = o.color;
 186: v2f_diffuse = o.diffuse;
 187: v2f_light = o.light;
 188: 
 189: }

[14:02:47] [main/ERROR]: Shader compilation log for flywheel:block.frag: No errors.

[14:02:47] [main/ERROR]: Source for shader 'flywheel:block.frag':
   1: #version 110
   2: 
   3: #if defined(USE_FOG)
   4: varying float FragDistance;
   5: uniform vec4 uFogColor;
   6: #endif
   7: 
   8: #if defined(USE_FOG_LINEAR)
   9: uniform vec2 uFogRange;
  10: 
  11: float FLWFogFactor() {
  12:     return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
  13: }
  14:     #endif
  15: 
  16:     #if defined(USE_FOG_EXP2)
  17: uniform float uFogDensity;
  18: 
  19: float FLWFogFactor() {
  20:     float dist = FragDistance * uFogDensity;
  21:     return 1. / exp2(dist * dist);
  22: }
  23:     #endif
  24: 
  25: uniform vec2 uTextureScale;
  26: uniform sampler2D uBlockAtlas;
  27: uniform sampler2D uLightMap;
  28: uniform sampler2D uCrumbling;
  29: 
  30: vec4 FLWBlockTexture(vec2 texCoords) {
  31:     vec4 cr = texture2D(uCrumbling, texCoords * uTextureScale);
  32:     float diffuseAlpha = texture2D(uBlockAtlas, texCoords).a;
  33:     cr.a = cr.a * diffuseAlpha;
  34:     return cr;
  35: }
  36: 
  37: void FLWFinalizeColor(vec4 color) {
  38:     #if defined(USE_FOG)
  39:     float a = color.a;
  40:     float fog = clamp(FLWFogFactor(), 0., 1.);
  41: 
  42:     color = mix(uFogColor, color, fog);
  43:     color.a = a;
  44:     #endif
  45: 
  46:     gl_FragColor = color;
  47: }
  48: 
  49: vec4 FLWLight(vec2 lightCoords) {
  50:     return vec4(1.);
  51: }
  52: 
  53: 
  54: 
  55: struct BlockFrag {
  56:     vec2 texCoords;
  57:     vec4 color;
  58:     float diffuse;
  59:     vec2 light;
  60: };
  61: 
  62: void FLWMain(BlockFrag r) {
  63:     vec4 tex = FLWBlockTexture(r.texCoords);
  64: 
  65:     vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;
  66: 
  67: //    flw_WorldPos = ;
  68: //    flw_Normal = ;
  69: //    flw_Albedo = tex.rgb;
  70: //    flw_Alpha = tex.a;
  71: //    flw_LightMap = r.light;
  72: //    flw_Tint = r.color;
  73:     FLWFinalizeColor(color);
  74: }
  75: 
  76: varying vec2 v2f_texCoords;
  77: varying vec4 v2f_color;
  78: varying float v2f_diffuse;
  79: varying vec2 v2f_light;
  80: 
  81: 
  82: //vec3 flw_WorldPos;
  83: //vec3 flw_Normal;
  84: //vec3 flw_Albedo;
  85: //float flw_Alpha;
  86: //vec2 flw_LightMap;
  87: //vec4 flw_Tint;
  88: 
  89: void main() {
  90:     BlockFrag f;
  91:     f.texCoords = v2f_texCoords;
  92: f.color = v2f_color;
  93: f.diffuse = v2f_diffuse;
  94: f.light = v2f_light;
  95: 
  96: 
  97:     FLWMain(f);
  98: }

[14:02:47] [main/ERROR]: Shader compilation log for flywheel:oriented.vert: No errors.

[14:02:47] [main/ERROR]: Source for shader 'flywheel:oriented.vert':
   1: #version 110
   2: #define DEBUG_NORMAL
   3: 
   4: uniform float uTime;
   5: uniform mat4 uViewProjection;
   6: uniform vec3 uCameraPos;
   7: 
   8: #if defined(USE_FOG)
   9: varying float FragDistance;
  10: #endif
  11: 
  12: void FLWFinalizeWorldPos(inout vec4 worldPos) {
  13:     #if defined(USE_FOG)
  14:     FragDistance = length(worldPos.xyz - uCameraPos);
  15:     #endif
  16: 
  17:     gl_Position = uViewProjection * worldPos;
  18: }
  19: 
  20: void FLWFinalizeNormal(inout vec3 normal) {
  21:     // noop
  22: }
  23: 
  24: 
  25: mat4 rotate(vec3 axis, float angle) {
  26:     float s = sin(angle);
  27:     float c = cos(angle);
  28:     float oc = 1. - c;
  29: 
  30:     vec3 sa = axis * s;
  31: 
  32:     mat4 mr = mat4(1.);
  33:     mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
  34:     mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
  35:     mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);
  36: 
  37:     return mr;
  38: }
  39: 
  40: mat4 rotation(vec3 rot) {
  41:     return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
  42: }
  43: 
  44: mat3 modelToNormal(mat4 mat) {
  45:     // Discard the edges. This won't be accurate for scaled or skewed matrices,
  46:     // but we don't have to work with those often.
  47:     mat3 m;
  48:     m[0] = mat[0].xyz;
  49:     m[1] = mat[1].xyz;
  50:     m[2] = mat[2].xyz;
  51:     return m;
  52: }
  53: 
  54: #define PIOVER2 1.5707963268
  55: 
  56: vec4 quat(vec3 axis, float angle) {
  57:     float halfAngle = angle * PIOVER2 / 180.0;
  58:     vec2 cs = sin(vec2(PIOVER2 - halfAngle, halfAngle)); // compute sin and cos in one instruction
  59:     return vec4(axis.xyz * cs.y,  cs.x);
  60: }
  61: 
  62: vec4 quatMult(vec4 q1, vec4 q2) {
  63:     // disgustingly vectorized quaternion multiplication
  64:     vec4 a = q1.w * q2.xyzw;
  65:     vec4 b = q1.x * q2.wzxy * vec4(1., -1., 1., -1.);
  66:     vec4 c = q1.y * q2.zwxy * vec4(1., 1., -1., -1.);
  67:     vec4 d = q1.z * q2.yxwz * vec4(-1., 1., 1., -1.);
  68: 
  69:     return a + b + c + d;
  70: }
  71: 
  72: vec3 rotateVertexByQuat(vec3 v, vec4 q) {
  73:     vec3 i = q.xyz;
  74:     return v + 2.0 * cross(i, cross(i, v) + q.w * v);
  75: }
  76: 
  77: vec3 rotateAbout(vec3 v, vec3 axis, float angle) {
  78:     return rotateVertexByQuat(v, quat(axis, angle));
  79: }
  80: 
  81: float diffuse(vec3 normal) {
  82:     vec3 n2 = normal * normal * vec3(.6, .25, .8);
  83:     return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
  84: }
  85: 
  86: 
  87: struct Oriented {
  88:     vec2 light;
  89:     vec4 color;
  90:     vec3 pos;
  91:     vec3 pivot;
  92:     vec4 rotation;
  93: };
  94: 
  95: 
  96: struct Vertex {
  97:     vec3 pos;
  98:     vec3 normal;
  99:     vec2 texCoords;
 100: };
 101: 
 102: struct BlockFrag {
 103:     vec2 texCoords;
 104:     vec4 color;
 105:     float diffuse;
 106:     vec2 light;
 107: };
 108: 
 109: BlockFrag FLWMain(Vertex v, Oriented o) {
 110:     vec4 worldPos = vec4(rotateVertexByQuat(v.pos - o.pivot, o.rotation) + o.pivot + o.pos, 1.);
 111: 
 112:     vec3 norm = rotateVertexByQuat(v.normal, o.rotation);
 113: 
 114:     FLWFinalizeWorldPos(worldPos);
 115:     FLWFinalizeNormal(norm);
 116: 
 117:     BlockFrag b;
 118:     b.diffuse = diffuse(norm);
 119:     b.texCoords = v.texCoords;
 120:     b.light = o.light;
 121:     #if defined(DEBUG_NORMAL)
 122:     b.color = vec4(norm, 1.);
 123:     #else
 124:     b.color = o.color;
 125:     #endif
 126:     return b;
 127: }
 128: attribute vec3 a_v_pos;
 129: attribute vec3 a_v_normal;
 130: attribute vec2 a_v_texCoords;
 131: 
 132: attribute vec2 a_i_light;
 133: attribute vec4 a_i_color;
 134: attribute vec3 a_i_pos;
 135: attribute vec3 a_i_pivot;
 136: attribute vec4 a_i_rotation;
 137: 
 138: 
 139: varying vec2 v2f_texCoords;
 140: varying vec4 v2f_color;
 141: varying float v2f_diffuse;
 142: varying vec2 v2f_light;
 143: 
 144: 
 145: void main() {
 146:     Vertex v;
 147:     v.pos = a_v_pos;
 148: v.normal = a_v_normal;
 149: v.texCoords = a_v_texCoords;
 150: 
 151: 
 152:     Oriented i;
 153:     i.light = a_i_light;
 154: i.color = a_i_color;
 155: i.pos = a_i_pos;
 156: i.pivot = a_i_pivot;
 157: i.rotation = a_i_rotation;
 158: 
 159: 
 160:     BlockFrag o = FLWMain(v, i);
 161: 
 162:     v2f_texCoords = o.texCoords;
 163: v2f_color = o.color;
 164: v2f_diffuse = o.diffuse;
 165: v2f_light = o.light;
 166: 
 167: }

[14:02:47] [main/ERROR]: Shader compilation log for flywheel:block.frag: No errors.

[14:02:47] [main/ERROR]: Source for shader 'flywheel:block.frag':
   1: #version 110
   2: #define DEBUG_NORMAL
   3: 
   4: #if defined(USE_FOG)
   5: varying float FragDistance;
   6: uniform vec4 uFogColor;
   7: #endif
   8: 
   9: #if defined(USE_FOG_LINEAR)
  10: uniform vec2 uFogRange;
  11: 
  12: float FLWFogFactor() {
  13:     return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
  14: }
  15:     #endif
  16: 
  17:     #if defined(USE_FOG_EXP2)
  18: uniform float uFogDensity;
  19: 
  20: float FLWFogFactor() {
  21:     float dist = FragDistance * uFogDensity;
  22:     return 1. / exp2(dist * dist);
  23: }
  24:     #endif
  25: 
  26: uniform vec2 uTextureScale;
  27: uniform sampler2D uBlockAtlas;
  28: uniform sampler2D uLightMap;
  29: uniform sampler2D uCrumbling;
  30: 
  31: vec4 FLWBlockTexture(vec2 texCoords) {
  32:     vec4 cr = texture2D(uCrumbling, texCoords * uTextureScale);
  33:     float diffuseAlpha = texture2D(uBlockAtlas, texCoords).a;
  34:     cr.a = cr.a * diffuseAlpha;
  35:     return cr;
  36: }
  37: 
  38: void FLWFinalizeColor(vec4 color) {
  39:     #if defined(USE_FOG)
  40:     float a = color.a;
  41:     float fog = clamp(FLWFogFactor(), 0., 1.);
  42: 
  43:     color = mix(uFogColor, color, fog);
  44:     color.a = a;
  45:     #endif
  46: 
  47:     gl_FragColor = color;
  48: }
  49: 
  50: vec4 FLWLight(vec2 lightCoords) {
  51:     return vec4(1.);
  52: }
  53: 
  54: 
  55: 
  56: struct BlockFrag {
  57:     vec2 texCoords;
  58:     vec4 color;
  59:     float diffuse;
  60:     vec2 light;
  61: };
  62: 
  63: void FLWMain(BlockFrag r) {
  64:     vec4 tex = FLWBlockTexture(r.texCoords);
  65: 
  66:     vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;
  67: 
  68: //    flw_WorldPos = ;
  69: //    flw_Normal = ;
  70: //    flw_Albedo = tex.rgb;
  71: //    flw_Alpha = tex.a;
  72: //    flw_LightMap = r.light;
  73: //    flw_Tint = r.color;
  74:     FLWFinalizeColor(color);
  75: }
  76: 
  77: varying vec2 v2f_texCoords;
  78: varying vec4 v2f_color;
  79: varying float v2f_diffuse;
  80: varying vec2 v2f_light;
  81: 
  82: 
  83: //vec3 flw_WorldPos;
  84: //vec3 flw_Normal;
  85: //vec3 flw_Albedo;
  86: //float flw_Alpha;
  87: //vec2 flw_LightMap;
  88: //vec4 flw_Tint;
  89: 
  90: void main() {
  91:     BlockFrag f;
  92:     f.texCoords = v2f_texCoords;
  93: f.color = v2f_color;
  94: f.diffuse = v2f_diffuse;
  95: f.light = v2f_light;
  96: 
  97: 
  98:     FLWMain(f);
  99: }

[14:02:47] [main/ERROR]: Shader compilation log for flywheel:oriented.vert: No errors.

[14:02:47] [main/ERROR]: Source for shader 'flywheel:oriented.vert':
   1: #version 110
   2: #define USE_FOG
   3: #define USE_FOG_LINEAR
   4: 
   5: uniform float uTime;
   6: uniform mat4 uViewProjection;
   7: uniform vec3 uCameraPos;
   8: 
   9: #if defined(USE_FOG)
  10: varying float FragDistance;
  11: #endif
  12: 
  13: void FLWFinalizeWorldPos(inout vec4 worldPos) {
  14:     #if defined(USE_FOG)
  15:     FragDistance = length(worldPos.xyz - uCameraPos);
  16:     #endif
  17: 
  18:     gl_Position = uViewProjection * worldPos;
  19: }
  20: 
  21: void FLWFinalizeNormal(inout vec3 normal) {
  22:     // noop
  23: }
  24: 
  25: 
  26: mat4 rotate(vec3 axis, float angle) {
  27:     float s = sin(angle);
  28:     float c = cos(angle);
  29:     float oc = 1. - c;
  30: 
  31:     vec3 sa = axis * s;
  32: 
  33:     mat4 mr = mat4(1.);
  34:     mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
  35:     mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
  36:     mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);
  37: 
  38:     return mr;
  39: }
  40: 
  41: mat4 rotation(vec3 rot) {
  42:     return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
  43: }
  44: 
  45: mat3 modelToNormal(mat4 mat) {
  46:     // Discard the edges. This won't be accurate for scaled or skewed matrices,
  47:     // but we don't have to work with those often.
  48:     mat3 m;
  49:     m[0] = mat[0].xyz;
  50:     m[1] = mat[1].xyz;
  51:     m[2] = mat[2].xyz;
  52:     return m;
  53: }
  54: 
  55: #define PIOVER2 1.5707963268
  56: 
  57: vec4 quat(vec3 axis, float angle) {
  58:     float halfAngle = angle * PIOVER2 / 180.0;
  59:     vec2 cs = sin(vec2(PIOVER2 - halfAngle, halfAngle)); // compute sin and cos in one instruction
  60:     return vec4(axis.xyz * cs.y,  cs.x);
  61: }
  62: 
  63: vec4 quatMult(vec4 q1, vec4 q2) {
  64:     // disgustingly vectorized quaternion multiplication
  65:     vec4 a = q1.w * q2.xyzw;
  66:     vec4 b = q1.x * q2.wzxy * vec4(1., -1., 1., -1.);
  67:     vec4 c = q1.y * q2.zwxy * vec4(1., 1., -1., -1.);
  68:     vec4 d = q1.z * q2.yxwz * vec4(-1., 1., 1., -1.);
  69: 
  70:     return a + b + c + d;
  71: }
  72: 
  73: vec3 rotateVertexByQuat(vec3 v, vec4 q) {
  74:     vec3 i = q.xyz;
  75:     return v + 2.0 * cross(i, cross(i, v) + q.w * v);
  76: }
  77: 
  78: vec3 rotateAbout(vec3 v, vec3 axis, float angle) {
  79:     return rotateVertexByQuat(v, quat(axis, angle));
  80: }
  81: 
  82: float diffuse(vec3 normal) {
  83:     vec3 n2 = normal * normal * vec3(.6, .25, .8);
  84:     return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
  85: }
  86: 
  87: 
  88: struct Oriented {
  89:     vec2 light;
  90:     vec4 color;
  91:     vec3 pos;
  92:     vec3 pivot;
  93:     vec4 rotation;
  94: };
  95: 
  96: 
  97: struct Vertex {
  98:     vec3 pos;
  99:     vec3 normal;
 100:     vec2 texCoords;
 101: };
 102: 
 103: struct BlockFrag {
 104:     vec2 texCoords;
 105:     vec4 color;
 106:     float diffuse;
 107:     vec2 light;
 108: };
 109: 
 110: BlockFrag FLWMain(Vertex v, Oriented o) {
 111:     vec4 worldPos = vec4(rotateVertexByQuat(v.pos - o.pivot, o.rotation) + o.pivot + o.pos, 1.);
 112: 
 113:     vec3 norm = rotateVertexByQuat(v.normal, o.rotation);
 114: 
 115:     FLWFinalizeWorldPos(worldPos);
 116:     FLWFinalizeNormal(norm);
 117: 
 118:     BlockFrag b;
 119:     b.diffuse = diffuse(norm);
 120:     b.texCoords = v.texCoords;
 121:     b.light = o.light;
 122:     #if defined(DEBUG_NORMAL)
 123:     b.color = vec4(norm, 1.);
 124:     #else
 125:     b.color = o.color;
 126:     #endif
 127:     return b;
 128: }
 129: attribute vec3 a_v_pos;
 130: attribute vec3 a_v_normal;
 131: attribute vec2 a_v_texCoords;
 132: 
 133: attribute vec2 a_i_light;
 134: attribute vec4 a_i_color;
 135: attribute vec3 a_i_pos;
 136: attribute vec3 a_i_pivot;
 137: attribute vec4 a_i_rotation;
 138: 
 139: 
 140: varying vec2 v2f_texCoords;
 141: varying vec4 v2f_color;
 142: varying float v2f_diffuse;
 143: varying vec2 v2f_light;
 144: 
 145: 
 146: void main() {
 147:     Vertex v;
 148:     v.pos = a_v_pos;
 149: v.normal = a_v_normal;
 150: v.texCoords = a_v_texCoords;
 151: 
 152: 
 153:     Oriented i;
 154:     i.light = a_i_light;
 155: i.color = a_i_color;
 156: i.pos = a_i_pos;
 157: i.pivot = a_i_pivot;
 158: i.rotation = a_i_rotation;
 159: 
 160: 
 161:     BlockFrag o = FLWMain(v, i);
 162: 
 163:     v2f_texCoords = o.texCoords;
 164: v2f_color = o.color;
 165: v2f_diffuse = o.diffuse;
 166: v2f_light = o.light;
 167: 
 168: }

[14:02:47] [main/ERROR]: Shader compilation log for flywheel:block.frag: No errors.

[14:02:47] [main/ERROR]: Source for shader 'flywheel:block.frag':
   1: #version 110
   2: #define USE_FOG
   3: #define USE_FOG_LINEAR
   4: 
   5: #if defined(USE_FOG)
   6: varying float FragDistance;
   7: uniform vec4 uFogColor;
   8: #endif
   9: 
  10: #if defined(USE_FOG_LINEAR)
  11: uniform vec2 uFogRange;
  12: 
  13: float FLWFogFactor() {
  14:     return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
  15: }
  16:     #endif
  17: 
  18:     #if defined(USE_FOG_EXP2)
  19: uniform float uFogDensity;
  20: 
  21: float FLWFogFactor() {
  22:     float dist = FragDistance * uFogDensity;
  23:     return 1. / exp2(dist * dist);
  24: }
  25:     #endif
  26: 
  27: uniform vec2 uTextureScale;
  28: uniform sampler2D uBlockAtlas;
  29: uniform sampler2D uLightMap;
  30: uniform sampler2D uCrumbling;
  31: 
  32: vec4 FLWBlockTexture(vec2 texCoords) {
  33:     vec4 cr = texture2D(uCrumbling, texCoords * uTextureScale);
  34:     float diffuseAlpha = texture2D(uBlockAtlas, texCoords).a;
  35:     cr.a = cr.a * diffuseAlpha;
  36:     return cr;
  37: }
  38: 
  39: void FLWFinalizeColor(vec4 color) {
  40:     #if defined(USE_FOG)
  41:     float a = color.a;
  42:     float fog = clamp(FLWFogFactor(), 0., 1.);
  43: 
  44:     color = mix(uFogColor, color, fog);
  45:     color.a = a;
  46:     #endif
  47: 
  48:     gl_FragColor = color;
  49: }
  50: 
  51: vec4 FLWLight(vec2 lightCoords) {
  52:     return vec4(1.);
  53: }
  54: 
  55: 
  56: 
  57: struct BlockFrag {
  58:     vec2 texCoords;
  59:     vec4 color;
  60:     float diffuse;
  61:     vec2 light;
  62: };
  63: 
  64: void FLWMain(BlockFrag r) {
  65:     vec4 tex = FLWBlockTexture(r.texCoords);
  66: 
  67:     vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;
  68: 
  69: //    flw_WorldPos = ;
  70: //    flw_Normal = ;
  71: //    flw_Albedo = tex.rgb;
  72: //    flw_Alpha = tex.a;
  73: //    flw_LightMap = r.light;
  74: //    flw_Tint = r.color;
  75:     FLWFinalizeColor(color);
  76: }
  77: 
  78: varying vec2 v2f_texCoords;
  79: varying vec4 v2f_color;
  80: varying float v2f_diffuse;
  81: varying vec2 v2f_light;
  82: 
  83: 
  84: //vec3 flw_WorldPos;
  85: //vec3 flw_Normal;
  86: //vec3 flw_Albedo;
  87: //float flw_Alpha;
  88: //vec2 flw_LightMap;
  89: //vec4 flw_Tint;
  90: 
  91: void main() {
  92:     BlockFrag f;
  93:     f.texCoords = v2f_texCoords;
  94: f.color = v2f_color;
  95: f.diffuse = v2f_diffuse;
  96: f.light = v2f_light;
  97: 
  98: 
  99:     FLWMain(f);
 100: }

[14:02:47] [main/ERROR]: Shader compilation log for flywheel:oriented.vert: No errors.

[14:02:47] [main/ERROR]: Source for shader 'flywheel:oriented.vert':
   1: #version 110
   2: #define USE_FOG
   3: #define USE_FOG_EXP2
   4: 
   5: uniform float uTime;
   6: uniform mat4 uViewProjection;
   7: uniform vec3 uCameraPos;
   8: 
   9: #if defined(USE_FOG)
  10: varying float FragDistance;
  11: #endif
  12: 
  13: void FLWFinalizeWorldPos(inout vec4 worldPos) {
  14:     #if defined(USE_FOG)
  15:     FragDistance = length(worldPos.xyz - uCameraPos);
  16:     #endif
  17: 
  18:     gl_Position = uViewProjection * worldPos;
  19: }
  20: 
  21: void FLWFinalizeNormal(inout vec3 normal) {
  22:     // noop
  23: }
  24: 
  25: 
  26: mat4 rotate(vec3 axis, float angle) {
  27:     float s = sin(angle);
  28:     float c = cos(angle);
  29:     float oc = 1. - c;
  30: 
  31:     vec3 sa = axis * s;
  32: 
  33:     mat4 mr = mat4(1.);
  34:     mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
  35:     mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
  36:     mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);
  37: 
  38:     return mr;
  39: }
  40: 
  41: mat4 rotation(vec3 rot) {
  42:     return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
  43: }
  44: 
  45: mat3 modelToNormal(mat4 mat) {
  46:     // Discard the edges. This won't be accurate for scaled or skewed matrices,
  47:     // but we don't have to work with those often.
  48:     mat3 m;
  49:     m[0] = mat[0].xyz;
  50:     m[1] = mat[1].xyz;
  51:     m[2] = mat[2].xyz;
  52:     return m;
  53: }
  54: 
  55: #define PIOVER2 1.5707963268
  56: 
  57: vec4 quat(vec3 axis, float angle) {
  58:     float halfAngle = angle * PIOVER2 / 180.0;
  59:     vec2 cs = sin(vec2(PIOVER2 - halfAngle, halfAngle)); // compute sin and cos in one instruction
  60:     return vec4(axis.xyz * cs.y,  cs.x);
  61: }
  62: 
  63: vec4 quatMult(vec4 q1, vec4 q2) {
  64:     // disgustingly vectorized quaternion multiplication
  65:     vec4 a = q1.w * q2.xyzw;
  66:     vec4 b = q1.x * q2.wzxy * vec4(1., -1., 1., -1.);
  67:     vec4 c = q1.y * q2.zwxy * vec4(1., 1., -1., -1.);
  68:     vec4 d = q1.z * q2.yxwz * vec4(-1., 1., 1., -1.);
  69: 
  70:     return a + b + c + d;
  71: }
  72: 
  73: vec3 rotateVertexByQuat(vec3 v, vec4 q) {
  74:     vec3 i = q.xyz;
  75:     return v + 2.0 * cross(i, cross(i, v) + q.w * v);
  76: }
  77: 
  78: vec3 rotateAbout(vec3 v, vec3 axis, float angle) {
  79:     return rotateVertexByQuat(v, quat(axis, angle));
  80: }
  81: 
  82: float diffuse(vec3 normal) {
  83:     vec3 n2 = normal * normal * vec3(.6, .25, .8);
  84:     return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
  85: }
  86: 
  87: 
  88: struct Oriented {
  89:     vec2 light;
  90:     vec4 color;
  91:     vec3 pos;
  92:     vec3 pivot;
  93:     vec4 rotation;
  94: };
  95: 
  96: 
  97: struct Vertex {
  98:     vec3 pos;
  99:     vec3 normal;
 100:     vec2 texCoords;
 101: };
 102: 
 103: struct BlockFrag {
 104:     vec2 texCoords;
 105:     vec4 color;
 106:     float diffuse;
 107:     vec2 light;
 108: };
 109: 
 110: BlockFrag FLWMain(Vertex v, Oriented o) {
 111:     vec4 worldPos = vec4(rotateVertexByQuat(v.pos - o.pivot, o.rotation) + o.pivot + o.pos, 1.);
 112: 
 113:     vec3 norm = rotateVertexByQuat(v.normal, o.rotation);
 114: 
 115:     FLWFinalizeWorldPos(worldPos);
 116:     FLWFinalizeNormal(norm);
 117: 
 118:     BlockFrag b;
 119:     b.diffuse = diffuse(norm);
 120:     b.texCoords = v.texCoords;
 121:     b.light = o.light;
 122:     #if defined(DEBUG_NORMAL)
 123:     b.color = vec4(norm, 1.);
 124:     #else
 125:     b.color = o.color;
 126:     #endif
 127:     return b;
 128: }
 129: attribute vec3 a_v_pos;
 130: attribute vec3 a_v_normal;
 131: attribute vec2 a_v_texCoords;
 132: 
 133: attribute vec2 a_i_light;
 134: attribute vec4 a_i_color;
 135: attribute vec3 a_i_pos;
 136: attribute vec3 a_i_pivot;
 137: attribute vec4 a_i_rotation;
 138: 
 139: 
 140: varying vec2 v2f_texCoords;
 141: varying vec4 v2f_color;
 142: varying float v2f_diffuse;
 143: varying vec2 v2f_light;
 144: 
 145: 
 146: void main() {
 147:     Vertex v;
 148:     v.pos = a_v_pos;
 149: v.normal = a_v_normal;
 150: v.texCoords = a_v_texCoords;
 151: 
 152: 
 153:     Oriented i;
 154:     i.light = a_i_light;
 155: i.color = a_i_color;
 156: i.pos = a_i_pos;
 157: i.pivot = a_i_pivot;
 158: i.rotation = a_i_rotation;
 159: 
 160: 
 161:     BlockFrag o = FLWMain(v, i);
 162: 
 163:     v2f_texCoords = o.texCoords;
 164: v2f_color = o.color;
 165: v2f_diffuse = o.diffuse;
 166: v2f_light = o.light;
 167: 
 168: }

[14:02:47] [main/ERROR]: Shader compilation log for flywheel:block.frag: No errors.

[14:02:47] [main/ERROR]: Source for shader 'flywheel:block.frag':
   1: #version 110
   2: #define USE_FOG
   3: #define USE_FOG_EXP2
   4: 
   5: #if defined(USE_FOG)
   6: varying float FragDistance;
   7: uniform vec4 uFogColor;
   8: #endif
   9: 
  10: #if defined(USE_FOG_LINEAR)
  11: uniform vec2 uFogRange;
  12: 
  13: float FLWFogFactor() {
  14:     return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
  15: }
  16:     #endif
  17: 
  18:     #if defined(USE_FOG_EXP2)
  19: uniform float uFogDensity;
  20: 
  21: float FLWFogFactor() {
  22:     float dist = FragDistance * uFogDensity;
  23:     return 1. / exp2(dist * dist);
  24: }
  25:     #endif
  26: 
  27: uniform vec2 uTextureScale;
  28: uniform sampler2D uBlockAtlas;
  29: uniform sampler2D uLightMap;
  30: uniform sampler2D uCrumbling;
  31: 
  32: vec4 FLWBlockTexture(vec2 texCoords) {
  33:     vec4 cr = texture2D(uCrumbling, texCoords * uTextureScale);
  34:     float diffuseAlpha = texture2D(uBlockAtlas, texCoords).a;
  35:     cr.a = cr.a * diffuseAlpha;
  36:     return cr;
  37: }
  38: 
  39: void FLWFinalizeColor(vec4 color) {
  40:     #if defined(USE_FOG)
  41:     float a = color.a;
  42:     float fog = clamp(FLWFogFactor(), 0., 1.);
  43: 
  44:     color = mix(uFogColor, color, fog);
  45:     color.a = a;
  46:     #endif
  47: 
  48:     gl_FragColor = color;
  49: }
  50: 
  51: vec4 FLWLight(vec2 lightCoords) {
  52:     return vec4(1.);
  53: }
  54: 
  55: 
  56: 
  57: struct BlockFrag {
  58:     vec2 texCoords;
  59:     vec4 color;
  60:     float diffuse;
  61:     vec2 light;
  62: };
  63: 
  64: void FLWMain(BlockFrag r) {
  65:     vec4 tex = FLWBlockTexture(r.texCoords);
  66: 
  67:     vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;
  68: 
  69: //    flw_WorldPos = ;
  70: //    flw_Normal = ;
  71: //    flw_Albedo = tex.rgb;
  72: //    flw_Alpha = tex.a;
  73: //    flw_LightMap = r.light;
  74: //    flw_Tint = r.color;
  75:     FLWFinalizeColor(color);
  76: }
  77: 
  78: varying vec2 v2f_texCoords;
  79: varying vec4 v2f_color;
  80: varying float v2f_diffuse;
  81: varying vec2 v2f_light;
  82: 
  83: 
  84: //vec3 flw_WorldPos;
  85: //vec3 flw_Normal;
  86: //vec3 flw_Albedo;
  87: //float flw_Alpha;
  88: //vec2 flw_LightMap;
  89: //vec4 flw_Tint;
  90: 
  91: void main() {
  92:     BlockFrag f;
  93:     f.texCoords = v2f_texCoords;
  94: f.color = v2f_color;
  95: f.diffuse = v2f_diffuse;
  96: f.light = v2f_light;
  97: 
  98: 
  99:     FLWMain(f);
 100: }

[14:02:47] [main/ERROR]: Shader compilation log for flywheel:oriented.vert: No errors.

[14:02:47] [main/ERROR]: Source for shader 'flywheel:oriented.vert':
   1: #version 110
   2: 
   3: uniform float uTime;
   4: uniform mat4 uViewProjection;
   5: uniform vec3 uCameraPos;
   6: 
   7: #if defined(USE_FOG)
   8: varying float FragDistance;
   9: #endif
  10: 
  11: void FLWFinalizeWorldPos(inout vec4 worldPos) {
  12:     #if defined(USE_FOG)
  13:     FragDistance = length(worldPos.xyz - uCameraPos);
  14:     #endif
  15: 
  16:     gl_Position = uViewProjection * worldPos;
  17: }
  18: 
  19: void FLWFinalizeNormal(inout vec3 normal) {
  20:     // noop
  21: }
  22: 
  23: 
  24: mat4 rotate(vec3 axis, float angle) {
  25:     float s = sin(angle);
  26:     float c = cos(angle);
  27:     float oc = 1. - c;
  28: 
  29:     vec3 sa = axis * s;
  30: 
  31:     mat4 mr = mat4(1.);
  32:     mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
  33:     mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
  34:     mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);
  35: 
  36:     return mr;
  37: }
  38: 
  39: mat4 rotation(vec3 rot) {
  40:     return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
  41: }
  42: 
  43: mat3 modelToNormal(mat4 mat) {
  44:     // Discard the edges. This won't be accurate for scaled or skewed matrices,
  45:     // but we don't have to work with those often.
  46:     mat3 m;
  47:     m[0] = mat[0].xyz;
  48:     m[1] = mat[1].xyz;
  49:     m[2] = mat[2].xyz;
  50:     return m;
  51: }
  52: 
  53: #define PIOVER2 1.5707963268
  54: 
  55: vec4 quat(vec3 axis, float angle) {
  56:     float halfAngle = angle * PIOVER2 / 180.0;
  57:     vec2 cs = sin(vec2(PIOVER2 - halfAngle, halfAngle)); // compute sin and cos in one instruction
  58:     return vec4(axis.xyz * cs.y,  cs.x);
  59: }
  60: 
  61: vec4 quatMult(vec4 q1, vec4 q2) {
  62:     // disgustingly vectorized quaternion multiplication
  63:     vec4 a = q1.w * q2.xyzw;
  64:     vec4 b = q1.x * q2.wzxy * vec4(1., -1., 1., -1.);
  65:     vec4 c = q1.y * q2.zwxy * vec4(1., 1., -1., -1.);
  66:     vec4 d = q1.z * q2.yxwz * vec4(-1., 1., 1., -1.);
  67: 
  68:     return a + b + c + d;
  69: }
  70: 
  71: vec3 rotateVertexByQuat(vec3 v, vec4 q) {
  72:     vec3 i = q.xyz;
  73:     return v + 2.0 * cross(i, cross(i, v) + q.w * v);
  74: }
  75: 
  76: vec3 rotateAbout(vec3 v, vec3 axis, float angle) {
  77:     return rotateVertexByQuat(v, quat(axis, angle));
  78: }
  79: 
  80: float diffuse(vec3 normal) {
  81:     vec3 n2 = normal * normal * vec3(.6, .25, .8);
  82:     return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
  83: }
  84: 
  85: 
  86: struct Oriented {
  87:     vec2 light;
  88:     vec4 color;
  89:     vec3 pos;
  90:     vec3 pivot;
  91:     vec4 rotation;
  92: };
  93: 
  94: 
  95: struct Vertex {
  96:     vec3 pos;
  97:     vec3 normal;
  98:     vec2 texCoords;
  99: };
 100: 
 101: struct BlockFrag {
 102:     vec2 texCoords;
 103:     vec4 color;
 104:     float diffuse;
 105:     vec2 light;
 106: };
 107: 
 108: BlockFrag FLWMain(Vertex v, Oriented o) {
 109:     vec4 worldPos = vec4(rotateVertexByQuat(v.pos - o.pivot, o.rotation) + o.pivot + o.pos, 1.);
 110: 
 111:     vec3 norm = rotateVertexByQuat(v.normal, o.rotation);
 112: 
 113:     FLWFinalizeWorldPos(worldPos);
 114:     FLWFinalizeNormal(norm);
 115: 
 116:     BlockFrag b;
 117:     b.diffuse = diffuse(norm);
 118:     b.texCoords = v.texCoords;
 119:     b.light = o.light;
 120:     #if defined(DEBUG_NORMAL)
 121:     b.color = vec4(norm, 1.);
 122:     #else
 123:     b.color = o.color;
 124:     #endif
 125:     return b;
 126: }
 127: attribute vec3 a_v_pos;
 128: attribute vec3 a_v_normal;
 129: attribute vec2 a_v_texCoords;
 130: 
 131: attribute vec2 a_i_light;
 132: attribute vec4 a_i_color;
 133: attribute vec3 a_i_pos;
 134: attribute vec3 a_i_pivot;
 135: attribute vec4 a_i_rotation;
 136: 
 137: 
 138: varying vec2 v2f_texCoords;
 139: varying vec4 v2f_color;
 140: varying float v2f_diffuse;
 141: varying vec2 v2f_light;
 142: 
 143: 
 144: void main() {
 145:     Vertex v;
 146:     v.pos = a_v_pos;
 147: v.normal = a_v_normal;
 148: v.texCoords = a_v_texCoords;
 149: 
 150: 
 151:     Oriented i;
 152:     i.light = a_i_light;
 153: i.color = a_i_color;
 154: i.pos = a_i_pos;
 155: i.pivot = a_i_pivot;
 156: i.rotation = a_i_rotation;
 157: 
 158: 
 159:     BlockFrag o = FLWMain(v, i);
 160: 
 161:     v2f_texCoords = o.texCoords;
 162: v2f_color = o.color;
 163: v2f_diffuse = o.diffuse;
 164: v2f_light = o.light;
 165: 
 166: }

[14:02:47] [main/ERROR]: Shader compilation log for flywheel:block.frag: No errors.

[14:02:47] [main/ERROR]: Source for shader 'flywheel:block.frag':
   1: #version 110
   2: 
   3: #if defined(USE_FOG)
   4: varying float FragDistance;
   5: uniform vec4 uFogColor;
   6: #endif
   7: 
   8: #if defined(USE_FOG_LINEAR)
   9: uniform vec2 uFogRange;
  10: 
  11: float FLWFogFactor() {
  12:     return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
  13: }
  14:     #endif
  15: 
  16:     #if defined(USE_FOG_EXP2)
  17: uniform float uFogDensity;
  18: 
  19: float FLWFogFactor() {
  20:     float dist = FragDistance * uFogDensity;
  21:     return 1. / exp2(dist * dist);
  22: }
  23:     #endif
  24: 
  25: uniform vec2 uTextureScale;
  26: uniform sampler2D uBlockAtlas;
  27: uniform sampler2D uLightMap;
  28: uniform sampler2D uCrumbling;
  29: 
  30: vec4 FLWBlockTexture(vec2 texCoords) {
  31:     vec4 cr = texture2D(uCrumbling, texCoords * uTextureScale);
  32:     float diffuseAlpha = texture2D(uBlockAtlas, texCoords).a;
  33:     cr.a = cr.a * diffuseAlpha;
  34:     return cr;
  35: }
  36: 
  37: void FLWFinalizeColor(vec4 color) {
  38:     #if defined(USE_FOG)
  39:     float a = color.a;
  40:     float fog = clamp(FLWFogFactor(), 0., 1.);
  41: 
  42:     color = mix(uFogColor, color, fog);
  43:     color.a = a;
  44:     #endif
  45: 
  46:     gl_FragColor = color;
  47: }
  48: 
  49: vec4 FLWLight(vec2 lightCoords) {
  50:     return vec4(1.);
  51: }
  52: 
  53: 
  54: 
  55: struct BlockFrag {
  56:     vec2 texCoords;
  57:     vec4 color;
  58:     float diffuse;
  59:     vec2 light;
  60: };
  61: 
  62: void FLWMain(BlockFrag r) {
  63:     vec4 tex = FLWBlockTexture(r.texCoords);
  64: 
  65:     vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;
  66: 
  67: //    flw_WorldPos = ;
  68: //    flw_Normal = ;
  69: //    flw_Albedo = tex.rgb;
  70: //    flw_Alpha = tex.a;
  71: //    flw_LightMap = r.light;
  72: //    flw_Tint = r.color;
  73:     FLWFinalizeColor(color);
  74: }
  75: 
  76: varying vec2 v2f_texCoords;
  77: varying vec4 v2f_color;
  78: varying float v2f_diffuse;
  79: varying vec2 v2f_light;
  80: 
  81: 
  82: //vec3 flw_WorldPos;
  83: //vec3 flw_Normal;
  84: //vec3 flw_Albedo;
  85: //float flw_Alpha;
  86: //vec2 flw_LightMap;
  87: //vec4 flw_Tint;
  88: 
  89: void main() {
  90:     BlockFrag f;
  91:     f.texCoords = v2f_texCoords;
  92: f.color = v2f_color;
  93: f.diffuse = v2f_diffuse;
  94: f.light = v2f_light;
  95: 
  96: 
  97:     FLWMain(f);
  98: }

[14:02:47] [main/ERROR]: Shader compilation log for flywheel:model.vert: No errors.

[14:02:47] [main/ERROR]: Source for shader 'flywheel:model.vert':
   1: #version 110
   2: #define DEBUG_NORMAL
   3: 
   4: uniform float uTime;
   5: uniform mat4 uViewProjection;
   6: uniform vec3 uCameraPos;
   7: 
   8: #if defined(USE_FOG)
   9: varying float FragDistance;
  10: #endif
  11: 
  12: void FLWFinalizeWorldPos(inout vec4 worldPos) {
  13:     #if defined(USE_FOG)
  14:     FragDistance = length(worldPos.xyz - uCameraPos);
  15:     #endif
  16: 
  17:     gl_Position = uViewProjection * worldPos;
  18: }
  19: 
  20: void FLWFinalizeNormal(inout vec3 normal) {
  21:     // noop
  22: }
  23: 
  24: 
  25: float diffuse(vec3 normal) {
  26:     vec3 n2 = normal * normal * vec3(.6, .25, .8);
  27:     return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
  28: }
  29: 
  30: 
  31: struct Vertex {
  32:     vec3 pos;
  33:     vec3 normal;
  34:     vec2 texCoords;
  35: };
  36: 
  37: struct BlockFrag {
  38:     vec2 texCoords;
  39:     vec4 color;
  40:     float diffuse;
  41:     vec2 light;
  42: };
  43: 
  44: 
  45: struct Instance {
  46:     vec2 light;
  47:     vec4 color;
  48:     mat4 transform;
  49:     mat3 normalMat;
  50: };
  51: 
  52: BlockFrag FLWMain(Vertex v, Instance i) {
  53:     vec4 worldPos = i.transform * vec4(v.pos, 1.);
  54: 
  55:     vec3 norm = i.normalMat * v.normal;
  56: 
  57:     FLWFinalizeWorldPos(worldPos);
  58:     FLWFinalizeNormal(norm);
  59: 
  60:     norm = normalize(norm);
  61: 
  62:     BlockFrag b;
  63:     b.diffuse = diffuse(norm);
  64:     b.texCoords = v.texCoords;
  65:     b.light = i.light;
  66:     #if defined(DEBUG_NORMAL)
  67:     b.color = vec4(norm, 1.);
  68:     #else
  69:     b.color = i.color;
  70:     #endif
  71:     return b;
  72: }
  73: attribute vec3 a_v_pos;
  74: attribute vec3 a_v_normal;
  75: attribute vec2 a_v_texCoords;
  76: 
  77: attribute vec2 a_i_light;
  78: attribute vec4 a_i_color;
  79: attribute mat4 a_i_transform;
  80: attribute mat3 a_i_normalMat;
  81: 
  82: 
  83: varying vec2 v2f_texCoords;
  84: varying vec4 v2f_color;
  85: varying float v2f_diffuse;
  86: varying vec2 v2f_light;
  87: 
  88: 
  89: void main() {
  90:     Vertex v;
  91:     v.pos = a_v_pos;
  92: v.normal = a_v_normal;
  93: v.texCoords = a_v_texCoords;
  94: 
  95: 
  96:     Instance i;
  97:     i.light = a_i_light;
  98: i.color = a_i_color;
  99: i.transform = a_i_transform;
 100: i.normalMat = a_i_normalMat;
 101: 
 102: 
 103:     BlockFrag o = FLWMain(v, i);
 104: 
 105:     v2f_texCoords = o.texCoords;
 106: v2f_color = o.color;
 107: v2f_diffuse = o.diffuse;
 108: v2f_light = o.light;
 109: 
 110: }

[14:02:47] [main/ERROR]: Shader compilation log for flywheel:block.frag: No errors.

[14:02:47] [main/ERROR]: Source for shader 'flywheel:block.frag':
   1: #version 110
   2: #define DEBUG_NORMAL
   3: 
   4: #if defined(USE_FOG)
   5: varying float FragDistance;
   6: uniform vec4 uFogColor;
   7: #endif
   8: 
   9: #if defined(USE_FOG_LINEAR)
  10: uniform vec2 uFogRange;
  11: 
  12: float FLWFogFactor() {
  13:     return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
  14: }
  15:     #endif
  16: 
  17:     #if defined(USE_FOG_EXP2)
  18: uniform float uFogDensity;
  19: 
  20: float FLWFogFactor() {
  21:     float dist = FragDistance * uFogDensity;
  22:     return 1. / exp2(dist * dist);
  23: }
  24:     #endif
  25: 
  26: uniform vec2 uTextureScale;
  27: uniform sampler2D uBlockAtlas;
  28: uniform sampler2D uLightMap;
  29: uniform sampler2D uCrumbling;
  30: 
  31: vec4 FLWBlockTexture(vec2 texCoords) {
  32:     vec4 cr = texture2D(uCrumbling, texCoords * uTextureScale);
  33:     float diffuseAlpha = texture2D(uBlockAtlas, texCoords).a;
  34:     cr.a = cr.a * diffuseAlpha;
  35:     return cr;
  36: }
  37: 
  38: void FLWFinalizeColor(vec4 color) {
  39:     #if defined(USE_FOG)
  40:     float a = color.a;
  41:     float fog = clamp(FLWFogFactor(), 0., 1.);
  42: 
  43:     color = mix(uFogColor, color, fog);
  44:     color.a = a;
  45:     #endif
  46: 
  47:     gl_FragColor = color;
  48: }
  49: 
  50: vec4 FLWLight(vec2 lightCoords) {
  51:     return vec4(1.);
  52: }
  53: 
  54: 
  55: 
  56: struct BlockFrag {
  57:     vec2 texCoords;
  58:     vec4 color;
  59:     float diffuse;
  60:     vec2 light;
  61: };
  62: 
  63: void FLWMain(BlockFrag r) {
  64:     vec4 tex = FLWBlockTexture(r.texCoords);
  65: 
  66:     vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;
  67: 
  68: //    flw_WorldPos = ;
  69: //    flw_Normal = ;
  70: //    flw_Albedo = tex.rgb;
  71: //    flw_Alpha = tex.a;
  72: //    flw_LightMap = r.light;
  73: //    flw_Tint = r.color;
  74:     FLWFinalizeColor(color);
  75: }
  76: 
  77: varying vec2 v2f_texCoords;
  78: varying vec4 v2f_color;
  79: varying float v2f_diffuse;
  80: varying vec2 v2f_light;
  81: 
  82: 
  83: //vec3 flw_WorldPos;
  84: //vec3 flw_Normal;
  85: //vec3 flw_Albedo;
  86: //float flw_Alpha;
  87: //vec2 flw_LightMap;
  88: //vec4 flw_Tint;
  89: 
  90: void main() {
  91:     BlockFrag f;
  92:     f.texCoords = v2f_texCoords;
  93: f.color = v2f_color;
  94: f.diffuse = v2f_diffuse;
  95: f.light = v2f_light;
  96: 
  97: 
  98:     FLWMain(f);
  99: }

[14:02:47] [main/ERROR]: Shader compilation log for flywheel:model.vert: No errors.

[14:02:47] [main/ERROR]: Source for shader 'flywheel:model.vert':
   1: #version 110
   2: #define USE_FOG
   3: #define USE_FOG_LINEAR
   4: 
   5: uniform float uTime;
   6: uniform mat4 uViewProjection;
   7: uniform vec3 uCameraPos;
   8: 
   9: #if defined(USE_FOG)
  10: varying float FragDistance;
  11: #endif
  12: 
  13: void FLWFinalizeWorldPos(inout vec4 worldPos) {
  14:     #if defined(USE_FOG)
  15:     FragDistance = length(worldPos.xyz - uCameraPos);
  16:     #endif
  17: 
  18:     gl_Position = uViewProjection * worldPos;
  19: }
  20: 
  21: void FLWFinalizeNormal(inout vec3 normal) {
  22:     // noop
  23: }
  24: 
  25: 
  26: float diffuse(vec3 normal) {
  27:     vec3 n2 = normal * normal * vec3(.6, .25, .8);
  28:     return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
  29: }
  30: 
  31: 
  32: struct Vertex {
  33:     vec3 pos;
  34:     vec3 normal;
  35:     vec2 texCoords;
  36: };
  37: 
  38: struct BlockFrag {
  39:     vec2 texCoords;
  40:     vec4 color;
  41:     float diffuse;
  42:     vec2 light;
  43: };
  44: 
  45: 
  46: struct Instance {
  47:     vec2 light;
  48:     vec4 color;
  49:     mat4 transform;
  50:     mat3 normalMat;
  51: };
  52: 
  53: BlockFrag FLWMain(Vertex v, Instance i) {
  54:     vec4 worldPos = i.transform * vec4(v.pos, 1.);
  55: 
  56:     vec3 norm = i.normalMat * v.normal;
  57: 
  58:     FLWFinalizeWorldPos(worldPos);
  59:     FLWFinalizeNormal(norm);
  60: 
  61:     norm = normalize(norm);
  62: 
  63:     BlockFrag b;
  64:     b.diffuse = diffuse(norm);
  65:     b.texCoords = v.texCoords;
  66:     b.light = i.light;
  67:     #if defined(DEBUG_NORMAL)
  68:     b.color = vec4(norm, 1.);
  69:     #else
  70:     b.color = i.color;
  71:     #endif
  72:     return b;
  73: }
  74: attribute vec3 a_v_pos;
  75: attribute vec3 a_v_normal;
  76: attribute vec2 a_v_texCoords;
  77: 
  78: attribute vec2 a_i_light;
  79: attribute vec4 a_i_color;
  80: attribute mat4 a_i_transform;
  81: attribute mat3 a_i_normalMat;
  82: 
  83: 
  84: varying vec2 v2f_texCoords;
  85: varying vec4 v2f_color;
  86: varying float v2f_diffuse;
  87: varying vec2 v2f_light;
  88: 
  89: 
  90: void main() {
  91:     Vertex v;
  92:     v.pos = a_v_pos;
  93: v.normal = a_v_normal;
  94: v.texCoords = a_v_texCoords;
  95: 
  96: 
  97:     Instance i;
  98:     i.light = a_i_light;
  99: i.color = a_i_color;
 100: i.transform = a_i_transform;
 101: i.normalMat = a_i_normalMat;
 102: 
 103: 
 104:     BlockFrag o = FLWMain(v, i);
 105: 
 106:     v2f_texCoords = o.texCoords;
 107: v2f_color = o.color;
 108: v2f_diffuse = o.diffuse;
 109: v2f_light = o.light;
 110: 
 111: }

[14:02:47] [main/ERROR]: Shader compilation log for flywheel:block.frag: No errors.

[14:02:47] [main/ERROR]: Source for shader 'flywheel:block.frag':
   1: #version 110
   2: #define USE_FOG
   3: #define USE_FOG_LINEAR
   4: 
   5: #if defined(USE_FOG)
   6: varying float FragDistance;
   7: uniform vec4 uFogColor;
   8: #endif
   9: 
  10: #if defined(USE_FOG_LINEAR)
  11: uniform vec2 uFogRange;
  12: 
  13: float FLWFogFactor() {
  14:     return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
  15: }
  16:     #endif
  17: 
  18:     #if defined(USE_FOG_EXP2)
  19: uniform float uFogDensity;
  20: 
  21: float FLWFogFactor() {
  22:     float dist = FragDistance * uFogDensity;
  23:     return 1. / exp2(dist * dist);
  24: }
  25:     #endif
  26: 
  27: uniform vec2 uTextureScale;
  28: uniform sampler2D uBlockAtlas;
  29: uniform sampler2D uLightMap;
  30: uniform sampler2D uCrumbling;
  31: 
  32: vec4 FLWBlockTexture(vec2 texCoords) {
  33:     vec4 cr = texture2D(uCrumbling, texCoords * uTextureScale);
  34:     float diffuseAlpha = texture2D(uBlockAtlas, texCoords).a;
  35:     cr.a = cr.a * diffuseAlpha;
  36:     return cr;
  37: }
  38: 
  39: void FLWFinalizeColor(vec4 color) {
  40:     #if defined(USE_FOG)
  41:     float a = color.a;
  42:     float fog = clamp(FLWFogFactor(), 0., 1.);
  43: 
  44:     color = mix(uFogColor, color, fog);
  45:     color.a = a;
  46:     #endif
  47: 
  48:     gl_FragColor = color;
  49: }
  50: 
  51: vec4 FLWLight(vec2 lightCoords) {
  52:     return vec4(1.);
  53: }
  54: 
  55: 
  56: 
  57: struct BlockFrag {
  58:     vec2 texCoords;
  59:     vec4 color;
  60:     float diffuse;
  61:     vec2 light;
  62: };
  63: 
  64: void FLWMain(BlockFrag r) {
  65:     vec4 tex = FLWBlockTexture(r.texCoords);
  66: 
  67:     vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;
  68: 
  69: //    flw_WorldPos = ;
  70: //    flw_Normal = ;
  71: //    flw_Albedo = tex.rgb;
  72: //    flw_Alpha = tex.a;
  73: //    flw_LightMap = r.light;
  74: //    flw_Tint = r.color;
  75:     FLWFinalizeColor(color);
  76: }
  77: 
  78: varying vec2 v2f_texCoords;
  79: varying vec4 v2f_color;
  80: varying float v2f_diffuse;
  81: varying vec2 v2f_light;
  82: 
  83: 
  84: //vec3 flw_WorldPos;
  85: //vec3 flw_Normal;
  86: //vec3 flw_Albedo;
  87: //float flw_Alpha;
  88: //vec2 flw_LightMap;
  89: //vec4 flw_Tint;
  90: 
  91: void main() {
  92:     BlockFrag f;
  93:     f.texCoords = v2f_texCoords;
  94: f.color = v2f_color;
  95: f.diffuse = v2f_diffuse;
  96: f.light = v2f_light;
  97: 
  98: 
  99:     FLWMain(f);
 100: }

[14:02:47] [main/ERROR]: Shader compilation log for flywheel:model.vert: No errors.

[14:02:47] [main/ERROR]: Source for shader 'flywheel:model.vert':
   1: #version 110
   2: #define USE_FOG
   3: #define USE_FOG_EXP2
   4: 
   5: uniform float uTime;
   6: uniform mat4 uViewProjection;
   7: uniform vec3 uCameraPos;
   8: 
   9: #if defined(USE_FOG)
  10: varying float FragDistance;
  11: #endif
  12: 
  13: void FLWFinalizeWorldPos(inout vec4 worldPos) {
  14:     #if defined(USE_FOG)
  15:     FragDistance = length(worldPos.xyz - uCameraPos);
  16:     #endif
  17: 
  18:     gl_Position = uViewProjection * worldPos;
  19: }
  20: 
  21: void FLWFinalizeNormal(inout vec3 normal) {
  22:     // noop
  23: }
  24: 
  25: 
  26: float diffuse(vec3 normal) {
  27:     vec3 n2 = normal * normal * vec3(.6, .25, .8);
  28:     return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
  29: }
  30: 
  31: 
  32: struct Vertex {
  33:     vec3 pos;
  34:     vec3 normal;
  35:     vec2 texCoords;
  36: };
  37: 
  38: struct BlockFrag {
  39:     vec2 texCoords;
  40:     vec4 color;
  41:     float diffuse;
  42:     vec2 light;
  43: };
  44: 
  45: 
  46: struct Instance {
  47:     vec2 light;
  48:     vec4 color;
  49:     mat4 transform;
  50:     mat3 normalMat;
  51: };
  52: 
  53: BlockFrag FLWMain(Vertex v, Instance i) {
  54:     vec4 worldPos = i.transform * vec4(v.pos, 1.);
  55: 
  56:     vec3 norm = i.normalMat * v.normal;
  57: 
  58:     FLWFinalizeWorldPos(worldPos);
  59:     FLWFinalizeNormal(norm);
  60: 
  61:     norm = normalize(norm);
  62: 
  63:     BlockFrag b;
  64:     b.diffuse = diffuse(norm);
  65:     b.texCoords = v.texCoords;
  66:     b.light = i.light;
  67:     #if defined(DEBUG_NORMAL)
  68:     b.color = vec4(norm, 1.);
  69:     #else
  70:     b.color = i.color;
  71:     #endif
  72:     return b;
  73: }
  74: attribute vec3 a_v_pos;
  75: attribute vec3 a_v_normal;
  76: attribute vec2 a_v_texCoords;
  77: 
  78: attribute vec2 a_i_light;
  79: attribute vec4 a_i_color;
  80: attribute mat4 a_i_transform;
  81: attribute mat3 a_i_normalMat;
  82: 
  83: 
  84: varying vec2 v2f_texCoords;
  85: varying vec4 v2f_color;
  86: varying float v2f_diffuse;
  87: varying vec2 v2f_light;
  88: 
  89: 
  90: void main() {
  91:     Vertex v;
  92:     v.pos = a_v_pos;
  93: v.normal = a_v_normal;
  94: v.texCoords = a_v_texCoords;
  95: 
  96: 
  97:     Instance i;
  98:     i.light = a_i_light;
  99: i.color = a_i_color;
 100: i.transform = a_i_transform;
 101: i.normalMat = a_i_normalMat;
 102: 
 103: 
 104:     BlockFrag o = FLWMain(v, i);
 105: 
 106:     v2f_texCoords = o.texCoords;
 107: v2f_color = o.color;
 108: v2f_diffuse = o.diffuse;
 109: v2f_light = o.light;
 110: 
 111: }

[14:02:47] [main/ERROR]: Shader compilation log for flywheel:block.frag: No errors.

[14:02:47] [main/ERROR]: Source for shader 'flywheel:block.frag':
   1: #version 110
   2: #define USE_FOG
   3: #define USE_FOG_EXP2
   4: 
   5: #if defined(USE_FOG)
   6: varying float FragDistance;
   7: uniform vec4 uFogColor;
   8: #endif
   9: 
  10: #if defined(USE_FOG_LINEAR)
  11: uniform vec2 uFogRange;
  12: 
  13: float FLWFogFactor() {
  14:     return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
  15: }
  16:     #endif
  17: 
  18:     #if defined(USE_FOG_EXP2)
  19: uniform float uFogDensity;
  20: 
  21: float FLWFogFactor() {
  22:     float dist = FragDistance * uFogDensity;
  23:     return 1. / exp2(dist * dist);
  24: }
  25:     #endif
  26: 
  27: uniform vec2 uTextureScale;
  28: uniform sampler2D uBlockAtlas;
  29: uniform sampler2D uLightMap;
  30: uniform sampler2D uCrumbling;
  31: 
  32: vec4 FLWBlockTexture(vec2 texCoords) {
  33:     vec4 cr = texture2D(uCrumbling, texCoords * uTextureScale);
  34:     float diffuseAlpha = texture2D(uBlockAtlas, texCoords).a;
  35:     cr.a = cr.a * diffuseAlpha;
  36:     return cr;
  37: }
  38: 
  39: void FLWFinalizeColor(vec4 color) {
  40:     #if defined(USE_FOG)
  41:     float a = color.a;
  42:     float fog = clamp(FLWFogFactor(), 0., 1.);
  43: 
  44:     color = mix(uFogColor, color, fog);
  45:     color.a = a;
  46:     #endif
  47: 
  48:     gl_FragColor = color;
  49: }
  50: 
  51: vec4 FLWLight(vec2 lightCoords) {
  52:     return vec4(1.);
  53: }
  54: 
  55: 
  56: 
  57: struct BlockFrag {
  58:     vec2 texCoords;
  59:     vec4 color;
  60:     float diffuse;
  61:     vec2 light;
  62: };
  63: 
  64: void FLWMain(BlockFrag r) {
  65:     vec4 tex = FLWBlockTexture(r.texCoords);
  66: 
  67:     vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;
  68: 
  69: //    flw_WorldPos = ;
  70: //    flw_Normal = ;
  71: //    flw_Albedo = tex.rgb;
  72: //    flw_Alpha = tex.a;
  73: //    flw_LightMap = r.light;
  74: //    flw_Tint = r.color;
  75:     FLWFinalizeColor(color);
  76: }
  77: 
  78: varying vec2 v2f_texCoords;
  79: varying vec4 v2f_color;
  80: varying float v2f_diffuse;
  81: varying vec2 v2f_light;
  82: 
  83: 
  84: //vec3 flw_WorldPos;
  85: //vec3 flw_Normal;
  86: //vec3 flw_Albedo;
  87: //float flw_Alpha;
  88: //vec2 flw_LightMap;
  89: //vec4 flw_Tint;
  90: 
  91: void main() {
  92:     BlockFrag f;
  93:     f.texCoords = v2f_texCoords;
  94: f.color = v2f_color;
  95: f.diffuse = v2f_diffuse;
  96: f.light = v2f_light;
  97: 
  98: 
  99:     FLWMain(f);
 100: }

[14:02:47] [main/ERROR]: Shader compilation log for flywheel:model.vert: No errors.

[14:02:47] [main/ERROR]: Source for shader 'flywheel:model.vert':
   1: #version 110
   2: 
   3: uniform float uTime;
   4: uniform mat4 uViewProjection;
   5: uniform vec3 uCameraPos;
   6: 
   7: #if defined(USE_FOG)
   8: varying float FragDistance;
   9: #endif
  10: 
  11: void FLWFinalizeWorldPos(inout vec4 worldPos) {
  12:     #if defined(USE_FOG)
  13:     FragDistance = length(worldPos.xyz - uCameraPos);
  14:     #endif
  15: 
  16:     gl_Position = uViewProjection * worldPos;
  17: }
  18: 
  19: void FLWFinalizeNormal(inout vec3 normal) {
  20:     // noop
  21: }
  22: 
  23: 
  24: float diffuse(vec3 normal) {
  25:     vec3 n2 = normal * normal * vec3(.6, .25, .8);
  26:     return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
  27: }
  28: 
  29: 
  30: struct Vertex {
  31:     vec3 pos;
  32:     vec3 normal;
  33:     vec2 texCoords;
  34: };
  35: 
  36: struct BlockFrag {
  37:     vec2 texCoords;
  38:     vec4 color;
  39:     float diffuse;
  40:     vec2 light;
  41: };
  42: 
  43: 
  44: struct Instance {
  45:     vec2 light;
  46:     vec4 color;
  47:     mat4 transform;
  48:     mat3 normalMat;
  49: };
  50: 
  51: BlockFrag FLWMain(Vertex v, Instance i) {
  52:     vec4 worldPos = i.transform * vec4(v.pos, 1.);
  53: 
  54:     vec3 norm = i.normalMat * v.normal;
  55: 
  56:     FLWFinalizeWorldPos(worldPos);
  57:     FLWFinalizeNormal(norm);
  58: 
  59:     norm = normalize(norm);
  60: 
  61:     BlockFrag b;
  62:     b.diffuse = diffuse(norm);
  63:     b.texCoords = v.texCoords;
  64:     b.light = i.light;
  65:     #if defined(DEBUG_NORMAL)
  66:     b.color = vec4(norm, 1.);
  67:     #else
  68:     b.color = i.color;
  69:     #endif
  70:     return b;
  71: }
  72: attribute vec3 a_v_pos;
  73: attribute vec3 a_v_normal;
  74: attribute vec2 a_v_texCoords;
  75: 
  76: attribute vec2 a_i_light;
  77: attribute vec4 a_i_color;
  78: attribute mat4 a_i_transform;
  79: attribute mat3 a_i_normalMat;
  80: 
  81: 
  82: varying vec2 v2f_texCoords;
  83: varying vec4 v2f_color;
  84: varying float v2f_diffuse;
  85: varying vec2 v2f_light;
  86: 
  87: 
  88: void main() {
  89:     Vertex v;
  90:     v.pos = a_v_pos;
  91: v.normal = a_v_normal;
  92: v.texCoords = a_v_texCoords;
  93: 
  94: 
  95:     Instance i;
  96:     i.light = a_i_light;
  97: i.color = a_i_color;
  98: i.transform = a_i_transform;
  99: i.normalMat = a_i_normalMat;
 100: 
 101: 
 102:     BlockFrag o = FLWMain(v, i);
 103: 
 104:     v2f_texCoords = o.texCoords;
 105: v2f_color = o.color;
 106: v2f_diffuse = o.diffuse;
 107: v2f_light = o.light;
 108: 
 109: }

[14:02:47] [main/ERROR]: Shader compilation log for flywheel:block.frag: No errors.

[14:02:47] [main/ERROR]: Source for shader 'flywheel:block.frag':
   1: #version 110
   2: 
   3: #if defined(USE_FOG)
   4: varying float FragDistance;
   5: uniform vec4 uFogColor;
   6: #endif
   7: 
   8: #if defined(USE_FOG_LINEAR)
   9: uniform vec2 uFogRange;
  10: 
  11: float FLWFogFactor() {
  12:     return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
  13: }
  14:     #endif
  15: 
  16:     #if defined(USE_FOG_EXP2)
  17: uniform float uFogDensity;
  18: 
  19: float FLWFogFactor() {
  20:     float dist = FragDistance * uFogDensity;
  21:     return 1. / exp2(dist * dist);
  22: }
  23:     #endif
  24: 
  25: uniform vec2 uTextureScale;
  26: uniform sampler2D uBlockAtlas;
  27: uniform sampler2D uLightMap;
  28: uniform sampler2D uCrumbling;
  29: 
  30: vec4 FLWBlockTexture(vec2 texCoords) {
  31:     vec4 cr = texture2D(uCrumbling, texCoords * uTextureScale);
  32:     float diffuseAlpha = texture2D(uBlockAtlas, texCoords).a;
  33:     cr.a = cr.a * diffuseAlpha;
  34:     return cr;
  35: }
  36: 
  37: void FLWFinalizeColor(vec4 color) {
  38:     #if defined(USE_FOG)
  39:     float a = color.a;
  40:     float fog = clamp(FLWFogFactor(), 0., 1.);
  41: 
  42:     color = mix(uFogColor, color, fog);
  43:     color.a = a;
  44:     #endif
  45: 
  46:     gl_FragColor = color;
  47: }
  48: 
  49: vec4 FLWLight(vec2 lightCoords) {
  50:     return vec4(1.);
  51: }
  52: 
  53: 
  54: 
  55: struct BlockFrag {
  56:     vec2 texCoords;
  57:     vec4 color;
  58:     float diffuse;
  59:     vec2 light;
  60: };
  61: 
  62: void FLWMain(BlockFrag r) {
  63:     vec4 tex = FLWBlockTexture(r.texCoords);
  64: 
  65:     vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;
  66: 
  67: //    flw_WorldPos = ;
  68: //    flw_Normal = ;
  69: //    flw_Albedo = tex.rgb;
  70: //    flw_Alpha = tex.a;
  71: //    flw_LightMap = r.light;
  72: //    flw_Tint = r.color;
  73:     FLWFinalizeColor(color);
  74: }
  75: 
  76: varying vec2 v2f_texCoords;
  77: varying vec4 v2f_color;
  78: varying float v2f_diffuse;
  79: varying vec2 v2f_light;
  80: 
  81: 
  82: //vec3 flw_WorldPos;
  83: //vec3 flw_Normal;
  84: //vec3 flw_Albedo;
  85: //float flw_Alpha;
  86: //vec2 flw_LightMap;
  87: //vec4 flw_Tint;
  88: 
  89: void main() {
  90:     BlockFrag f;
  91:     f.texCoords = v2f_texCoords;
  92: f.color = v2f_color;
  93: f.diffuse = v2f_diffuse;
  94: f.light = v2f_light;
  95: 
  96: 
  97:     FLWMain(f);
  98: }

[14:02:47] [main/INFO]: Loading context 'flywheel:context/world'
[14:02:47] [main/ERROR]: Shader compilation log for create:rotating.vert: No errors.

[14:02:47] [main/ERROR]: Source for shader 'create:rotating.vert':
   1: #version 110
   2: #define DEBUG_RAINBOW
   3: 
   4: #define PI 3.1415926538
   5: 
   6: uniform float uTime;
   7: uniform mat4 uViewProjection;
   8: uniform vec3 uCameraPos;
   9: 
  10: #if defined(USE_FOG)
  11: varying float FragDistance;
  12: #endif
  13: 
  14: void FLWFinalizeWorldPos(inout vec4 worldPos) {
  15:     #if defined(USE_FOG)
  16:     FragDistance = length(worldPos.xyz - uCameraPos);
  17:     #endif
  18: 
  19:     gl_Position = uViewProjection * worldPos;
  20: }
  21: 
  22: void FLWFinalizeNormal(inout vec3 normal) {
  23:     // noop
  24: }
  25: 
  26: 
  27: mat4 rotate(vec3 axis, float angle) {
  28:     float s = sin(angle);
  29:     float c = cos(angle);
  30:     float oc = 1. - c;
  31: 
  32:     vec3 sa = axis * s;
  33: 
  34:     mat4 mr = mat4(1.);
  35:     mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
  36:     mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
  37:     mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);
  38: 
  39:     return mr;
  40: }
  41: 
  42: mat4 rotation(vec3 rot) {
  43:     return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
  44: }
  45: 
  46: mat3 modelToNormal(mat4 mat) {
  47:     // Discard the edges. This won't be accurate for scaled or skewed matrices,
  48:     // but we don't have to work with those often.
  49:     mat3 m;
  50:     m[0] = mat[0].xyz;
  51:     m[1] = mat[1].xyz;
  52:     m[2] = mat[2].xyz;
  53:     return m;
  54: }
  55: 
  56: float diffuse(vec3 normal) {
  57:     vec3 n2 = normal * normal * vec3(.6, .25, .8);
  58:     return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
  59: }
  60: 
  61: 
  62: struct Rotating {
  63:     vec2 light;
  64:     vec4 color;
  65:     vec3 pos;
  66:     float speed;
  67:     float offset;
  68:     vec3 axis;
  69: };
  70: 
  71: 
  72: struct Vertex {
  73:     vec3 pos;
  74:     vec3 normal;
  75:     vec2 texCoords;
  76: };
  77: 
  78: struct BlockFrag {
  79:     vec2 texCoords;
  80:     vec4 color;
  81:     float diffuse;
  82:     vec2 light;
  83: };
  84: 
  85: mat4 kineticRotation(float offset, float speed, vec3 axis) {
  86:     float degrees = offset + uTime * speed * 3./10.;
  87:     float angle = fract(degrees / 360.) * PI * 2.;
  88: 
  89:     return rotate(axis, angle);
  90: }
  91: 
  92: BlockFrag FLWMain(Vertex v, Rotating instance) {
  93:     mat4 spin = kineticRotation(instance.offset, instance.speed, instance.axis);
  94: 
  95:     vec4 worldPos = spin * vec4(v.pos - .5, 1.);
  96:     worldPos += vec4(instance.pos + .5, 0.);
  97: 
  98:     vec3 norm = modelToNormal(spin) * v.normal;
  99: 
 100:     FLWFinalizeWorldPos(worldPos);
 101:     FLWFinalizeNormal(norm);
 102: 
 103:     BlockFrag b;
 104:     b.diffuse = diffuse(norm);
 105:     b.texCoords = v.texCoords;
 106:     b.light = instance.light;
 107: 
 108:     #if defined(DEBUG_RAINBOW)
 109:     b.color = instance.color;
 110:     #elif defined(DEBUG_NORMAL)
 111:     b.color = vec4(norm, 1.);
 112:     #else
 113:     b.color = vec4(1.);
 114:     #endif
 115: 
 116:     return b;
 117: }
 118: attribute vec3 a_v_pos;
 119: attribute vec3 a_v_normal;
 120: attribute vec2 a_v_texCoords;
 121: 
 122: attribute vec2 a_i_light;
 123: attribute vec4 a_i_color;
 124: attribute vec3 a_i_pos;
 125: attribute float a_i_speed;
 126: attribute float a_i_offset;
 127: attribute vec3 a_i_axis;
 128: 
 129: 
 130: varying vec2 v2f_texCoords;
 131: varying vec4 v2f_color;
 132: varying float v2f_diffuse;
 133: varying vec2 v2f_light;
 134: 
 135: 
 136: void main() {
 137:     Vertex v;
 138:     v.pos = a_v_pos;
 139: v.normal = a_v_normal;
 140: v.texCoords = a_v_texCoords;
 141: 
 142: 
 143:     Rotating i;
 144:     i.light = a_i_light;
 145: i.color = a_i_color;
 146: i.pos = a_i_pos;
 147: i.speed = a_i_speed;
 148: i.offset = a_i_offset;
 149: i.axis = a_i_axis;
 150: 
 151: 
 152:     BlockFrag o = FLWMain(v, i);
 153: 
 154:     v2f_texCoords = o.texCoords;
 155: v2f_color = o.color;
 156: v2f_diffuse = o.diffuse;
 157: v2f_light = o.light;
 158: 
 159: }

[14:02:47] [main/ERROR]: Shader compilation log for flywheel:block.frag: No errors.

[14:02:47] [main/ERROR]: Source for shader 'flywheel:block.frag':
   1: #version 110
   2: #define DEBUG_RAINBOW
   3: 
   4: #if defined(USE_FOG)
   5: varying float FragDistance;
   6: uniform vec4 uFogColor;
   7: #endif
   8: 
   9: #if defined(USE_FOG_LINEAR)
  10: uniform vec2 uFogRange;
  11: 
  12: float FLWFogFactor() {
  13:     return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
  14: }
  15:     #endif
  16: 
  17:     #if defined(USE_FOG_EXP2)
  18: uniform float uFogDensity;
  19: 
  20: float FLWFogFactor() {
  21:     float dist = FragDistance * uFogDensity;
  22:     return 1. / exp2(dist * dist);
  23: }
  24:     #endif
  25: // Adjust the [0,1] normalized lightmap value based on the texture matrix from LightTexture#enableLightmap
  26: vec2 shiftLight(vec2 lm) {
  27:     return lm * 0.99609375 + 0.03125;// * 255/256 + 1/32
  28: }
  29: 
  30: uniform sampler2D uBlockAtlas;
  31: uniform sampler2D uLightMap;
  32: 
  33: vec4 FLWBlockTexture(vec2 texCoords) {
  34:     return texture2D(uBlockAtlas, texCoords);
  35: }
  36: 
  37: void FLWFinalizeColor(vec4 color) {
  38:     #if defined(USE_FOG)
  39:     float a = color.a;
  40:     float fog = clamp(FLWFogFactor(), 0., 1.);
  41: 
  42:     color = mix(uFogColor, color, fog);
  43:     color.a = a;
  44:     #endif
  45: 
  46:     gl_FragColor = color;
  47: }
  48: 
  49: vec4 FLWLight(vec2 lightCoords) {
  50:     return texture2D(uLightMap, shiftLight(lightCoords));
  51: }
  52: 
  53: 
  54: 
  55: struct BlockFrag {
  56:     vec2 texCoords;
  57:     vec4 color;
  58:     float diffuse;
  59:     vec2 light;
  60: };
  61: 
  62: void FLWMain(BlockFrag r) {
  63:     vec4 tex = FLWBlockTexture(r.texCoords);
  64: 
  65:     vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;
  66: 
  67: //    flw_WorldPos = ;
  68: //    flw_Normal = ;
  69: //    flw_Albedo = tex.rgb;
  70: //    flw_Alpha = tex.a;
  71: //    flw_LightMap = r.light;
  72: //    flw_Tint = r.color;
  73:     FLWFinalizeColor(color);
  74: }
  75: 
  76: varying vec2 v2f_texCoords;
  77: varying vec4 v2f_color;
  78: varying float v2f_diffuse;
  79: varying vec2 v2f_light;
  80: 
  81: 
  82: //vec3 flw_WorldPos;
  83: //vec3 flw_Normal;
  84: //vec3 flw_Albedo;
  85: //float flw_Alpha;
  86: //vec2 flw_LightMap;
  87: //vec4 flw_Tint;
  88: 
  89: void main() {
  90:     BlockFrag f;
  91:     f.texCoords = v2f_texCoords;
  92: f.color = v2f_color;
  93: f.diffuse = v2f_diffuse;
  94: f.light = v2f_light;
  95: 
  96: 
  97:     FLWMain(f);
  98: }

[14:02:47] [main/ERROR]: Shader compilation log for create:rotating.vert: No errors.

[14:02:47] [main/ERROR]: Source for shader 'create:rotating.vert':
   1: #version 110
   2: #define DEBUG_NORMAL
   3: 
   4: #define PI 3.1415926538
   5: 
   6: uniform float uTime;
   7: uniform mat4 uViewProjection;
   8: uniform vec3 uCameraPos;
   9: 
  10: #if defined(USE_FOG)
  11: varying float FragDistance;
  12: #endif
  13: 
  14: void FLWFinalizeWorldPos(inout vec4 worldPos) {
  15:     #if defined(USE_FOG)
  16:     FragDistance = length(worldPos.xyz - uCameraPos);
  17:     #endif
  18: 
  19:     gl_Position = uViewProjection * worldPos;
  20: }
  21: 
  22: void FLWFinalizeNormal(inout vec3 normal) {
  23:     // noop
  24: }
  25: 
  26: 
  27: mat4 rotate(vec3 axis, float angle) {
  28:     float s = sin(angle);
  29:     float c = cos(angle);
  30:     float oc = 1. - c;
  31: 
  32:     vec3 sa = axis * s;
  33: 
  34:     mat4 mr = mat4(1.);
  35:     mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
  36:     mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
  37:     mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);
  38: 
  39:     return mr;
  40: }
  41: 
  42: mat4 rotation(vec3 rot) {
  43:     return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
  44: }
  45: 
  46: mat3 modelToNormal(mat4 mat) {
  47:     // Discard the edges. This won't be accurate for scaled or skewed matrices,
  48:     // but we don't have to work with those often.
  49:     mat3 m;
  50:     m[0] = mat[0].xyz;
  51:     m[1] = mat[1].xyz;
  52:     m[2] = mat[2].xyz;
  53:     return m;
  54: }
  55: 
  56: float diffuse(vec3 normal) {
  57:     vec3 n2 = normal * normal * vec3(.6, .25, .8);
  58:     return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
  59: }
  60: 
  61: 
  62: struct Rotating {
  63:     vec2 light;
  64:     vec4 color;
  65:     vec3 pos;
  66:     float speed;
  67:     float offset;
  68:     vec3 axis;
  69: };
  70: 
  71: 
  72: struct Vertex {
  73:     vec3 pos;
  74:     vec3 normal;
  75:     vec2 texCoords;
  76: };
  77: 
  78: struct BlockFrag {
  79:     vec2 texCoords;
  80:     vec4 color;
  81:     float diffuse;
  82:     vec2 light;
  83: };
  84: 
  85: mat4 kineticRotation(float offset, float speed, vec3 axis) {
  86:     float degrees = offset + uTime * speed * 3./10.;
  87:     float angle = fract(degrees / 360.) * PI * 2.;
  88: 
  89:     return rotate(axis, angle);
  90: }
  91: 
  92: BlockFrag FLWMain(Vertex v, Rotating instance) {
  93:     mat4 spin = kineticRotation(instance.offset, instance.speed, instance.axis);
  94: 
  95:     vec4 worldPos = spin * vec4(v.pos - .5, 1.);
  96:     worldPos += vec4(instance.pos + .5, 0.);
  97: 
  98:     vec3 norm = modelToNormal(spin) * v.normal;
  99: 
 100:     FLWFinalizeWorldPos(worldPos);
 101:     FLWFinalizeNormal(norm);
 102: 
 103:     BlockFrag b;
 104:     b.diffuse = diffuse(norm);
 105:     b.texCoords = v.texCoords;
 106:     b.light = instance.light;
 107: 
 108:     #if defined(DEBUG_RAINBOW)
 109:     b.color = instance.color;
 110:     #elif defined(DEBUG_NORMAL)
 111:     b.color = vec4(norm, 1.);
 112:     #else
 113:     b.color = vec4(1.);
 114:     #endif
 115: 
 116:     return b;
 117: }
 118: attribute vec3 a_v_pos;
 119: attribute vec3 a_v_normal;
 120: attribute vec2 a_v_texCoords;
 121: 
 122: attribute vec2 a_i_light;
 123: attribute vec4 a_i_color;
 124: attribute vec3 a_i_pos;
 125: attribute float a_i_speed;
 126: attribute float a_i_offset;
 127: attribute vec3 a_i_axis;
 128: 
 129: 
 130: varying vec2 v2f_texCoords;
 131: varying vec4 v2f_color;
 132: varying float v2f_diffuse;
 133: varying vec2 v2f_light;
 134: 
 135: 
 136: void main() {
 137:     Vertex v;
 138:     v.pos = a_v_pos;
 139: v.normal = a_v_normal;
 140: v.texCoords = a_v_texCoords;
 141: 
 142: 
 143:     Rotating i;
 144:     i.light = a_i_light;
 145: i.color = a_i_color;
 146: i.pos = a_i_pos;
 147: i.speed = a_i_speed;
 148: i.offset = a_i_offset;
 149: i.axis = a_i_axis;
 150: 
 151: 
 152:     BlockFrag o = FLWMain(v, i);
 153: 
 154:     v2f_texCoords = o.texCoords;
 155: v2f_color = o.color;
 156: v2f_diffuse = o.diffuse;
 157: v2f_light = o.light;
 158: 
 159: }

[14:02:47] [main/ERROR]: Shader compilation log for flywheel:block.frag: No errors.

[14:02:47] [main/ERROR]: Source for shader 'flywheel:block.frag':
   1: #version 110
   2: #define DEBUG_NORMAL
   3: 
   4: #if defined(USE_FOG)
   5: varying float FragDistance;
   6: uniform vec4 uFogColor;
   7: #endif
   8: 
   9: #if defined(USE_FOG_LINEAR)
  10: uniform vec2 uFogRange;
  11: 
  12: float FLWFogFactor() {
  13:     return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
  14: }
  15:     #endif
  16: 
  17:     #if defined(USE_FOG_EXP2)
  18: uniform float uFogDensity;
  19: 
  20: float FLWFogFactor() {
  21:     float dist = FragDistance * uFogDensity;
  22:     return 1. / exp2(dist * dist);
  23: }
  24:     #endif
  25: // Adjust the [0,1] normalized lightmap value based on the texture matrix from LightTexture#enableLightmap
  26: vec2 shiftLight(vec2 lm) {
  27:     return lm * 0.99609375 + 0.03125;// * 255/256 + 1/32
  28: }
  29: 
  30: uniform sampler2D uBlockAtlas;
  31: uniform sampler2D uLightMap;
  32: 
  33: vec4 FLWBlockTexture(vec2 texCoords) {
  34:     return texture2D(uBlockAtlas, texCoords);
  35: }
  36: 
  37: void FLWFinalizeColor(vec4 color) {
  38:     #if defined(USE_FOG)
  39:     float a = color.a;
  40:     float fog = clamp(FLWFogFactor(), 0., 1.);
  41: 
  42:     color = mix(uFogColor, color, fog);
  43:     color.a = a;
  44:     #endif
  45: 
  46:     gl_FragColor = color;
  47: }
  48: 
  49: vec4 FLWLight(vec2 lightCoords) {
  50:     return texture2D(uLightMap, shiftLight(lightCoords));
  51: }
  52: 
  53: 
  54: 
  55: struct BlockFrag {
  56:     vec2 texCoords;
  57:     vec4 color;
  58:     float diffuse;
  59:     vec2 light;
  60: };
  61: 
  62: void FLWMain(BlockFrag r) {
  63:     vec4 tex = FLWBlockTexture(r.texCoords);
  64: 
  65:     vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;
  66: 
  67: //    flw_WorldPos = ;
  68: //    flw_Normal = ;
  69: //    flw_Albedo = tex.rgb;
  70: //    flw_Alpha = tex.a;
  71: //    flw_LightMap = r.light;
  72: //    flw_Tint = r.color;
  73:     FLWFinalizeColor(color);
  74: }
  75: 
  76: varying vec2 v2f_texCoords;
  77: varying vec4 v2f_color;
  78: varying float v2f_diffuse;
  79: varying vec2 v2f_light;
  80: 
  81: 
  82: //vec3 flw_WorldPos;
  83: //vec3 flw_Normal;
  84: //vec3 flw_Albedo;
  85: //float flw_Alpha;
  86: //vec2 flw_LightMap;
  87: //vec4 flw_Tint;
  88: 
  89: void main() {
  90:     BlockFrag f;
  91:     f.texCoords = v2f_texCoords;
  92: f.color = v2f_color;
  93: f.diffuse = v2f_diffuse;
  94: f.light = v2f_light;
  95: 
  96: 
  97:     FLWMain(f);
  98: }

[14:02:47] [main/ERROR]: Shader compilation log for create:rotating.vert: No errors.

[14:02:47] [main/ERROR]: Source for shader 'create:rotating.vert':
   1: #version 110
   2: #define USE_FOG
   3: #define USE_FOG_LINEAR
   4: 
   5: #define PI 3.1415926538
   6: 
   7: uniform float uTime;
   8: uniform mat4 uViewProjection;
   9: uniform vec3 uCameraPos;
  10: 
  11: #if defined(USE_FOG)
  12: varying float FragDistance;
  13: #endif
  14: 
  15: void FLWFinalizeWorldPos(inout vec4 worldPos) {
  16:     #if defined(USE_FOG)
  17:     FragDistance = length(worldPos.xyz - uCameraPos);
  18:     #endif
  19: 
  20:     gl_Position = uViewProjection * worldPos;
  21: }
  22: 
  23: void FLWFinalizeNormal(inout vec3 normal) {
  24:     // noop
  25: }
  26: 
  27: 
  28: mat4 rotate(vec3 axis, float angle) {
  29:     float s = sin(angle);
  30:     float c = cos(angle);
  31:     float oc = 1. - c;
  32: 
  33:     vec3 sa = axis * s;
  34: 
  35:     mat4 mr = mat4(1.);
  36:     mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
  37:     mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
  38:     mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);
  39: 
  40:     return mr;
  41: }
  42: 
  43: mat4 rotation(vec3 rot) {
  44:     return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
  45: }
  46: 
  47: mat3 modelToNormal(mat4 mat) {
  48:     // Discard the edges. This won't be accurate for scaled or skewed matrices,
  49:     // but we don't have to work with those often.
  50:     mat3 m;
  51:     m[0] = mat[0].xyz;
  52:     m[1] = mat[1].xyz;
  53:     m[2] = mat[2].xyz;
  54:     return m;
  55: }
  56: 
  57: float diffuse(vec3 normal) {
  58:     vec3 n2 = normal * normal * vec3(.6, .25, .8);
  59:     return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
  60: }
  61: 
  62: 
  63: struct Rotating {
  64:     vec2 light;
  65:     vec4 color;
  66:     vec3 pos;
  67:     float speed;
  68:     float offset;
  69:     vec3 axis;
  70: };
  71: 
  72: 
  73: struct Vertex {
  74:     vec3 pos;
  75:     vec3 normal;
  76:     vec2 texCoords;
  77: };
  78: 
  79: struct BlockFrag {
  80:     vec2 texCoords;
  81:     vec4 color;
  82:     float diffuse;
  83:     vec2 light;
  84: };
  85: 
  86: mat4 kineticRotation(float offset, float speed, vec3 axis) {
  87:     float degrees = offset + uTime * speed * 3./10.;
  88:     float angle = fract(degrees / 360.) * PI * 2.;
  89: 
  90:     return rotate(axis, angle);
  91: }
  92: 
  93: BlockFrag FLWMain(Vertex v, Rotating instance) {
  94:     mat4 spin = kineticRotation(instance.offset, instance.speed, instance.axis);
  95: 
  96:     vec4 worldPos = spin * vec4(v.pos - .5, 1.);
  97:     worldPos += vec4(instance.pos + .5, 0.);
  98: 
  99:     vec3 norm = modelToNormal(spin) * v.normal;
 100: 
 101:     FLWFinalizeWorldPos(worldPos);
 102:     FLWFinalizeNormal(norm);
 103: 
 104:     BlockFrag b;
 105:     b.diffuse = diffuse(norm);
 106:     b.texCoords = v.texCoords;
 107:     b.light = instance.light;
 108: 
 109:     #if defined(DEBUG_RAINBOW)
 110:     b.color = instance.color;
 111:     #elif defined(DEBUG_NORMAL)
 112:     b.color = vec4(norm, 1.);
 113:     #else
 114:     b.color = vec4(1.);
 115:     #endif
 116: 
 117:     return b;
 118: }
 119: attribute vec3 a_v_pos;
 120: attribute vec3 a_v_normal;
 121: attribute vec2 a_v_texCoords;
 122: 
 123: attribute vec2 a_i_light;
 124: attribute vec4 a_i_color;
 125: attribute vec3 a_i_pos;
 126: attribute float a_i_speed;
 127: attribute float a_i_offset;
 128: attribute vec3 a_i_axis;
 129: 
 130: 
 131: varying vec2 v2f_texCoords;
 132: varying vec4 v2f_color;
 133: varying float v2f_diffuse;
 134: varying vec2 v2f_light;
 135: 
 136: 
 137: void main() {
 138:     Vertex v;
 139:     v.pos = a_v_pos;
 140: v.normal = a_v_normal;
 141: v.texCoords = a_v_texCoords;
 142: 
 143: 
 144:     Rotating i;
 145:     i.light = a_i_light;
 146: i.color = a_i_color;
 147: i.pos = a_i_pos;
 148: i.speed = a_i_speed;
 149: i.offset = a_i_offset;
 150: i.axis = a_i_axis;
 151: 
 152: 
 153:     BlockFrag o = FLWMain(v, i);
 154: 
 155:     v2f_texCoords = o.texCoords;
 156: v2f_color = o.color;
 157: v2f_diffuse = o.diffuse;
 158: v2f_light = o.light;
 159: 
 160: }

[14:02:47] [main/ERROR]: Shader compilation log for flywheel:block.frag: No errors.

[14:02:47] [main/ERROR]: Source for shader 'flywheel:block.frag':
   1: #version 110
   2: #define USE_FOG
   3: #define USE_FOG_LINEAR
   4: 
   5: #if defined(USE_FOG)
   6: varying float FragDistance;
   7: uniform vec4 uFogColor;
   8: #endif
   9: 
  10: #if defined(USE_FOG_LINEAR)
  11: uniform vec2 uFogRange;
  12: 
  13: float FLWFogFactor() {
  14:     return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
  15: }
  16:     #endif
  17: 
  18:     #if defined(USE_FOG_EXP2)
  19: uniform float uFogDensity;
  20: 
  21: float FLWFogFactor() {
  22:     float dist = FragDistance * uFogDensity;
  23:     return 1. / exp2(dist * dist);
  24: }
  25:     #endif
  26: // Adjust the [0,1] normalized lightmap value based on the texture matrix from LightTexture#enableLightmap
  27: vec2 shiftLight(vec2 lm) {
  28:     return lm * 0.99609375 + 0.03125;// * 255/256 + 1/32
  29: }
  30: 
  31: uniform sampler2D uBlockAtlas;
  32: uniform sampler2D uLightMap;
  33: 
  34: vec4 FLWBlockTexture(vec2 texCoords) {
  35:     return texture2D(uBlockAtlas, texCoords);
  36: }
  37: 
  38: void FLWFinalizeColor(vec4 color) {
  39:     #if defined(USE_FOG)
  40:     float a = color.a;
  41:     float fog = clamp(FLWFogFactor(), 0., 1.);
  42: 
  43:     color = mix(uFogColor, color, fog);
  44:     color.a = a;
  45:     #endif
  46: 
  47:     gl_FragColor = color;
  48: }
  49: 
  50: vec4 FLWLight(vec2 lightCoords) {
  51:     return texture2D(uLightMap, shiftLight(lightCoords));
  52: }
  53: 
  54: 
  55: 
  56: struct BlockFrag {
  57:     vec2 texCoords;
  58:     vec4 color;
  59:     float diffuse;
  60:     vec2 light;
  61: };
  62: 
  63: void FLWMain(BlockFrag r) {
  64:     vec4 tex = FLWBlockTexture(r.texCoords);
  65: 
  66:     vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;
  67: 
  68: //    flw_WorldPos = ;
  69: //    flw_Normal = ;
  70: //    flw_Albedo = tex.rgb;
  71: //    flw_Alpha = tex.a;
  72: //    flw_LightMap = r.light;
  73: //    flw_Tint = r.color;
  74:     FLWFinalizeColor(color);
  75: }
  76: 
  77: varying vec2 v2f_texCoords;
  78: varying vec4 v2f_color;
  79: varying float v2f_diffuse;
  80: varying vec2 v2f_light;
  81: 
  82: 
  83: //vec3 flw_WorldPos;
  84: //vec3 flw_Normal;
  85: //vec3 flw_Albedo;
  86: //float flw_Alpha;
  87: //vec2 flw_LightMap;
  88: //vec4 flw_Tint;
  89: 
  90: void main() {
  91:     BlockFrag f;
  92:     f.texCoords = v2f_texCoords;
  93: f.color = v2f_color;
  94: f.diffuse = v2f_diffuse;
  95: f.light = v2f_light;
  96: 
  97: 
  98:     FLWMain(f);
  99: }

[14:02:48] [main/ERROR]: Shader compilation log for create:rotating.vert: No errors.

[14:02:48] [main/ERROR]: Source for shader 'create:rotating.vert':
   1: #version 110
   2: #define USE_FOG
   3: #define USE_FOG_EXP2
   4: 
   5: #define PI 3.1415926538
   6: 
   7: uniform float uTime;
   8: uniform mat4 uViewProjection;
   9: uniform vec3 uCameraPos;
  10: 
  11: #if defined(USE_FOG)
  12: varying float FragDistance;
  13: #endif
  14: 
  15: void FLWFinalizeWorldPos(inout vec4 worldPos) {
  16:     #if defined(USE_FOG)
  17:     FragDistance = length(worldPos.xyz - uCameraPos);
  18:     #endif
  19: 
  20:     gl_Position = uViewProjection * worldPos;
  21: }
  22: 
  23: void FLWFinalizeNormal(inout vec3 normal) {
  24:     // noop
  25: }
  26: 
  27: 
  28: mat4 rotate(vec3 axis, float angle) {
  29:     float s = sin(angle);
  30:     float c = cos(angle);
  31:     float oc = 1. - c;
  32: 
  33:     vec3 sa = axis * s;
  34: 
  35:     mat4 mr = mat4(1.);
  36:     mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
  37:     mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
  38:     mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);
  39: 
  40:     return mr;
  41: }
  42: 
  43: mat4 rotation(vec3 rot) {
  44:     return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
  45: }
  46: 
  47: mat3 modelToNormal(mat4 mat) {
  48:     // Discard the edges. This won't be accurate for scaled or skewed matrices,
  49:     // but we don't have to work with those often.
  50:     mat3 m;
  51:     m[0] = mat[0].xyz;
  52:     m[1] = mat[1].xyz;
  53:     m[2] = mat[2].xyz;
  54:     return m;
  55: }
  56: 
  57: float diffuse(vec3 normal) {
  58:     vec3 n2 = normal * normal * vec3(.6, .25, .8);
  59:     return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
  60: }
  61: 
  62: 
  63: struct Rotating {
  64:     vec2 light;
  65:     vec4 color;
  66:     vec3 pos;
  67:     float speed;
  68:     float offset;
  69:     vec3 axis;
  70: };
  71: 
  72: 
  73: struct Vertex {
  74:     vec3 pos;
  75:     vec3 normal;
  76:     vec2 texCoords;
  77: };
  78: 
  79: struct BlockFrag {
  80:     vec2 texCoords;
  81:     vec4 color;
  82:     float diffuse;
  83:     vec2 light;
  84: };
  85: 
  86: mat4 kineticRotation(float offset, float speed, vec3 axis) {
  87:     float degrees = offset + uTime * speed * 3./10.;
  88:     float angle = fract(degrees / 360.) * PI * 2.;
  89: 
  90:     return rotate(axis, angle);
  91: }
  92: 
  93: BlockFrag FLWMain(Vertex v, Rotating instance) {
  94:     mat4 spin = kineticRotation(instance.offset, instance.speed, instance.axis);
  95: 
  96:     vec4 worldPos = spin * vec4(v.pos - .5, 1.);
  97:     worldPos += vec4(instance.pos + .5, 0.);
  98: 
  99:     vec3 norm = modelToNormal(spin) * v.normal;
 100: 
 101:     FLWFinalizeWorldPos(worldPos);
 102:     FLWFinalizeNormal(norm);
 103: 
 104:     BlockFrag b;
 105:     b.diffuse = diffuse(norm);
 106:     b.texCoords = v.texCoords;
 107:     b.light = instance.light;
 108: 
 109:     #if defined(DEBUG_RAINBOW)
 110:     b.color = instance.color;
 111:     #elif defined(DEBUG_NORMAL)
 112:     b.color = vec4(norm, 1.);
 113:     #else
 114:     b.color = vec4(1.);
 115:     #endif
 116: 
 117:     return b;
 118: }
 119: attribute vec3 a_v_pos;
 120: attribute vec3 a_v_normal;
 121: attribute vec2 a_v_texCoords;
 122: 
 123: attribute vec2 a_i_light;
 124: attribute vec4 a_i_color;
 125: attribute vec3 a_i_pos;
 126: attribute float a_i_speed;
 127: attribute float a_i_offset;
 128: attribute vec3 a_i_axis;
 129: 
 130: 
 131: varying vec2 v2f_texCoords;
 132: varying vec4 v2f_color;
 133: varying float v2f_diffuse;
 134: varying vec2 v2f_light;
 135: 
 136: 
 137: void main() {
 138:     Vertex v;
 139:     v.pos = a_v_pos;
 140: v.normal = a_v_normal;
 141: v.texCoords = a_v_texCoords;
 142: 
 143: 
 144:     Rotating i;
 145:     i.light = a_i_light;
 146: i.color = a_i_color;
 147: i.pos = a_i_pos;
 148: i.speed = a_i_speed;
 149: i.offset = a_i_offset;
 150: i.axis = a_i_axis;
 151: 
 152: 
 153:     BlockFrag o = FLWMain(v, i);
 154: 
 155:     v2f_texCoords = o.texCoords;
 156: v2f_color = o.color;
 157: v2f_diffuse = o.diffuse;
 158: v2f_light = o.light;
 159: 
 160: }

[14:02:48] [main/ERROR]: Shader compilation log for flywheel:block.frag: No errors.

[14:02:48] [main/ERROR]: Source for shader 'flywheel:block.frag':
   1: #version 110
   2: #define USE_FOG
   3: #define USE_FOG_EXP2
   4: 
   5: #if defined(USE_FOG)
   6: varying float FragDistance;
   7: uniform vec4 uFogColor;
   8: #endif
   9: 
  10: #if defined(USE_FOG_LINEAR)
  11: uniform vec2 uFogRange;
  12: 
  13: float FLWFogFactor() {
  14:     return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
  15: }
  16:     #endif
  17: 
  18:     #if defined(USE_FOG_EXP2)
  19: uniform float uFogDensity;
  20: 
  21: float FLWFogFactor() {
  22:     float dist = FragDistance * uFogDensity;
  23:     return 1. / exp2(dist * dist);
  24: }
  25:     #endif
  26: // Adjust the [0,1] normalized lightmap value based on the texture matrix from LightTexture#enableLightmap
  27: vec2 shiftLight(vec2 lm) {
  28:     return lm * 0.99609375 + 0.03125;// * 255/256 + 1/32
  29: }
  30: 
  31: uniform sampler2D uBlockAtlas;
  32: uniform sampler2D uLightMap;
  33: 
  34: vec4 FLWBlockTexture(vec2 texCoords) {
  35:     return texture2D(uBlockAtlas, texCoords);
  36: }
  37: 
  38: void FLWFinalizeColor(vec4 color) {
  39:     #if defined(USE_FOG)
  40:     float a = color.a;
  41:     float fog = clamp(FLWFogFactor(), 0., 1.);
  42: 
  43:     color = mix(uFogColor, color, fog);
  44:     color.a = a;
  45:     #endif
  46: 
  47:     gl_FragColor = color;
  48: }
  49: 
  50: vec4 FLWLight(vec2 lightCoords) {
  51:     return texture2D(uLightMap, shiftLight(lightCoords));
  52: }
  53: 
  54: 
  55: 
  56: struct BlockFrag {
  57:     vec2 texCoords;
  58:     vec4 color;
  59:     float diffuse;
  60:     vec2 light;
  61: };
  62: 
  63: void FLWMain(BlockFrag r) {
  64:     vec4 tex = FLWBlockTexture(r.texCoords);
  65: 
  66:     vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;
  67: 
  68: //    flw_WorldPos = ;
  69: //    flw_Normal = ;
  70: //    flw_Albedo = tex.rgb;
  71: //    flw_Alpha = tex.a;
  72: //    flw_LightMap = r.light;
  73: //    flw_Tint = r.color;
  74:     FLWFinalizeColor(color);
  75: }
  76: 
  77: varying vec2 v2f_texCoords;
  78: varying vec4 v2f_color;
  79: varying float v2f_diffuse;
  80: varying vec2 v2f_light;
  81: 
  82: 
  83: //vec3 flw_WorldPos;
  84: //vec3 flw_Normal;
  85: //vec3 flw_Albedo;
  86: //float flw_Alpha;
  87: //vec2 flw_LightMap;
  88: //vec4 flw_Tint;
  89: 
  90: void main() {
  91:     BlockFrag f;
  92:     f.texCoords = v2f_texCoords;
  93: f.color = v2f_color;
  94: f.diffuse = v2f_diffuse;
  95: f.light = v2f_light;
  96: 
  97: 
  98:     FLWMain(f);
  99: }

[14:02:48] [main/ERROR]: Shader compilation log for create:rotating.vert: No errors.

[14:02:48] [main/ERROR]: Source for shader 'create:rotating.vert':
   1: #version 110
   2: 
   3: #define PI 3.1415926538
   4: 
   5: uniform float uTime;
   6: uniform mat4 uViewProjection;
   7: uniform vec3 uCameraPos;
   8: 
   9: #if defined(USE_FOG)
  10: varying float FragDistance;
  11: #endif
  12: 
  13: void FLWFinalizeWorldPos(inout vec4 worldPos) {
  14:     #if defined(USE_FOG)
  15:     FragDistance = length(worldPos.xyz - uCameraPos);
  16:     #endif
  17: 
  18:     gl_Position = uViewProjection * worldPos;
  19: }
  20: 
  21: void FLWFinalizeNormal(inout vec3 normal) {
  22:     // noop
  23: }
  24: 
  25: 
  26: mat4 rotate(vec3 axis, float angle) {
  27:     float s = sin(angle);
  28:     float c = cos(angle);
  29:     float oc = 1. - c;
  30: 
  31:     vec3 sa = axis * s;
  32: 
  33:     mat4 mr = mat4(1.);
  34:     mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
  35:     mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
  36:     mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);
  37: 
  38:     return mr;
  39: }
  40: 
  41: mat4 rotation(vec3 rot) {
  42:     return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
  43: }
  44: 
  45: mat3 modelToNormal(mat4 mat) {
  46:     // Discard the edges. This won't be accurate for scaled or skewed matrices,
  47:     // but we don't have to work with those often.
  48:     mat3 m;
  49:     m[0] = mat[0].xyz;
  50:     m[1] = mat[1].xyz;
  51:     m[2] = mat[2].xyz;
  52:     return m;
  53: }
  54: 
  55: float diffuse(vec3 normal) {
  56:     vec3 n2 = normal * normal * vec3(.6, .25, .8);
  57:     return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
  58: }
  59: 
  60: 
  61: struct Rotating {
  62:     vec2 light;
  63:     vec4 color;
  64:     vec3 pos;
  65:     float speed;
  66:     float offset;
  67:     vec3 axis;
  68: };
  69: 
  70: 
  71: struct Vertex {
  72:     vec3 pos;
  73:     vec3 normal;
  74:     vec2 texCoords;
  75: };
  76: 
  77: struct BlockFrag {
  78:     vec2 texCoords;
  79:     vec4 color;
  80:     float diffuse;
  81:     vec2 light;
  82: };
  83: 
  84: mat4 kineticRotation(float offset, float speed, vec3 axis) {
  85:     float degrees = offset + uTime * speed * 3./10.;
  86:     float angle = fract(degrees / 360.) * PI * 2.;
  87: 
  88:     return rotate(axis, angle);
  89: }
  90: 
  91: BlockFrag FLWMain(Vertex v, Rotating instance) {
  92:     mat4 spin = kineticRotation(instance.offset, instance.speed, instance.axis);
  93: 
  94:     vec4 worldPos = spin * vec4(v.pos - .5, 1.);
  95:     worldPos += vec4(instance.pos + .5, 0.);
  96: 
  97:     vec3 norm = modelToNormal(spin) * v.normal;
  98: 
  99:     FLWFinalizeWorldPos(worldPos);
 100:     FLWFinalizeNormal(norm);
 101: 
 102:     BlockFrag b;
 103:     b.diffuse = diffuse(norm);
 104:     b.texCoords = v.texCoords;
 105:     b.light = instance.light;
 106: 
 107:     #if defined(DEBUG_RAINBOW)
 108:     b.color = instance.color;
 109:     #elif defined(DEBUG_NORMAL)
 110:     b.color = vec4(norm, 1.);
 111:     #else
 112:     b.color = vec4(1.);
 113:     #endif
 114: 
 115:     return b;
 116: }
 117: attribute vec3 a_v_pos;
 118: attribute vec3 a_v_normal;
 119: attribute vec2 a_v_texCoords;
 120: 
 121: attribute vec2 a_i_light;
 122: attribute vec4 a_i_color;
 123: attribute vec3 a_i_pos;
 124: attribute float a_i_speed;
 125: attribute float a_i_offset;
 126: attribute vec3 a_i_axis;
 127: 
 128: 
 129: varying vec2 v2f_texCoords;
 130: varying vec4 v2f_color;
 131: varying float v2f_diffuse;
 132: varying vec2 v2f_light;
 133: 
 134: 
 135: void main() {
 136:     Vertex v;
 137:     v.pos = a_v_pos;
 138: v.normal = a_v_normal;
 139: v.texCoords = a_v_texCoords;
 140: 
 141: 
 142:     Rotating i;
 143:     i.light = a_i_light;
 144: i.color = a_i_color;
 145: i.pos = a_i_pos;
 146: i.speed = a_i_speed;
 147: i.offset = a_i_offset;
 148: i.axis = a_i_axis;
 149: 
 150: 
 151:     BlockFrag o = FLWMain(v, i);
 152: 
 153:     v2f_texCoords = o.texCoords;
 154: v2f_color = o.color;
 155: v2f_diffuse = o.diffuse;
 156: v2f_light = o.light;
 157: 
 158: }

[14:02:48] [main/ERROR]: Shader compilation log for flywheel:block.frag: No errors.

[14:02:48] [main/ERROR]: Source for shader 'flywheel:block.frag':
   1: #version 110
   2: 
   3: #if defined(USE_FOG)
   4: varying float FragDistance;
   5: uniform vec4 uFogColor;
   6: #endif
   7: 
   8: #if defined(USE_FOG_LINEAR)
   9: uniform vec2 uFogRange;
  10: 
  11: float FLWFogFactor() {
  12:     return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
  13: }
  14:     #endif
  15: 
  16:     #if defined(USE_FOG_EXP2)
  17: uniform float uFogDensity;
  18: 
  19: float FLWFogFactor() {
  20:     float dist = FragDistance * uFogDensity;
  21:     return 1. / exp2(dist * dist);
  22: }
  23:     #endif
  24: // Adjust the [0,1] normalized lightmap value based on the texture matrix from LightTexture#enableLightmap
  25: vec2 shiftLight(vec2 lm) {
  26:     return lm * 0.99609375 + 0.03125;// * 255/256 + 1/32
  27: }
  28: 
  29: uniform sampler2D uBlockAtlas;
  30: uniform sampler2D uLightMap;
  31: 
  32: vec4 FLWBlockTexture(vec2 texCoords) {
  33:     return texture2D(uBlockAtlas, texCoords);
  34: }
  35: 
  36: void FLWFinalizeColor(vec4 color) {
  37:     #if defined(USE_FOG)
  38:     float a = color.a;
  39:     float fog = clamp(FLWFogFactor(), 0., 1.);
  40: 
  41:     color = mix(uFogColor, color, fog);
  42:     color.a = a;
  43:     #endif
  44: 
  45:     gl_FragColor = color;
  46: }
  47: 
  48: vec4 FLWLight(vec2 lightCoords) {
  49:     return texture2D(uLightMap, shiftLight(lightCoords));
  50: }
  51: 
  52: 
  53: 
  54: struct BlockFrag {
  55:     vec2 texCoords;
  56:     vec4 color;
  57:     float diffuse;
  58:     vec2 light;
  59: };
  60: 
  61: void FLWMain(BlockFrag r) {
  62:     vec4 tex = FLWBlockTexture(r.texCoords);
  63: 
  64:     vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;
  65: 
  66: //    flw_WorldPos = ;
  67: //    flw_Normal = ;
  68: //    flw_Albedo = tex.rgb;
  69: //    flw_Alpha = tex.a;
  70: //    flw_LightMap = r.light;
  71: //    flw_Tint = r.color;
  72:     FLWFinalizeColor(color);
  73: }
  74: 
  75: varying vec2 v2f_texCoords;
  76: varying vec4 v2f_color;
  77: varying float v2f_diffuse;
  78: varying vec2 v2f_light;
  79: 
  80: 
  81: //vec3 flw_WorldPos;
  82: //vec3 flw_Normal;
  83: //vec3 flw_Albedo;
  84: //float flw_Alpha;
  85: //vec2 flw_LightMap;
  86: //vec4 flw_Tint;
  87: 
  88: void main() {
  89:     BlockFrag f;
  90:     f.texCoords = v2f_texCoords;
  91: f.color = v2f_color;
  92: f.diffuse = v2f_diffuse;
  93: f.light = v2f_light;
  94: 
  95: 
  96:     FLWMain(f);
  97: }

[14:02:48] [main/ERROR]: Shader compilation log for create:contraption_actor.vert: No errors.

[14:02:48] [main/ERROR]: Source for shader 'create:contraption_actor.vert':
   1: #version 110
   2: #define DEBUG_NORMAL
   3: 
   4: #define PI 3.1415926538
   5: 
   6: uniform float uTime;
   7: uniform mat4 uViewProjection;
   8: uniform vec3 uCameraPos;
   9: 
  10: #if defined(USE_FOG)
  11: varying float FragDistance;
  12: #endif
  13: 
  14: void FLWFinalizeWorldPos(inout vec4 worldPos) {
  15:     #if defined(USE_FOG)
  16:     FragDistance = length(worldPos.xyz - uCameraPos);
  17:     #endif
  18: 
  19:     gl_Position = uViewProjection * worldPos;
  20: }
  21: 
  22: void FLWFinalizeNormal(inout vec3 normal) {
  23:     // noop
  24: }
  25: 
  26: 
  27: mat4 rotate(vec3 axis, float angle) {
  28:     float s = sin(angle);
  29:     float c = cos(angle);
  30:     float oc = 1. - c;
  31: 
  32:     vec3 sa = axis * s;
  33: 
  34:     mat4 mr = mat4(1.);
  35:     mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
  36:     mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
  37:     mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);
  38: 
  39:     return mr;
  40: }
  41: 
  42: mat4 rotation(vec3 rot) {
  43:     return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
  44: }
  45: 
  46: mat3 modelToNormal(mat4 mat) {
  47:     // Discard the edges. This won't be accurate for scaled or skewed matrices,
  48:     // but we don't have to work with those often.
  49:     mat3 m;
  50:     m[0] = mat[0].xyz;
  51:     m[1] = mat[1].xyz;
  52:     m[2] = mat[2].xyz;
  53:     return m;
  54: }
  55: 
  56: #define PIOVER2 1.5707963268
  57: 
  58: vec4 quat(vec3 axis, float angle) {
  59:     float halfAngle = angle * PIOVER2 / 180.0;
  60:     vec2 cs = sin(vec2(PIOVER2 - halfAngle, halfAngle)); // compute sin and cos in one instruction
  61:     return vec4(axis.xyz * cs.y,  cs.x);
  62: }
  63: 
  64: vec4 quatMult(vec4 q1, vec4 q2) {
  65:     // disgustingly vectorized quaternion multiplication
  66:     vec4 a = q1.w * q2.xyzw;
  67:     vec4 b = q1.x * q2.wzxy * vec4(1., -1., 1., -1.);
  68:     vec4 c = q1.y * q2.zwxy * vec4(1., 1., -1., -1.);
  69:     vec4 d = q1.z * q2.yxwz * vec4(-1., 1., 1., -1.);
  70: 
  71:     return a + b + c + d;
  72: }
  73: 
  74: vec3 rotateVertexByQuat(vec3 v, vec4 q) {
  75:     vec3 i = q.xyz;
  76:     return v + 2.0 * cross(i, cross(i, v) + q.w * v);
  77: }
  78: 
  79: vec3 rotateAbout(vec3 v, vec3 axis, float angle) {
  80:     return rotateVertexByQuat(v, quat(axis, angle));
  81: }
  82: 
  83: float diffuse(vec3 normal) {
  84:     vec3 n2 = normal * normal * vec3(.6, .25, .8);
  85:     return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
  86: }
  87: 
  88: 
  89: struct Actor {
  90:     vec3 pos;
  91:     vec2 light;
  92:     float offset;
  93:     vec3 axis;
  94:     vec4 rotation;
  95:     vec3 rotationCenter;
  96:     float speed;
  97: };
  98: 
  99: 
 100: struct Vertex {
 101:     vec3 pos;
 102:     vec3 normal;
 103:     vec2 texCoords;
 104: };
 105: 
 106: struct BlockFrag {
 107:     vec2 texCoords;
 108:     vec4 color;
 109:     float diffuse;
 110:     vec2 light;
 111: };
 112: 
 113: BlockFrag FLWMain(Vertex v, Actor instance) {
 114:     float degrees = instance.offset + uTime * instance.speed / 20.;
 115:     //float angle = fract(degrees / 360.) * PI * 2.;
 116: 
 117:     vec4 kineticRot = quat(instance.axis, degrees);
 118:     vec3 rotated = rotateVertexByQuat(v.pos - instance.rotationCenter, kineticRot) + instance.rotationCenter;
 119: 
 120:     vec4 worldPos = vec4(rotateVertexByQuat(rotated - .5, instance.rotation) + instance.pos + .5, 1.);
 121:     vec3 norm = rotateVertexByQuat(rotateVertexByQuat(v.normal, kineticRot), instance.rotation);
 122: 
 123:     FLWFinalizeWorldPos(worldPos);
 124:     FLWFinalizeNormal(norm);
 125: 
 126:     BlockFrag b;
 127:     b.diffuse = diffuse(norm);
 128:     b.texCoords = v.texCoords;
 129:     b.light = instance.light;
 130: 
 131:     #if defined(DEBUG_NORMAL)
 132:     b.color = vec4(norm, 1.);
 133:     #else
 134:     b.color = vec4(1.);
 135:     #endif
 136: 
 137:     return b;
 138: }
 139: attribute vec3 a_v_pos;
 140: attribute vec3 a_v_normal;
 141: attribute vec2 a_v_texCoords;
 142: 
 143: attribute vec3 a_i_pos;
 144: attribute vec2 a_i_light;
 145: attribute float a_i_offset;
 146: attribute vec3 a_i_axis;
 147: attribute vec4 a_i_rotation;
 148: attribute vec3 a_i_rotationCenter;
 149: attribute float a_i_speed;
 150: 
 151: 
 152: varying vec2 v2f_texCoords;
 153: varying vec4 v2f_color;
 154: varying float v2f_diffuse;
 155: varying vec2 v2f_light;
 156: 
 157: 
 158: void main() {
 159:     Vertex v;
 160:     v.pos = a_v_pos;
 161: v.normal = a_v_normal;
 162: v.texCoords = a_v_texCoords;
 163: 
 164: 
 165:     Actor i;
 166:     i.pos = a_i_pos;
 167: i.light = a_i_light;
 168: i.offset = a_i_offset;
 169: i.axis = a_i_axis;
 170: i.rotation = a_i_rotation;
 171: i.rotationCenter = a_i_rotationCenter;
 172: i.speed = a_i_speed;
 173: 
 174: 
 175:     BlockFrag o = FLWMain(v, i);
 176: 
 177:     v2f_texCoords = o.texCoords;
 178: v2f_color = o.color;
 179: v2f_diffuse = o.diffuse;
 180: v2f_light = o.light;
 181: 
 182: }

[14:02:48] [main/ERROR]: Shader compilation log for flywheel:block.frag: No errors.

[14:02:48] [main/ERROR]: Source for shader 'flywheel:block.frag':
   1: #version 110
   2: #define DEBUG_NORMAL
   3: 
   4: #if defined(USE_FOG)
   5: varying float FragDistance;
   6: uniform vec4 uFogColor;
   7: #endif
   8: 
   9: #if defined(USE_FOG_LINEAR)
  10: uniform vec2 uFogRange;
  11: 
  12: float FLWFogFactor() {
  13:     return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
  14: }
  15:     #endif
  16: 
  17:     #if defined(USE_FOG_EXP2)
  18: uniform float uFogDensity;
  19: 
  20: float FLWFogFactor() {
  21:     float dist = FragDistance * uFogDensity;
  22:     return 1. / exp2(dist * dist);
  23: }
  24:     #endif
  25: // Adjust the [0,1] normalized lightmap value based on the texture matrix from LightTexture#enableLightmap
  26: vec2 shiftLight(vec2 lm) {
  27:     return lm * 0.99609375 + 0.03125;// * 255/256 + 1/32
  28: }
  29: 
  30: uniform sampler2D uBlockAtlas;
  31: uniform sampler2D uLightMap;
  32: 
  33: vec4 FLWBlockTexture(vec2 texCoords) {
  34:     return texture2D(uBlockAtlas, texCoords);
  35: }
  36: 
  37: void FLWFinalizeColor(vec4 color) {
  38:     #if defined(USE_FOG)
  39:     float a = color.a;
  40:     float fog = clamp(FLWFogFactor(), 0., 1.);
  41: 
  42:     color = mix(uFogColor, color, fog);
  43:     color.a = a;
  44:     #endif
  45: 
  46:     gl_FragColor = color;
  47: }
  48: 
  49: vec4 FLWLight(vec2 lightCoords) {
  50:     return texture2D(uLightMap, shiftLight(lightCoords));
  51: }
  52: 
  53: 
  54: 
  55: struct BlockFrag {
  56:     vec2 texCoords;
  57:     vec4 color;
  58:     float diffuse;
  59:     vec2 light;
  60: };
  61: 
  62: void FLWMain(BlockFrag r) {
  63:     vec4 tex = FLWBlockTexture(r.texCoords);
  64: 
  65:     vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;
  66: 
  67: //    flw_WorldPos = ;
  68: //    flw_Normal = ;
  69: //    flw_Albedo = tex.rgb;
  70: //    flw_Alpha = tex.a;
  71: //    flw_LightMap = r.light;
  72: //    flw_Tint = r.color;
  73:     FLWFinalizeColor(color);
  74: }
  75: 
  76: varying vec2 v2f_texCoords;
  77: varying vec4 v2f_color;
  78: varying float v2f_diffuse;
  79: varying vec2 v2f_light;
  80: 
  81: 
  82: //vec3 flw_WorldPos;
  83: //vec3 flw_Normal;
  84: //vec3 flw_Albedo;
  85: //float flw_Alpha;
  86: //vec2 flw_LightMap;
  87: //vec4 flw_Tint;
  88: 
  89: void main() {
  90:     BlockFrag f;
  91:     f.texCoords = v2f_texCoords;
  92: f.color = v2f_color;
  93: f.diffuse = v2f_diffuse;
  94: f.light = v2f_light;
  95: 
  96: 
  97:     FLWMain(f);
  98: }

[14:02:48] [main/ERROR]: Shader compilation log for create:contraption_actor.vert: No errors.

[14:02:48] [main/ERROR]: Source for shader 'create:contraption_actor.vert':
   1: #version 110
   2: #define USE_FOG
   3: #define USE_FOG_LINEAR
   4: 
   5: #define PI 3.1415926538
   6: 
   7: uniform float uTime;
   8: uniform mat4 uViewProjection;
   9: uniform vec3 uCameraPos;
  10: 
  11: #if defined(USE_FOG)
  12: varying float FragDistance;
  13: #endif
  14: 
  15: void FLWFinalizeWorldPos(inout vec4 worldPos) {
  16:     #if defined(USE_FOG)
  17:     FragDistance = length(worldPos.xyz - uCameraPos);
  18:     #endif
  19: 
  20:     gl_Position = uViewProjection * worldPos;
  21: }
  22: 
  23: void FLWFinalizeNormal(inout vec3 normal) {
  24:     // noop
  25: }
  26: 
  27: 
  28: mat4 rotate(vec3 axis, float angle) {
  29:     float s = sin(angle);
  30:     float c = cos(angle);
  31:     float oc = 1. - c;
  32: 
  33:     vec3 sa = axis * s;
  34: 
  35:     mat4 mr = mat4(1.);
  36:     mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
  37:     mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
  38:     mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);
  39: 
  40:     return mr;
  41: }
  42: 
  43: mat4 rotation(vec3 rot) {
  44:     return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
  45: }
  46: 
  47: mat3 modelToNormal(mat4 mat) {
  48:     // Discard the edges. This won't be accurate for scaled or skewed matrices,
  49:     // but we don't have to work with those often.
  50:     mat3 m;
  51:     m[0] = mat[0].xyz;
  52:     m[1] = mat[1].xyz;
  53:     m[2] = mat[2].xyz;
  54:     return m;
  55: }
  56: 
  57: #define PIOVER2 1.5707963268
  58: 
  59: vec4 quat(vec3 axis, float angle) {
  60:     float halfAngle = angle * PIOVER2 / 180.0;
  61:     vec2 cs = sin(vec2(PIOVER2 - halfAngle, halfAngle)); // compute sin and cos in one instruction
  62:     return vec4(axis.xyz * cs.y,  cs.x);
  63: }
  64: 
  65: vec4 quatMult(vec4 q1, vec4 q2) {
  66:     // disgustingly vectorized quaternion multiplication
  67:     vec4 a = q1.w * q2.xyzw;
  68:     vec4 b = q1.x * q2.wzxy * vec4(1., -1., 1., -1.);
  69:     vec4 c = q1.y * q2.zwxy * vec4(1., 1., -1., -1.);
  70:     vec4 d = q1.z * q2.yxwz * vec4(-1., 1., 1., -1.);
  71: 
  72:     return a + b + c + d;
  73: }
  74: 
  75: vec3 rotateVertexByQuat(vec3 v, vec4 q) {
  76:     vec3 i = q.xyz;
  77:     return v + 2.0 * cross(i, cross(i, v) + q.w * v);
  78: }
  79: 
  80: vec3 rotateAbout(vec3 v, vec3 axis, float angle) {
  81:     return rotateVertexByQuat(v, quat(axis, angle));
  82: }
  83: 
  84: float diffuse(vec3 normal) {
  85:     vec3 n2 = normal * normal * vec3(.6, .25, .8);
  86:     return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
  87: }
  88: 
  89: 
  90: struct Actor {
  91:     vec3 pos;
  92:     vec2 light;
  93:     float offset;
  94:     vec3 axis;
  95:     vec4 rotation;
  96:     vec3 rotationCenter;
  97:     float speed;
  98: };
  99: 
 100: 
 101: struct Vertex {
 102:     vec3 pos;
 103:     vec3 normal;
 104:     vec2 texCoords;
 105: };
 106: 
 107: struct BlockFrag {
 108:     vec2 texCoords;
 109:     vec4 color;
 110:     float diffuse;
 111:     vec2 light;
 112: };
 113: 
 114: BlockFrag FLWMain(Vertex v, Actor instance) {
 115:     float degrees = instance.offset + uTime * instance.speed / 20.;
 116:     //float angle = fract(degrees / 360.) * PI * 2.;
 117: 
 118:     vec4 kineticRot = quat(instance.axis, degrees);
 119:     vec3 rotated = rotateVertexByQuat(v.pos - instance.rotationCenter, kineticRot) + instance.rotationCenter;
 120: 
 121:     vec4 worldPos = vec4(rotateVertexByQuat(rotated - .5, instance.rotation) + instance.pos + .5, 1.);
 122:     vec3 norm = rotateVertexByQuat(rotateVertexByQuat(v.normal, kineticRot), instance.rotation);
 123: 
 124:     FLWFinalizeWorldPos(worldPos);
 125:     FLWFinalizeNormal(norm);
 126: 
 127:     BlockFrag b;
 128:     b.diffuse = diffuse(norm);
 129:     b.texCoords = v.texCoords;
 130:     b.light = instance.light;
 131: 
 132:     #if defined(DEBUG_NORMAL)
 133:     b.color = vec4(norm, 1.);
 134:     #else
 135:     b.color = vec4(1.);
 136:     #endif
 137: 
 138:     return b;
 139: }
 140: attribute vec3 a_v_pos;
 141: attribute vec3 a_v_normal;
 142: attribute vec2 a_v_texCoords;
 143: 
 144: attribute vec3 a_i_pos;
 145: attribute vec2 a_i_light;
 146: attribute float a_i_offset;
 147: attribute vec3 a_i_axis;
 148: attribute vec4 a_i_rotation;
 149: attribute vec3 a_i_rotationCenter;
 150: attribute float a_i_speed;
 151: 
 152: 
 153: varying vec2 v2f_texCoords;
 154: varying vec4 v2f_color;
 155: varying float v2f_diffuse;
 156: varying vec2 v2f_light;
 157: 
 158: 
 159: void main() {
 160:     Vertex v;
 161:     v.pos = a_v_pos;
 162: v.normal = a_v_normal;
 163: v.texCoords = a_v_texCoords;
 164: 
 165: 
 166:     Actor i;
 167:     i.pos = a_i_pos;
 168: i.light = a_i_light;
 169: i.offset = a_i_offset;
 170: i.axis = a_i_axis;
 171: i.rotation = a_i_rotation;
 172: i.rotationCenter = a_i_rotationCenter;
 173: i.speed = a_i_speed;
 174: 
 175: 
 176:     BlockFrag o = FLWMain(v, i);
 177: 
 178:     v2f_texCoords = o.texCoords;
 179: v2f_color = o.color;
 180: v2f_diffuse = o.diffuse;
 181: v2f_light = o.light;
 182: 
 183: }

[14:02:48] [main/ERROR]: Shader compilation log for flywheel:block.frag: No errors.

[14:02:48] [main/ERROR]: Source for shader 'flywheel:block.frag':
   1: #version 110
   2: #define USE_FOG
   3: #define USE_FOG_LINEAR
   4: 
   5: #if defined(USE_FOG)
   6: varying float FragDistance;
   7: uniform vec4 uFogColor;
   8: #endif
   9: 
  10: #if defined(USE_FOG_LINEAR)
  11: uniform vec2 uFogRange;
  12: 
  13: float FLWFogFactor() {
  14:     return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
  15: }
  16:     #endif
  17: 
  18:     #if defined(USE_FOG_EXP2)
  19: uniform float uFogDensity;
  20: 
  21: float FLWFogFactor() {
  22:     float dist = FragDistance * uFogDensity;
  23:     return 1. / exp2(dist * dist);
  24: }
  25:     #endif
  26: // Adjust the [0,1] normalized lightmap value based on the texture matrix from LightTexture#enableLightmap
  27: vec2 shiftLight(vec2 lm) {
  28:     return lm * 0.99609375 + 0.03125;// * 255/256 + 1/32
  29: }
  30: 
  31: uniform sampler2D uBlockAtlas;
  32: uniform sampler2D uLightMap;
  33: 
  34: vec4 FLWBlockTexture(vec2 texCoords) {
  35:     return texture2D(uBlockAtlas, texCoords);
  36: }
  37: 
  38: void FLWFinalizeColor(vec4 color) {
  39:     #if defined(USE_FOG)
  40:     float a = color.a;
  41:     float fog = clamp(FLWFogFactor(), 0., 1.);
  42: 
  43:     color = mix(uFogColor, color, fog);
  44:     color.a = a;
  45:     #endif
  46: 
  47:     gl_FragColor = color;
  48: }
  49: 
  50: vec4 FLWLight(vec2 lightCoords) {
  51:     return texture2D(uLightMap, shiftLight(lightCoords));
  52: }
  53: 
  54: 
  55: 
  56: struct BlockFrag {
  57:     vec2 texCoords;
  58:     vec4 color;
  59:     float diffuse;
  60:     vec2 light;
  61: };
  62: 
  63: void FLWMain(BlockFrag r) {
  64:     vec4 tex = FLWBlockTexture(r.texCoords);
  65: 
  66:     vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;
  67: 
  68: //    flw_WorldPos = ;
  69: //    flw_Normal = ;
  70: //    flw_Albedo = tex.rgb;
  71: //    flw_Alpha = tex.a;
  72: //    flw_LightMap = r.light;
  73: //    flw_Tint = r.color;
  74:     FLWFinalizeColor(color);
  75: }
  76: 
  77: varying vec2 v2f_texCoords;
  78: varying vec4 v2f_color;
  79: varying float v2f_diffuse;
  80: varying vec2 v2f_light;
  81: 
  82: 
  83: //vec3 flw_WorldPos;
  84: //vec3 flw_Normal;
  85: //vec3 flw_Albedo;
  86: //float flw_Alpha;
  87: //vec2 flw_LightMap;
  88: //vec4 flw_Tint;
  89: 
  90: void main() {
  91:     BlockFrag f;
  92:     f.texCoords = v2f_texCoords;
  93: f.color = v2f_color;
  94: f.diffuse = v2f_diffuse;
  95: f.light = v2f_light;
  96: 
  97: 
  98:     FLWMain(f);
  99: }

[14:02:48] [main/ERROR]: Shader compilation log for create:contraption_actor.vert: No errors.

[14:02:48] [main/ERROR]: Source for shader 'create:contraption_actor.vert':
   1: #version 110
   2: #define USE_FOG
   3: #define USE_FOG_EXP2
   4: 
   5: #define PI 3.1415926538
   6: 
   7: uniform float uTime;
   8: uniform mat4 uViewProjection;
   9: uniform vec3 uCameraPos;
  10: 
  11: #if defined(USE_FOG)
  12: varying float FragDistance;
  13: #endif
  14: 
  15: void FLWFinalizeWorldPos(inout vec4 worldPos) {
  16:     #if defined(USE_FOG)
  17:     FragDistance = length(worldPos.xyz - uCameraPos);
  18:     #endif
  19: 
  20:     gl_Position = uViewProjection * worldPos;
  21: }
  22: 
  23: void FLWFinalizeNormal(inout vec3 normal) {
  24:     // noop
  25: }
  26: 
  27: 
  28: mat4 rotate(vec3 axis, float angle) {
  29:     float s = sin(angle);
  30:     float c = cos(angle);
  31:     float oc = 1. - c;
  32: 
  33:     vec3 sa = axis * s;
  34: 
  35:     mat4 mr = mat4(1.);
  36:     mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
  37:     mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
  38:     mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);
  39: 
  40:     return mr;
  41: }
  42: 
  43: mat4 rotation(vec3 rot) {
  44:     return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
  45: }
  46: 
  47: mat3 modelToNormal(mat4 mat) {
  48:     // Discard the edges. This won't be accurate for scaled or skewed matrices,
  49:     // but we don't have to work with those often.
  50:     mat3 m;
  51:     m[0] = mat[0].xyz;
  52:     m[1] = mat[1].xyz;
  53:     m[2] = mat[2].xyz;
  54:     return m;
  55: }
  56: 
  57: #define PIOVER2 1.5707963268
  58: 
  59: vec4 quat(vec3 axis, float angle) {
  60:     float halfAngle = angle * PIOVER2 / 180.0;
  61:     vec2 cs = sin(vec2(PIOVER2 - halfAngle, halfAngle)); // compute sin and cos in one instruction
  62:     return vec4(axis.xyz * cs.y,  cs.x);
  63: }
  64: 
  65: vec4 quatMult(vec4 q1, vec4 q2) {
  66:     // disgustingly vectorized quaternion multiplication
  67:     vec4 a = q1.w * q2.xyzw;
  68:     vec4 b = q1.x * q2.wzxy * vec4(1., -1., 1., -1.);
  69:     vec4 c = q1.y * q2.zwxy * vec4(1., 1., -1., -1.);
  70:     vec4 d = q1.z * q2.yxwz * vec4(-1., 1., 1., -1.);
  71: 
  72:     return a + b + c + d;
  73: }
  74: 
  75: vec3 rotateVertexByQuat(vec3 v, vec4 q) {
  76:     vec3 i = q.xyz;
  77:     return v + 2.0 * cross(i, cross(i, v) + q.w * v);
  78: }
  79: 
  80: vec3 rotateAbout(vec3 v, vec3 axis, float angle) {
  81:     return rotateVertexByQuat(v, quat(axis, angle));
  82: }
  83: 
  84: float diffuse(vec3 normal) {
  85:     vec3 n2 = normal * normal * vec3(.6, .25, .8);
  86:     return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
  87: }
  88: 
  89: 
  90: struct Actor {
  91:     vec3 pos;
  92:     vec2 light;
  93:     float offset;
  94:     vec3 axis;
  95:     vec4 rotation;
  96:     vec3 rotationCenter;
  97:     float speed;
  98: };
  99: 
 100: 
 101: struct Vertex {
 102:     vec3 pos;
 103:     vec3 normal;
 104:     vec2 texCoords;
 105: };
 106: 
 107: struct BlockFrag {
 108:     vec2 texCoords;
 109:     vec4 color;
 110:     float diffuse;
 111:     vec2 light;
 112: };
 113: 
 114: BlockFrag FLWMain(Vertex v, Actor instance) {
 115:     float degrees = instance.offset + uTime * instance.speed / 20.;
 116:     //float angle = fract(degrees / 360.) * PI * 2.;
 117: 
 118:     vec4 kineticRot = quat(instance.axis, degrees);
 119:     vec3 rotated = rotateVertexByQuat(v.pos - instance.rotationCenter, kineticRot) + instance.rotationCenter;
 120: 
 121:     vec4 worldPos = vec4(rotateVertexByQuat(rotated - .5, instance.rotation) + instance.pos + .5, 1.);
 122:     vec3 norm = rotateVertexByQuat(rotateVertexByQuat(v.normal, kineticRot), instance.rotation);
 123: 
 124:     FLWFinalizeWorldPos(worldPos);
 125:     FLWFinalizeNormal(norm);
 126: 
 127:     BlockFrag b;
 128:     b.diffuse = diffuse(norm);
 129:     b.texCoords = v.texCoords;
 130:     b.light = instance.light;
 131: 
 132:     #if defined(DEBUG_NORMAL)
 133:     b.color = vec4(norm, 1.);
 134:     #else
 135:     b.color = vec4(1.);
 136:     #endif
 137: 
 138:     return b;
 139: }
 140: attribute vec3 a_v_pos;
 141: attribute vec3 a_v_normal;
 142: attribute vec2 a_v_texCoords;
 143: 
 144: attribute vec3 a_i_pos;
 145: attribute vec2 a_i_light;
 146: attribute float a_i_offset;
 147: attribute vec3 a_i_axis;
 148: attribute vec4 a_i_rotation;
 149: attribute vec3 a_i_rotationCenter;
 150: attribute float a_i_speed;
 151: 
 152: 
 153: varying vec2 v2f_texCoords;
 154: varying vec4 v2f_color;
 155: varying float v2f_diffuse;
 156: varying vec2 v2f_light;
 157: 
 158: 
 159: void main() {
 160:     Vertex v;
 161:     v.pos = a_v_pos;
 162: v.normal = a_v_normal;
 163: v.texCoords = a_v_texCoords;
 164: 
 165: 
 166:     Actor i;
 167:     i.pos = a_i_pos;
 168: i.light = a_i_light;
 169: i.offset = a_i_offset;
 170: i.axis = a_i_axis;
 171: i.rotation = a_i_rotation;
 172: i.rotationCenter = a_i_rotationCenter;
 173: i.speed = a_i_speed;
 174: 
 175: 
 176:     BlockFrag o = FLWMain(v, i);
 177: 
 178:     v2f_texCoords = o.texCoords;
 179: v2f_color = o.color;
 180: v2f_diffuse = o.diffuse;
 181: v2f_light = o.light;
 182: 
 183: }

[14:02:48] [main/ERROR]: Shader compilation log for flywheel:block.frag: No errors.

[14:02:48] [main/ERROR]: Source for shader 'flywheel:block.frag':
   1: #version 110
   2: #define USE_FOG
   3: #define USE_FOG_EXP2
   4: 
   5: #if defined(USE_FOG)
   6: varying float FragDistance;
   7: uniform vec4 uFogColor;
   8: #endif
   9: 
  10: #if defined(USE_FOG_LINEAR)
  11: uniform vec2 uFogRange;
  12: 
  13: float FLWFogFactor() {
  14:     return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
  15: }
  16:     #endif
  17: 
  18:     #if defined(USE_FOG_EXP2)
  19: uniform float uFogDensity;
  20: 
  21: float FLWFogFactor() {
  22:     float dist = FragDistance * uFogDensity;
  23:     return 1. / exp2(dist * dist);
  24: }
  25:     #endif
  26: // Adjust the [0,1] normalized lightmap value based on the texture matrix from LightTexture#enableLightmap
  27: vec2 shiftLight(vec2 lm) {
  28:     return lm * 0.99609375 + 0.03125;// * 255/256 + 1/32
  29: }
  30: 
  31: uniform sampler2D uBlockAtlas;
  32: uniform sampler2D uLightMap;
  33: 
  34: vec4 FLWBlockTexture(vec2 texCoords) {
  35:     return texture2D(uBlockAtlas, texCoords);
  36: }
  37: 
  38: void FLWFinalizeColor(vec4 color) {
  39:     #if defined(USE_FOG)
  40:     float a = color.a;
  41:     float fog = clamp(FLWFogFactor(), 0., 1.);
  42: 
  43:     color = mix(uFogColor, color, fog);
  44:     color.a = a;
  45:     #endif
  46: 
  47:     gl_FragColor = color;
  48: }
  49: 
  50: vec4 FLWLight(vec2 lightCoords) {
  51:     return texture2D(uLightMap, shiftLight(lightCoords));
  52: }
  53: 
  54: 
  55: 
  56: struct BlockFrag {
  57:     vec2 texCoords;
  58:     vec4 color;
  59:     float diffuse;
  60:     vec2 light;
  61: };
  62: 
  63: void FLWMain(BlockFrag r) {
  64:     vec4 tex = FLWBlockTexture(r.texCoords);
  65: 
  66:     vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;
  67: 
  68: //    flw_WorldPos = ;
  69: //    flw_Normal = ;
  70: //    flw_Albedo = tex.rgb;
  71: //    flw_Alpha = tex.a;
  72: //    flw_LightMap = r.light;
  73: //    flw_Tint = r.color;
  74:     FLWFinalizeColor(color);
  75: }
  76: 
  77: varying vec2 v2f_texCoords;
  78: varying vec4 v2f_color;
  79: varying float v2f_diffuse;
  80: varying vec2 v2f_light;
  81: 
  82: 
  83: //vec3 flw_WorldPos;
  84: //vec3 flw_Normal;
  85: //vec3 flw_Albedo;
  86: //float flw_Alpha;
  87: //vec2 flw_LightMap;
  88: //vec4 flw_Tint;
  89: 
  90: void main() {
  91:     BlockFrag f;
  92:     f.texCoords = v2f_texCoords;
  93: f.color = v2f_color;
  94: f.diffuse = v2f_diffuse;
  95: f.light = v2f_light;
  96: 
  97: 
  98:     FLWMain(f);
  99: }

[14:02:48] [main/ERROR]: Shader compilation log for create:contraption_actor.vert: No errors.

[14:02:48] [main/ERROR]: Source for shader 'create:contraption_actor.vert':
   1: #version 110
   2: 
   3: #define PI 3.1415926538
   4: 
   5: uniform float uTime;
   6: uniform mat4 uViewProjection;
   7: uniform vec3 uCameraPos;
   8: 
   9: #if defined(USE_FOG)
  10: varying float FragDistance;
  11: #endif
  12: 
  13: void FLWFinalizeWorldPos(inout vec4 worldPos) {
  14:     #if defined(USE_FOG)
  15:     FragDistance = length(worldPos.xyz - uCameraPos);
  16:     #endif
  17: 
  18:     gl_Position = uViewProjection * worldPos;
  19: }
  20: 
  21: void FLWFinalizeNormal(inout vec3 normal) {
  22:     // noop
  23: }
  24: 
  25: 
  26: mat4 rotate(vec3 axis, float angle) {
  27:     float s = sin(angle);
  28:     float c = cos(angle);
  29:     float oc = 1. - c;
  30: 
  31:     vec3 sa = axis * s;
  32: 
  33:     mat4 mr = mat4(1.);
  34:     mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
  35:     mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
  36:     mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);
  37: 
  38:     return mr;
  39: }
  40: 
  41: mat4 rotation(vec3 rot) {
  42:     return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
  43: }
  44: 
  45: mat3 modelToNormal(mat4 mat) {
  46:     // Discard the edges. This won't be accurate for scaled or skewed matrices,
  47:     // but we don't have to work with those often.
  48:     mat3 m;
  49:     m[0] = mat[0].xyz;
  50:     m[1] = mat[1].xyz;
  51:     m[2] = mat[2].xyz;
  52:     return m;
  53: }
  54: 
  55: #define PIOVER2 1.5707963268
  56: 
  57: vec4 quat(vec3 axis, float angle) {
  58:     float halfAngle = angle * PIOVER2 / 180.0;
  59:     vec2 cs = sin(vec2(PIOVER2 - halfAngle, halfAngle)); // compute sin and cos in one instruction
  60:     return vec4(axis.xyz * cs.y,  cs.x);
  61: }
  62: 
  63: vec4 quatMult(vec4 q1, vec4 q2) {
  64:     // disgustingly vectorized quaternion multiplication
  65:     vec4 a = q1.w * q2.xyzw;
  66:     vec4 b = q1.x * q2.wzxy * vec4(1., -1., 1., -1.);
  67:     vec4 c = q1.y * q2.zwxy * vec4(1., 1., -1., -1.);
  68:     vec4 d = q1.z * q2.yxwz * vec4(-1., 1., 1., -1.);
  69: 
  70:     return a + b + c + d;
  71: }
  72: 
  73: vec3 rotateVertexByQuat(vec3 v, vec4 q) {
  74:     vec3 i = q.xyz;
  75:     return v + 2.0 * cross(i, cross(i, v) + q.w * v);
  76: }
  77: 
  78: vec3 rotateAbout(vec3 v, vec3 axis, float angle) {
  79:     return rotateVertexByQuat(v, quat(axis, angle));
  80: }
  81: 
  82: float diffuse(vec3 normal) {
  83:     vec3 n2 = normal * normal * vec3(.6, .25, .8);
  84:     return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
  85: }
  86: 
  87: 
  88: struct Actor {
  89:     vec3 pos;
  90:     vec2 light;
  91:     float offset;
  92:     vec3 axis;
  93:     vec4 rotation;
  94:     vec3 rotationCenter;
  95:     float speed;
  96: };
  97: 
  98: 
  99: struct Vertex {
 100:     vec3 pos;
 101:     vec3 normal;
 102:     vec2 texCoords;
 103: };
 104: 
 105: struct BlockFrag {
 106:     vec2 texCoords;
 107:     vec4 color;
 108:     float diffuse;
 109:     vec2 light;
 110: };
 111: 
 112: BlockFrag FLWMain(Vertex v, Actor instance) {
 113:     float degrees = instance.offset + uTime * instance.speed / 20.;
 114:     //float angle = fract(degrees / 360.) * PI * 2.;
 115: 
 116:     vec4 kineticRot = quat(instance.axis, degrees);
 117:     vec3 rotated = rotateVertexByQuat(v.pos - instance.rotationCenter, kineticRot) + instance.rotationCenter;
 118: 
 119:     vec4 worldPos = vec4(rotateVertexByQuat(rotated - .5, instance.rotation) + instance.pos + .5, 1.);
 120:     vec3 norm = rotateVertexByQuat(rotateVertexByQuat(v.normal, kineticRot), instance.rotation);
 121: 
 122:     FLWFinalizeWorldPos(worldPos);
 123:     FLWFinalizeNormal(norm);
 124: 
 125:     BlockFrag b;
 126:     b.diffuse = diffuse(norm);
 127:     b.texCoords = v.texCoords;
 128:     b.light = instance.light;
 129: 
 130:     #if defined(DEBUG_NORMAL)
 131:     b.color = vec4(norm, 1.);
 132:     #else
 133:     b.color = vec4(1.);
 134:     #endif
 135: 
 136:     return b;
 137: }
 138: attribute vec3 a_v_pos;
 139: attribute vec3 a_v_normal;
 140: attribute vec2 a_v_texCoords;
 141: 
 142: attribute vec3 a_i_pos;
 143: attribute vec2 a_i_light;
 144: attribute float a_i_offset;
 145: attribute vec3 a_i_axis;
 146: attribute vec4 a_i_rotation;
 147: attribute vec3 a_i_rotationCenter;
 148: attribute float a_i_speed;
 149: 
 150: 
 151: varying vec2 v2f_texCoords;
 152: varying vec4 v2f_color;
 153: varying float v2f_diffuse;
 154: varying vec2 v2f_light;
 155: 
 156: 
 157: void main() {
 158:     Vertex v;
 159:     v.pos = a_v_pos;
 160: v.normal = a_v_normal;
 161: v.texCoords = a_v_texCoords;
 162: 
 163: 
 164:     Actor i;
 165:     i.pos = a_i_pos;
 166: i.light = a_i_light;
 167: i.offset = a_i_offset;
 168: i.axis = a_i_axis;
 169: i.rotation = a_i_rotation;
 170: i.rotationCenter = a_i_rotationCenter;
 171: i.speed = a_i_speed;
 172: 
 173: 
 174:     BlockFrag o = FLWMain(v, i);
 175: 
 176:     v2f_texCoords = o.texCoords;
 177: v2f_color = o.color;
 178: v2f_diffuse = o.diffuse;
 179: v2f_light = o.light;
 180: 
 181: }

[14:02:48] [main/ERROR]: Shader compilation log for flywheel:block.frag: No errors.

[14:02:48] [main/ERROR]: Source for shader 'flywheel:block.frag':
   1: #version 110
   2: 
   3: #if defined(USE_FOG)
   4: varying float FragDistance;
   5: uniform vec4 uFogColor;
   6: #endif
   7: 
   8: #if defined(USE_FOG_LINEAR)
   9: uniform vec2 uFogRange;
  10: 
  11: float FLWFogFactor() {
  12:     return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
  13: }
  14:     #endif
  15: 
  16:     #if defined(USE_FOG_EXP2)
  17: uniform float uFogDensity;
  18: 
  19: float FLWFogFactor() {
  20:     float dist = FragDistance * uFogDensity;
  21:     return 1. / exp2(dist * dist);
  22: }
  23:     #endif
  24: // Adjust the [0,1] normalized lightmap value based on the texture matrix from LightTexture#enableLightmap
  25: vec2 shiftLight(vec2 lm) {
  26:     return lm * 0.99609375 + 0.03125;// * 255/256 + 1/32
  27: }
  28: 
  29: uniform sampler2D uBlockAtlas;
  30: uniform sampler2D uLightMap;
  31: 
  32: vec4 FLWBlockTexture(vec2 texCoords) {
  33:     return texture2D(uBlockAtlas, texCoords);
  34: }
  35: 
  36: void FLWFinalizeColor(vec4 color) {
  37:     #if defined(USE_FOG)
  38:     float a = color.a;
  39:     float fog = clamp(FLWFogFactor(), 0., 1.);
  40: 
  41:     color = mix(uFogColor, color, fog);
  42:     color.a = a;
  43:     #endif
  44: 
  45:     gl_FragColor = color;
  46: }
  47: 
  48: vec4 FLWLight(vec2 lightCoords) {
  49:     return texture2D(uLightMap, shiftLight(lightCoords));
  50: }
  51: 
  52: 
  53: 
  54: struct BlockFrag {
  55:     vec2 texCoords;
  56:     vec4 color;
  57:     float diffuse;
  58:     vec2 light;
  59: };
  60: 
  61: void FLWMain(BlockFrag r) {
  62:     vec4 tex = FLWBlockTexture(r.texCoords);
  63: 
  64:     vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;
  65: 
  66: //    flw_WorldPos = ;
  67: //    flw_Normal = ;
  68: //    flw_Albedo = tex.rgb;
  69: //    flw_Alpha = tex.a;
  70: //    flw_LightMap = r.light;
  71: //    flw_Tint = r.color;
  72:     FLWFinalizeColor(color);
  73: }
  74: 
  75: varying vec2 v2f_texCoords;
  76: varying vec4 v2f_color;
  77: varying float v2f_diffuse;
  78: varying vec2 v2f_light;
  79: 
  80: 
  81: //vec3 flw_WorldPos;
  82: //vec3 flw_Normal;
  83: //vec3 flw_Albedo;
  84: //float flw_Alpha;
  85: //vec2 flw_LightMap;
  86: //vec4 flw_Tint;
  87: 
  88: void main() {
  89:     BlockFrag f;
  90:     f.texCoords = v2f_texCoords;
  91: f.color = v2f_color;
  92: f.diffuse = v2f_diffuse;
  93: f.light = v2f_light;
  94: 
  95: 
  96:     FLWMain(f);
  97: }

[14:02:48] [main/ERROR]: Shader compilation log for create:flap.vert: No errors.

[14:02:48] [main/ERROR]: Source for shader 'create:flap.vert':
   1: #version 110
   2: #define DEBUG_NORMAL
   3: 
   4: #define PI 3.1415926538
   5: 
   6: uniform float uTime;
   7: uniform mat4 uViewProjection;
   8: uniform vec3 uCameraPos;
   9: 
  10: #if defined(USE_FOG)
  11: varying float FragDistance;
  12: #endif
  13: 
  14: void FLWFinalizeWorldPos(inout vec4 worldPos) {
  15:     #if defined(USE_FOG)
  16:     FragDistance = length(worldPos.xyz - uCameraPos);
  17:     #endif
  18: 
  19:     gl_Position = uViewProjection * worldPos;
  20: }
  21: 
  22: void FLWFinalizeNormal(inout vec3 normal) {
  23:     // noop
  24: }
  25: 
  26: 
  27: mat4 rotate(vec3 axis, float angle) {
  28:     float s = sin(angle);
  29:     float c = cos(angle);
  30:     float oc = 1. - c;
  31: 
  32:     vec3 sa = axis * s;
  33: 
  34:     mat4 mr = mat4(1.);
  35:     mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
  36:     mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
  37:     mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);
  38: 
  39:     return mr;
  40: }
  41: 
  42: mat4 rotation(vec3 rot) {
  43:     return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
  44: }
  45: 
  46: mat3 modelToNormal(mat4 mat) {
  47:     // Discard the edges. This won't be accurate for scaled or skewed matrices,
  48:     // but we don't have to work with those often.
  49:     mat3 m;
  50:     m[0] = mat[0].xyz;
  51:     m[1] = mat[1].xyz;
  52:     m[2] = mat[2].xyz;
  53:     return m;
  54: }
  55: 
  56: #define PIOVER2 1.5707963268
  57: 
  58: vec4 quat(vec3 axis, float angle) {
  59:     float halfAngle = angle * PIOVER2 / 180.0;
  60:     vec2 cs = sin(vec2(PIOVER2 - halfAngle, halfAngle)); // compute sin and cos in one instruction
  61:     return vec4(axis.xyz * cs.y,  cs.x);
  62: }
  63: 
  64: vec4 quatMult(vec4 q1, vec4 q2) {
  65:     // disgustingly vectorized quaternion multiplication
  66:     vec4 a = q1.w * q2.xyzw;
  67:     vec4 b = q1.x * q2.wzxy * vec4(1., -1., 1., -1.);
  68:     vec4 c = q1.y * q2.zwxy * vec4(1., 1., -1., -1.);
  69:     vec4 d = q1.z * q2.yxwz * vec4(-1., 1., 1., -1.);
  70: 
  71:     return a + b + c + d;
  72: }
  73: 
  74: vec3 rotateVertexByQuat(vec3 v, vec4 q) {
  75:     vec3 i = q.xyz;
  76:     return v + 2.0 * cross(i, cross(i, v) + q.w * v);
  77: }
  78: 
  79: vec3 rotateAbout(vec3 v, vec3 axis, float angle) {
  80:     return rotateVertexByQuat(v, quat(axis, angle));
  81: }
  82: 
  83: float diffuse(vec3 normal) {
  84:     vec3 n2 = normal * normal * vec3(.6, .25, .8);
  85:     return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
  86: }
  87: 
  88: 
  89: struct Flap {
  90:     vec3 instancePos;
  91:     vec2 light;
  92:     vec3 segmentOffset;
  93:     vec3 pivot;
  94:     float horizontalAngle;
  95:     float intensity;
  96:     float flapScale;
  97:     float flapness;
  98: };
  99: 
 100: 
 101: struct Vertex {
 102:     vec3 pos;
 103:     vec3 normal;
 104:     vec2 texCoords;
 105: };
 106: 
 107: struct BlockFrag {
 108:     vec2 texCoords;
 109:     vec4 color;
 110:     float diffuse;
 111:     vec2 light;
 112: };
 113: 
 114: 
 115: float toRad(float degrees) {
 116:     return fract(degrees / 360.) * PI * 2.;
 117: }
 118: 
 119: float getFlapAngle(float flapness, float intensity, float scale) {
 120:     float absFlap = abs(flapness);
 121: 
 122:     float angle = sin((1. - absFlap) * PI * intensity) * 30. * flapness * scale;
 123: 
 124:     float halfAngle = angle * 0.5;
 125: 
 126:     float which = step(0., flapness);// 0 if negative, 1 if positive
 127:     float degrees = which * halfAngle + (1. - which) * angle;// branchless conditional multiply
 128: 
 129:     return degrees;
 130: }
 131: 
 132: BlockFrag FLWMain(Vertex v, Flap flap) {
 133:     float flapAngle = getFlapAngle(flap.flapness, flap.intensity, flap.flapScale);
 134: 
 135:     vec4 orientation = quat(vec3(0., 1., 0.), -flap.horizontalAngle);
 136:     vec4 flapRotation = quat(vec3(1., 0., 0.), flapAngle);
 137: 
 138:     vec3 rotated = rotateVertexByQuat(v.pos - flap.pivot, flapRotation) + flap.pivot + flap.segmentOffset;
 139:     rotated = rotateVertexByQuat(rotated - .5, orientation) + flap.instancePos + .5;
 140: 
 141:     vec4 worldPos = vec4(rotated, 1.);
 142:     vec3 norm = rotateVertexByQuat(rotateVertexByQuat(v.normal, flapRotation), orientation);
 143: 
 144:     FLWFinalizeWorldPos(worldPos);
 145:     FLWFinalizeNormal(norm);
 146: 
 147:     BlockFrag b;
 148:     b.diffuse = diffuse(norm);
 149:     b.texCoords = v.texCoords;
 150:     b.light = flap.light;
 151:     #if defined(DEBUG_NORMAL)
 152:     b.color = vec4(norm, 1.);
 153:     #else
 154:     b.color = vec4(1.);
 155:     #endif
 156:     return b;
 157: }
 158: attribute vec3 a_v_pos;
 159: attribute vec3 a_v_normal;
 160: attribute vec2 a_v_texCoords;
 161: 
 162: attribute vec3 a_i_instancePos;
 163: attribute vec2 a_i_light;
 164: attribute vec3 a_i_segmentOffset;
 165: attribute vec3 a_i_pivot;
 166: attribute float a_i_horizontalAngle;
 167: attribute float a_i_intensity;
 168: attribute float a_i_flapScale;
 169: attribute float a_i_flapness;
 170: 
 171: 
 172: varying vec2 v2f_texCoords;
 173: varying vec4 v2f_color;
 174: varying float v2f_diffuse;
 175: varying vec2 v2f_light;
 176: 
 177: 
 178: void main() {
 179:     Vertex v;
 180:     v.pos = a_v_pos;
 181: v.normal = a_v_normal;
 182: v.texCoords = a_v_texCoords;
 183: 
 184: 
 185:     Flap i;
 186:     i.instancePos = a_i_instancePos;
 187: i.light = a_i_light;
 188: i.segmentOffset = a_i_segmentOffset;
 189: i.pivot = a_i_pivot;
 190: i.horizontalAngle = a_i_horizontalAngle;
 191: i.intensity = a_i_intensity;
 192: i.flapScale = a_i_flapScale;
 193: i.flapness = a_i_flapness;
 194: 
 195: 
 196:     BlockFrag o = FLWMain(v, i);
 197: 
 198:     v2f_texCoords = o.texCoords;
 199: v2f_color = o.color;
 200: v2f_diffuse = o.diffuse;
 201: v2f_light = o.light;
 202: 
 203: }

[14:02:48] [main/ERROR]: Shader compilation log for flywheel:block.frag: No errors.

[14:02:48] [main/ERROR]: Source for shader 'flywheel:block.frag':
   1: #version 110
   2: #define DEBUG_NORMAL
   3: 
   4: #if defined(USE_FOG)
   5: varying float FragDistance;
   6: uniform vec4 uFogColor;
   7: #endif
   8: 
   9: #if defined(USE_FOG_LINEAR)
  10: uniform vec2 uFogRange;
  11: 
  12: float FLWFogFactor() {
  13:     return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
  14: }
  15:     #endif
  16: 
  17:     #if defined(USE_FOG_EXP2)
  18: uniform float uFogDensity;
  19: 
  20: float FLWFogFactor() {
  21:     float dist = FragDistance * uFogDensity;
  22:     return 1. / exp2(dist * dist);
  23: }
  24:     #endif
  25: // Adjust the [0,1] normalized lightmap value based on the texture matrix from LightTexture#enableLightmap
  26: vec2 shiftLight(vec2 lm) {
  27:     return lm * 0.99609375 + 0.03125;// * 255/256 + 1/32
  28: }
  29: 
  30: uniform sampler2D uBlockAtlas;
  31: uniform sampler2D uLightMap;
  32: 
  33: vec4 FLWBlockTexture(vec2 texCoords) {
  34:     return texture2D(uBlockAtlas, texCoords);
  35: }
  36: 
  37: void FLWFinalizeColor(vec4 color) {
  38:     #if defined(USE_FOG)
  39:     float a = color.a;
  40:     float fog = clamp(FLWFogFactor(), 0., 1.);
  41: 
  42:     color = mix(uFogColor, color, fog);
  43:     color.a = a;
  44:     #endif
  45: 
  46:     gl_FragColor = color;
  47: }
  48: 
  49: vec4 FLWLight(vec2 lightCoords) {
  50:     return texture2D(uLightMap, shiftLight(lightCoords));
  51: }
  52: 
  53: 
  54: 
  55: struct BlockFrag {
  56:     vec2 texCoords;
  57:     vec4 color;
  58:     float diffuse;
  59:     vec2 light;
  60: };
  61: 
  62: void FLWMain(BlockFrag r) {
  63:     vec4 tex = FLWBlockTexture(r.texCoords);
  64: 
  65:     vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;
  66: 
  67: //    flw_WorldPos = ;
  68: //    flw_Normal = ;
  69: //    flw_Albedo = tex.rgb;
  70: //    flw_Alpha = tex.a;
  71: //    flw_LightMap = r.light;
  72: //    flw_Tint = r.color;
  73:     FLWFinalizeColor(color);
  74: }
  75: 
  76: varying vec2 v2f_texCoords;
  77: varying vec4 v2f_color;
  78: varying float v2f_diffuse;
  79: varying vec2 v2f_light;
  80: 
  81: 
  82: //vec3 flw_WorldPos;
  83: //vec3 flw_Normal;
  84: //vec3 flw_Albedo;
  85: //float flw_Alpha;
  86: //vec2 flw_LightMap;
  87: //vec4 flw_Tint;
  88: 
  89: void main() {
  90:     BlockFrag f;
  91:     f.texCoords = v2f_texCoords;
  92: f.color = v2f_color;
  93: f.diffuse = v2f_diffuse;
  94: f.light = v2f_light;
  95: 
  96: 
  97:     FLWMain(f);
  98: }

[14:02:48] [main/ERROR]: Shader compilation log for create:flap.vert: No errors.

[14:02:48] [main/ERROR]: Source for shader 'create:flap.vert':
   1: #version 110
   2: #define USE_FOG
   3: #define USE_FOG_LINEAR
   4: 
   5: #define PI 3.1415926538
   6: 
   7: uniform float uTime;
   8: uniform mat4 uViewProjection;
   9: uniform vec3 uCameraPos;
  10: 
  11: #if defined(USE_FOG)
  12: varying float FragDistance;
  13: #endif
  14: 
  15: void FLWFinalizeWorldPos(inout vec4 worldPos) {
  16:     #if defined(USE_FOG)
  17:     FragDistance = length(worldPos.xyz - uCameraPos);
  18:     #endif
  19: 
  20:     gl_Position = uViewProjection * worldPos;
  21: }
  22: 
  23: void FLWFinalizeNormal(inout vec3 normal) {
  24:     // noop
  25: }
  26: 
  27: 
  28: mat4 rotate(vec3 axis, float angle) {
  29:     float s = sin(angle);
  30:     float c = cos(angle);
  31:     float oc = 1. - c;
  32: 
  33:     vec3 sa = axis * s;
  34: 
  35:     mat4 mr = mat4(1.);
  36:     mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
  37:     mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
  38:     mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);
  39: 
  40:     return mr;
  41: }
  42: 
  43: mat4 rotation(vec3 rot) {
  44:     return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
  45: }
  46: 
  47: mat3 modelToNormal(mat4 mat) {
  48:     // Discard the edges. This won't be accurate for scaled or skewed matrices,
  49:     // but we don't have to work with those often.
  50:     mat3 m;
  51:     m[0] = mat[0].xyz;
  52:     m[1] = mat[1].xyz;
  53:     m[2] = mat[2].xyz;
  54:     return m;
  55: }
  56: 
  57: #define PIOVER2 1.5707963268
  58: 
  59: vec4 quat(vec3 axis, float angle) {
  60:     float halfAngle = angle * PIOVER2 / 180.0;
  61:     vec2 cs = sin(vec2(PIOVER2 - halfAngle, halfAngle)); // compute sin and cos in one instruction
  62:     return vec4(axis.xyz * cs.y,  cs.x);
  63: }
  64: 
  65: vec4 quatMult(vec4 q1, vec4 q2) {
  66:     // disgustingly vectorized quaternion multiplication
  67:     vec4 a = q1.w * q2.xyzw;
  68:     vec4 b = q1.x * q2.wzxy * vec4(1., -1., 1., -1.);
  69:     vec4 c = q1.y * q2.zwxy * vec4(1., 1., -1., -1.);
  70:     vec4 d = q1.z * q2.yxwz * vec4(-1., 1., 1., -1.);
  71: 
  72:     return a + b + c + d;
  73: }
  74: 
  75: vec3 rotateVertexByQuat(vec3 v, vec4 q) {
  76:     vec3 i = q.xyz;
  77:     return v + 2.0 * cross(i, cross(i, v) + q.w * v);
  78: }
  79: 
  80: vec3 rotateAbout(vec3 v, vec3 axis, float angle) {
  81:     return rotateVertexByQuat(v, quat(axis, angle));
  82: }
  83: 
  84: float diffuse(vec3 normal) {
  85:     vec3 n2 = normal * normal * vec3(.6, .25, .8);
  86:     return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
  87: }
  88: 
  89: 
  90: struct Flap {
  91:     vec3 instancePos;
  92:     vec2 light;
  93:     vec3 segmentOffset;
  94:     vec3 pivot;
  95:     float horizontalAngle;
  96:     float intensity;
  97:     float flapScale;
  98:     float flapness;
  99: };
 100: 
 101: 
 102: struct Vertex {
 103:     vec3 pos;
 104:     vec3 normal;
 105:     vec2 texCoords;
 106: };
 107: 
 108: struct BlockFrag {
 109:     vec2 texCoords;
 110:     vec4 color;
 111:     float diffuse;
 112:     vec2 light;
 113: };
 114: 
 115: 
 116: float toRad(float degrees) {
 117:     return fract(degrees / 360.) * PI * 2.;
 118: }
 119: 
 120: float getFlapAngle(float flapness, float intensity, float scale) {
 121:     float absFlap = abs(flapness);
 122: 
 123:     float angle = sin((1. - absFlap) * PI * intensity) * 30. * flapness * scale;
 124: 
 125:     float halfAngle = angle * 0.5;
 126: 
 127:     float which = step(0., flapness);// 0 if negative, 1 if positive
 128:     float degrees = which * halfAngle + (1. - which) * angle;// branchless conditional multiply
 129: 
 130:     return degrees;
 131: }
 132: 
 133: BlockFrag FLWMain(Vertex v, Flap flap) {
 134:     float flapAngle = getFlapAngle(flap.flapness, flap.intensity, flap.flapScale);
 135: 
 136:     vec4 orientation = quat(vec3(0., 1., 0.), -flap.horizontalAngle);
 137:     vec4 flapRotation = quat(vec3(1., 0., 0.), flapAngle);
 138: 
 139:     vec3 rotated = rotateVertexByQuat(v.pos - flap.pivot, flapRotation) + flap.pivot + flap.segmentOffset;
 140:     rotated = rotateVertexByQuat(rotated - .5, orientation) + flap.instancePos + .5;
 141: 
 142:     vec4 worldPos = vec4(rotated, 1.);
 143:     vec3 norm = rotateVertexByQuat(rotateVertexByQuat(v.normal, flapRotation), orientation);
 144: 
 145:     FLWFinalizeWorldPos(worldPos);
 146:     FLWFinalizeNormal(norm);
 147: 
 148:     BlockFrag b;
 149:     b.diffuse = diffuse(norm);
 150:     b.texCoords = v.texCoords;
 151:     b.light = flap.light;
 152:     #if defined(DEBUG_NORMAL)
 153:     b.color = vec4(norm, 1.);
 154:     #else
 155:     b.color = vec4(1.);
 156:     #endif
 157:     return b;
 158: }
 159: attribute vec3 a_v_pos;
 160: attribute vec3 a_v_normal;
 161: attribute vec2 a_v_texCoords;
 162: 
 163: attribute vec3 a_i_instancePos;
 164: attribute vec2 a_i_light;
 165: attribute vec3 a_i_segmentOffset;
 166: attribute vec3 a_i_pivot;
 167: attribute float a_i_horizontalAngle;
 168: attribute float a_i_intensity;
 169: attribute float a_i_flapScale;
 170: attribute float a_i_flapness;
 171: 
 172: 
 173: varying vec2 v2f_texCoords;
 174: varying vec4 v2f_color;
 175: varying float v2f_diffuse;
 176: varying vec2 v2f_light;
 177: 
 178: 
 179: void main() {
 180:     Vertex v;
 181:     v.pos = a_v_pos;
 182: v.normal = a_v_normal;
 183: v.texCoords = a_v_texCoords;
 184: 
 185: 
 186:     Flap i;
 187:     i.instancePos = a_i_instancePos;
 188: i.light = a_i_light;
 189: i.segmentOffset = a_i_segmentOffset;
 190: i.pivot = a_i_pivot;
 191: i.horizontalAngle = a_i_horizontalAngle;
 192: i.intensity = a_i_intensity;
 193: i.flapScale = a_i_flapScale;
 194: i.flapness = a_i_flapness;
 195: 
 196: 
 197:     BlockFrag o = FLWMain(v, i);
 198: 
 199:     v2f_texCoords = o.texCoords;
 200: v2f_color = o.color;
 201: v2f_diffuse = o.diffuse;
 202: v2f_light = o.light;
 203: 
 204: }

[14:02:48] [main/ERROR]: Shader compilation log for flywheel:block.frag: No errors.

[14:02:48] [main/ERROR]: Source for shader 'flywheel:block.frag':
   1: #version 110
   2: #define USE_FOG
   3: #define USE_FOG_LINEAR
   4: 
   5: #if defined(USE_FOG)
   6: varying float FragDistance;
   7: uniform vec4 uFogColor;
   8: #endif
   9: 
  10: #if defined(USE_FOG_LINEAR)
  11: uniform vec2 uFogRange;
  12: 
  13: float FLWFogFactor() {
  14:     return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
  15: }
  16:     #endif
  17: 
  18:     #if defined(USE_FOG_EXP2)
  19: uniform float uFogDensity;
  20: 
  21: float FLWFogFactor() {
  22:     float dist = FragDistance * uFogDensity;
  23:     return 1. / exp2(dist * dist);
  24: }
  25:     #endif
  26: // Adjust the [0,1] normalized lightmap value based on the texture matrix from LightTexture#enableLightmap
  27: vec2 shiftLight(vec2 lm) {
  28:     return lm * 0.99609375 + 0.03125;// * 255/256 + 1/32
  29: }
  30: 
  31: uniform sampler2D uBlockAtlas;
  32: uniform sampler2D uLightMap;
  33: 
  34: vec4 FLWBlockTexture(vec2 texCoords) {
  35:     return texture2D(uBlockAtlas, texCoords);
  36: }
  37: 
  38: void FLWFinalizeColor(vec4 color) {
  39:     #if defined(USE_FOG)
  40:     float a = color.a;
  41:     float fog = clamp(FLWFogFactor(), 0., 1.);
  42: 
  43:     color = mix(uFogColor, color, fog);
  44:     color.a = a;
  45:     #endif
  46: 
  47:     gl_FragColor = color;
  48: }
  49: 
  50: vec4 FLWLight(vec2 lightCoords) {
  51:     return texture2D(uLightMap, shiftLight(lightCoords));
  52: }
  53: 
  54: 
  55: 
  56: struct BlockFrag {
  57:     vec2 texCoords;
  58:     vec4 color;
  59:     float diffuse;
  60:     vec2 light;
  61: };
  62: 
  63: void FLWMain(BlockFrag r) {
  64:     vec4 tex = FLWBlockTexture(r.texCoords);
  65: 
  66:     vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;
  67: 
  68: //    flw_WorldPos = ;
  69: //    flw_Normal = ;
  70: //    flw_Albedo = tex.rgb;
  71: //    flw_Alpha = tex.a;
  72: //    flw_LightMap = r.light;
  73: //    flw_Tint = r.color;
  74:     FLWFinalizeColor(color);
  75: }
  76: 
  77: varying vec2 v2f_texCoords;
  78: varying vec4 v2f_color;
  79: varying float v2f_diffuse;
  80: varying vec2 v2f_light;
  81: 
  82: 
  83: //vec3 flw_WorldPos;
  84: //vec3 flw_Normal;
  85: //vec3 flw_Albedo;
  86: //float flw_Alpha;
  87: //vec2 flw_LightMap;
  88: //vec4 flw_Tint;
  89: 
  90: void main() {
  91:     BlockFrag f;
  92:     f.texCoords = v2f_texCoords;
  93: f.color = v2f_color;
  94: f.diffuse = v2f_diffuse;
  95: f.light = v2f_light;
  96: 
  97: 
  98:     FLWMain(f);
  99: }

[14:02:48] [main/ERROR]: Shader compilation log for create:flap.vert: No errors.

[14:02:48] [main/ERROR]: Source for shader 'create:flap.vert':
   1: #version 110
   2: #define USE_FOG
   3: #define USE_FOG_EXP2
   4: 
   5: #define PI 3.1415926538
   6: 
   7: uniform float uTime;
   8: uniform mat4 uViewProjection;
   9: uniform vec3 uCameraPos;
  10: 
  11: #if defined(USE_FOG)
  12: varying float FragDistance;
  13: #endif
  14: 
  15: void FLWFinalizeWorldPos(inout vec4 worldPos) {
  16:     #if defined(USE_FOG)
  17:     FragDistance = length(worldPos.xyz - uCameraPos);
  18:     #endif
  19: 
  20:     gl_Position = uViewProjection * worldPos;
  21: }
  22: 
  23: void FLWFinalizeNormal(inout vec3 normal) {
  24:     // noop
  25: }
  26: 
  27: 
  28: mat4 rotate(vec3 axis, float angle) {
  29:     float s = sin(angle);
  30:     float c = cos(angle);
  31:     float oc = 1. - c;
  32: 
  33:     vec3 sa = axis * s;
  34: 
  35:     mat4 mr = mat4(1.);
  36:     mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
  37:     mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
  38:     mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);
  39: 
  40:     return mr;
  41: }
  42: 
  43: mat4 rotation(vec3 rot) {
  44:     return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
  45: }
  46: 
  47: mat3 modelToNormal(mat4 mat) {
  48:     // Discard the edges. This won't be accurate for scaled or skewed matrices,
  49:     // but we don't have to work with those often.
  50:     mat3 m;
  51:     m[0] = mat[0].xyz;
  52:     m[1] = mat[1].xyz;
  53:     m[2] = mat[2].xyz;
  54:     return m;
  55: }
  56: 
  57: #define PIOVER2 1.5707963268
  58: 
  59: vec4 quat(vec3 axis, float angle) {
  60:     float halfAngle = angle * PIOVER2 / 180.0;
  61:     vec2 cs = sin(vec2(PIOVER2 - halfAngle, halfAngle)); // compute sin and cos in one instruction
  62:     return vec4(axis.xyz * cs.y,  cs.x);
  63: }
  64: 
  65: vec4 quatMult(vec4 q1, vec4 q2) {
  66:     // disgustingly vectorized quaternion multiplication
  67:     vec4 a = q1.w * q2.xyzw;
  68:     vec4 b = q1.x * q2.wzxy * vec4(1., -1., 1., -1.);
  69:     vec4 c = q1.y * q2.zwxy * vec4(1., 1., -1., -1.);
  70:     vec4 d = q1.z * q2.yxwz * vec4(-1., 1., 1., -1.);
  71: 
  72:     return a + b + c + d;
  73: }
  74: 
  75: vec3 rotateVertexByQuat(vec3 v, vec4 q) {
  76:     vec3 i = q.xyz;
  77:     return v + 2.0 * cross(i, cross(i, v) + q.w * v);
  78: }
  79: 
  80: vec3 rotateAbout(vec3 v, vec3 axis, float angle) {
  81:     return rotateVertexByQuat(v, quat(axis, angle));
  82: }
  83: 
  84: float diffuse(vec3 normal) {
  85:     vec3 n2 = normal * normal * vec3(.6, .25, .8);
  86:     return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
  87: }
  88: 
  89: 
  90: struct Flap {
  91:     vec3 instancePos;
  92:     vec2 light;
  93:     vec3 segmentOffset;
  94:     vec3 pivot;
  95:     float horizontalAngle;
  96:     float intensity;
  97:     float flapScale;
  98:     float flapness;
  99: };
 100: 
 101: 
 102: struct Vertex {
 103:     vec3 pos;
 104:     vec3 normal;
 105:     vec2 texCoords;
 106: };
 107: 
 108: struct BlockFrag {
 109:     vec2 texCoords;
 110:     vec4 color;
 111:     float diffuse;
 112:     vec2 light;
 113: };
 114: 
 115: 
 116: float toRad(float degrees) {
 117:     return fract(degrees / 360.) * PI * 2.;
 118: }
 119: 
 120: float getFlapAngle(float flapness, float intensity, float scale) {
 121:     float absFlap = abs(flapness);
 122: 
 123:     float angle = sin((1. - absFlap) * PI * intensity) * 30. * flapness * scale;
 124: 
 125:     float halfAngle = angle * 0.5;
 126: 
 127:     float which = step(0., flapness);// 0 if negative, 1 if positive
 128:     float degrees = which * halfAngle + (1. - which) * angle;// branchless conditional multiply
 129: 
 130:     return degrees;
 131: }
 132: 
 133: BlockFrag FLWMain(Vertex v, Flap flap) {
 134:     float flapAngle = getFlapAngle(flap.flapness, flap.intensity, flap.flapScale);
 135: 
 136:     vec4 orientation = quat(vec3(0., 1., 0.), -flap.horizontalAngle);
 137:     vec4 flapRotation = quat(vec3(1., 0., 0.), flapAngle);
 138: 
 139:     vec3 rotated = rotateVertexByQuat(v.pos - flap.pivot, flapRotation) + flap.pivot + flap.segmentOffset;
 140:     rotated = rotateVertexByQuat(rotated - .5, orientation) + flap.instancePos + .5;
 141: 
 142:     vec4 worldPos = vec4(rotated, 1.);
 143:     vec3 norm = rotateVertexByQuat(rotateVertexByQuat(v.normal, flapRotation), orientation);
 144: 
 145:     FLWFinalizeWorldPos(worldPos);
 146:     FLWFinalizeNormal(norm);
 147: 
 148:     BlockFrag b;
 149:     b.diffuse = diffuse(norm);
 150:     b.texCoords = v.texCoords;
 151:     b.light = flap.light;
 152:     #if defined(DEBUG_NORMAL)
 153:     b.color = vec4(norm, 1.);
 154:     #else
 155:     b.color = vec4(1.);
 156:     #endif
 157:     return b;
 158: }
 159: attribute vec3 a_v_pos;
 160: attribute vec3 a_v_normal;
 161: attribute vec2 a_v_texCoords;
 162: 
 163: attribute vec3 a_i_instancePos;
 164: attribute vec2 a_i_light;
 165: attribute vec3 a_i_segmentOffset;
 166: attribute vec3 a_i_pivot;
 167: attribute float a_i_horizontalAngle;
 168: attribute float a_i_intensity;
 169: attribute float a_i_flapScale;
 170: attribute float a_i_flapness;
 171: 
 172: 
 173: varying vec2 v2f_texCoords;
 174: varying vec4 v2f_color;
 175: varying float v2f_diffuse;
 176: varying vec2 v2f_light;
 177: 
 178: 
 179: void main() {
 180:     Vertex v;
 181:     v.pos = a_v_pos;
 182: v.normal = a_v_normal;
 183: v.texCoords = a_v_texCoords;
 184: 
 185: 
 186:     Flap i;
 187:     i.instancePos = a_i_instancePos;
 188: i.light = a_i_light;
 189: i.segmentOffset = a_i_segmentOffset;
 190: i.pivot = a_i_pivot;
 191: i.horizontalAngle = a_i_horizontalAngle;
 192: i.intensity = a_i_intensity;
 193: i.flapScale = a_i_flapScale;
 194: i.flapness = a_i_flapness;
 195: 
 196: 
 197:     BlockFrag o = FLWMain(v, i);
 198: 
 199:     v2f_texCoords = o.texCoords;
 200: v2f_color = o.color;
 201: v2f_diffuse = o.diffuse;
 202: v2f_light = o.light;
 203: 
 204: }

[14:02:48] [main/ERROR]: Shader compilation log for flywheel:block.frag: No errors.

[14:02:48] [main/ERROR]: Source for shader 'flywheel:block.frag':
   1: #version 110
   2: #define USE_FOG
   3: #define USE_FOG_EXP2
   4: 
   5: #if defined(USE_FOG)
   6: varying float FragDistance;
   7: uniform vec4 uFogColor;
   8: #endif
   9: 
  10: #if defined(USE_FOG_LINEAR)
  11: uniform vec2 uFogRange;
  12: 
  13: float FLWFogFactor() {
  14:     return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
  15: }
  16:     #endif
  17: 
  18:     #if defined(USE_FOG_EXP2)
  19: uniform float uFogDensity;
  20: 
  21: float FLWFogFactor() {
  22:     float dist = FragDistance * uFogDensity;
  23:     return 1. / exp2(dist * dist);
  24: }
  25:     #endif
  26: // Adjust the [0,1] normalized lightmap value based on the texture matrix from LightTexture#enableLightmap
  27: vec2 shiftLight(vec2 lm) {
  28:     return lm * 0.99609375 + 0.03125;// * 255/256 + 1/32
  29: }
  30: 
  31: uniform sampler2D uBlockAtlas;
  32: uniform sampler2D uLightMap;
  33: 
  34: vec4 FLWBlockTexture(vec2 texCoords) {
  35:     return texture2D(uBlockAtlas, texCoords);
  36: }
  37: 
  38: void FLWFinalizeColor(vec4 color) {
  39:     #if defined(USE_FOG)
  40:     float a = color.a;
  41:     float fog = clamp(FLWFogFactor(), 0., 1.);
  42: 
  43:     color = mix(uFogColor, color, fog);
  44:     color.a = a;
  45:     #endif
  46: 
  47:     gl_FragColor = color;
  48: }
  49: 
  50: vec4 FLWLight(vec2 lightCoords) {
  51:     return texture2D(uLightMap, shiftLight(lightCoords));
  52: }
  53: 
  54: 
  55: 
  56: struct BlockFrag {
  57:     vec2 texCoords;
  58:     vec4 color;
  59:     float diffuse;
  60:     vec2 light;
  61: };
  62: 
  63: void FLWMain(BlockFrag r) {
  64:     vec4 tex = FLWBlockTexture(r.texCoords);
  65: 
  66:     vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;
  67: 
  68: //    flw_WorldPos = ;
  69: //    flw_Normal = ;
  70: //    flw_Albedo = tex.rgb;
  71: //    flw_Alpha = tex.a;
  72: //    flw_LightMap = r.light;
  73: //    flw_Tint = r.color;
  74:     FLWFinalizeColor(color);
  75: }
  76: 
  77: varying vec2 v2f_texCoords;
  78: varying vec4 v2f_color;
  79: varying float v2f_diffuse;
  80: varying vec2 v2f_light;
  81: 
  82: 
  83: //vec3 flw_WorldPos;
  84: //vec3 flw_Normal;
  85: //vec3 flw_Albedo;
  86: //float flw_Alpha;
  87: //vec2 flw_LightMap;
  88: //vec4 flw_Tint;
  89: 
  90: void main() {
  91:     BlockFrag f;
  92:     f.texCoords = v2f_texCoords;
  93: f.color = v2f_color;
  94: f.diffuse = v2f_diffuse;
  95: f.light = v2f_light;
  96: 
  97: 
  98:     FLWMain(f);
  99: }

[14:02:48] [main/ERROR]: Shader compilation log for create:flap.vert: No errors.

[14:02:48] [main/ERROR]: Source for shader 'create:flap.vert':
   1: #version 110
   2: 
   3: #define PI 3.1415926538
   4: 
   5: uniform float uTime;
   6: uniform mat4 uViewProjection;
   7: uniform vec3 uCameraPos;
   8: 
   9: #if defined(USE_FOG)
  10: varying float FragDistance;
  11: #endif
  12: 
  13: void FLWFinalizeWorldPos(inout vec4 worldPos) {
  14:     #if defined(USE_FOG)
  15:     FragDistance = length(worldPos.xyz - uCameraPos);
  16:     #endif
  17: 
  18:     gl_Position = uViewProjection * worldPos;
  19: }
  20: 
  21: void FLWFinalizeNormal(inout vec3 normal) {
  22:     // noop
  23: }
  24: 
  25: 
  26: mat4 rotate(vec3 axis, float angle) {
  27:     float s = sin(angle);
  28:     float c = cos(angle);
  29:     float oc = 1. - c;
  30: 
  31:     vec3 sa = axis * s;
  32: 
  33:     mat4 mr = mat4(1.);
  34:     mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
  35:     mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
  36:     mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);
  37: 
  38:     return mr;
  39: }
  40: 
  41: mat4 rotation(vec3 rot) {
  42:     return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
  43: }
  44: 
  45: mat3 modelToNormal(mat4 mat) {
  46:     // Discard the edges. This won't be accurate for scaled or skewed matrices,
  47:     // but we don't have to work with those often.
  48:     mat3 m;
  49:     m[0] = mat[0].xyz;
  50:     m[1] = mat[1].xyz;
  51:     m[2] = mat[2].xyz;
  52:     return m;
  53: }
  54: 
  55: #define PIOVER2 1.5707963268
  56: 
  57: vec4 quat(vec3 axis, float angle) {
  58:     float halfAngle = angle * PIOVER2 / 180.0;
  59:     vec2 cs = sin(vec2(PIOVER2 - halfAngle, halfAngle)); // compute sin and cos in one instruction
  60:     return vec4(axis.xyz * cs.y,  cs.x);
  61: }
  62: 
  63: vec4 quatMult(vec4 q1, vec4 q2) {
  64:     // disgustingly vectorized quaternion multiplication
  65:     vec4 a = q1.w * q2.xyzw;
  66:     vec4 b = q1.x * q2.wzxy * vec4(1., -1., 1., -1.);
  67:     vec4 c = q1.y * q2.zwxy * vec4(1., 1., -1., -1.);
  68:     vec4 d = q1.z * q2.yxwz * vec4(-1., 1., 1., -1.);
  69: 
  70:     return a + b + c + d;
  71: }
  72: 
  73: vec3 rotateVertexByQuat(vec3 v, vec4 q) {
  74:     vec3 i = q.xyz;
  75:     return v + 2.0 * cross(i, cross(i, v) + q.w * v);
  76: }
  77: 
  78: vec3 rotateAbout(vec3 v, vec3 axis, float angle) {
  79:     return rotateVertexByQuat(v, quat(axis, angle));
  80: }
  81: 
  82: float diffuse(vec3 normal) {
  83:     vec3 n2 = normal * normal * vec3(.6, .25, .8);
  84:     return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
  85: }
  86: 
  87: 
  88: struct Flap {
  89:     vec3 instancePos;
  90:     vec2 light;
  91:     vec3 segmentOffset;
  92:     vec3 pivot;
  93:     float horizontalAngle;
  94:     float intensity;
  95:     float flapScale;
  96:     float flapness;
  97: };
  98: 
  99: 
 100: struct Vertex {
 101:     vec3 pos;
 102:     vec3 normal;
 103:     vec2 texCoords;
 104: };
 105: 
 106: struct BlockFrag {
 107:     vec2 texCoords;
 108:     vec4 color;
 109:     float diffuse;
 110:     vec2 light;
 111: };
 112: 
 113: 
 114: float toRad(float degrees) {
 115:     return fract(degrees / 360.) * PI * 2.;
 116: }
 117: 
 118: float getFlapAngle(float flapness, float intensity, float scale) {
 119:     float absFlap = abs(flapness);
 120: 
 121:     float angle = sin((1. - absFlap) * PI * intensity) * 30. * flapness * scale;
 122: 
 123:     float halfAngle = angle * 0.5;
 124: 
 125:     float which = step(0., flapness);// 0 if negative, 1 if positive
 126:     float degrees = which * halfAngle + (1. - which) * angle;// branchless conditional multiply
 127: 
 128:     return degrees;
 129: }
 130: 
 131: BlockFrag FLWMain(Vertex v, Flap flap) {
 132:     float flapAngle = getFlapAngle(flap.flapness, flap.intensity, flap.flapScale);
 133: 
 134:     vec4 orientation = quat(vec3(0., 1., 0.), -flap.horizontalAngle);
 135:     vec4 flapRotation = quat(vec3(1., 0., 0.), flapAngle);
 136: 
 137:     vec3 rotated = rotateVertexByQuat(v.pos - flap.pivot, flapRotation) + flap.pivot + flap.segmentOffset;
 138:     rotated = rotateVertexByQuat(rotated - .5, orientation) + flap.instancePos + .5;
 139: 
 140:     vec4 worldPos = vec4(rotated, 1.);
 141:     vec3 norm = rotateVertexByQuat(rotateVertexByQuat(v.normal, flapRotation), orientation);
 142: 
 143:     FLWFinalizeWorldPos(worldPos);
 144:     FLWFinalizeNormal(norm);
 145: 
 146:     BlockFrag b;
 147:     b.diffuse = diffuse(norm);
 148:     b.texCoords = v.texCoords;
 149:     b.light = flap.light;
 150:     #if defined(DEBUG_NORMAL)
 151:     b.color = vec4(norm, 1.);
 152:     #else
 153:     b.color = vec4(1.);
 154:     #endif
 155:     return b;
 156: }
 157: attribute vec3 a_v_pos;
 158: attribute vec3 a_v_normal;
 159: attribute vec2 a_v_texCoords;
 160: 
 161: attribute vec3 a_i_instancePos;
 162: attribute vec2 a_i_light;
 163: attribute vec3 a_i_segmentOffset;
 164: attribute vec3 a_i_pivot;
 165: attribute float a_i_horizontalAngle;
 166: attribute float a_i_intensity;
 167: attribute float a_i_flapScale;
 168: attribute float a_i_flapness;
 169: 
 170: 
 171: varying vec2 v2f_texCoords;
 172: varying vec4 v2f_color;
 173: varying float v2f_diffuse;
 174: varying vec2 v2f_light;
 175: 
 176: 
 177: void main() {
 178:     Vertex v;
 179:     v.pos = a_v_pos;
 180: v.normal = a_v_normal;
 181: v.texCoords = a_v_texCoords;
 182: 
 183: 
 184:     Flap i;
 185:     i.instancePos = a_i_instancePos;
 186: i.light = a_i_light;
 187: i.segmentOffset = a_i_segmentOffset;
 188: i.pivot = a_i_pivot;
 189: i.horizontalAngle = a_i_horizontalAngle;
 190: i.intensity = a_i_intensity;
 191: i.flapScale = a_i_flapScale;
 192: i.flapness = a_i_flapness;
 193: 
 194: 
 195:     BlockFrag o = FLWMain(v, i);
 196: 
 197:     v2f_texCoords = o.texCoords;
 198: v2f_color = o.color;
 199: v2f_diffuse = o.diffuse;
 200: v2f_light = o.light;
 201: 
 202: }

[14:02:48] [main/ERROR]: Shader compilation log for flywheel:block.frag: No errors.

[14:02:48] [main/ERROR]: Source for shader 'flywheel:block.frag':
   1: #version 110
   2: 
   3: #if defined(USE_FOG)
   4: varying float FragDistance;
   5: uniform vec4 uFogColor;
   6: #endif
   7: 
   8: #if defined(USE_FOG_LINEAR)
   9: uniform vec2 uFogRange;
  10: 
  11: float FLWFogFactor() {
  12:     return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
  13: }
  14:     #endif
  15: 
  16:     #if defined(USE_FOG_EXP2)
  17: uniform float uFogDensity;
  18: 
  19: float FLWFogFactor() {
  20:     float dist = FragDistance * uFogDensity;
  21:     return 1. / exp2(dist * dist);
  22: }
  23:     #endif
  24: // Adjust the [0,1] normalized lightmap value based on the texture matrix from LightTexture#enableLightmap
  25: vec2 shiftLight(vec2 lm) {
  26:     return lm * 0.99609375 + 0.03125;// * 255/256 + 1/32
  27: }
  28: 
  29: uniform sampler2D uBlockAtlas;
  30: uniform sampler2D uLightMap;
  31: 
  32: vec4 FLWBlockTexture(vec2 texCoords) {
  33:     return texture2D(uBlockAtlas, texCoords);
  34: }
  35: 
  36: void FLWFinalizeColor(vec4 color) {
  37:     #if defined(USE_FOG)
  38:     float a = color.a;
  39:     float fog = clamp(FLWFogFactor(), 0., 1.);
  40: 
  41:     color = mix(uFogColor, color, fog);
  42:     color.a = a;
  43:     #endif
  44: 
  45:     gl_FragColor = color;
  46: }
  47: 
  48: vec4 FLWLight(vec2 lightCoords) {
  49:     return texture2D(uLightMap, shiftLight(lightCoords));
  50: }
  51: 
  52: 
  53: 
  54: struct BlockFrag {
  55:     vec2 texCoords;
  56:     vec4 color;
  57:     float diffuse;
  58:     vec2 light;
  59: };
  60: 
  61: void FLWMain(BlockFrag r) {
  62:     vec4 tex = FLWBlockTexture(r.texCoords);
  63: 
  64:     vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;
  65: 
  66: //    flw_WorldPos = ;
  67: //    flw_Normal = ;
  68: //    flw_Albedo = tex.rgb;
  69: //    flw_Alpha = tex.a;
  70: //    flw_LightMap = r.light;
  71: //    flw_Tint = r.color;
  72:     FLWFinalizeColor(color);
  73: }
  74: 
  75: varying vec2 v2f_texCoords;
  76: varying vec4 v2f_color;
  77: varying float v2f_diffuse;
  78: varying vec2 v2f_light;
  79: 
  80: 
  81: //vec3 flw_WorldPos;
  82: //vec3 flw_Normal;
  83: //vec3 flw_Albedo;
  84: //float flw_Alpha;
  85: //vec2 flw_LightMap;
  86: //vec4 flw_Tint;
  87: 
  88: void main() {
  89:     BlockFrag f;
  90:     f.texCoords = v2f_texCoords;
  91: f.color = v2f_color;
  92: f.diffuse = v2f_diffuse;
  93: f.light = v2f_light;
  94: 
  95: 
  96:     FLWMain(f);
  97: }

[14:02:48] [main/ERROR]: Shader compilation log for create:belt.vert: No errors.

[14:02:48] [main/ERROR]: Source for shader 'create:belt.vert':
   1: #version 110
   2: #define DEBUG_RAINBOW
   3: 
   4: #define PI 3.1415926538
   5: 
   6: uniform float uTime;
   7: uniform mat4 uViewProjection;
   8: uniform vec3 uCameraPos;
   9: 
  10: #if defined(USE_FOG)
  11: varying float FragDistance;
  12: #endif
  13: 
  14: void FLWFinalizeWorldPos(inout vec4 worldPos) {
  15:     #if defined(USE_FOG)
  16:     FragDistance = length(worldPos.xyz - uCameraPos);
  17:     #endif
  18: 
  19:     gl_Position = uViewProjection * worldPos;
  20: }
  21: 
  22: void FLWFinalizeNormal(inout vec3 normal) {
  23:     // noop
  24: }
  25: 
  26: 
  27: #define PIOVER2 1.5707963268
  28: 
  29: vec4 quat(vec3 axis, float angle) {
  30:     float halfAngle = angle * PIOVER2 / 180.0;
  31:     vec2 cs = sin(vec2(PIOVER2 - halfAngle, halfAngle)); // compute sin and cos in one instruction
  32:     return vec4(axis.xyz * cs.y,  cs.x);
  33: }
  34: 
  35: vec4 quatMult(vec4 q1, vec4 q2) {
  36:     // disgustingly vectorized quaternion multiplication
  37:     vec4 a = q1.w * q2.xyzw;
  38:     vec4 b = q1.x * q2.wzxy * vec4(1., -1., 1., -1.);
  39:     vec4 c = q1.y * q2.zwxy * vec4(1., 1., -1., -1.);
  40:     vec4 d = q1.z * q2.yxwz * vec4(-1., 1., 1., -1.);
  41: 
  42:     return a + b + c + d;
  43: }
  44: 
  45: vec3 rotateVertexByQuat(vec3 v, vec4 q) {
  46:     vec3 i = q.xyz;
  47:     return v + 2.0 * cross(i, cross(i, v) + q.w * v);
  48: }
  49: 
  50: vec3 rotateAbout(vec3 v, vec3 axis, float angle) {
  51:     return rotateVertexByQuat(v, quat(axis, angle));
  52: }
  53: 
  54: mat4 rotate(vec3 axis, float angle) {
  55:     float s = sin(angle);
  56:     float c = cos(angle);
  57:     float oc = 1. - c;
  58: 
  59:     vec3 sa = axis * s;
  60: 
  61:     mat4 mr = mat4(1.);
  62:     mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
  63:     mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
  64:     mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);
  65: 
  66:     return mr;
  67: }
  68: 
  69: mat4 rotation(vec3 rot) {
  70:     return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
  71: }
  72: 
  73: mat3 modelToNormal(mat4 mat) {
  74:     // Discard the edges. This won't be accurate for scaled or skewed matrices,
  75:     // but we don't have to work with those often.
  76:     mat3 m;
  77:     m[0] = mat[0].xyz;
  78:     m[1] = mat[1].xyz;
  79:     m[2] = mat[2].xyz;
  80:     return m;
  81: }
  82: 
  83: float diffuse(vec3 normal) {
  84:     vec3 n2 = normal * normal * vec3(.6, .25, .8);
  85:     return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
  86: }
  87: 
  88: 
  89: struct Belt {
  90:     vec2 light;
  91:     vec4 color;
  92:     vec3 pos;
  93:     float speed;
  94:     float offset;
  95:     vec4 rotation;
  96:     vec2 sourceTexture;
  97:     vec4 scrollTexture;
  98:     float scrollMult;
  99: };
 100: 
 101: 
 102: struct Vertex {
 103:     vec3 pos;
 104:     vec3 normal;
 105:     vec2 texCoords;
 106: };
 107: 
 108: struct BlockFrag {
 109:     vec2 texCoords;
 110:     vec4 color;
 111:     float diffuse;
 112:     vec2 light;
 113: };
 114: 
 115: BlockFrag FLWMain(Vertex v, Belt instance) {
 116:     vec3 rotated = rotateVertexByQuat(v.pos - .5, instance.rotation) + instance.pos + .5;
 117: 
 118:     vec4 worldPos = vec4(rotated, 1.);
 119: 
 120:     vec3 norm = rotateVertexByQuat(v.normal, instance.rotation);
 121: 
 122:     FLWFinalizeWorldPos(worldPos);
 123:     FLWFinalizeNormal(norm);
 124: 
 125:     float scrollSize = instance.scrollTexture.w - instance.scrollTexture.y;
 126:     float scroll = fract(instance.speed * uTime / (31.5 * 16.) + instance.offset) * scrollSize * instance.scrollMult;
 127: 
 128:     BlockFrag b;
 129:     b.diffuse = diffuse(norm);
 130:     b.texCoords = v.texCoords - instance.sourceTexture + instance.scrollTexture.xy + vec2(0, scroll);
 131:     b.light = instance.light;
 132: 
 133:     #if defined(DEBUG_RAINBOW)
 134:     b.color = instance.color;
 135:     #elif defined(DEBUG_NORMAL)
 136:     b.color = vec4(norm, 1.);
 137:     #else
 138:     b.color = vec4(1.);
 139:     #endif
 140: 
 141:     return b;
 142: }
 143: attribute vec3 a_v_pos;
 144: attribute vec3 a_v_normal;
 145: attribute vec2 a_v_texCoords;
 146: 
 147: attribute vec2 a_i_light;
 148: attribute vec4 a_i_color;
 149: attribute vec3 a_i_pos;
 150: attribute float a_i_speed;
 151: attribute float a_i_offset;
 152: attribute vec4 a_i_rotation;
 153: attribute vec2 a_i_sourceTexture;
 154: attribute vec4 a_i_scrollTexture;
 155: attribute float a_i_scrollMult;
 156: 
 157: 
 158: varying vec2 v2f_texCoords;
 159: varying vec4 v2f_color;
 160: varying float v2f_diffuse;
 161: varying vec2 v2f_light;
 162: 
 163: 
 164: void main() {
 165:     Vertex v;
 166:     v.pos = a_v_pos;
 167: v.normal = a_v_normal;
 168: v.texCoords = a_v_texCoords;
 169: 
 170: 
 171:     Belt i;
 172:     i.light = a_i_light;
 173: i.color = a_i_color;
 174: i.pos = a_i_pos;
 175: i.speed = a_i_speed;
 176: i.offset = a_i_offset;
 177: i.rotation = a_i_rotation;
 178: i.sourceTexture = a_i_sourceTexture;
 179: i.scrollTexture = a_i_scrollTexture;
 180: i.scrollMult = a_i_scrollMult;
 181: 
 182: 
 183:     BlockFrag o = FLWMain(v, i);
 184: 
 185:     v2f_texCoords = o.texCoords;
 186: v2f_color = o.color;
 187: v2f_diffuse = o.diffuse;
 188: v2f_light = o.light;
 189: 
 190: }

[14:02:48] [main/ERROR]: Shader compilation log for flywheel:block.frag: No errors.

[14:02:48] [main/ERROR]: Source for shader 'flywheel:block.frag':
   1: #version 110
   2: #define DEBUG_RAINBOW
   3: 
   4: #if defined(USE_FOG)
   5: varying float FragDistance;
   6: uniform vec4 uFogColor;
   7: #endif
   8: 
   9: #if defined(USE_FOG_LINEAR)
  10: uniform vec2 uFogRange;
  11: 
  12: float FLWFogFactor() {
  13:     return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
  14: }
  15:     #endif
  16: 
  17:     #if defined(USE_FOG_EXP2)
  18: uniform float uFogDensity;
  19: 
  20: float FLWFogFactor() {
  21:     float dist = FragDistance * uFogDensity;
  22:     return 1. / exp2(dist * dist);
  23: }
  24:     #endif
  25: // Adjust the [0,1] normalized lightmap value based on the texture matrix from LightTexture#enableLightmap
  26: vec2 shiftLight(vec2 lm) {
  27:     return lm * 0.99609375 + 0.03125;// * 255/256 + 1/32
  28: }
  29: 
  30: uniform sampler2D uBlockAtlas;
  31: uniform sampler2D uLightMap;
  32: 
  33: vec4 FLWBlockTexture(vec2 texCoords) {
  34:     return texture2D(uBlockAtlas, texCoords);
  35: }
  36: 
  37: void FLWFinalizeColor(vec4 color) {
  38:     #if defined(USE_FOG)
  39:     float a = color.a;
  40:     float fog = clamp(FLWFogFactor(), 0., 1.);
  41: 
  42:     color = mix(uFogColor, color, fog);
  43:     color.a = a;
  44:     #endif
  45: 
  46:     gl_FragColor = color;
  47: }
  48: 
  49: vec4 FLWLight(vec2 lightCoords) {
  50:     return texture2D(uLightMap, shiftLight(lightCoords));
  51: }
  52: 
  53: 
  54: 
  55: struct BlockFrag {
  56:     vec2 texCoords;
  57:     vec4 color;
  58:     float diffuse;
  59:     vec2 light;
  60: };
  61: 
  62: void FLWMain(BlockFrag r) {
  63:     vec4 tex = FLWBlockTexture(r.texCoords);
  64: 
  65:     vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;
  66: 
  67: //    flw_WorldPos = ;
  68: //    flw_Normal = ;
  69: //    flw_Albedo = tex.rgb;
  70: //    flw_Alpha = tex.a;
  71: //    flw_LightMap = r.light;
  72: //    flw_Tint = r.color;
  73:     FLWFinalizeColor(color);
  74: }
  75: 
  76: varying vec2 v2f_texCoords;
  77: varying vec4 v2f_color;
  78: varying float v2f_diffuse;
  79: varying vec2 v2f_light;
  80: 
  81: 
  82: //vec3 flw_WorldPos;
  83: //vec3 flw_Normal;
  84: //vec3 flw_Albedo;
  85: //float flw_Alpha;
  86: //vec2 flw_LightMap;
  87: //vec4 flw_Tint;
  88: 
  89: void main() {
  90:     BlockFrag f;
  91:     f.texCoords = v2f_texCoords;
  92: f.color = v2f_color;
  93: f.diffuse = v2f_diffuse;
  94: f.light = v2f_light;
  95: 
  96: 
  97:     FLWMain(f);
  98: }

[14:02:48] [main/ERROR]: Shader compilation log for create:belt.vert: No errors.

[14:02:48] [main/ERROR]: Source for shader 'create:belt.vert':
   1: #version 110
   2: #define DEBUG_NORMAL
   3: 
   4: #define PI 3.1415926538
   5: 
   6: uniform float uTime;
   7: uniform mat4 uViewProjection;
   8: uniform vec3 uCameraPos;
   9: 
  10: #if defined(USE_FOG)
  11: varying float FragDistance;
  12: #endif
  13: 
  14: void FLWFinalizeWorldPos(inout vec4 worldPos) {
  15:     #if defined(USE_FOG)
  16:     FragDistance = length(worldPos.xyz - uCameraPos);
  17:     #endif
  18: 
  19:     gl_Position = uViewProjection * worldPos;
  20: }
  21: 
  22: void FLWFinalizeNormal(inout vec3 normal) {
  23:     // noop
  24: }
  25: 
  26: 
  27: #define PIOVER2 1.5707963268
  28: 
  29: vec4 quat(vec3 axis, float angle) {
  30:     float halfAngle = angle * PIOVER2 / 180.0;
  31:     vec2 cs = sin(vec2(PIOVER2 - halfAngle, halfAngle)); // compute sin and cos in one instruction
  32:     return vec4(axis.xyz * cs.y,  cs.x);
  33: }
  34: 
  35: vec4 quatMult(vec4 q1, vec4 q2) {
  36:     // disgustingly vectorized quaternion multiplication
  37:     vec4 a = q1.w * q2.xyzw;
  38:     vec4 b = q1.x * q2.wzxy * vec4(1., -1., 1., -1.);
  39:     vec4 c = q1.y * q2.zwxy * vec4(1., 1., -1., -1.);
  40:     vec4 d = q1.z * q2.yxwz * vec4(-1., 1., 1., -1.);
  41: 
  42:     return a + b + c + d;
  43: }
  44: 
  45: vec3 rotateVertexByQuat(vec3 v, vec4 q) {
  46:     vec3 i = q.xyz;
  47:     return v + 2.0 * cross(i, cross(i, v) + q.w * v);
  48: }
  49: 
  50: vec3 rotateAbout(vec3 v, vec3 axis, float angle) {
  51:     return rotateVertexByQuat(v, quat(axis, angle));
  52: }
  53: 
  54: mat4 rotate(vec3 axis, float angle) {
  55:     float s = sin(angle);
  56:     float c = cos(angle);
  57:     float oc = 1. - c;
  58: 
  59:     vec3 sa = axis * s;
  60: 
  61:     mat4 mr = mat4(1.);
  62:     mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
  63:     mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
  64:     mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);
  65: 
  66:     return mr;
  67: }
  68: 
  69: mat4 rotation(vec3 rot) {
  70:     return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
  71: }
  72: 
  73: mat3 modelToNormal(mat4 mat) {
  74:     // Discard the edges. This won't be accurate for scaled or skewed matrices,
  75:     // but we don't have to work with those often.
  76:     mat3 m;
  77:     m[0] = mat[0].xyz;
  78:     m[1] = mat[1].xyz;
  79:     m[2] = mat[2].xyz;
  80:     return m;
  81: }
  82: 
  83: float diffuse(vec3 normal) {
  84:     vec3 n2 = normal * normal * vec3(.6, .25, .8);
  85:     return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
  86: }
  87: 
  88: 
  89: struct Belt {
  90:     vec2 light;
  91:     vec4 color;
  92:     vec3 pos;
  93:     float speed;
  94:     float offset;
  95:     vec4 rotation;
  96:     vec2 sourceTexture;
  97:     vec4 scrollTexture;
  98:     float scrollMult;
  99: };
 100: 
 101: 
 102: struct Vertex {
 103:     vec3 pos;
 104:     vec3 normal;
 105:     vec2 texCoords;
 106: };
 107: 
 108: struct BlockFrag {
 109:     vec2 texCoords;
 110:     vec4 color;
 111:     float diffuse;
 112:     vec2 light;
 113: };
 114: 
 115: BlockFrag FLWMain(Vertex v, Belt instance) {
 116:     vec3 rotated = rotateVertexByQuat(v.pos - .5, instance.rotation) + instance.pos + .5;
 117: 
 118:     vec4 worldPos = vec4(rotated, 1.);
 119: 
 120:     vec3 norm = rotateVertexByQuat(v.normal, instance.rotation);
 121: 
 122:     FLWFinalizeWorldPos(worldPos);
 123:     FLWFinalizeNormal(norm);
 124: 
 125:     float scrollSize = instance.scrollTexture.w - instance.scrollTexture.y;
 126:     float scroll = fract(instance.speed * uTime / (31.5 * 16.) + instance.offset) * scrollSize * instance.scrollMult;
 127: 
 128:     BlockFrag b;
 129:     b.diffuse = diffuse(norm);
 130:     b.texCoords = v.texCoords - instance.sourceTexture + instance.scrollTexture.xy + vec2(0, scroll);
 131:     b.light = instance.light;
 132: 
 133:     #if defined(DEBUG_RAINBOW)
 134:     b.color = instance.color;
 135:     #elif defined(DEBUG_NORMAL)
 136:     b.color = vec4(norm, 1.);
 137:     #else
 138:     b.color = vec4(1.);
 139:     #endif
 140: 
 141:     return b;
 142: }
 143: attribute vec3 a_v_pos;
 144: attribute vec3 a_v_normal;
 145: attribute vec2 a_v_texCoords;
 146: 
 147: attribute vec2 a_i_light;
 148: attribute vec4 a_i_color;
 149: attribute vec3 a_i_pos;
 150: attribute float a_i_speed;
 151: attribute float a_i_offset;
 152: attribute vec4 a_i_rotation;
 153: attribute vec2 a_i_sourceTexture;
 154: attribute vec4 a_i_scrollTexture;
 155: attribute float a_i_scrollMult;
 156: 
 157: 
 158: varying vec2 v2f_texCoords;
 159: varying vec4 v2f_color;
 160: varying float v2f_diffuse;
 161: varying vec2 v2f_light;
 162: 
 163: 
 164: void main() {
 165:     Vertex v;
 166:     v.pos = a_v_pos;
 167: v.normal = a_v_normal;
 168: v.texCoords = a_v_texCoords;
 169: 
 170: 
 171:     Belt i;
 172:     i.light = a_i_light;
 173: i.color = a_i_color;
 174: i.pos = a_i_pos;
 175: i.speed = a_i_speed;
 176: i.offset = a_i_offset;
 177: i.rotation = a_i_rotation;
 178: i.sourceTexture = a_i_sourceTexture;
 179: i.scrollTexture = a_i_scrollTexture;
 180: i.scrollMult = a_i_scrollMult;
 181: 
 182: 
 183:     BlockFrag o = FLWMain(v, i);
 184: 
 185:     v2f_texCoords = o.texCoords;
 186: v2f_color = o.color;
 187: v2f_diffuse = o.diffuse;
 188: v2f_light = o.light;
 189: 
 190: }

[14:02:48] [main/ERROR]: Shader compilation log for flywheel:block.frag: No errors.

[14:02:48] [main/ERROR]: Source for shader 'flywheel:block.frag':
   1: #version 110
   2: #define DEBUG_NORMAL
   3: 
   4: #if defined(USE_FOG)
   5: varying float FragDistance;
   6: uniform vec4 uFogColor;
   7: #endif
   8: 
   9: #if defined(USE_FOG_LINEAR)
  10: uniform vec2 uFogRange;
  11: 
  12: float FLWFogFactor() {
  13:     return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
  14: }
  15:     #endif
  16: 
  17:     #if defined(USE_FOG_EXP2)
  18: uniform float uFogDensity;
  19: 
  20: float FLWFogFactor() {
  21:     float dist = FragDistance * uFogDensity;
  22:     return 1. / exp2(dist * dist);
  23: }
  24:     #endif
  25: // Adjust the [0,1] normalized lightmap value based on the texture matrix from LightTexture#enableLightmap
  26: vec2 shiftLight(vec2 lm) {
  27:     return lm * 0.99609375 + 0.03125;// * 255/256 + 1/32
  28: }
  29: 
  30: uniform sampler2D uBlockAtlas;
  31: uniform sampler2D uLightMap;
  32: 
  33: vec4 FLWBlockTexture(vec2 texCoords) {
  34:     return texture2D(uBlockAtlas, texCoords);
  35: }
  36: 
  37: void FLWFinalizeColor(vec4 color) {
  38:     #if defined(USE_FOG)
  39:     float a = color.a;
  40:     float fog = clamp(FLWFogFactor(), 0., 1.);
  41: 
  42:     color = mix(uFogColor, color, fog);
  43:     color.a = a;
  44:     #endif
  45: 
  46:     gl_FragColor = color;
  47: }
  48: 
  49: vec4 FLWLight(vec2 lightCoords) {
  50:     return texture2D(uLightMap, shiftLight(lightCoords));
  51: }
  52: 
  53: 
  54: 
  55: struct BlockFrag {
  56:     vec2 texCoords;
  57:     vec4 color;
  58:     float diffuse;
  59:     vec2 light;
  60: };
  61: 
  62: void FLWMain(BlockFrag r) {
  63:     vec4 tex = FLWBlockTexture(r.texCoords);
  64: 
  65:     vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;
  66: 
  67: //    flw_WorldPos = ;
  68: //    flw_Normal = ;
  69: //    flw_Albedo = tex.rgb;
  70: //    flw_Alpha = tex.a;
  71: //    flw_LightMap = r.light;
  72: //    flw_Tint = r.color;
  73:     FLWFinalizeColor(color);
  74: }
  75: 
  76: varying vec2 v2f_texCoords;
  77: varying vec4 v2f_color;
  78: varying float v2f_diffuse;
  79: varying vec2 v2f_light;
  80: 
  81: 
  82: //vec3 flw_WorldPos;
  83: //vec3 flw_Normal;
  84: //vec3 flw_Albedo;
  85: //float flw_Alpha;
  86: //vec2 flw_LightMap;
  87: //vec4 flw_Tint;
  88: 
  89: void main() {
  90:     BlockFrag f;
  91:     f.texCoords = v2f_texCoords;
  92: f.color = v2f_color;
  93: f.diffuse = v2f_diffuse;
  94: f.light = v2f_light;
  95: 
  96: 
  97:     FLWMain(f);
  98: }

[14:02:49] [main/ERROR]: Shader compilation log for create:belt.vert: No errors.

[14:02:49] [main/ERROR]: Source for shader 'create:belt.vert':
   1: #version 110
   2: #define USE_FOG
   3: #define USE_FOG_LINEAR
   4: 
   5: #define PI 3.1415926538
   6: 
   7: uniform float uTime;
   8: uniform mat4 uViewProjection;
   9: uniform vec3 uCameraPos;
  10: 
  11: #if defined(USE_FOG)
  12: varying float FragDistance;
  13: #endif
  14: 
  15: void FLWFinalizeWorldPos(inout vec4 worldPos) {
  16:     #if defined(USE_FOG)
  17:     FragDistance = length(worldPos.xyz - uCameraPos);
  18:     #endif
  19: 
  20:     gl_Position = uViewProjection * worldPos;
  21: }
  22: 
  23: void FLWFinalizeNormal(inout vec3 normal) {
  24:     // noop
  25: }
  26: 
  27: 
  28: #define PIOVER2 1.5707963268
  29: 
  30: vec4 quat(vec3 axis, float angle) {
  31:     float halfAngle = angle * PIOVER2 / 180.0;
  32:     vec2 cs = sin(vec2(PIOVER2 - halfAngle, halfAngle)); // compute sin and cos in one instruction
  33:     return vec4(axis.xyz * cs.y,  cs.x);
  34: }
  35: 
  36: vec4 quatMult(vec4 q1, vec4 q2) {
  37:     // disgustingly vectorized quaternion multiplication
  38:     vec4 a = q1.w * q2.xyzw;
  39:     vec4 b = q1.x * q2.wzxy * vec4(1., -1., 1., -1.);
  40:     vec4 c = q1.y * q2.zwxy * vec4(1., 1., -1., -1.);
  41:     vec4 d = q1.z * q2.yxwz * vec4(-1., 1., 1., -1.);
  42: 
  43:     return a + b + c + d;
  44: }
  45: 
  46: vec3 rotateVertexByQuat(vec3 v, vec4 q) {
  47:     vec3 i = q.xyz;
  48:     return v + 2.0 * cross(i, cross(i, v) + q.w * v);
  49: }
  50: 
  51: vec3 rotateAbout(vec3 v, vec3 axis, float angle) {
  52:     return rotateVertexByQuat(v, quat(axis, angle));
  53: }
  54: 
  55: mat4 rotate(vec3 axis, float angle) {
  56:     float s = sin(angle);
  57:     float c = cos(angle);
  58:     float oc = 1. - c;
  59: 
  60:     vec3 sa = axis * s;
  61: 
  62:     mat4 mr = mat4(1.);
  63:     mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
  64:     mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
  65:     mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);
  66: 
  67:     return mr;
  68: }
  69: 
  70: mat4 rotation(vec3 rot) {
  71:     return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
  72: }
  73: 
  74: mat3 modelToNormal(mat4 mat) {
  75:     // Discard the edges. This won't be accurate for scaled or skewed matrices,
  76:     // but we don't have to work with those often.
  77:     mat3 m;
  78:     m[0] = mat[0].xyz;
  79:     m[1] = mat[1].xyz;
  80:     m[2] = mat[2].xyz;
  81:     return m;
  82: }
  83: 
  84: float diffuse(vec3 normal) {
  85:     vec3 n2 = normal * normal * vec3(.6, .25, .8);
  86:     return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
  87: }
  88: 
  89: 
  90: struct Belt {
  91:     vec2 light;
  92:     vec4 color;
  93:     vec3 pos;
  94:     float speed;
  95:     float offset;
  96:     vec4 rotation;
  97:     vec2 sourceTexture;
  98:     vec4 scrollTexture;
  99:     float scrollMult;
 100: };
 101: 
 102: 
 103: struct Vertex {
 104:     vec3 pos;
 105:     vec3 normal;
 106:     vec2 texCoords;
 107: };
 108: 
 109: struct BlockFrag {
 110:     vec2 texCoords;
 111:     vec4 color;
 112:     float diffuse;
 113:     vec2 light;
 114: };
 115: 
 116: BlockFrag FLWMain(Vertex v, Belt instance) {
 117:     vec3 rotated = rotateVertexByQuat(v.pos - .5, instance.rotation) + instance.pos + .5;
 118: 
 119:     vec4 worldPos = vec4(rotated, 1.);
 120: 
 121:     vec3 norm = rotateVertexByQuat(v.normal, instance.rotation);
 122: 
 123:     FLWFinalizeWorldPos(worldPos);
 124:     FLWFinalizeNormal(norm);
 125: 
 126:     float scrollSize = instance.scrollTexture.w - instance.scrollTexture.y;
 127:     float scroll = fract(instance.speed * uTime / (31.5 * 16.) + instance.offset) * scrollSize * instance.scrollMult;
 128: 
 129:     BlockFrag b;
 130:     b.diffuse = diffuse(norm);
 131:     b.texCoords = v.texCoords - instance.sourceTexture + instance.scrollTexture.xy + vec2(0, scroll);
 132:     b.light = instance.light;
 133: 
 134:     #if defined(DEBUG_RAINBOW)
 135:     b.color = instance.color;
 136:     #elif defined(DEBUG_NORMAL)
 137:     b.color = vec4(norm, 1.);
 138:     #else
 139:     b.color = vec4(1.);
 140:     #endif
 141: 
 142:     return b;
 143: }
 144: attribute vec3 a_v_pos;
 145: attribute vec3 a_v_normal;
 146: attribute vec2 a_v_texCoords;
 147: 
 148: attribute vec2 a_i_light;
 149: attribute vec4 a_i_color;
 150: attribute vec3 a_i_pos;
 151: attribute float a_i_speed;
 152: attribute float a_i_offset;
 153: attribute vec4 a_i_rotation;
 154: attribute vec2 a_i_sourceTexture;
 155: attribute vec4 a_i_scrollTexture;
 156: attribute float a_i_scrollMult;
 157: 
 158: 
 159: varying vec2 v2f_texCoords;
 160: varying vec4 v2f_color;
 161: varying float v2f_diffuse;
 162: varying vec2 v2f_light;
 163: 
 164: 
 165: void main() {
 166:     Vertex v;
 167:     v.pos = a_v_pos;
 168: v.normal = a_v_normal;
 169: v.texCoords = a_v_texCoords;
 170: 
 171: 
 172:     Belt i;
 173:     i.light = a_i_light;
 174: i.color = a_i_color;
 175: i.pos = a_i_pos;
 176: i.speed = a_i_speed;
 177: i.offset = a_i_offset;
 178: i.rotation = a_i_rotation;
 179: i.sourceTexture = a_i_sourceTexture;
 180: i.scrollTexture = a_i_scrollTexture;
 181: i.scrollMult = a_i_scrollMult;
 182: 
 183: 
 184:     BlockFrag o = FLWMain(v, i);
 185: 
 186:     v2f_texCoords = o.texCoords;
 187: v2f_color = o.color;
 188: v2f_diffuse = o.diffuse;
 189: v2f_light = o.light;
 190: 
 191: }

[14:02:49] [main/ERROR]: Shader compilation log for flywheel:block.frag: No errors.

[14:02:49] [main/ERROR]: Source for shader 'flywheel:block.frag':
   1: #version 110
   2: #define USE_FOG
   3: #define USE_FOG_LINEAR
   4: 
   5: #if defined(USE_FOG)
   6: varying float FragDistance;
   7: uniform vec4 uFogColor;
   8: #endif
   9: 
  10: #if defined(USE_FOG_LINEAR)
  11: uniform vec2 uFogRange;
  12: 
  13: float FLWFogFactor() {
  14:     return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
  15: }
  16:     #endif
  17: 
  18:     #if defined(USE_FOG_EXP2)
  19: uniform float uFogDensity;
  20: 
  21: float FLWFogFactor() {
  22:     float dist = FragDistance * uFogDensity;
  23:     return 1. / exp2(dist * dist);
  24: }
  25:     #endif
  26: // Adjust the [0,1] normalized lightmap value based on the texture matrix from LightTexture#enableLightmap
  27: vec2 shiftLight(vec2 lm) {
  28:     return lm * 0.99609375 + 0.03125;// * 255/256 + 1/32
  29: }
  30: 
  31: uniform sampler2D uBlockAtlas;
  32: uniform sampler2D uLightMap;
  33: 
  34: vec4 FLWBlockTexture(vec2 texCoords) {
  35:     return texture2D(uBlockAtlas, texCoords);
  36: }
  37: 
  38: void FLWFinalizeColor(vec4 color) {
  39:     #if defined(USE_FOG)
  40:     float a = color.a;
  41:     float fog = clamp(FLWFogFactor(), 0., 1.);
  42: 
  43:     color = mix(uFogColor, color, fog);
  44:     color.a = a;
  45:     #endif
  46: 
  47:     gl_FragColor = color;
  48: }
  49: 
  50: vec4 FLWLight(vec2 lightCoords) {
  51:     return texture2D(uLightMap, shiftLight(lightCoords));
  52: }
  53: 
  54: 
  55: 
  56: struct BlockFrag {
  57:     vec2 texCoords;
  58:     vec4 color;
  59:     float diffuse;
  60:     vec2 light;
  61: };
  62: 
  63: void FLWMain(BlockFrag r) {
  64:     vec4 tex = FLWBlockTexture(r.texCoords);
  65: 
  66:     vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;
  67: 
  68: //    flw_WorldPos = ;
  69: //    flw_Normal = ;
  70: //    flw_Albedo = tex.rgb;
  71: //    flw_Alpha = tex.a;
  72: //    flw_LightMap = r.light;
  73: //    flw_Tint = r.color;
  74:     FLWFinalizeColor(color);
  75: }
  76: 
  77: varying vec2 v2f_texCoords;
  78: varying vec4 v2f_color;
  79: varying float v2f_diffuse;
  80: varying vec2 v2f_light;
  81: 
  82: 
  83: //vec3 flw_WorldPos;
  84: //vec3 flw_Normal;
  85: //vec3 flw_Albedo;
  86: //float flw_Alpha;
  87: //vec2 flw_LightMap;
  88: //vec4 flw_Tint;
  89: 
  90: void main() {
  91:     BlockFrag f;
  92:     f.texCoords = v2f_texCoords;
  93: f.color = v2f_color;
  94: f.diffuse = v2f_diffuse;
  95: f.light = v2f_light;
  96: 
  97: 
  98:     FLWMain(f);
  99: }

[14:02:49] [main/ERROR]: Shader compilation log for create:belt.vert: No errors.

[14:02:49] [main/ERROR]: Source for shader 'create:belt.vert':
   1: #version 110
   2: #define USE_FOG
   3: #define USE_FOG_EXP2
   4: 
   5: #define PI 3.1415926538
   6: 
   7: uniform float uTime;
   8: uniform mat4 uViewProjection;
   9: uniform vec3 uCameraPos;
  10: 
  11: #if defined(USE_FOG)
  12: varying float FragDistance;
  13: #endif
  14: 
  15: void FLWFinalizeWorldPos(inout vec4 worldPos) {
  16:     #if defined(USE_FOG)
  17:     FragDistance = length(worldPos.xyz - uCameraPos);
  18:     #endif
  19: 
  20:     gl_Position = uViewProjection * worldPos;
  21: }
  22: 
  23: void FLWFinalizeNormal(inout vec3 normal) {
  24:     // noop
  25: }
  26: 
  27: 
  28: #define PIOVER2 1.5707963268
  29: 
  30: vec4 quat(vec3 axis, float angle) {
  31:     float halfAngle = angle * PIOVER2 / 180.0;
  32:     vec2 cs = sin(vec2(PIOVER2 - halfAngle, halfAngle)); // compute sin and cos in one instruction
  33:     return vec4(axis.xyz * cs.y,  cs.x);
  34: }
  35: 
  36: vec4 quatMult(vec4 q1, vec4 q2) {
  37:     // disgustingly vectorized quaternion multiplication
  38:     vec4 a = q1.w * q2.xyzw;
  39:     vec4 b = q1.x * q2.wzxy * vec4(1., -1., 1., -1.);
  40:     vec4 c = q1.y * q2.zwxy * vec4(1., 1., -1., -1.);
  41:     vec4 d = q1.z * q2.yxwz * vec4(-1., 1., 1., -1.);
  42: 
  43:     return a + b + c + d;
  44: }
  45: 
  46: vec3 rotateVertexByQuat(vec3 v, vec4 q) {
  47:     vec3 i = q.xyz;
  48:     return v + 2.0 * cross(i, cross(i, v) + q.w * v);
  49: }
  50: 
  51: vec3 rotateAbout(vec3 v, vec3 axis, float angle) {
  52:     return rotateVertexByQuat(v, quat(axis, angle));
  53: }
  54: 
  55: mat4 rotate(vec3 axis, float angle) {
  56:     float s = sin(angle);
  57:     float c = cos(angle);
  58:     float oc = 1. - c;
  59: 
  60:     vec3 sa = axis * s;
  61: 
  62:     mat4 mr = mat4(1.);
  63:     mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
  64:     mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
  65:     mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);
  66: 
  67:     return mr;
  68: }
  69: 
  70: mat4 rotation(vec3 rot) {
  71:     return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
  72: }
  73: 
  74: mat3 modelToNormal(mat4 mat) {
  75:     // Discard the edges. This won't be accurate for scaled or skewed matrices,
  76:     // but we don't have to work with those often.
  77:     mat3 m;
  78:     m[0] = mat[0].xyz;
  79:     m[1] = mat[1].xyz;
  80:     m[2] = mat[2].xyz;
  81:     return m;
  82: }
  83: 
  84: float diffuse(vec3 normal) {
  85:     vec3 n2 = normal * normal * vec3(.6, .25, .8);
  86:     return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
  87: }
  88: 
  89: 
  90: struct Belt {
  91:     vec2 light;
  92:     vec4 color;
  93:     vec3 pos;
  94:     float speed;
  95:     float offset;
  96:     vec4 rotation;
  97:     vec2 sourceTexture;
  98:     vec4 scrollTexture;
  99:     float scrollMult;
 100: };
 101: 
 102: 
 103: struct Vertex {
 104:     vec3 pos;
 105:     vec3 normal;
 106:     vec2 texCoords;
 107: };
 108: 
 109: struct BlockFrag {
 110:     vec2 texCoords;
 111:     vec4 color;
 112:     float diffuse;
 113:     vec2 light;
 114: };
 115: 
 116: BlockFrag FLWMain(Vertex v, Belt instance) {
 117:     vec3 rotated = rotateVertexByQuat(v.pos - .5, instance.rotation) + instance.pos + .5;
 118: 
 119:     vec4 worldPos = vec4(rotated, 1.);
 120: 
 121:     vec3 norm = rotateVertexByQuat(v.normal, instance.rotation);
 122: 
 123:     FLWFinalizeWorldPos(worldPos);
 124:     FLWFinalizeNormal(norm);
 125: 
 126:     float scrollSize = instance.scrollTexture.w - instance.scrollTexture.y;
 127:     float scroll = fract(instance.speed * uTime / (31.5 * 16.) + instance.offset) * scrollSize * instance.scrollMult;
 128: 
 129:     BlockFrag b;
 130:     b.diffuse = diffuse(norm);
 131:     b.texCoords = v.texCoords - instance.sourceTexture + instance.scrollTexture.xy + vec2(0, scroll);
 132:     b.light = instance.light;
 133: 
 134:     #if defined(DEBUG_RAINBOW)
 135:     b.color = instance.color;
 136:     #elif defined(DEBUG_NORMAL)
 137:     b.color = vec4(norm, 1.);
 138:     #else
 139:     b.color = vec4(1.);
 140:     #endif
 141: 
 142:     return b;
 143: }
 144: attribute vec3 a_v_pos;
 145: attribute vec3 a_v_normal;
 146: attribute vec2 a_v_texCoords;
 147: 
 148: attribute vec2 a_i_light;
 149: attribute vec4 a_i_color;
 150: attribute vec3 a_i_pos;
 151: attribute float a_i_speed;
 152: attribute float a_i_offset;
 153: attribute vec4 a_i_rotation;
 154: attribute vec2 a_i_sourceTexture;
 155: attribute vec4 a_i_scrollTexture;
 156: attribute float a_i_scrollMult;
 157: 
 158: 
 159: varying vec2 v2f_texCoords;
 160: varying vec4 v2f_color;
 161: varying float v2f_diffuse;
 162: varying vec2 v2f_light;
 163: 
 164: 
 165: void main() {
 166:     Vertex v;
 167:     v.pos = a_v_pos;
 168: v.normal = a_v_normal;
 169: v.texCoords = a_v_texCoords;
 170: 
 171: 
 172:     Belt i;
 173:     i.light = a_i_light;
 174: i.color = a_i_color;
 175: i.pos = a_i_pos;
 176: i.speed = a_i_speed;
 177: i.offset = a_i_offset;
 178: i.rotation = a_i_rotation;
 179: i.sourceTexture = a_i_sourceTexture;
 180: i.scrollTexture = a_i_scrollTexture;
 181: i.scrollMult = a_i_scrollMult;
 182: 
 183: 
 184:     BlockFrag o = FLWMain(v, i);
 185: 
 186:     v2f_texCoords = o.texCoords;
 187: v2f_color = o.color;
 188: v2f_diffuse = o.diffuse;
 189: v2f_light = o.light;
 190: 
 191: }

[14:02:49] [main/ERROR]: Shader compilation log for flywheel:block.frag: No errors.

[14:02:49] [main/ERROR]: Source for shader 'flywheel:block.frag':
   1: #version 110
   2: #define USE_FOG
   3: #define USE_FOG_EXP2
   4: 
   5: #if defined(USE_FOG)
   6: varying float FragDistance;
   7: uniform vec4 uFogColor;
   8: #endif
   9: 
  10: #if defined(USE_FOG_LINEAR)
  11: uniform vec2 uFogRange;
  12: 
  13: float FLWFogFactor() {
  14:     return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
  15: }
  16:     #endif
  17: 
  18:     #if defined(USE_FOG_EXP2)
  19: uniform float uFogDensity;
  20: 
  21: float FLWFogFactor() {
  22:     float dist = FragDistance * uFogDensity;
  23:     return 1. / exp2(dist * dist);
  24: }
  25:     #endif
  26: // Adjust the [0,1] normalized lightmap value based on the texture matrix from LightTexture#enableLightmap
  27: vec2 shiftLight(vec2 lm) {
  28:     return lm * 0.99609375 + 0.03125;// * 255/256 + 1/32
  29: }
  30: 
  31: uniform sampler2D uBlockAtlas;
  32: uniform sampler2D uLightMap;
  33: 
  34: vec4 FLWBlockTexture(vec2 texCoords) {
  35:     return texture2D(uBlockAtlas, texCoords);
  36: }
  37: 
  38: void FLWFinalizeColor(vec4 color) {
  39:     #if defined(USE_FOG)
  40:     float a = color.a;
  41:     float fog = clamp(FLWFogFactor(), 0., 1.);
  42: 
  43:     color = mix(uFogColor, color, fog);
  44:     color.a = a;
  45:     #endif
  46: 
  47:     gl_FragColor = color;
  48: }
  49: 
  50: vec4 FLWLight(vec2 lightCoords) {
  51:     return texture2D(uLightMap, shiftLight(lightCoords));
  52: }
  53: 
  54: 
  55: 
  56: struct BlockFrag {
  57:     vec2 texCoords;
  58:     vec4 color;
  59:     float diffuse;
  60:     vec2 light;
  61: };
  62: 
  63: void FLWMain(BlockFrag r) {
  64:     vec4 tex = FLWBlockTexture(r.texCoords);
  65: 
  66:     vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;
  67: 
  68: //    flw_WorldPos = ;
  69: //    flw_Normal = ;
  70: //    flw_Albedo = tex.rgb;
  71: //    flw_Alpha = tex.a;
  72: //    flw_LightMap = r.light;
  73: //    flw_Tint = r.color;
  74:     FLWFinalizeColor(color);
  75: }
  76: 
  77: varying vec2 v2f_texCoords;
  78: varying vec4 v2f_color;
  79: varying float v2f_diffuse;
  80: varying vec2 v2f_light;
  81: 
  82: 
  83: //vec3 flw_WorldPos;
  84: //vec3 flw_Normal;
  85: //vec3 flw_Albedo;
  86: //float flw_Alpha;
  87: //vec2 flw_LightMap;
  88: //vec4 flw_Tint;
  89: 
  90: void main() {
  91:     BlockFrag f;
  92:     f.texCoords = v2f_texCoords;
  93: f.color = v2f_color;
  94: f.diffuse = v2f_diffuse;
  95: f.light = v2f_light;
  96: 
  97: 
  98:     FLWMain(f);
  99: }

[14:02:49] [main/ERROR]: Shader compilation log for create:belt.vert: No errors.

[14:02:49] [main/ERROR]: Source for shader 'create:belt.vert':
   1: #version 110
   2: 
   3: #define PI 3.1415926538
   4: 
   5: uniform float uTime;
   6: uniform mat4 uViewProjection;
   7: uniform vec3 uCameraPos;
   8: 
   9: #if defined(USE_FOG)
  10: varying float FragDistance;
  11: #endif
  12: 
  13: void FLWFinalizeWorldPos(inout vec4 worldPos) {
  14:     #if defined(USE_FOG)
  15:     FragDistance = length(worldPos.xyz - uCameraPos);
  16:     #endif
  17: 
  18:     gl_Position = uViewProjection * worldPos;
  19: }
  20: 
  21: void FLWFinalizeNormal(inout vec3 normal) {
  22:     // noop
  23: }
  24: 
  25: 
  26: #define PIOVER2 1.5707963268
  27: 
  28: vec4 quat(vec3 axis, float angle) {
  29:     float halfAngle = angle * PIOVER2 / 180.0;
  30:     vec2 cs = sin(vec2(PIOVER2 - halfAngle, halfAngle)); // compute sin and cos in one instruction
  31:     return vec4(axis.xyz * cs.y,  cs.x);
  32: }
  33: 
  34: vec4 quatMult(vec4 q1, vec4 q2) {
  35:     // disgustingly vectorized quaternion multiplication
  36:     vec4 a = q1.w * q2.xyzw;
  37:     vec4 b = q1.x * q2.wzxy * vec4(1., -1., 1., -1.);
  38:     vec4 c = q1.y * q2.zwxy * vec4(1., 1., -1., -1.);
  39:     vec4 d = q1.z * q2.yxwz * vec4(-1., 1., 1., -1.);
  40: 
  41:     return a + b + c + d;
  42: }
  43: 
  44: vec3 rotateVertexByQuat(vec3 v, vec4 q) {
  45:     vec3 i = q.xyz;
  46:     return v + 2.0 * cross(i, cross(i, v) + q.w * v);
  47: }
  48: 
  49: vec3 rotateAbout(vec3 v, vec3 axis, float angle) {
  50:     return rotateVertexByQuat(v, quat(axis, angle));
  51: }
  52: 
  53: mat4 rotate(vec3 axis, float angle) {
  54:     float s = sin(angle);
  55:     float c = cos(angle);
  56:     float oc = 1. - c;
  57: 
  58:     vec3 sa = axis * s;
  59: 
  60:     mat4 mr = mat4(1.);
  61:     mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
  62:     mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
  63:     mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);
  64: 
  65:     return mr;
  66: }
  67: 
  68: mat4 rotation(vec3 rot) {
  69:     return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
  70: }
  71: 
  72: mat3 modelToNormal(mat4 mat) {
  73:     // Discard the edges. This won't be accurate for scaled or skewed matrices,
  74:     // but we don't have to work with those often.
  75:     mat3 m;
  76:     m[0] = mat[0].xyz;
  77:     m[1] = mat[1].xyz;
  78:     m[2] = mat[2].xyz;
  79:     return m;
  80: }
  81: 
  82: float diffuse(vec3 normal) {
  83:     vec3 n2 = normal * normal * vec3(.6, .25, .8);
  84:     return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
  85: }
  86: 
  87: 
  88: struct Belt {
  89:     vec2 light;
  90:     vec4 color;
  91:     vec3 pos;
  92:     float speed;
  93:     float offset;
  94:     vec4 rotation;
  95:     vec2 sourceTexture;
  96:     vec4 scrollTexture;
  97:     float scrollMult;
  98: };
  99: 
 100: 
 101: struct Vertex {
 102:     vec3 pos;
 103:     vec3 normal;
 104:     vec2 texCoords;
 105: };
 106: 
 107: struct BlockFrag {
 108:     vec2 texCoords;
 109:     vec4 color;
 110:     float diffuse;
 111:     vec2 light;
 112: };
 113: 
 114: BlockFrag FLWMain(Vertex v, Belt instance) {
 115:     vec3 rotated = rotateVertexByQuat(v.pos - .5, instance.rotation) + instance.pos + .5;
 116: 
 117:     vec4 worldPos = vec4(rotated, 1.);
 118: 
 119:     vec3 norm = rotateVertexByQuat(v.normal, instance.rotation);
 120: 
 121:     FLWFinalizeWorldPos(worldPos);
 122:     FLWFinalizeNormal(norm);
 123: 
 124:     float scrollSize = instance.scrollTexture.w - instance.scrollTexture.y;
 125:     float scroll = fract(instance.speed * uTime / (31.5 * 16.) + instance.offset) * scrollSize * instance.scrollMult;
 126: 
 127:     BlockFrag b;
 128:     b.diffuse = diffuse(norm);
 129:     b.texCoords = v.texCoords - instance.sourceTexture + instance.scrollTexture.xy + vec2(0, scroll);
 130:     b.light = instance.light;
 131: 
 132:     #if defined(DEBUG_RAINBOW)
 133:     b.color = instance.color;
 134:     #elif defined(DEBUG_NORMAL)
 135:     b.color = vec4(norm, 1.);
 136:     #else
 137:     b.color = vec4(1.);
 138:     #endif
 139: 
 140:     return b;
 141: }
 142: attribute vec3 a_v_pos;
 143: attribute vec3 a_v_normal;
 144: attribute vec2 a_v_texCoords;
 145: 
 146: attribute vec2 a_i_light;
 147: attribute vec4 a_i_color;
 148: attribute vec3 a_i_pos;
 149: attribute float a_i_speed;
 150: attribute float a_i_offset;
 151: attribute vec4 a_i_rotation;
 152: attribute vec2 a_i_sourceTexture;
 153: attribute vec4 a_i_scrollTexture;
 154: attribute float a_i_scrollMult;
 155: 
 156: 
 157: varying vec2 v2f_texCoords;
 158: varying vec4 v2f_color;
 159: varying float v2f_diffuse;
 160: varying vec2 v2f_light;
 161: 
 162: 
 163: void main() {
 164:     Vertex v;
 165:     v.pos = a_v_pos;
 166: v.normal = a_v_normal;
 167: v.texCoords = a_v_texCoords;
 168: 
 169: 
 170:     Belt i;
 171:     i.light = a_i_light;
 172: i.color = a_i_color;
 173: i.pos = a_i_pos;
 174: i.speed = a_i_speed;
 175: i.offset = a_i_offset;
 176: i.rotation = a_i_rotation;
 177: i.sourceTexture = a_i_sourceTexture;
 178: i.scrollTexture = a_i_scrollTexture;
 179: i.scrollMult = a_i_scrollMult;
 180: 
 181: 
 182:     BlockFrag o = FLWMain(v, i);
 183: 
 184:     v2f_texCoords = o.texCoords;
 185: v2f_color = o.color;
 186: v2f_diffuse = o.diffuse;
 187: v2f_light = o.light;
 188: 
 189: }

[14:02:49] [main/ERROR]: Shader compilation log for flywheel:block.frag: No errors.

[14:02:49] [main/ERROR]: Source for shader 'flywheel:block.frag':
   1: #version 110
   2: 
   3: #if defined(USE_FOG)
   4: varying float FragDistance;
   5: uniform vec4 uFogColor;
   6: #endif
   7: 
   8: #if defined(USE_FOG_LINEAR)
   9: uniform vec2 uFogRange;
  10: 
  11: float FLWFogFactor() {
  12:     return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
  13: }
  14:     #endif
  15: 
  16:     #if defined(USE_FOG_EXP2)
  17: uniform float uFogDensity;
  18: 
  19: float FLWFogFactor() {
  20:     float dist = FragDistance * uFogDensity;
  21:     return 1. / exp2(dist * dist);
  22: }
  23:     #endif
  24: // Adjust the [0,1] normalized lightmap value based on the texture matrix from LightTexture#enableLightmap
  25: vec2 shiftLight(vec2 lm) {
  26:     return lm * 0.99609375 + 0.03125;// * 255/256 + 1/32
  27: }
  28: 
  29: uniform sampler2D uBlockAtlas;
  30: uniform sampler2D uLightMap;
  31: 
  32: vec4 FLWBlockTexture(vec2 texCoords) {
  33:     return texture2D(uBlockAtlas, texCoords);
  34: }
  35: 
  36: void FLWFinalizeColor(vec4 color) {
  37:     #if defined(USE_FOG)
  38:     float a = color.a;
  39:     float fog = clamp(FLWFogFactor(), 0., 1.);
  40: 
  41:     color = mix(uFogColor, color, fog);
  42:     color.a = a;
  43:     #endif
  44: 
  45:     gl_FragColor = color;
  46: }
  47: 
  48: vec4 FLWLight(vec2 lightCoords) {
  49:     return texture2D(uLightMap, shiftLight(lightCoords));
  50: }
  51: 
  52: 
  53: 
  54: struct BlockFrag {
  55:     vec2 texCoords;
  56:     vec4 color;
  57:     float diffuse;
  58:     vec2 light;
  59: };
  60: 
  61: void FLWMain(BlockFrag r) {
  62:     vec4 tex = FLWBlockTexture(r.texCoords);
  63: 
  64:     vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;
  65: 
  66: //    flw_WorldPos = ;
  67: //    flw_Normal = ;
  68: //    flw_Albedo = tex.rgb;
  69: //    flw_Alpha = tex.a;
  70: //    flw_LightMap = r.light;
  71: //    flw_Tint = r.color;
  72:     FLWFinalizeColor(color);
  73: }
  74: 
  75: varying vec2 v2f_texCoords;
  76: varying vec4 v2f_color;
  77: varying float v2f_diffuse;
  78: varying vec2 v2f_light;
  79: 
  80: 
  81: //vec3 flw_WorldPos;
  82: //vec3 flw_Normal;
  83: //vec3 flw_Albedo;
  84: //float flw_Alpha;
  85: //vec2 flw_LightMap;
  86: //vec4 flw_Tint;
  87: 
  88: void main() {
  89:     BlockFrag f;
  90:     f.texCoords = v2f_texCoords;
  91: f.color = v2f_color;
  92: f.diffuse = v2f_diffuse;
  93: f.light = v2f_light;
  94: 
  95: 
  96:     FLWMain(f);
  97: }

[14:02:49] [main/ERROR]: Shader compilation log for flywheel:oriented.vert: No errors.

[14:02:49] [main/ERROR]: Source for shader 'flywheel:oriented.vert':
   1: #version 110
   2: #define DEBUG_NORMAL
   3: 
   4: uniform float uTime;
   5: uniform mat4 uViewProjection;
   6: uniform vec3 uCameraPos;
   7: 
   8: #if defined(USE_FOG)
   9: varying float FragDistance;
  10: #endif
  11: 
  12: void FLWFinalizeWorldPos(inout vec4 worldPos) {
  13:     #if defined(USE_FOG)
  14:     FragDistance = length(worldPos.xyz - uCameraPos);
  15:     #endif
  16: 
  17:     gl_Position = uViewProjection * worldPos;
  18: }
  19: 
  20: void FLWFinalizeNormal(inout vec3 normal) {
  21:     // noop
  22: }
  23: 
  24: 
  25: mat4 rotate(vec3 axis, float angle) {
  26:     float s = sin(angle);
  27:     float c = cos(angle);
  28:     float oc = 1. - c;
  29: 
  30:     vec3 sa = axis * s;
  31: 
  32:     mat4 mr = mat4(1.);
  33:     mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
  34:     mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
  35:     mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);
  36: 
  37:     return mr;
  38: }
  39: 
  40: mat4 rotation(vec3 rot) {
  41:     return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
  42: }
  43: 
  44: mat3 modelToNormal(mat4 mat) {
  45:     // Discard the edges. This won't be accurate for scaled or skewed matrices,
  46:     // but we don't have to work with those often.
  47:     mat3 m;
  48:     m[0] = mat[0].xyz;
  49:     m[1] = mat[1].xyz;
  50:     m[2] = mat[2].xyz;
  51:     return m;
  52: }
  53: 
  54: #define PIOVER2 1.5707963268
  55: 
  56: vec4 quat(vec3 axis, float angle) {
  57:     float halfAngle = angle * PIOVER2 / 180.0;
  58:     vec2 cs = sin(vec2(PIOVER2 - halfAngle, halfAngle)); // compute sin and cos in one instruction
  59:     return vec4(axis.xyz * cs.y,  cs.x);
  60: }
  61: 
  62: vec4 quatMult(vec4 q1, vec4 q2) {
  63:     // disgustingly vectorized quaternion multiplication
  64:     vec4 a = q1.w * q2.xyzw;
  65:     vec4 b = q1.x * q2.wzxy * vec4(1., -1., 1., -1.);
  66:     vec4 c = q1.y * q2.zwxy * vec4(1., 1., -1., -1.);
  67:     vec4 d = q1.z * q2.yxwz * vec4(-1., 1., 1., -1.);
  68: 
  69:     return a + b + c + d;
  70: }
  71: 
  72: vec3 rotateVertexByQuat(vec3 v, vec4 q) {
  73:     vec3 i = q.xyz;
  74:     return v + 2.0 * cross(i, cross(i, v) + q.w * v);
  75: }
  76: 
  77: vec3 rotateAbout(vec3 v, vec3 axis, float angle) {
  78:     return rotateVertexByQuat(v, quat(axis, angle));
  79: }
  80: 
  81: float diffuse(vec3 normal) {
  82:     vec3 n2 = normal * normal * vec3(.6, .25, .8);
  83:     return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
  84: }
  85: 
  86: 
  87: struct Oriented {
  88:     vec2 light;
  89:     vec4 color;
  90:     vec3 pos;
  91:     vec3 pivot;
  92:     vec4 rotation;
  93: };
  94: 
  95: 
  96: struct Vertex {
  97:     vec3 pos;
  98:     vec3 normal;
  99:     vec2 texCoords;
 100: };
 101: 
 102: struct BlockFrag {
 103:     vec2 texCoords;
 104:     vec4 color;
 105:     float diffuse;
 106:     vec2 light;
 107: };
 108: 
 109: BlockFrag FLWMain(Vertex v, Oriented o) {
 110:     vec4 worldPos = vec4(rotateVertexByQuat(v.pos - o.pivot, o.rotation) + o.pivot + o.pos, 1.);
 111: 
 112:     vec3 norm = rotateVertexByQuat(v.normal, o.rotation);
 113: 
 114:     FLWFinalizeWorldPos(worldPos);
 115:     FLWFinalizeNormal(norm);
 116: 
 117:     BlockFrag b;
 118:     b.diffuse = diffuse(norm);
 119:     b.texCoords = v.texCoords;
 120:     b.light = o.light;
 121:     #if defined(DEBUG_NORMAL)
 122:     b.color = vec4(norm, 1.);
 123:     #else
 124:     b.color = o.color;
 125:     #endif
 126:     return b;
 127: }
 128: attribute vec3 a_v_pos;
 129: attribute vec3 a_v_normal;
 130: attribute vec2 a_v_texCoords;
 131: 
 132: attribute vec2 a_i_light;
 133: attribute vec4 a_i_color;
 134: attribute vec3 a_i_pos;
 135: attribute vec3 a_i_pivot;
 136: attribute vec4 a_i_rotation;
 137: 
 138: 
 139: varying vec2 v2f_texCoords;
 140: varying vec4 v2f_color;
 141: varying float v2f_diffuse;
 142: varying vec2 v2f_light;
 143: 
 144: 
 145: void main() {
 146:     Vertex v;
 147:     v.pos = a_v_pos;
 148: v.normal = a_v_normal;
 149: v.texCoords = a_v_texCoords;
 150: 
 151: 
 152:     Oriented i;
 153:     i.light = a_i_light;
 154: i.color = a_i_color;
 155: i.pos = a_i_pos;
 156: i.pivot = a_i_pivot;
 157: i.rotation = a_i_rotation;
 158: 
 159: 
 160:     BlockFrag o = FLWMain(v, i);
 161: 
 162:     v2f_texCoords = o.texCoords;
 163: v2f_color = o.color;
 164: v2f_diffuse = o.diffuse;
 165: v2f_light = o.light;
 166: 
 167: }

[14:02:49] [main/ERROR]: Shader compilation log for flywheel:block.frag: No errors.

[14:02:49] [main/ERROR]: Source for shader 'flywheel:block.frag':
   1: #version 110
   2: #define DEBUG_NORMAL
   3: 
   4: #if defined(USE_FOG)
   5: varying float FragDistance;
   6: uniform vec4 uFogColor;
   7: #endif
   8: 
   9: #if defined(USE_FOG_LINEAR)
  10: uniform vec2 uFogRange;
  11: 
  12: float FLWFogFactor() {
  13:     return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
  14: }
  15:     #endif
  16: 
  17:     #if defined(USE_FOG_EXP2)
  18: uniform float uFogDensity;
  19: 
  20: float FLWFogFactor() {
  21:     float dist = FragDistance * uFogDensity;
  22:     return 1. / exp2(dist * dist);
  23: }
  24:     #endif
  25: // Adjust the [0,1] normalized lightmap value based on the texture matrix from LightTexture#enableLightmap
  26: vec2 shiftLight(vec2 lm) {
  27:     return lm * 0.99609375 + 0.03125;// * 255/256 + 1/32
  28: }
  29: 
  30: uniform sampler2D uBlockAtlas;
  31: uniform sampler2D uLightMap;
  32: 
  33: vec4 FLWBlockTexture(vec2 texCoords) {
  34:     return texture2D(uBlockAtlas, texCoords);
  35: }
  36: 
  37: void FLWFinalizeColor(vec4 color) {
  38:     #if defined(USE_FOG)
  39:     float a = color.a;
  40:     float fog = clamp(FLWFogFactor(), 0., 1.);
  41: 
  42:     color = mix(uFogColor, color, fog);
  43:     color.a = a;
  44:     #endif
  45: 
  46:     gl_FragColor = color;
  47: }
  48: 
  49: vec4 FLWLight(vec2 lightCoords) {
  50:     return texture2D(uLightMap, shiftLight(lightCoords));
  51: }
  52: 
  53: 
  54: 
  55: struct BlockFrag {
  56:     vec2 texCoords;
  57:     vec4 color;
  58:     float diffuse;
  59:     vec2 light;
  60: };
  61: 
  62: void FLWMain(BlockFrag r) {
  63:     vec4 tex = FLWBlockTexture(r.texCoords);
  64: 
  65:     vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;
  66: 
  67: //    flw_WorldPos = ;
  68: //    flw_Normal = ;
  69: //    flw_Albedo = tex.rgb;
  70: //    flw_Alpha = tex.a;
  71: //    flw_LightMap = r.light;
  72: //    flw_Tint = r.color;
  73:     FLWFinalizeColor(color);
  74: }
  75: 
  76: varying vec2 v2f_texCoords;
  77: varying vec4 v2f_color;
  78: varying float v2f_diffuse;
  79: varying vec2 v2f_light;
  80: 
  81: 
  82: //vec3 flw_WorldPos;
  83: //vec3 flw_Normal;
  84: //vec3 flw_Albedo;
  85: //float flw_Alpha;
  86: //vec2 flw_LightMap;
  87: //vec4 flw_Tint;
  88: 
  89: void main() {
  90:     BlockFrag f;
  91:     f.texCoords = v2f_texCoords;
  92: f.color = v2f_color;
  93: f.diffuse = v2f_diffuse;
  94: f.light = v2f_light;
  95: 
  96: 
  97:     FLWMain(f);
  98: }

[14:02:49] [main/ERROR]: Shader compilation log for flywheel:oriented.vert: No errors.

[14:02:49] [main/ERROR]: Source for shader 'flywheel:oriented.vert':
   1: #version 110
   2: #define USE_FOG
   3: #define USE_FOG_LINEAR
   4: 
   5: uniform float uTime;
   6: uniform mat4 uViewProjection;
   7: uniform vec3 uCameraPos;
   8: 
   9: #if defined(USE_FOG)
  10: varying float FragDistance;
  11: #endif
  12: 
  13: void FLWFinalizeWorldPos(inout vec4 worldPos) {
  14:     #if defined(USE_FOG)
  15:     FragDistance = length(worldPos.xyz - uCameraPos);
  16:     #endif
  17: 
  18:     gl_Position = uViewProjection * worldPos;
  19: }
  20: 
  21: void FLWFinalizeNormal(inout vec3 normal) {
  22:     // noop
  23: }
  24: 
  25: 
  26: mat4 rotate(vec3 axis, float angle) {
  27:     float s = sin(angle);
  28:     float c = cos(angle);
  29:     float oc = 1. - c;
  30: 
  31:     vec3 sa = axis * s;
  32: 
  33:     mat4 mr = mat4(1.);
  34:     mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
  35:     mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
  36:     mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);
  37: 
  38:     return mr;
  39: }
  40: 
  41: mat4 rotation(vec3 rot) {
  42:     return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
  43: }
  44: 
  45: mat3 modelToNormal(mat4 mat) {
  46:     // Discard the edges. This won't be accurate for scaled or skewed matrices,
  47:     // but we don't have to work with those often.
  48:     mat3 m;
  49:     m[0] = mat[0].xyz;
  50:     m[1] = mat[1].xyz;
  51:     m[2] = mat[2].xyz;
  52:     return m;
  53: }
  54: 
  55: #define PIOVER2 1.5707963268
  56: 
  57: vec4 quat(vec3 axis, float angle) {
  58:     float halfAngle = angle * PIOVER2 / 180.0;
  59:     vec2 cs = sin(vec2(PIOVER2 - halfAngle, halfAngle)); // compute sin and cos in one instruction
  60:     return vec4(axis.xyz * cs.y,  cs.x);
  61: }
  62: 
  63: vec4 quatMult(vec4 q1, vec4 q2) {
  64:     // disgustingly vectorized quaternion multiplication
  65:     vec4 a = q1.w * q2.xyzw;
  66:     vec4 b = q1.x * q2.wzxy * vec4(1., -1., 1., -1.);
  67:     vec4 c = q1.y * q2.zwxy * vec4(1., 1., -1., -1.);
  68:     vec4 d = q1.z * q2.yxwz * vec4(-1., 1., 1., -1.);
  69: 
  70:     return a + b + c + d;
  71: }
  72: 
  73: vec3 rotateVertexByQuat(vec3 v, vec4 q) {
  74:     vec3 i = q.xyz;
  75:     return v + 2.0 * cross(i, cross(i, v) + q.w * v);
  76: }
  77: 
  78: vec3 rotateAbout(vec3 v, vec3 axis, float angle) {
  79:     return rotateVertexByQuat(v, quat(axis, angle));
  80: }
  81: 
  82: float diffuse(vec3 normal) {
  83:     vec3 n2 = normal * normal * vec3(.6, .25, .8);
  84:     return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
  85: }
  86: 
  87: 
  88: struct Oriented {
  89:     vec2 light;
  90:     vec4 color;
  91:     vec3 pos;
  92:     vec3 pivot;
  93:     vec4 rotation;
  94: };
  95: 
  96: 
  97: struct Vertex {
  98:     vec3 pos;
  99:     vec3 normal;
 100:     vec2 texCoords;
 101: };
 102: 
 103: struct BlockFrag {
 104:     vec2 texCoords;
 105:     vec4 color;
 106:     float diffuse;
 107:     vec2 light;
 108: };
 109: 
 110: BlockFrag FLWMain(Vertex v, Oriented o) {
 111:     vec4 worldPos = vec4(rotateVertexByQuat(v.pos - o.pivot, o.rotation) + o.pivot + o.pos, 1.);
 112: 
 113:     vec3 norm = rotateVertexByQuat(v.normal, o.rotation);
 114: 
 115:     FLWFinalizeWorldPos(worldPos);
 116:     FLWFinalizeNormal(norm);
 117: 
 118:     BlockFrag b;
 119:     b.diffuse = diffuse(norm);
 120:     b.texCoords = v.texCoords;
 121:     b.light = o.light;
 122:     #if defined(DEBUG_NORMAL)
 123:     b.color = vec4(norm, 1.);
 124:     #else
 125:     b.color = o.color;
 126:     #endif
 127:     return b;
 128: }
 129: attribute vec3 a_v_pos;
 130: attribute vec3 a_v_normal;
 131: attribute vec2 a_v_texCoords;
 132: 
 133: attribute vec2 a_i_light;
 134: attribute vec4 a_i_color;
 135: attribute vec3 a_i_pos;
 136: attribute vec3 a_i_pivot;
 137: attribute vec4 a_i_rotation;
 138: 
 139: 
 140: varying vec2 v2f_texCoords;
 141: varying vec4 v2f_color;
 142: varying float v2f_diffuse;
 143: varying vec2 v2f_light;
 144: 
 145: 
 146: void main() {
 147:     Vertex v;
 148:     v.pos = a_v_pos;
 149: v.normal = a_v_normal;
 150: v.texCoords = a_v_texCoords;
 151: 
 152: 
 153:     Oriented i;
 154:     i.light = a_i_light;
 155: i.color = a_i_color;
 156: i.pos = a_i_pos;
 157: i.pivot = a_i_pivot;
 158: i.rotation = a_i_rotation;
 159: 
 160: 
 161:     BlockFrag o = FLWMain(v, i);
 162: 
 163:     v2f_texCoords = o.texCoords;
 164: v2f_color = o.color;
 165: v2f_diffuse = o.diffuse;
 166: v2f_light = o.light;
 167: 
 168: }

[14:02:49] [main/ERROR]: Shader compilation log for flywheel:block.frag: No errors.

[14:02:49] [main/ERROR]: Source for shader 'flywheel:block.frag':
   1: #version 110
   2: #define USE_FOG
   3: #define USE_FOG_LINEAR
   4: 
   5: #if defined(USE_FOG)
   6: varying float FragDistance;
   7: uniform vec4 uFogColor;
   8: #endif
   9: 
  10: #if defined(USE_FOG_LINEAR)
  11: uniform vec2 uFogRange;
  12: 
  13: float FLWFogFactor() {
  14:     return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
  15: }
  16:     #endif
  17: 
  18:     #if defined(USE_FOG_EXP2)
  19: uniform float uFogDensity;
  20: 
  21: float FLWFogFactor() {
  22:     float dist = FragDistance * uFogDensity;
  23:     return 1. / exp2(dist * dist);
  24: }
  25:     #endif
  26: // Adjust the [0,1] normalized lightmap value based on the texture matrix from LightTexture#enableLightmap
  27: vec2 shiftLight(vec2 lm) {
  28:     return lm * 0.99609375 + 0.03125;// * 255/256 + 1/32
  29: }
  30: 
  31: uniform sampler2D uBlockAtlas;
  32: uniform sampler2D uLightMap;
  33: 
  34: vec4 FLWBlockTexture(vec2 texCoords) {
  35:     return texture2D(uBlockAtlas, texCoords);
  36: }
  37: 
  38: void FLWFinalizeColor(vec4 color) {
  39:     #if defined(USE_FOG)
  40:     float a = color.a;
  41:     float fog = clamp(FLWFogFactor(), 0., 1.);
  42: 
  43:     color = mix(uFogColor, color, fog);
  44:     color.a = a;
  45:     #endif
  46: 
  47:     gl_FragColor = color;
  48: }
  49: 
  50: vec4 FLWLight(vec2 lightCoords) {
  51:     return texture2D(uLightMap, shiftLight(lightCoords));
  52: }
  53: 
  54: 
  55: 
  56: struct BlockFrag {
  57:     vec2 texCoords;
  58:     vec4 color;
  59:     float diffuse;
  60:     vec2 light;
  61: };
  62: 
  63: void FLWMain(BlockFrag r) {
  64:     vec4 tex = FLWBlockTexture(r.texCoords);
  65: 
  66:     vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;
  67: 
  68: //    flw_WorldPos = ;
  69: //    flw_Normal = ;
  70: //    flw_Albedo = tex.rgb;
  71: //    flw_Alpha = tex.a;
  72: //    flw_LightMap = r.light;
  73: //    flw_Tint = r.color;
  74:     FLWFinalizeColor(color);
  75: }
  76: 
  77: varying vec2 v2f_texCoords;
  78: varying vec4 v2f_color;
  79: varying float v2f_diffuse;
  80: varying vec2 v2f_light;
  81: 
  82: 
  83: //vec3 flw_WorldPos;
  84: //vec3 flw_Normal;
  85: //vec3 flw_Albedo;
  86: //float flw_Alpha;
  87: //vec2 flw_LightMap;
  88: //vec4 flw_Tint;
  89: 
  90: void main() {
  91:     BlockFrag f;
  92:     f.texCoords = v2f_texCoords;
  93: f.color = v2f_color;
  94: f.diffuse = v2f_diffuse;
  95: f.light = v2f_light;
  96: 
  97: 
  98:     FLWMain(f);
  99: }

[14:02:49] [main/ERROR]: Shader compilation log for flywheel:oriented.vert: No errors.

[14:02:49] [main/ERROR]: Source for shader 'flywheel:oriented.vert':
   1: #version 110
   2: #define USE_FOG
   3: #define USE_FOG_EXP2
   4: 
   5: uniform float uTime;
   6: uniform mat4 uViewProjection;
   7: uniform vec3 uCameraPos;
   8: 
   9: #if defined(USE_FOG)
  10: varying float FragDistance;
  11: #endif
  12: 
  13: void FLWFinalizeWorldPos(inout vec4 worldPos) {
  14:     #if defined(USE_FOG)
  15:     FragDistance = length(worldPos.xyz - uCameraPos);
  16:     #endif
  17: 
  18:     gl_Position = uViewProjection * worldPos;
  19: }
  20: 
  21: void FLWFinalizeNormal(inout vec3 normal) {
  22:     // noop
  23: }
  24: 
  25: 
  26: mat4 rotate(vec3 axis, float angle) {
  27:     float s = sin(angle);
  28:     float c = cos(angle);
  29:     float oc = 1. - c;
  30: 
  31:     vec3 sa = axis * s;
  32: 
  33:     mat4 mr = mat4(1.);
  34:     mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
  35:     mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
  36:     mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);
  37: 
  38:     return mr;
  39: }
  40: 
  41: mat4 rotation(vec3 rot) {
  42:     return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
  43: }
  44: 
  45: mat3 modelToNormal(mat4 mat) {
  46:     // Discard the edges. This won't be accurate for scaled or skewed matrices,
  47:     // but we don't have to work with those often.
  48:     mat3 m;
  49:     m[0] = mat[0].xyz;
  50:     m[1] = mat[1].xyz;
  51:     m[2] = mat[2].xyz;
  52:     return m;
  53: }
  54: 
  55: #define PIOVER2 1.5707963268
  56: 
  57: vec4 quat(vec3 axis, float angle) {
  58:     float halfAngle = angle * PIOVER2 / 180.0;
  59:     vec2 cs = sin(vec2(PIOVER2 - halfAngle, halfAngle)); // compute sin and cos in one instruction
  60:     return vec4(axis.xyz * cs.y,  cs.x);
  61: }
  62: 
  63: vec4 quatMult(vec4 q1, vec4 q2) {
  64:     // disgustingly vectorized quaternion multiplication
  65:     vec4 a = q1.w * q2.xyzw;
  66:     vec4 b = q1.x * q2.wzxy * vec4(1., -1., 1., -1.);
  67:     vec4 c = q1.y * q2.zwxy * vec4(1., 1., -1., -1.);
  68:     vec4 d = q1.z * q2.yxwz * vec4(-1., 1., 1., -1.);
  69: 
  70:     return a + b + c + d;
  71: }
  72: 
  73: vec3 rotateVertexByQuat(vec3 v, vec4 q) {
  74:     vec3 i = q.xyz;
  75:     return v + 2.0 * cross(i, cross(i, v) + q.w * v);
  76: }
  77: 
  78: vec3 rotateAbout(vec3 v, vec3 axis, float angle) {
  79:     return rotateVertexByQuat(v, quat(axis, angle));
  80: }
  81: 
  82: float diffuse(vec3 normal) {
  83:     vec3 n2 = normal * normal * vec3(.6, .25, .8);
  84:     return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
  85: }
  86: 
  87: 
  88: struct Oriented {
  89:     vec2 light;
  90:     vec4 color;
  91:     vec3 pos;
  92:     vec3 pivot;
  93:     vec4 rotation;
  94: };
  95: 
  96: 
  97: struct Vertex {
  98:     vec3 pos;
  99:     vec3 normal;
 100:     vec2 texCoords;
 101: };
 102: 
 103: struct BlockFrag {
 104:     vec2 texCoords;
 105:     vec4 color;
 106:     float diffuse;
 107:     vec2 light;
 108: };
 109: 
 110: BlockFrag FLWMain(Vertex v, Oriented o) {
 111:     vec4 worldPos = vec4(rotateVertexByQuat(v.pos - o.pivot, o.rotation) + o.pivot + o.pos, 1.);
 112: 
 113:     vec3 norm = rotateVertexByQuat(v.normal, o.rotation);
 114: 
 115:     FLWFinalizeWorldPos(worldPos);
 116:     FLWFinalizeNormal(norm);
 117: 
 118:     BlockFrag b;
 119:     b.diffuse = diffuse(norm);
 120:     b.texCoords = v.texCoords;
 121:     b.light = o.light;
 122:     #if defined(DEBUG_NORMAL)
 123:     b.color = vec4(norm, 1.);
 124:     #else
 125:     b.color = o.color;
 126:     #endif
 127:     return b;
 128: }
 129: attribute vec3 a_v_pos;
 130: attribute vec3 a_v_normal;
 131: attribute vec2 a_v_texCoords;
 132: 
 133: attribute vec2 a_i_light;
 134: attribute vec4 a_i_color;
 135: attribute vec3 a_i_pos;
 136: attribute vec3 a_i_pivot;
 137: attribute vec4 a_i_rotation;
 138: 
 139: 
 140: varying vec2 v2f_texCoords;
 141: varying vec4 v2f_color;
 142: varying float v2f_diffuse;
 143: varying vec2 v2f_light;
 144: 
 145: 
 146: void main() {
 147:     Vertex v;
 148:     v.pos = a_v_pos;
 149: v.normal = a_v_normal;
 150: v.texCoords = a_v_texCoords;
 151: 
 152: 
 153:     Oriented i;
 154:     i.light = a_i_light;
 155: i.color = a_i_color;
 156: i.pos = a_i_pos;
 157: i.pivot = a_i_pivot;
 158: i.rotation = a_i_rotation;
 159: 
 160: 
 161:     BlockFrag o = FLWMain(v, i);
 162: 
 163:     v2f_texCoords = o.texCoords;
 164: v2f_color = o.color;
 165: v2f_diffuse = o.diffuse;
 166: v2f_light = o.light;
 167: 
 168: }

[14:02:49] [main/ERROR]: Shader compilation log for flywheel:block.frag: No errors.

[14:02:49] [main/ERROR]: Source for shader 'flywheel:block.frag':
   1: #version 110
   2: #define USE_FOG
   3: #define USE_FOG_EXP2
   4: 
   5: #if defined(USE_FOG)
   6: varying float FragDistance;
   7: uniform vec4 uFogColor;
   8: #endif
   9: 
  10: #if defined(USE_FOG_LINEAR)
  11: uniform vec2 uFogRange;
  12: 
  13: float FLWFogFactor() {
  14:     return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
  15: }
  16:     #endif
  17: 
  18:     #if defined(USE_FOG_EXP2)
  19: uniform float uFogDensity;
  20: 
  21: float FLWFogFactor() {
  22:     float dist = FragDistance * uFogDensity;
  23:     return 1. / exp2(dist * dist);
  24: }
  25:     #endif
  26: // Adjust the [0,1] normalized lightmap value based on the texture matrix from LightTexture#enableLightmap
  27: vec2 shiftLight(vec2 lm) {
  28:     return lm * 0.99609375 + 0.03125;// * 255/256 + 1/32
  29: }
  30: 
  31: uniform sampler2D uBlockAtlas;
  32: uniform sampler2D uLightMap;
  33: 
  34: vec4 FLWBlockTexture(vec2 texCoords) {
  35:     return texture2D(uBlockAtlas, texCoords);
  36: }
  37: 
  38: void FLWFinalizeColor(vec4 color) {
  39:     #if defined(USE_FOG)
  40:     float a = color.a;
  41:     float fog = clamp(FLWFogFactor(), 0., 1.);
  42: 
  43:     color = mix(uFogColor, color, fog);
  44:     color.a = a;
  45:     #endif
  46: 
  47:     gl_FragColor = color;
  48: }
  49: 
  50: vec4 FLWLight(vec2 lightCoords) {
  51:     return texture2D(uLightMap, shiftLight(lightCoords));
  52: }
  53: 
  54: 
  55: 
  56: struct BlockFrag {
  57:     vec2 texCoords;
  58:     vec4 color;
  59:     float diffuse;
  60:     vec2 light;
  61: };
  62: 
  63: void FLWMain(BlockFrag r) {
  64:     vec4 tex = FLWBlockTexture(r.texCoords);
  65: 
  66:     vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;
  67: 
  68: //    flw_WorldPos = ;
  69: //    flw_Normal = ;
  70: //    flw_Albedo = tex.rgb;
  71: //    flw_Alpha = tex.a;
  72: //    flw_LightMap = r.light;
  73: //    flw_Tint = r.color;
  74:     FLWFinalizeColor(color);
  75: }
  76: 
  77: varying vec2 v2f_texCoords;
  78: varying vec4 v2f_color;
  79: varying float v2f_diffuse;
  80: varying vec2 v2f_light;
  81: 
  82: 
  83: //vec3 flw_WorldPos;
  84: //vec3 flw_Normal;
  85: //vec3 flw_Albedo;
  86: //float flw_Alpha;
  87: //vec2 flw_LightMap;
  88: //vec4 flw_Tint;
  89: 
  90: void main() {
  91:     BlockFrag f;
  92:     f.texCoords = v2f_texCoords;
  93: f.color = v2f_color;
  94: f.diffuse = v2f_diffuse;
  95: f.light = v2f_light;
  96: 
  97: 
  98:     FLWMain(f);
  99: }

[14:02:49] [main/ERROR]: Shader compilation log for flywheel:oriented.vert: No errors.

[14:02:49] [main/ERROR]: Source for shader 'flywheel:oriented.vert':
   1: #version 110
   2: 
   3: uniform float uTime;
   4: uniform mat4 uViewProjection;
   5: uniform vec3 uCameraPos;
   6: 
   7: #if defined(USE_FOG)
   8: varying float FragDistance;
   9: #endif
  10: 
  11: void FLWFinalizeWorldPos(inout vec4 worldPos) {
  12:     #if defined(USE_FOG)
  13:     FragDistance = length(worldPos.xyz - uCameraPos);
  14:     #endif
  15: 
  16:     gl_Position = uViewProjection * worldPos;
  17: }
  18: 
  19: void FLWFinalizeNormal(inout vec3 normal) {
  20:     // noop
  21: }
  22: 
  23: 
  24: mat4 rotate(vec3 axis, float angle) {
  25:     float s = sin(angle);
  26:     float c = cos(angle);
  27:     float oc = 1. - c;
  28: 
  29:     vec3 sa = axis * s;
  30: 
  31:     mat4 mr = mat4(1.);
  32:     mr[0].xyz = oc * axis.xxz * axis.xyx + vec3(c, sa.z, -sa.y);
  33:     mr[1].xyz = oc * axis.xyy * axis.yyz + vec3(-sa.z, c, sa.x);
  34:     mr[2].xyz = oc * axis.zyz * axis.xzz + vec3(sa.y, -sa.x, c);
  35: 
  36:     return mr;
  37: }
  38: 
  39: mat4 rotation(vec3 rot) {
  40:     return rotate(vec3(0., 1., 0.), rot.y) * rotate(vec3(0., 0., 1.), rot.z) * rotate(vec3(1., 0., 0.), rot.x);
  41: }
  42: 
  43: mat3 modelToNormal(mat4 mat) {
  44:     // Discard the edges. This won't be accurate for scaled or skewed matrices,
  45:     // but we don't have to work with those often.
  46:     mat3 m;
  47:     m[0] = mat[0].xyz;
  48:     m[1] = mat[1].xyz;
  49:     m[2] = mat[2].xyz;
  50:     return m;
  51: }
  52: 
  53: #define PIOVER2 1.5707963268
  54: 
  55: vec4 quat(vec3 axis, float angle) {
  56:     float halfAngle = angle * PIOVER2 / 180.0;
  57:     vec2 cs = sin(vec2(PIOVER2 - halfAngle, halfAngle)); // compute sin and cos in one instruction
  58:     return vec4(axis.xyz * cs.y,  cs.x);
  59: }
  60: 
  61: vec4 quatMult(vec4 q1, vec4 q2) {
  62:     // disgustingly vectorized quaternion multiplication
  63:     vec4 a = q1.w * q2.xyzw;
  64:     vec4 b = q1.x * q2.wzxy * vec4(1., -1., 1., -1.);
  65:     vec4 c = q1.y * q2.zwxy * vec4(1., 1., -1., -1.);
  66:     vec4 d = q1.z * q2.yxwz * vec4(-1., 1., 1., -1.);
  67: 
  68:     return a + b + c + d;
  69: }
  70: 
  71: vec3 rotateVertexByQuat(vec3 v, vec4 q) {
  72:     vec3 i = q.xyz;
  73:     return v + 2.0 * cross(i, cross(i, v) + q.w * v);
  74: }
  75: 
  76: vec3 rotateAbout(vec3 v, vec3 axis, float angle) {
  77:     return rotateVertexByQuat(v, quat(axis, angle));
  78: }
  79: 
  80: float diffuse(vec3 normal) {
  81:     vec3 n2 = normal * normal * vec3(.6, .25, .8);
  82:     return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
  83: }
  84: 
  85: 
  86: struct Oriented {
  87:     vec2 light;
  88:     vec4 color;
  89:     vec3 pos;
  90:     vec3 pivot;
  91:     vec4 rotation;
  92: };
  93: 
  94: 
  95: struct Vertex {
  96:     vec3 pos;
  97:     vec3 normal;
  98:     vec2 texCoords;
  99: };
 100: 
 101: struct BlockFrag {
 102:     vec2 texCoords;
 103:     vec4 color;
 104:     float diffuse;
 105:     vec2 light;
 106: };
 107: 
 108: BlockFrag FLWMain(Vertex v, Oriented o) {
 109:     vec4 worldPos = vec4(rotateVertexByQuat(v.pos - o.pivot, o.rotation) + o.pivot + o.pos, 1.);
 110: 
 111:     vec3 norm = rotateVertexByQuat(v.normal, o.rotation);
 112: 
 113:     FLWFinalizeWorldPos(worldPos);
 114:     FLWFinalizeNormal(norm);
 115: 
 116:     BlockFrag b;
 117:     b.diffuse = diffuse(norm);
 118:     b.texCoords = v.texCoords;
 119:     b.light = o.light;
 120:     #if defined(DEBUG_NORMAL)
 121:     b.color = vec4(norm, 1.);
 122:     #else
 123:     b.color = o.color;
 124:     #endif
 125:     return b;
 126: }
 127: attribute vec3 a_v_pos;
 128: attribute vec3 a_v_normal;
 129: attribute vec2 a_v_texCoords;
 130: 
 131: attribute vec2 a_i_light;
 132: attribute vec4 a_i_color;
 133: attribute vec3 a_i_pos;
 134: attribute vec3 a_i_pivot;
 135: attribute vec4 a_i_rotation;
 136: 
 137: 
 138: varying vec2 v2f_texCoords;
 139: varying vec4 v2f_color;
 140: varying float v2f_diffuse;
 141: varying vec2 v2f_light;
 142: 
 143: 
 144: void main() {
 145:     Vertex v;
 146:     v.pos = a_v_pos;
 147: v.normal = a_v_normal;
 148: v.texCoords = a_v_texCoords;
 149: 
 150: 
 151:     Oriented i;
 152:     i.light = a_i_light;
 153: i.color = a_i_color;
 154: i.pos = a_i_pos;
 155: i.pivot = a_i_pivot;
 156: i.rotation = a_i_rotation;
 157: 
 158: 
 159:     BlockFrag o = FLWMain(v, i);
 160: 
 161:     v2f_texCoords = o.texCoords;
 162: v2f_color = o.color;
 163: v2f_diffuse = o.diffuse;
 164: v2f_light = o.light;
 165: 
 166: }

[14:02:49] [main/ERROR]: Shader compilation log for flywheel:block.frag: No errors.

[14:02:49] [main/ERROR]: Source for shader 'flywheel:block.frag':
   1: #version 110
   2: 
   3: #if defined(USE_FOG)
   4: varying float FragDistance;
   5: uniform vec4 uFogColor;
   6: #endif
   7: 
   8: #if defined(USE_FOG_LINEAR)
   9: uniform vec2 uFogRange;
  10: 
  11: float FLWFogFactor() {
  12:     return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
  13: }
  14:     #endif
  15: 
  16:     #if defined(USE_FOG_EXP2)
  17: uniform float uFogDensity;
  18: 
  19: float FLWFogFactor() {
  20:     float dist = FragDistance * uFogDensity;
  21:     return 1. / exp2(dist * dist);
  22: }
  23:     #endif
  24: // Adjust the [0,1] normalized lightmap value based on the texture matrix from LightTexture#enableLightmap
  25: vec2 shiftLight(vec2 lm) {
  26:     return lm * 0.99609375 + 0.03125;// * 255/256 + 1/32
  27: }
  28: 
  29: uniform sampler2D uBlockAtlas;
  30: uniform sampler2D uLightMap;
  31: 
  32: vec4 FLWBlockTexture(vec2 texCoords) {
  33:     return texture2D(uBlockAtlas, texCoords);
  34: }
  35: 
  36: void FLWFinalizeColor(vec4 color) {
  37:     #if defined(USE_FOG)
  38:     float a = color.a;
  39:     float fog = clamp(FLWFogFactor(), 0., 1.);
  40: 
  41:     color = mix(uFogColor, color, fog);
  42:     color.a = a;
  43:     #endif
  44: 
  45:     gl_FragColor = color;
  46: }
  47: 
  48: vec4 FLWLight(vec2 lightCoords) {
  49:     return texture2D(uLightMap, shiftLight(lightCoords));
  50: }
  51: 
  52: 
  53: 
  54: struct BlockFrag {
  55:     vec2 texCoords;
  56:     vec4 color;
  57:     float diffuse;
  58:     vec2 light;
  59: };
  60: 
  61: void FLWMain(BlockFrag r) {
  62:     vec4 tex = FLWBlockTexture(r.texCoords);
  63: 
  64:     vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;
  65: 
  66: //    flw_WorldPos = ;
  67: //    flw_Normal = ;
  68: //    flw_Albedo = tex.rgb;
  69: //    flw_Alpha = tex.a;
  70: //    flw_LightMap = r.light;
  71: //    flw_Tint = r.color;
  72:     FLWFinalizeColor(color);
  73: }
  74: 
  75: varying vec2 v2f_texCoords;
  76: varying vec4 v2f_color;
  77: varying float v2f_diffuse;
  78: varying vec2 v2f_light;
  79: 
  80: 
  81: //vec3 flw_WorldPos;
  82: //vec3 flw_Normal;
  83: //vec3 flw_Albedo;
  84: //float flw_Alpha;
  85: //vec2 flw_LightMap;
  86: //vec4 flw_Tint;
  87: 
  88: void main() {
  89:     BlockFrag f;
  90:     f.texCoords = v2f_texCoords;
  91: f.color = v2f_color;
  92: f.diffuse = v2f_diffuse;
  93: f.light = v2f_light;
  94: 
  95: 
  96:     FLWMain(f);
  97: }

[14:02:49] [main/ERROR]: Shader compilation log for flywheel:model.vert: No errors.

[14:02:49] [main/ERROR]: Source for shader 'flywheel:model.vert':
   1: #version 110
   2: #define DEBUG_NORMAL
   3: 
   4: uniform float uTime;
   5: uniform mat4 uViewProjection;
   6: uniform vec3 uCameraPos;
   7: 
   8: #if defined(USE_FOG)
   9: varying float FragDistance;
  10: #endif
  11: 
  12: void FLWFinalizeWorldPos(inout vec4 worldPos) {
  13:     #if defined(USE_FOG)
  14:     FragDistance = length(worldPos.xyz - uCameraPos);
  15:     #endif
  16: 
  17:     gl_Position = uViewProjection * worldPos;
  18: }
  19: 
  20: void FLWFinalizeNormal(inout vec3 normal) {
  21:     // noop
  22: }
  23: 
  24: 
  25: float diffuse(vec3 normal) {
  26:     vec3 n2 = normal * normal * vec3(.6, .25, .8);
  27:     return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
  28: }
  29: 
  30: 
  31: struct Vertex {
  32:     vec3 pos;
  33:     vec3 normal;
  34:     vec2 texCoords;
  35: };
  36: 
  37: struct BlockFrag {
  38:     vec2 texCoords;
  39:     vec4 color;
  40:     float diffuse;
  41:     vec2 light;
  42: };
  43: 
  44: 
  45: struct Instance {
  46:     vec2 light;
  47:     vec4 color;
  48:     mat4 transform;
  49:     mat3 normalMat;
  50: };
  51: 
  52: BlockFrag FLWMain(Vertex v, Instance i) {
  53:     vec4 worldPos = i.transform * vec4(v.pos, 1.);
  54: 
  55:     vec3 norm = i.normalMat * v.normal;
  56: 
  57:     FLWFinalizeWorldPos(worldPos);
  58:     FLWFinalizeNormal(norm);
  59: 
  60:     norm = normalize(norm);
  61: 
  62:     BlockFrag b;
  63:     b.diffuse = diffuse(norm);
  64:     b.texCoords = v.texCoords;
  65:     b.light = i.light;
  66:     #if defined(DEBUG_NORMAL)
  67:     b.color = vec4(norm, 1.);
  68:     #else
  69:     b.color = i.color;
  70:     #endif
  71:     return b;
  72: }
  73: attribute vec3 a_v_pos;
  74: attribute vec3 a_v_normal;
  75: attribute vec2 a_v_texCoords;
  76: 
  77: attribute vec2 a_i_light;
  78: attribute vec4 a_i_color;
  79: attribute mat4 a_i_transform;
  80: attribute mat3 a_i_normalMat;
  81: 
  82: 
  83: varying vec2 v2f_texCoords;
  84: varying vec4 v2f_color;
  85: varying float v2f_diffuse;
  86: varying vec2 v2f_light;
  87: 
  88: 
  89: void main() {
  90:     Vertex v;
  91:     v.pos = a_v_pos;
  92: v.normal = a_v_normal;
  93: v.texCoords = a_v_texCoords;
  94: 
  95: 
  96:     Instance i;
  97:     i.light = a_i_light;
  98: i.color = a_i_color;
  99: i.transform = a_i_transform;
 100: i.normalMat = a_i_normalMat;
 101: 
 102: 
 103:     BlockFrag o = FLWMain(v, i);
 104: 
 105:     v2f_texCoords = o.texCoords;
 106: v2f_color = o.color;
 107: v2f_diffuse = o.diffuse;
 108: v2f_light = o.light;
 109: 
 110: }

[14:02:49] [main/ERROR]: Shader compilation log for flywheel:block.frag: No errors.

[14:02:49] [main/ERROR]: Source for shader 'flywheel:block.frag':
   1: #version 110
   2: #define DEBUG_NORMAL
   3: 
   4: #if defined(USE_FOG)
   5: varying float FragDistance;
   6: uniform vec4 uFogColor;
   7: #endif
   8: 
   9: #if defined(USE_FOG_LINEAR)
  10: uniform vec2 uFogRange;
  11: 
  12: float FLWFogFactor() {
  13:     return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
  14: }
  15:     #endif
  16: 
  17:     #if defined(USE_FOG_EXP2)
  18: uniform float uFogDensity;
  19: 
  20: float FLWFogFactor() {
  21:     float dist = FragDistance * uFogDensity;
  22:     return 1. / exp2(dist * dist);
  23: }
  24:     #endif
  25: // Adjust the [0,1] normalized lightmap value based on the texture matrix from LightTexture#enableLightmap
  26: vec2 shiftLight(vec2 lm) {
  27:     return lm * 0.99609375 + 0.03125;// * 255/256 + 1/32
  28: }
  29: 
  30: uniform sampler2D uBlockAtlas;
  31: uniform sampler2D uLightMap;
  32: 
  33: vec4 FLWBlockTexture(vec2 texCoords) {
  34:     return texture2D(uBlockAtlas, texCoords);
  35: }
  36: 
  37: void FLWFinalizeColor(vec4 color) {
  38:     #if defined(USE_FOG)
  39:     float a = color.a;
  40:     float fog = clamp(FLWFogFactor(), 0., 1.);
  41: 
  42:     color = mix(uFogColor, color, fog);
  43:     color.a = a;
  44:     #endif
  45: 
  46:     gl_FragColor = color;
  47: }
  48: 
  49: vec4 FLWLight(vec2 lightCoords) {
  50:     return texture2D(uLightMap, shiftLight(lightCoords));
  51: }
  52: 
  53: 
  54: 
  55: struct BlockFrag {
  56:     vec2 texCoords;
  57:     vec4 color;
  58:     float diffuse;
  59:     vec2 light;
  60: };
  61: 
  62: void FLWMain(BlockFrag r) {
  63:     vec4 tex = FLWBlockTexture(r.texCoords);
  64: 
  65:     vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;
  66: 
  67: //    flw_WorldPos = ;
  68: //    flw_Normal = ;
  69: //    flw_Albedo = tex.rgb;
  70: //    flw_Alpha = tex.a;
  71: //    flw_LightMap = r.light;
  72: //    flw_Tint = r.color;
  73:     FLWFinalizeColor(color);
  74: }
  75: 
  76: varying vec2 v2f_texCoords;
  77: varying vec4 v2f_color;
  78: varying float v2f_diffuse;
  79: varying vec2 v2f_light;
  80: 
  81: 
  82: //vec3 flw_WorldPos;
  83: //vec3 flw_Normal;
  84: //vec3 flw_Albedo;
  85: //float flw_Alpha;
  86: //vec2 flw_LightMap;
  87: //vec4 flw_Tint;
  88: 
  89: void main() {
  90:     BlockFrag f;
  91:     f.texCoords = v2f_texCoords;
  92: f.color = v2f_color;
  93: f.diffuse = v2f_diffuse;
  94: f.light = v2f_light;
  95: 
  96: 
  97:     FLWMain(f);
  98: }

[14:02:49] [main/ERROR]: Shader compilation log for flywheel:model.vert: No errors.

[14:02:49] [main/ERROR]: Source for shader 'flywheel:model.vert':
   1: #version 110
   2: #define USE_FOG
   3: #define USE_FOG_LINEAR
   4: 
   5: uniform float uTime;
   6: uniform mat4 uViewProjection;
   7: uniform vec3 uCameraPos;
   8: 
   9: #if defined(USE_FOG)
  10: varying float FragDistance;
  11: #endif
  12: 
  13: void FLWFinalizeWorldPos(inout vec4 worldPos) {
  14:     #if defined(USE_FOG)
  15:     FragDistance = length(worldPos.xyz - uCameraPos);
  16:     #endif
  17: 
  18:     gl_Position = uViewProjection * worldPos;
  19: }
  20: 
  21: void FLWFinalizeNormal(inout vec3 normal) {
  22:     // noop
  23: }
  24: 
  25: 
  26: float diffuse(vec3 normal) {
  27:     vec3 n2 = normal * normal * vec3(.6, .25, .8);
  28:     return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
  29: }
  30: 
  31: 
  32: struct Vertex {
  33:     vec3 pos;
  34:     vec3 normal;
  35:     vec2 texCoords;
  36: };
  37: 
  38: struct BlockFrag {
  39:     vec2 texCoords;
  40:     vec4 color;
  41:     float diffuse;
  42:     vec2 light;
  43: };
  44: 
  45: 
  46: struct Instance {
  47:     vec2 light;
  48:     vec4 color;
  49:     mat4 transform;
  50:     mat3 normalMat;
  51: };
  52: 
  53: BlockFrag FLWMain(Vertex v, Instance i) {
  54:     vec4 worldPos = i.transform * vec4(v.pos, 1.);
  55: 
  56:     vec3 norm = i.normalMat * v.normal;
  57: 
  58:     FLWFinalizeWorldPos(worldPos);
  59:     FLWFinalizeNormal(norm);
  60: 
  61:     norm = normalize(norm);
  62: 
  63:     BlockFrag b;
  64:     b.diffuse = diffuse(norm);
  65:     b.texCoords = v.texCoords;
  66:     b.light = i.light;
  67:     #if defined(DEBUG_NORMAL)
  68:     b.color = vec4(norm, 1.);
  69:     #else
  70:     b.color = i.color;
  71:     #endif
  72:     return b;
  73: }
  74: attribute vec3 a_v_pos;
  75: attribute vec3 a_v_normal;
  76: attribute vec2 a_v_texCoords;
  77: 
  78: attribute vec2 a_i_light;
  79: attribute vec4 a_i_color;
  80: attribute mat4 a_i_transform;
  81: attribute mat3 a_i_normalMat;
  82: 
  83: 
  84: varying vec2 v2f_texCoords;
  85: varying vec4 v2f_color;
  86: varying float v2f_diffuse;
  87: varying vec2 v2f_light;
  88: 
  89: 
  90: void main() {
  91:     Vertex v;
  92:     v.pos = a_v_pos;
  93: v.normal = a_v_normal;
  94: v.texCoords = a_v_texCoords;
  95: 
  96: 
  97:     Instance i;
  98:     i.light = a_i_light;
  99: i.color = a_i_color;
 100: i.transform = a_i_transform;
 101: i.normalMat = a_i_normalMat;
 102: 
 103: 
 104:     BlockFrag o = FLWMain(v, i);
 105: 
 106:     v2f_texCoords = o.texCoords;
 107: v2f_color = o.color;
 108: v2f_diffuse = o.diffuse;
 109: v2f_light = o.light;
 110: 
 111: }

[14:02:49] [main/ERROR]: Shader compilation log for flywheel:block.frag: No errors.

[14:02:49] [main/ERROR]: Source for shader 'flywheel:block.frag':
   1: #version 110
   2: #define USE_FOG
   3: #define USE_FOG_LINEAR
   4: 
   5: #if defined(USE_FOG)
   6: varying float FragDistance;
   7: uniform vec4 uFogColor;
   8: #endif
   9: 
  10: #if defined(USE_FOG_LINEAR)
  11: uniform vec2 uFogRange;
  12: 
  13: float FLWFogFactor() {
  14:     return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
  15: }
  16:     #endif
  17: 
  18:     #if defined(USE_FOG_EXP2)
  19: uniform float uFogDensity;
  20: 
  21: float FLWFogFactor() {
  22:     float dist = FragDistance * uFogDensity;
  23:     return 1. / exp2(dist * dist);
  24: }
  25:     #endif
  26: // Adjust the [0,1] normalized lightmap value based on the texture matrix from LightTexture#enableLightmap
  27: vec2 shiftLight(vec2 lm) {
  28:     return lm * 0.99609375 + 0.03125;// * 255/256 + 1/32
  29: }
  30: 
  31: uniform sampler2D uBlockAtlas;
  32: uniform sampler2D uLightMap;
  33: 
  34: vec4 FLWBlockTexture(vec2 texCoords) {
  35:     return texture2D(uBlockAtlas, texCoords);
  36: }
  37: 
  38: void FLWFinalizeColor(vec4 color) {
  39:     #if defined(USE_FOG)
  40:     float a = color.a;
  41:     float fog = clamp(FLWFogFactor(), 0., 1.);
  42: 
  43:     color = mix(uFogColor, color, fog);
  44:     color.a = a;
  45:     #endif
  46: 
  47:     gl_FragColor = color;
  48: }
  49: 
  50: vec4 FLWLight(vec2 lightCoords) {
  51:     return texture2D(uLightMap, shiftLight(lightCoords));
  52: }
  53: 
  54: 
  55: 
  56: struct BlockFrag {
  57:     vec2 texCoords;
  58:     vec4 color;
  59:     float diffuse;
  60:     vec2 light;
  61: };
  62: 
  63: void FLWMain(BlockFrag r) {
  64:     vec4 tex = FLWBlockTexture(r.texCoords);
  65: 
  66:     vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;
  67: 
  68: //    flw_WorldPos = ;
  69: //    flw_Normal = ;
  70: //    flw_Albedo = tex.rgb;
  71: //    flw_Alpha = tex.a;
  72: //    flw_LightMap = r.light;
  73: //    flw_Tint = r.color;
  74:     FLWFinalizeColor(color);
  75: }
  76: 
  77: varying vec2 v2f_texCoords;
  78: varying vec4 v2f_color;
  79: varying float v2f_diffuse;
  80: varying vec2 v2f_light;
  81: 
  82: 
  83: //vec3 flw_WorldPos;
  84: //vec3 flw_Normal;
  85: //vec3 flw_Albedo;
  86: //float flw_Alpha;
  87: //vec2 flw_LightMap;
  88: //vec4 flw_Tint;
  89: 
  90: void main() {
  91:     BlockFrag f;
  92:     f.texCoords = v2f_texCoords;
  93: f.color = v2f_color;
  94: f.diffuse = v2f_diffuse;
  95: f.light = v2f_light;
  96: 
  97: 
  98:     FLWMain(f);
  99: }

[14:02:50] [main/ERROR]: Shader compilation log for flywheel:model.vert: No errors.

[14:02:50] [main/ERROR]: Source for shader 'flywheel:model.vert':
   1: #version 110
   2: #define USE_FOG
   3: #define USE_FOG_EXP2
   4: 
   5: uniform float uTime;
   6: uniform mat4 uViewProjection;
   7: uniform vec3 uCameraPos;
   8: 
   9: #if defined(USE_FOG)
  10: varying float FragDistance;
  11: #endif
  12: 
  13: void FLWFinalizeWorldPos(inout vec4 worldPos) {
  14:     #if defined(USE_FOG)
  15:     FragDistance = length(worldPos.xyz - uCameraPos);
  16:     #endif
  17: 
  18:     gl_Position = uViewProjection * worldPos;
  19: }
  20: 
  21: void FLWFinalizeNormal(inout vec3 normal) {
  22:     // noop
  23: }
  24: 
  25: 
  26: float diffuse(vec3 normal) {
  27:     vec3 n2 = normal * normal * vec3(.6, .25, .8);
  28:     return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
  29: }
  30: 
  31: 
  32: struct Vertex {
  33:     vec3 pos;
  34:     vec3 normal;
  35:     vec2 texCoords;
  36: };
  37: 
  38: struct BlockFrag {
  39:     vec2 texCoords;
  40:     vec4 color;
  41:     float diffuse;
  42:     vec2 light;
  43: };
  44: 
  45: 
  46: struct Instance {
  47:     vec2 light;
  48:     vec4 color;
  49:     mat4 transform;
  50:     mat3 normalMat;
  51: };
  52: 
  53: BlockFrag FLWMain(Vertex v, Instance i) {
  54:     vec4 worldPos = i.transform * vec4(v.pos, 1.);
  55: 
  56:     vec3 norm = i.normalMat * v.normal;
  57: 
  58:     FLWFinalizeWorldPos(worldPos);
  59:     FLWFinalizeNormal(norm);
  60: 
  61:     norm = normalize(norm);
  62: 
  63:     BlockFrag b;
  64:     b.diffuse = diffuse(norm);
  65:     b.texCoords = v.texCoords;
  66:     b.light = i.light;
  67:     #if defined(DEBUG_NORMAL)
  68:     b.color = vec4(norm, 1.);
  69:     #else
  70:     b.color = i.color;
  71:     #endif
  72:     return b;
  73: }
  74: attribute vec3 a_v_pos;
  75: attribute vec3 a_v_normal;
  76: attribute vec2 a_v_texCoords;
  77: 
  78: attribute vec2 a_i_light;
  79: attribute vec4 a_i_color;
  80: attribute mat4 a_i_transform;
  81: attribute mat3 a_i_normalMat;
  82: 
  83: 
  84: varying vec2 v2f_texCoords;
  85: varying vec4 v2f_color;
  86: varying float v2f_diffuse;
  87: varying vec2 v2f_light;
  88: 
  89: 
  90: void main() {
  91:     Vertex v;
  92:     v.pos = a_v_pos;
  93: v.normal = a_v_normal;
  94: v.texCoords = a_v_texCoords;
  95: 
  96: 
  97:     Instance i;
  98:     i.light = a_i_light;
  99: i.color = a_i_color;
 100: i.transform = a_i_transform;
 101: i.normalMat = a_i_normalMat;
 102: 
 103: 
 104:     BlockFrag o = FLWMain(v, i);
 105: 
 106:     v2f_texCoords = o.texCoords;
 107: v2f_color = o.color;
 108: v2f_diffuse = o.diffuse;
 109: v2f_light = o.light;
 110: 
 111: }

[14:02:50] [main/ERROR]: Shader compilation log for flywheel:block.frag: No errors.

[14:02:50] [main/ERROR]: Source for shader 'flywheel:block.frag':
   1: #version 110
   2: #define USE_FOG
   3: #define USE_FOG_EXP2
   4: 
   5: #if defined(USE_FOG)
   6: varying float FragDistance;
   7: uniform vec4 uFogColor;
   8: #endif
   9: 
  10: #if defined(USE_FOG_LINEAR)
  11: uniform vec2 uFogRange;
  12: 
  13: float FLWFogFactor() {
  14:     return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
  15: }
  16:     #endif
  17: 
  18:     #if defined(USE_FOG_EXP2)
  19: uniform float uFogDensity;
  20: 
  21: float FLWFogFactor() {
  22:     float dist = FragDistance * uFogDensity;
  23:     return 1. / exp2(dist * dist);
  24: }
  25:     #endif
  26: // Adjust the [0,1] normalized lightmap value based on the texture matrix from LightTexture#enableLightmap
  27: vec2 shiftLight(vec2 lm) {
  28:     return lm * 0.99609375 + 0.03125;// * 255/256 + 1/32
  29: }
  30: 
  31: uniform sampler2D uBlockAtlas;
  32: uniform sampler2D uLightMap;
  33: 
  34: vec4 FLWBlockTexture(vec2 texCoords) {
  35:     return texture2D(uBlockAtlas, texCoords);
  36: }
  37: 
  38: void FLWFinalizeColor(vec4 color) {
  39:     #if defined(USE_FOG)
  40:     float a = color.a;
  41:     float fog = clamp(FLWFogFactor(), 0., 1.);
  42: 
  43:     color = mix(uFogColor, color, fog);
  44:     color.a = a;
  45:     #endif
  46: 
  47:     gl_FragColor = color;
  48: }
  49: 
  50: vec4 FLWLight(vec2 lightCoords) {
  51:     return texture2D(uLightMap, shiftLight(lightCoords));
  52: }
  53: 
  54: 
  55: 
  56: struct BlockFrag {
  57:     vec2 texCoords;
  58:     vec4 color;
  59:     float diffuse;
  60:     vec2 light;
  61: };
  62: 
  63: void FLWMain(BlockFrag r) {
  64:     vec4 tex = FLWBlockTexture(r.texCoords);
  65: 
  66:     vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;
  67: 
  68: //    flw_WorldPos = ;
  69: //    flw_Normal = ;
  70: //    flw_Albedo = tex.rgb;
  71: //    flw_Alpha = tex.a;
  72: //    flw_LightMap = r.light;
  73: //    flw_Tint = r.color;
  74:     FLWFinalizeColor(color);
  75: }
  76: 
  77: varying vec2 v2f_texCoords;
  78: varying vec4 v2f_color;
  79: varying float v2f_diffuse;
  80: varying vec2 v2f_light;
  81: 
  82: 
  83: //vec3 flw_WorldPos;
  84: //vec3 flw_Normal;
  85: //vec3 flw_Albedo;
  86: //float flw_Alpha;
  87: //vec2 flw_LightMap;
  88: //vec4 flw_Tint;
  89: 
  90: void main() {
  91:     BlockFrag f;
  92:     f.texCoords = v2f_texCoords;
  93: f.color = v2f_color;
  94: f.diffuse = v2f_diffuse;
  95: f.light = v2f_light;
  96: 
  97: 
  98:     FLWMain(f);
  99: }

[14:02:50] [main/ERROR]: Shader compilation log for flywheel:model.vert: No errors.

[14:02:50] [main/ERROR]: Source for shader 'flywheel:model.vert':
   1: #version 110
   2: 
   3: uniform float uTime;
   4: uniform mat4 uViewProjection;
   5: uniform vec3 uCameraPos;
   6: 
   7: #if defined(USE_FOG)
   8: varying float FragDistance;
   9: #endif
  10: 
  11: void FLWFinalizeWorldPos(inout vec4 worldPos) {
  12:     #if defined(USE_FOG)
  13:     FragDistance = length(worldPos.xyz - uCameraPos);
  14:     #endif
  15: 
  16:     gl_Position = uViewProjection * worldPos;
  17: }
  18: 
  19: void FLWFinalizeNormal(inout vec3 normal) {
  20:     // noop
  21: }
  22: 
  23: 
  24: float diffuse(vec3 normal) {
  25:     vec3 n2 = normal * normal * vec3(.6, .25, .8);
  26:     return min(n2.x + n2.y * (3. + normal.y) + n2.z, 1.);
  27: }
  28: 
  29: 
  30: struct Vertex {
  31:     vec3 pos;
  32:     vec3 normal;
  33:     vec2 texCoords;
  34: };
  35: 
  36: struct BlockFrag {
  37:     vec2 texCoords;
  38:     vec4 color;
  39:     float diffuse;
  40:     vec2 light;
  41: };
  42: 
  43: 
  44: struct Instance {
  45:     vec2 light;
  46:     vec4 color;
  47:     mat4 transform;
  48:     mat3 normalMat;
  49: };
  50: 
  51: BlockFrag FLWMain(Vertex v, Instance i) {
  52:     vec4 worldPos = i.transform * vec4(v.pos, 1.);
  53: 
  54:     vec3 norm = i.normalMat * v.normal;
  55: 
  56:     FLWFinalizeWorldPos(worldPos);
  57:     FLWFinalizeNormal(norm);
  58: 
  59:     norm = normalize(norm);
  60: 
  61:     BlockFrag b;
  62:     b.diffuse = diffuse(norm);
  63:     b.texCoords = v.texCoords;
  64:     b.light = i.light;
  65:     #if defined(DEBUG_NORMAL)
  66:     b.color = vec4(norm, 1.);
  67:     #else
  68:     b.color = i.color;
  69:     #endif
  70:     return b;
  71: }
  72: attribute vec3 a_v_pos;
  73: attribute vec3 a_v_normal;
  74: attribute vec2 a_v_texCoords;
  75: 
  76: attribute vec2 a_i_light;
  77: attribute vec4 a_i_color;
  78: attribute mat4 a_i_transform;
  79: attribute mat3 a_i_normalMat;
  80: 
  81: 
  82: varying vec2 v2f_texCoords;
  83: varying vec4 v2f_color;
  84: varying float v2f_diffuse;
  85: varying vec2 v2f_light;
  86: 
  87: 
  88: void main() {
  89:     Vertex v;
  90:     v.pos = a_v_pos;
  91: v.normal = a_v_normal;
  92: v.texCoords = a_v_texCoords;
  93: 
  94: 
  95:     Instance i;
  96:     i.light = a_i_light;
  97: i.color = a_i_color;
  98: i.transform = a_i_transform;
  99: i.normalMat = a_i_normalMat;
 100: 
 101: 
 102:     BlockFrag o = FLWMain(v, i);
 103: 
 104:     v2f_texCoords = o.texCoords;
 105: v2f_color = o.color;
 106: v2f_diffuse = o.diffuse;
 107: v2f_light = o.light;
 108: 
 109: }

[14:02:50] [main/ERROR]: Shader compilation log for flywheel:block.frag: No errors.

[14:02:50] [main/ERROR]: Source for shader 'flywheel:block.frag':
   1: #version 110
   2: 
   3: #if defined(USE_FOG)
   4: varying float FragDistance;
   5: uniform vec4 uFogColor;
   6: #endif
   7: 
   8: #if defined(USE_FOG_LINEAR)
   9: uniform vec2 uFogRange;
  10: 
  11: float FLWFogFactor() {
  12:     return (uFogRange.y - FragDistance) / (uFogRange.y - uFogRange.x);
  13: }
  14:     #endif
  15: 
  16:     #if defined(USE_FOG_EXP2)
  17: uniform float uFogDensity;
  18: 
  19: float FLWFogFactor() {
  20:     float dist = FragDistance * uFogDensity;
  21:     return 1. / exp2(dist * dist);
  22: }
  23:     #endif
  24: // Adjust the [0,1] normalized lightmap value based on the texture matrix from LightTexture#enableLightmap
  25: vec2 shiftLight(vec2 lm) {
  26:     return lm * 0.99609375 + 0.03125;// * 255/256 + 1/32
  27: }
  28: 
  29: uniform sampler2D uBlockAtlas;
  30: uniform sampler2D uLightMap;
  31: 
  32: vec4 FLWBlockTexture(vec2 texCoords) {
  33:     return texture2D(uBlockAtlas, texCoords);
  34: }
  35: 
  36: void FLWFinalizeColor(vec4 color) {
  37:     #if defined(USE_FOG)
  38:     float a = color.a;
  39:     float fog = clamp(FLWFogFactor(), 0., 1.);
  40: 
  41:     color = mix(uFogColor, color, fog);
  42:     color.a = a;
  43:     #endif
  44: 
  45:     gl_FragColor = color;
  46: }
  47: 
  48: vec4 FLWLight(vec2 lightCoords) {
  49:     return texture2D(uLightMap, shiftLight(lightCoords));
  50: }
  51: 
  52: 
  53: 
  54: struct BlockFrag {
  55:     vec2 texCoords;
  56:     vec4 color;
  57:     float diffuse;
  58:     vec2 light;
  59: };
  60: 
  61: void FLWMain(BlockFrag r) {
  62:     vec4 tex = FLWBlockTexture(r.texCoords);
  63: 
  64:     vec4 color = vec4(tex.rgb * FLWLight(r.light).rgb * r.diffuse, tex.a) * r.color;
  65: 
  66: //    flw_WorldPos = ;
  67: //    flw_Normal = ;
  68: //    flw_Albedo = tex.rgb;
  69: //    flw_Alpha = tex.a;
  70: //    flw_LightMap = r.light;
  71: //    flw_Tint = r.color;
  72:     FLWFinalizeColor(color);
  73: }
  74: 
  75: varying vec2 v2f_texCoords;
  76: varying vec4 v2f_color;
  77: varying float v2f_diffuse;
  78: varying vec2 v2f_light;
  79: 
  80: 
  81: //vec3 flw_WorldPos;
  82: //vec3 flw_Normal;
  83: //vec3 flw_Albedo;
  84: //float flw_Alpha;
  85: //vec2 flw_LightMap;
  86: //vec4 flw_Tint;
  87: 
  88: void main() {
  89:     BlockFrag f;
  90:     f.texCoords = v2f_texCoords;
  91: f.color = v2f_color;
  92: f.diffuse = v2f_diffuse;
  93: f.light = v2f_light;
  94: 
  95: 
  96:     FLWMain(f);
  97: }

[14:02:50] [main/INFO]: Loaded all shader programs.
[14:02:51] [Worker-Main-9/INFO]: Registered plugin at mekanism.common.integration.lookingat.hwyla.MekanismHwylaPlugin
[14:02:51] [Worker-Main-9/INFO]: Registered plugin at net.blay09.mods.cookingforblockheads.compat.WailaAddon
[14:02:51] [Worker-Main-9/INFO]: Registered plugin at mcp.mobius.waila.addons.minecraft.PluginMinecraft
[14:02:51] [Worker-Main-9/INFO]: Registered plugin at de.maxhenkel.gravestone.integration.waila.PluginGraveStone
[14:02:51] [Worker-Main-9/INFO]: Registered plugin at net.geforcemods.securitycraft.compat.waila.WailaDataProvider
[14:02:51] [Worker-Main-9/INFO]: Registered plugin at com.jaquadro.minecraft.storagedrawers.integration.Waila
[14:02:52] [main/INFO]: Journeymap PostInit
[14:02:52] [main/ERROR]: Couldn't locate icons for flat: C:\Users\kaues\AppData\Roaming\.minecraft\versions\Ender%20Tech\mods\journeymap-1.16.5-5.8.0.jar\assets\journeymap\theme\flat
[14:02:52] [main/INFO]: Preloaded theme textures: 0
[14:02:52] [main/INFO]: postInitialize EXIT, elapsed count 1 avg 258,77ms
[14:02:57] [JM-VersionCheck-1/ERROR]: Could not check version URL
javax.net.ssl.SSLHandshakeException: sun.security.validator.ValidatorException: PKIX path building failed: sun.security.provider.certpath.SunCertPathBuilderException: unable to find valid certification path to requested target
	at sun.security.ssl.Alerts.getSSLException(Alerts.java:192) ~[?:1.8.0_51]
	at sun.security.ssl.SSLSocketImpl.fatal(SSLSocketImpl.java:1949) ~[?:1.8.0_51]
	at sun.security.ssl.Handshaker.fatalSE(Handshaker.java:302) ~[?:1.8.0_51]
	at sun.security.ssl.Handshaker.fatalSE(Handshaker.java:296) ~[?:1.8.0_51]
	at sun.security.ssl.ClientHandshaker.serverCertificate(ClientHandshaker.java:1497) ~[?:1.8.0_51]
	at sun.security.ssl.ClientHandshaker.processMessage(ClientHandshaker.java:212) ~[?:1.8.0_51]
	at sun.security.ssl.Handshaker.processLoop(Handshaker.java:979) ~[?:1.8.0_51]
	at sun.security.ssl.Handshaker.process_record(Handshaker.java:914) ~[?:1.8.0_51]
	at sun.security.ssl.SSLSocketImpl.readRecord(SSLSocketImpl.java:1062) ~[?:1.8.0_51]
	at sun.security.ssl.SSLSocketImpl.performInitialHandshake(SSLSocketImpl.java:1375) ~[?:1.8.0_51]
	at sun.security.ssl.SSLSocketImpl.startHandshake(SSLSocketImpl.java:1403) ~[?:1.8.0_51]
	at sun.security.ssl.SSLSocketImpl.startHandshake(SSLSocketImpl.java:1387) ~[?:1.8.0_51]
	at org.apache.http.conn.ssl.SSLConnectionSocketFactory.createLayeredSocket(SSLConnectionSocketFactory.java:275) ~[httpclient-4.3.3.jar:4.3.3]
	at org.apache.http.conn.ssl.SSLConnectionSocketFactory.connectSocket(SSLConnectionSocketFactory.java:254) ~[httpclient-4.3.3.jar:4.3.3]
	at org.apache.http.impl.conn.HttpClientConnectionOperator.connect(HttpClientConnectionOperator.java:117) ~[httpclient-4.3.3.jar:4.3.3]
	at org.apache.http.impl.conn.PoolingHttpClientConnectionManager.connect(PoolingHttpClientConnectionManager.java:314) ~[httpclient-4.3.3.jar:4.3.3]
	at org.apache.http.impl.execchain.MainClientExec.establishRoute(MainClientExec.java:363) ~[httpclient-4.3.3.jar:4.3.3]
	at org.apache.http.impl.execchain.MainClientExec.execute(MainClientExec.java:219) ~[httpclient-4.3.3.jar:4.3.3]
	at org.apache.http.impl.execchain.ProtocolExec.execute(ProtocolExec.java:195) ~[httpclient-4.3.3.jar:4.3.3]
	at org.apache.http.impl.execchain.RetryExec.execute(RetryExec.java:86) ~[httpclient-4.3.3.jar:4.3.3]
	at org.apache.http.impl.execchain.RedirectExec.execute(RedirectExec.java:108) ~[httpclient-4.3.3.jar:4.3.3]
	at org.apache.http.impl.client.InternalHttpClient.doExecute(InternalHttpClient.java:186) ~[httpclient-4.3.3.jar:4.3.3]
	at org.apache.http.impl.client.CloseableHttpClient.execute(CloseableHttpClient.java:82) ~[httpclient-4.3.3.jar:4.3.3]
	at org.apache.http.impl.client.CloseableHttpClient.execute(CloseableHttpClient.java:106) ~[httpclient-4.3.3.jar:4.3.3]
	at org.apache.http.impl.client.CloseableHttpClient.execute(CloseableHttpClient.java:57) ~[httpclient-4.3.3.jar:4.3.3]
	at journeymap.common.version.VersionCheck.makeGetRequest(VersionCheck.java:211) [?:1.16.5-5.8.0]
	at journeymap.common.version.VersionCheck.lambda$checkVersion$1(VersionCheck.java:121) [?:1.16.5-5.8.0]
	at journeymap.common.version.VersionCheck$$Lambda$11588/1404140575.run(Unknown Source) [?:1.16.5-5.8.0]
	at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511) [?:1.8.0_51]
	at java.util.concurrent.FutureTask.run(FutureTask.java:266) [?:1.8.0_51]
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142) [?:1.8.0_51]
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617) [?:1.8.0_51]
	at java.lang.Thread.run(Thread.java:745) [?:1.8.0_51]
Caused by: sun.security.validator.ValidatorException: PKIX path building failed: sun.security.provider.certpath.SunCertPathBuilderException: unable to find valid certification path to requested target
	at sun.security.validator.PKIXValidator.doBuild(PKIXValidator.java:387) ~[?:1.8.0_51]
	at sun.security.validator.PKIXValidator.engineValidate(PKIXValidator.java:292) ~[?:1.8.0_51]
	at sun.security.validator.Validator.validate(Validator.java:260) ~[?:1.8.0_51]
	at sun.security.ssl.X509TrustManagerImpl.validate(X509TrustManagerImpl.java:324) ~[?:1.8.0_51]
	at sun.security.ssl.X509TrustManagerImpl.checkTrusted(X509TrustManagerImpl.java:229) ~[?:1.8.0_51]
	at sun.security.ssl.X509TrustManagerImpl.checkServerTrusted(X509TrustManagerImpl.java:124) ~[?:1.8.0_51]
	at sun.security.ssl.ClientHandshaker.serverCertificate(ClientHandshaker.java:1479) ~[?:1.8.0_51]
	... 28 more
Caused by: sun.security.provider.certpath.SunCertPathBuilderException: unable to find valid certification path to requested target
	at sun.security.provider.certpath.SunCertPathBuilder.build(SunCertPathBuilder.java:145) ~[?:1.8.0_51]
	at sun.security.provider.certpath.SunCertPathBuilder.engineBuild(SunCertPathBuilder.java:131) ~[?:1.8.0_51]
	at java.security.cert.CertPathBuilder.build(CertPathBuilder.java:280) ~[?:1.8.0_51]
	at sun.security.validator.PKIXValidator.doBuild(PKIXValidator.java:382) ~[?:1.8.0_51]
	at sun.security.validator.PKIXValidator.engineValidate(PKIXValidator.java:292) ~[?:1.8.0_51]
	at sun.security.validator.Validator.validate(Validator.java:260) ~[?:1.8.0_51]
	at sun.security.ssl.X509TrustManagerImpl.validate(X509TrustManagerImpl.java:324) ~[?:1.8.0_51]
	at sun.security.ssl.X509TrustManagerImpl.checkTrusted(X509TrustManagerImpl.java:229) ~[?:1.8.0_51]
	at sun.security.ssl.X509TrustManagerImpl.checkServerTrusted(X509TrustManagerImpl.java:124) ~[?:1.8.0_51]
	at sun.security.ssl.ClientHandshaker.serverCertificate(ClientHandshaker.java:1479) ~[?:1.8.0_51]
	... 28 more
[14:02:57] [JM-VersionCheck-1/ERROR]: Could not check version URL
javax.net.ssl.SSLHandshakeException: sun.security.validator.ValidatorException: PKIX path building failed: sun.security.provider.certpath.SunCertPathBuilderException: unable to find valid certification path to requested target
	at sun.security.ssl.Alerts.getSSLException(Alerts.java:192) ~[?:1.8.0_51]
	at sun.security.ssl.SSLSocketImpl.fatal(SSLSocketImpl.java:1949) ~[?:1.8.0_51]
	at sun.security.ssl.Handshaker.fatalSE(Handshaker.java:302) ~[?:1.8.0_51]
	at sun.security.ssl.Handshaker.fatalSE(Handshaker.java:296) ~[?:1.8.0_51]
	at sun.security.ssl.ClientHandshaker.serverCertificate(ClientHandshaker.java:1497) ~[?:1.8.0_51]
	at sun.security.ssl.ClientHandshaker.processMessage(ClientHandshaker.java:212) ~[?:1.8.0_51]
	at sun.security.ssl.Handshaker.processLoop(Handshaker.java:979) ~[?:1.8.0_51]
	at sun.security.ssl.Handshaker.process_record(Handshaker.java:914) ~[?:1.8.0_51]
	at sun.security.ssl.SSLSocketImpl.readRecord(SSLSocketImpl.java:1062) ~[?:1.8.0_51]
	at sun.security.ssl.SSLSocketImpl.performInitialHandshake(SSLSocketImpl.java:1375) ~[?:1.8.0_51]
	at sun.security.ssl.SSLSocketImpl.startHandshake(SSLSocketImpl.java:1403) ~[?:1.8.0_51]
	at sun.security.ssl.SSLSocketImpl.startHandshake(SSLSocketImpl.java:1387) ~[?:1.8.0_51]
	at org.apache.http.conn.ssl.SSLConnectionSocketFactory.createLayeredSocket(SSLConnectionSocketFactory.java:275) ~[httpclient-4.3.3.jar:4.3.3]
	at org.apache.http.conn.ssl.SSLConnectionSocketFactory.connectSocket(SSLConnectionSocketFactory.java:254) ~[httpclient-4.3.3.jar:4.3.3]
	at org.apache.http.impl.conn.HttpClientConnectionOperator.connect(HttpClientConnectionOperator.java:117) ~[httpclient-4.3.3.jar:4.3.3]
	at org.apache.http.impl.conn.PoolingHttpClientConnectionManager.connect(PoolingHttpClientConnectionManager.java:314) ~[httpclient-4.3.3.jar:4.3.3]
	at org.apache.http.impl.execchain.MainClientExec.establishRoute(MainClientExec.java:363) ~[httpclient-4.3.3.jar:4.3.3]
	at org.apache.http.impl.execchain.MainClientExec.execute(MainClientExec.java:219) ~[httpclient-4.3.3.jar:4.3.3]
	at org.apache.http.impl.execchain.ProtocolExec.execute(ProtocolExec.java:195) ~[httpclient-4.3.3.jar:4.3.3]
	at org.apache.http.impl.execchain.RetryExec.execute(RetryExec.java:86) ~[httpclient-4.3.3.jar:4.3.3]
	at org.apache.http.impl.execchain.RedirectExec.execute(RedirectExec.java:108) ~[httpclient-4.3.3.jar:4.3.3]
	at org.apache.http.impl.client.InternalHttpClient.doExecute(InternalHttpClient.java:186) ~[httpclient-4.3.3.jar:4.3.3]
	at org.apache.http.impl.client.CloseableHttpClient.execute(CloseableHttpClient.java:82) ~[httpclient-4.3.3.jar:4.3.3]
	at org.apache.http.impl.client.CloseableHttpClient.execute(CloseableHttpClient.java:106) ~[httpclient-4.3.3.jar:4.3.3]
	at org.apache.http.impl.client.CloseableHttpClient.execute(CloseableHttpClient.java:57) ~[httpclient-4.3.3.jar:4.3.3]
	at journeymap.common.version.VersionCheck.makeGetRequest(VersionCheck.java:211) [?:1.16.5-5.8.0]
	at journeymap.common.version.VersionCheck.lambda$checkVersion$1(VersionCheck.java:122) [?:1.16.5-5.8.0]
	at journeymap.common.version.VersionCheck$$Lambda$11588/1404140575.run(Unknown Source) [?:1.16.5-5.8.0]
	at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511) [?:1.8.0_51]
	at java.util.concurrent.FutureTask.run(FutureTask.java:266) [?:1.8.0_51]
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142) [?:1.8.0_51]
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617) [?:1.8.0_51]
	at java.lang.Thread.run(Thread.java:745) [?:1.8.0_51]
Caused by: sun.security.validator.ValidatorException: PKIX path building failed: sun.security.provider.certpath.SunCertPathBuilderException: unable to find valid certification path to requested target
	at sun.security.validator.PKIXValidator.doBuild(PKIXValidator.java:387) ~[?:1.8.0_51]
	at sun.security.validator.PKIXValidator.engineValidate(PKIXValidator.java:292) ~[?:1.8.0_51]
	at sun.security.validator.Validator.validate(Validator.java:260) ~[?:1.8.0_51]
	at sun.security.ssl.X509TrustManagerImpl.validate(X509TrustManagerImpl.java:324) ~[?:1.8.0_51]
	at sun.security.ssl.X509TrustManagerImpl.checkTrusted(X509TrustManagerImpl.java:229) ~[?:1.8.0_51]
	at sun.security.ssl.X509TrustManagerImpl.checkServerTrusted(X509TrustManagerImpl.java:124) ~[?:1.8.0_51]
	at sun.security.ssl.ClientHandshaker.serverCertificate(ClientHandshaker.java:1479) ~[?:1.8.0_51]
	... 28 more
Caused by: sun.security.provider.certpath.SunCertPathBuilderException: unable to find valid certification path to requested target
	at sun.security.provider.certpath.SunCertPathBuilder.build(SunCertPathBuilder.java:145) ~[?:1.8.0_51]
	at sun.security.provider.certpath.SunCertPathBuilder.engineBuild(SunCertPathBuilder.java:131) ~[?:1.8.0_51]
	at java.security.cert.CertPathBuilder.build(CertPathBuilder.java:280) ~[?:1.8.0_51]
	at sun.security.validator.PKIXValidator.doBuild(PKIXValidator.java:382) ~[?:1.8.0_51]
	at sun.security.validator.PKIXValidator.engineValidate(PKIXValidator.java:292) ~[?:1.8.0_51]
	at sun.security.validator.Validator.validate(Validator.java:260) ~[?:1.8.0_51]
	at sun.security.ssl.X509TrustManagerImpl.validate(X509TrustManagerImpl.java:324) ~[?:1.8.0_51]
	at sun.security.ssl.X509TrustManagerImpl.checkTrusted(X509TrustManagerImpl.java:229) ~[?:1.8.0_51]
	at sun.security.ssl.X509TrustManagerImpl.checkServerTrusted(X509TrustManagerImpl.java:124) ~[?:1.8.0_51]
	at sun.security.ssl.ClientHandshaker.serverCertificate(ClientHandshaker.java:1479) ~[?:1.8.0_51]
	... 28 more
[14:03:12] [main/INFO]: OpenAL initialized.
[14:03:12] [main/INFO]: Sound engine started
[14:03:12] [main/INFO]: Created: 128x256x0 jei:textures/atlas/gui.png-atlas
[14:03:13] [main/INFO]: [OptiFine] Animated sprites: 0
[14:03:13] [main/WARN]: [OptiFine] Invalid grid V: 16, icon: jei:gui/icons/config_button
[14:03:13] [main/WARN]: [OptiFine] Invalid grid V: 16, icon: jei:gui/icons/config_button
[14:03:13] [main/WARN]: [OptiFine] Invalid grid V: 16, icon: jei:gui/icons/config_button_cheat
[14:03:13] [main/WARN]: [OptiFine] Invalid grid V: 16, icon: jei:gui/icons/config_button_cheat
[14:03:13] [main/WARN]: [OptiFine] Invalid grid V: 16, icon: jei:gui/icons/arrow_previous
[14:03:13] [main/WARN]: [OptiFine] Invalid grid V: 16, icon: jei:gui/icons/arrow_previous
[14:03:13] [main/WARN]: [OptiFine] Invalid grid V: 16, icon: jei:gui/icons/arrow_next
[14:03:13] [main/WARN]: [OptiFine] Invalid grid V: 16, icon: jei:gui/icons/arrow_next
[14:03:13] [main/WARN]: [OptiFine] Invalid grid V: 16, icon: minecraft:missingno
[14:03:13] [main/WARN]: [OptiFine] Invalid grid V: 16, icon: minecraft:missingno
[14:03:13] [main/WARN]: [OptiFine] Invalid grid V: 16, icon: jei:gui/icons/info
[14:03:13] [main/WARN]: [OptiFine] Invalid grid V: 16, icon: jei:gui/icons/info
[14:03:13] [main/WARN]: [OptiFine] Invalid grid V: 16, icon: jei:gui/icons/recipe_transfer
[14:03:13] [main/WARN]: [OptiFine] Invalid grid V: 16, icon: jei:gui/icons/recipe_transfer
[14:03:13] [main/INFO]: Created: 256x128x0 mekanism:textures/atlas/robit.png-atlas
[14:03:13] [main/INFO]: [OptiFine] Animated sprites: 0
[14:03:13] [main/INFO]: Created: 2048x2048x4 minecraft:textures/atlas/blocks.png-atlas
[14:03:22] [main/INFO]: [OptiFine] Animated sprites: 162
[14:03:22] [main/INFO]: Created: 256x128x4 minecraft:textures/atlas/signs.png-atlas
[14:03:22] [main/INFO]: [OptiFine] Animated sprites: 0
[14:03:22] [main/INFO]: Created: 512x512x4 minecraft:textures/atlas/banner_patterns.png-atlas
[14:03:22] [main/INFO]: [OptiFine] Animated sprites: 0
[14:03:22] [main/INFO]: Created: 512x512x4 minecraft:textures/atlas/shield_patterns.png-atlas
[14:03:22] [main/INFO]: [OptiFine] Animated sprites: 0
[14:03:22] [main/INFO]: Created: 512x256x4 minecraft:textures/atlas/chest.png-atlas
[14:03:22] [main/INFO]: [OptiFine] Animated sprites: 0
[14:03:22] [main/INFO]: Created: 512x256x4 minecraft:textures/atlas/beds.png-atlas
[14:03:22] [main/INFO]: [OptiFine] Animated sprites: 0
[14:03:22] [main/INFO]: Created: 512x256x4 minecraft:textures/atlas/shulker_boxes.png-atlas
[14:03:22] [main/INFO]: [OptiFine] Animated sprites: 0
[14:03:39] [main/INFO]: Created: 256x256x0 minecraft:textures/atlas/particles.png-atlas
[14:03:39] [main/INFO]: [OptiFine] Animated sprites: 0
[14:03:39] [main/INFO]: Created: 256x256x0 minecraft:textures/atlas/paintings.png-atlas
[14:03:39] [main/INFO]: [OptiFine] Animated sprites: 0
[14:03:39] [main/INFO]: Created: 256x256x0 minecraft:textures/atlas/mob_effects.png-atlas
[14:03:39] [main/INFO]: [OptiFine] Animated sprites: 0
[14:03:40] [main/INFO]: [OptiFine] *** Reloading custom textures ***
[14:03:40] [main/WARN]: [OptiFine] Unknown resource pack file: mod_resources
[14:03:40] [main/WARN]: [OptiFine] Unknown resource pack file: mod_resources
[14:03:40] [main/WARN]: [OptiFine] Unknown resource pack file: mod_resources
[14:04:38] [main/WARN]: [OptiFine] Unknown resource pack file: mod_resources
[14:04:41] [main/WARN]: [OptiFine] Unknown resource pack file: mod_resources
[14:04:41] [main/WARN]: [OptiFine] Unknown resource pack file: mod_resources
[14:04:41] [main/INFO]: [OptiFine] Disable Forge light pipeline
[14:04:42] [main/INFO]: [OptiFine] Set ForgeConfig.CLIENT.forgeLightPipelineEnabled=false
[14:04:52] [main/INFO]: [org.tlauncher.util.TLModCfg:<clinit>:28]: [TLSkinCape] Current TLSkinCape version is 1.17
[14:04:52] [main/INFO]: [org.tlauncher.util.TLModCfg:<clinit>:51]: [TLSkinCape] Current Minecraft version is 1.15.
[14:04:52] [main/INFO]: [org.tlauncher.util.TLModCfg:<clinit>:55]: [TLSkinCape] OptiFine detected.
[14:04:53] [main/INFO]: [FANCYMENU] Updating animation sizes..
[14:04:56] [Realms Notification Availability checker #1/INFO]: Could not authorize you against Realms server: Invalid session id
[16:00:06] [main/INFO]: Stopping!
